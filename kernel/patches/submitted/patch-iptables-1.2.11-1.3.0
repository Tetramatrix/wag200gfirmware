diff -urN iptables-1.2.11/COMMIT_NOTES iptables-1.3.0/COMMIT_NOTES
--- iptables-1.2.11/COMMIT_NOTES	2003-04-13 13:29:28.000000000 +0200
+++ iptables-1.3.0/COMMIT_NOTES	2005-02-12 21:57:58.000000000 +0100
@@ -1,15 +1,15 @@
-A quick list of rules for committing stuff into netfilter cvs:
+A quick list of rules for committing stuff into netfilter svn:
 
-- Always include the Name of the Author/Contributor in the CVS comment
+- Always include the Name of the Author/Contributor in the SVN comment
   like 'fix for foo (Au Thor)'
 
 - make sure that you have set the executable bits on an 'extensions/.*-test'
-  script before adding/committing it to CVS
+  script before adding/committing it to SVN
 
 - If the commit fixes a bugzilla bug, please include '(Closes: #bugnr)' in
   the commit message
 
-- Make sure you don't commit to CVS while a feature freeze is announced
+- Make sure you don't commit to svn while a feature freeze is announced
 
 - For new extensions, there are two possible cases:
 	1) header files are just in patch-o-matic patch, you need an
diff -urN iptables-1.2.11/CURRENT_ISSUES iptables-1.3.0/CURRENT_ISSUES
--- iptables-1.2.11/CURRENT_ISSUES	2004-02-19 19:13:48.000000000 +0100
+++ iptables-1.3.0/CURRENT_ISSUES	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-save/restore problem of owner match
-	- userspace
-u32 match
-	- can wait
-XDMCP conntrack/nat
-	- can wait
-nf_debug stuff
-	- can wait
-ipt_ACCOUNT
-	- can wait
-UDP stream timeout (180s) doens't apply for first reply packet
-	- fix by Martin Josefsson, needs review/testing
-SLOG target
-	- no further work expected
-	- needs to be integrated with recent nfnetlink/ctnetlink
-loop detection / nf_hipac (mail from dec 15
-	- need time
-IPv6 REJECT target fix
-	- important, it's a pity that it's still broken
-bi-directional ftp state tracking
-	- do we want this?
-final ACK of a SYN - SYN/ACK - ACK tcp handshake establishes ASSURED
-	- patch is on list, needs testing + comments from kadlec
-expectations allegedly don't work on sparc64
-	- see <771F217D7A4AF84494632457889470A412D77A@bcmsg011.corp.ads>
-	- is this in bugzilla yet?
-new bytelimit match
-	- unify it with 'limit' for 2.5.x
-boolean MARK operations
-	- patch by Anders Fugmann, needs 64bit testing
diff -urN iptables-1.2.11/INSTALL iptables-1.3.0/INSTALL
--- iptables-1.2.11/INSTALL	2002-08-02 14:54:19.000000000 +0200
+++ iptables-1.3.0/INSTALL	2004-10-10 11:56:27.000000000 +0200
@@ -36,6 +36,12 @@
 
 	% make NO_SHARED_LIBS=1
 
+5) If you want to build a single BusyBox style multipurpose binary instead of
+   the individual iptables, iptables-save and iptables-restore binaries, then
+   please use
+
+	% make DO_MULTI=1
+
 NOTE: make sure you build with at least the correct LIBDIR=
 specification, otherwise iptables(8) won't know where to find the
 dynamic objects.
diff -urN iptables-1.2.11/Makefile iptables-1.3.0/Makefile
--- iptables-1.2.11/Makefile	2004-06-17 13:21:07.000000000 +0200
+++ iptables-1.3.0/Makefile	2005-02-12 21:59:48.000000000 +0100
@@ -14,8 +14,8 @@
 ifndef KERNEL_DIR
 KERNEL_DIR=/usr/src/linux
 endif
-IPTABLES_VERSION:=1.2.11
-OLD_IPTABLES_VERSION:=1.2.10
+IPTABLES_VERSION:=1.3.0
+OLD_IPTABLES_VERSION:=1.2.11
 
 PREFIX:=/usr/local
 LIBDIR:=$(PREFIX)/lib
@@ -42,7 +42,9 @@
 EXTRA_INSTALLS+=$(DESTDIR)$(BINDIR)/iptables $(DESTDIR)$(MANDIR)/man8/iptables.8
 
 # No longer experimental.
+ifneq ($(DO_MULTI), 1)
 EXTRAS+=iptables-save iptables-restore
+endif
 EXTRA_INSTALLS+=$(DESTDIR)$(BINDIR)/iptables-save $(DESTDIR)$(BINDIR)/iptables-restore $(DESTDIR)$(MANDIR)/man8/iptables-restore.8 $(DESTDIR)$(MANDIR)/man8/iptables-save.8
 
 ifeq ($(DO_IPV6), 1)
@@ -114,8 +116,13 @@
 iptables.o: iptables.c
 	$(CC) $(CFLAGS) -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" -c -o $@ $<
 
+ifeq ($(DO_MULTI), 1)
+iptables: iptables-multi.c iptables-save.c iptables-restore.c iptables-standalone.c iptables.o $(STATIC_LIBS) libiptc/libiptc.a
+	$(CC) $(CFLAGS) -DIPTABLES_MULTI -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
+else
 iptables: iptables-standalone.c iptables.o $(STATIC_LIBS) libiptc/libiptc.a
 	$(CC) $(CFLAGS) -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
+endif
 
 $(DESTDIR)$(BINDIR)/iptables: iptables
 	@[ -d $(DESTDIR)$(BINDIR) ] || mkdir -p $(DESTDIR)$(BINDIR)
@@ -124,16 +131,28 @@
 iptables-save: iptables-save.c iptables.o $(STATIC_LIBS) libiptc/libiptc.a
 	$(CC) $(CFLAGS) -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
 
+ifeq ($(DO_MULTI), 1)
+$(DESTDIR)$(BINDIR)/iptables-save: iptables
+	@[ -d $(DESTDIR)$(BINDIR) ] || mkdir -p $(DESTDIR)$(BINDIR)
+	ln -sf $< $@
+else
 $(DESTDIR)$(BINDIR)/iptables-save: iptables-save
 	@[ -d $(DESTDIR)$(BINDIR) ] || mkdir -p $(DESTDIR)$(BINDIR)
 	cp $< $@
+endif
 
 iptables-restore: iptables-restore.c iptables.o $(STATIC_LIBS) libiptc/libiptc.a
 	$(CC) $(CFLAGS) -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
 
+ifeq ($(DO_MULTI), 1)
+$(DESTDIR)$(BINDIR)/iptables-restore: iptables
+	@[ -d $(DESTDIR)$(BINDIR) ] || mkdir -p $(DESTDIR)$(BINDIR)
+	ln -sf $< $@
+else
 $(DESTDIR)$(BINDIR)/iptables-restore: iptables-restore
 	@[ -d $(DESTDIR)$(BINDIR) ] || mkdir -p $(DESTDIR)$(BINDIR)
 	cp $< $@
+endif
 
 ip6tables.o: ip6tables.c
 	$(CC) $(CFLAGS) -DIP6T_LIB_DIR=\"$(IPT_LIBDIR)\" -c -o $@ $<
@@ -172,7 +191,7 @@
 	sed -e '/@MATCH@/ r extensions/libipt_matches.man' -e '/@TARGET@/ r extensions/libipt_targets.man' iptables.8.in >iptables.8
 
 ip6tables.8: ip6tables.8.in extensions/libip6t_matches.man extensions/libip6t_targets.man
-	sed -e '/@MATCH@/ r extensions/libip6t_matches.man' -e '/@TARGET@/ r extensions/libiptt_targets.man' ip6tables.8.in >ip6tables.8
+	sed -e '/@MATCH@/ r extensions/libip6t_matches.man' -e '/@TARGET@/ r extensions/libip6t_targets.man' ip6tables.8.in >ip6tables.8
 
 # Development Targets
 .PHONY: install-devel-man3
@@ -216,7 +235,7 @@
 	rm -f $(RELEASE_DIR)/iptables-$(IPTABLES_VERSION).tar.bz2
 
 $(RELEASE_DIR)/iptables-$(IPTABLES_VERSION).tar.bz2:
-	cd .. && ln -sf iptables iptables-$(IPTABLES_VERSION) && tar cvf - --exclude CVS iptables-$(IPTABLES_VERSION)/. | bzip2 -9 > $@ && rm iptables-$(IPTABLES_VERSION)
+	cd .. && ln -sf iptables iptables-$(IPTABLES_VERSION) && tar cvf - --exclude .svn iptables-$(IPTABLES_VERSION)/. | bzip2 -9 > $@ && rm iptables-$(IPTABLES_VERSION)
 
 .PHONY: diff
 diff: $(RELEASE_DIR)/iptables-$(IPTABLES_VERSION).tar.bz2
diff -urN iptables-1.2.11/TODO iptables-1.3.0/TODO
--- iptables-1.2.11/TODO	2003-11-10 19:11:11.000000000 +0100
+++ iptables-1.3.0/TODO	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-TODO List for netfilter / iptables. 
-Currently maintained by Harald Welte <laforge@gnumonks.org>
-
-Please inform me, if you want to work on any of the TODO items, so I
-can update this list and thus prevent two people doing the same work.
-
-CVS ID: $Id: TODO,v 1.72 2003/11/10 18:11:11 laforge Exp $
-
-IMPORTANT issues:
-- erroneously too-fast dropped conntrack for half-open TCP connections [JK]
-- --mac-source not working in FORWARD (manpage bug?) [BZ]
-- locally bound udp port can still be used for MASQ/SNAT [BZ]
-- unaligned access of nulldevname during string match [BZ]
-- unaligned access in interface match (ip_tables core)
-- update documentation to reflect newnat
-- release iptables-1.3.0-test (with new libiptc for speedup)
-- ipv6 ldp (igmp) and ndisc bypasses LOCAL_OUT hook
-
-TO BE INVESTIGATED:
-- packet counters on sparc64 platform [BZ]
-- conntrack helper not called for first packet (udp!)
-- different behaviour for first packet towards an l2-unresolved ip?
-
-NICE to have:
-- sysctl support for ftp-multi, irc-conntrack/nat, ftp-fxp [BZ]
-- port conntrack to IPv6 (code reuse?) 
-- ip_nat_ident module [BZ]
-- make iptables / ip6tables use the same codebase (as libiptc) [KA]
-- libipq reentrancy [JM]
-- compiling without O2 issue [BZ]
-- libipq runtime version, do before 1.2.5 [JM]
-- l3 independent ip_queue / ULOG (2.6)
-- add support for IRC tracking in opposite direction
-- Find mirrors for www.TLD.netfilter.org domains
-- example section on homepage
-- searchable mailinglist archives
-- faq-o-matic system
-
-FUTURE extensions:
-- dealing with fragmented expectation-causes (i.e. DCC chat split
-  over two packets, etc.)
-- conntrack / nat failover [HW]
-- unified nfnetlink for queue,ulog,conntrack (and more?) (2.5 issue)
-
-Userspace queuing for 2.5:
-- Integration with nfnetlink.
-- Multiple queues per protocol.
-- Netlink broadcast support.
-- Allow multiple reader/writers in userspace.
-- How to handle multiple protocols (e.g. use separate queue handlers
-  or a multiplexer like ipqmpd).
-- Peformance improvements: multipart messages, mmaped socket (possibly).
-- Simplify queuing logic, which is quite ugly at the moment. (BC suggested
-  removing logic from kernel).
-- Allow userspace to set nfmark.
-- Allow userspace to set queue length etc.
-- Possibly pass conntrack/NAT info to userspace with packet.
-
-======================================================================
-[BC]	Brad Chapman <kakadu_croc@yahoo.com>
-[HW]	Harald Welte <laforge@gnumonks.org>
-[JK]	Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
-[JM]	James Morris <jmorris@intercode.com.au>
-[KA]	Kiz-Szabo Andras <kisza@sch.bme.hu>
-[RR]	Paul 'Rusty' Russel <rusty@rustcorp.com.au>
-[BZ]	Included in Bugzilla System
diff -urN iptables-1.2.11/extensions/.addrtype-test iptables-1.3.0/extensions/.addrtype-test
--- iptables-1.2.11/extensions/.addrtype-test	2003-05-07 18:51:40.000000000 +0200
+++ iptables-1.3.0/extensions/.addrtype-test	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-#!/bin/bash
-
-if test -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_addrtype.h; then
-	echo "addrtype"
-fi
diff -urN iptables-1.2.11/extensions/Makefile iptables-1.3.0/extensions/Makefile
--- iptables-1.2.11/extensions/Makefile	2004-06-17 12:22:54.000000000 +0200
+++ iptables-1.3.0/extensions/Makefile	2004-11-18 23:52:12.000000000 +0100
@@ -5,8 +5,8 @@
 # header files are present in the include/linux directory of this iptables
 # package (HW)
 #
-PF_EXT_SLIB:=ah connlimit connmark conntrack dscp ecn esp helper icmp iprange length limit mac mark multiport owner physdev pkttype realm rpc sctp standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE TTL ULOG
-PF6_EXT_SLIB:=eui64 hl icmpv6 length limit mac mark multiport owner standard tcp udp HL LOG MARK TRACE
+PF_EXT_SLIB:=ah addrtype comment connlimit connmark conntrack dscp ecn esp hashlimit helper icmp iprange length limit mac mark multiport owner physdev pkttype realm rpc sctp standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE TTL ULOG
+PF6_EXT_SLIB:=eui64 hl icmpv6 length limit mac mark multiport owner physdev standard tcp udp HL LOG MARK TRACE
 
 # Optionals
 PF_EXT_SLIB_OPTS:=$(foreach T,$(wildcard extensions/.*-test),$(shell KERNEL_DIR=$(KERNEL_DIR) $(T)))
diff -urN iptables-1.2.11/extensions/libip6t_HL.c iptables-1.3.0/extensions/libip6t_HL.c
--- iptables-1.2.11/extensions/libip6t_HL.c	2003-01-08 10:14:20.000000000 +0100
+++ iptables-1.3.0/extensions/libip6t_HL.c	2005-02-01 14:33:40.000000000 +0100
@@ -24,9 +24,9 @@
 {
 	printf(
 "HL target v%s options\n"
-"  --hl-set value		Set HL to <value>\n"
-"  --hl-dec value		Decrement HL by <value>\n"
-"  --hl-inc value		Increment HL by <value>\n"
+"  --hl-set value		Set HL to <value 0-255>\n"
+"  --hl-dec value		Decrement HL by <value 1-255>\n"
+"  --hl-inc value		Increment HL by <value 1-255>\n"
 , IPTABLES_VERSION);
 }
 
@@ -35,7 +35,7 @@
 		struct ip6t_entry_target **target)
 {
 	struct ip6t_HL_info *info = (struct ip6t_HL_info *) (*target)->data;
-	u_int8_t value;
+	unsigned int value;
 
 	if (*flags & IP6T_HL_USED) {
 		exit_error(PARAMETER_PROBLEM, 
@@ -50,7 +50,9 @@
 		exit_error(PARAMETER_PROBLEM,
 				"HL: unexpected `!'");
 	
-	value = atoi(optarg);
+	if (string_to_number(optarg, 0, 255, &value) == -1)	
+		exit_error(PARAMETER_PROBLEM,	
+		           "HL: Expected value between 0 and 255");
 
 	switch (c) {
 
@@ -145,17 +147,17 @@
 
 static
 struct ip6tables_target HL = { NULL, 
-	"HL",
-	IPTABLES_VERSION,
-	IP6T_ALIGN(sizeof(struct ip6t_HL_info)),
-	IP6T_ALIGN(sizeof(struct ip6t_HL_info)),
-	&help,
-	&init,
-	&parse,
-	&final_check,
-	&print,
-	&save,
-	opts 
+	.name 		= "HL",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_HL_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_HL_info)),
+	.help		= &help, 
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts 
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_REJECT.c iptables-1.3.0/extensions/libip6t_REJECT.c
--- iptables-1.2.11/extensions/libip6t_REJECT.c	2002-06-14 09:38:16.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_REJECT.c	2005-02-01 16:17:09.000000000 +0100
@@ -152,19 +152,18 @@
 	printf("--reject-with %s ", reject_table[i].name);
 }
 
-struct ip6tables_target reject
-= { NULL,
-    "REJECT",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_reject_info)),
-    IP6T_ALIGN(sizeof(struct ip6t_reject_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct ip6tables_target reject = {
+	.name = "REJECT",
+	.version	= IPTABLES_VERSION,
+	.size 		= IP6T_ALIGN(sizeof(struct ip6t_reject_info)),
+	.userspacesize 	= IP6T_ALIGN(sizeof(struct ip6t_reject_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_ROUTE.c iptables-1.3.0/extensions/libip6t_ROUTE.c
--- iptables-1.2.11/extensions/libip6t_ROUTE.c	2003-09-05 14:54:06.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_ROUTE.c	2005-02-01 16:18:25.000000000 +0100
@@ -1,6 +1,6 @@
 /* Shared library add-on to iptables to add ROUTE v6 target support.
  * Author : Cedric de Launois, <delaunois@info.ucl.ac.be>
- * v 1.0 2003/06/24
+ * v 1.1 2004/11/23
  */
 
 #include <stdio.h>
@@ -15,6 +15,11 @@
 #include <linux/netfilter_ipv6/ip6_tables.h>
 #include <linux/netfilter_ipv6/ip6t_ROUTE.h>
 
+/* compile IP6T_ROUTE_TEE support even if kernel headers are unpatched */
+#ifndef IP6T_ROUTE_TEE
+#define IP6T_ROUTE_TEE		0x02
+#endif
+
 /* Function which prints out usage message. */
 static void
 help(void)
@@ -23,9 +28,13 @@
 "ROUTE target v%s options:\n"
 "    --oif   \tifname \t\tRoute the packet through `ifname' network interface\n"
 "    --gw    \tip     \t\tRoute the packet via this gateway\n"
-"    --continue\t     \t\tRoute the packet and continue traversing the rules.\n"
+"    --continue\t     \t\tRoute packet and continue traversing the\n"
+"            \t       \t\trules. Not valid with --iif or --tee.\n"
+"    --tee\t  \t\tDuplicate packet, route the duplicate,\n"
+"            \t       \t\tcontinue traversing with original packet.\n"
+"            \t       \t\tNot valid with --iif or --continue.\n"
 "\n",
-"1.0");
+"1.1");
 }
 
 static struct option opts[] = {
@@ -33,6 +42,7 @@
 	{ "iif", 1, 0, '2' },
 	{ "gw", 1, 0, '3' },
 	{ "continue", 0, 0, '4' },
+	{ "tee", 0, 0, '5' },
 	{ 0 }
 };
 
@@ -57,6 +67,7 @@
 #define IP6T_ROUTE_OPT_IIF      0x02
 #define IP6T_ROUTE_OPT_GW       0x04
 #define IP6T_ROUTE_OPT_CONTINUE 0x08
+#define IP6T_ROUTE_OPT_TEE      0x10
 
 /* Function which parses command options; returns true if it
    ate an option */
@@ -114,12 +125,28 @@
 		if (*flags & IP6T_ROUTE_OPT_CONTINUE)
 			exit_error(PARAMETER_PROBLEM,
 				   "Can't specify --continue twice");
+		if (*flags & IP6T_ROUTE_OPT_TEE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue AND --tee");
 
 		route_info->flags |= IP6T_ROUTE_CONTINUE;
 		*flags |= IP6T_ROUTE_OPT_CONTINUE;
 
 		break;
 
+	case '5':
+		if (*flags & IP6T_ROUTE_OPT_TEE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee twice");
+		if (*flags & IP6T_ROUTE_OPT_CONTINUE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee AND --continue");
+
+		route_info->flags |= IP6T_ROUTE_TEE;
+		*flags |= IP6T_ROUTE_OPT_TEE;
+
+		break;
+
 	default:
 		return 0;
 	}
@@ -162,6 +189,9 @@
 	if (route_info->flags & IP6T_ROUTE_CONTINUE)
 		printf("continue");
 
+	if (route_info->flags & IP6T_ROUTE_TEE)
+		printf("tee");
+
 }
 
 
@@ -184,23 +214,24 @@
 
 	if (route_info->flags & IP6T_ROUTE_CONTINUE)
 		printf("--continue ");
+
+	if (route_info->flags & IP6T_ROUTE_TEE)
+		printf("--tee ");
 }
 
 
-static
-struct ip6tables_target route
-= { NULL,
-    "ROUTE",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_route_target_info)),
-    IP6T_ALIGN(sizeof(struct ip6t_route_target_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct ip6tables_target route = { 
+	.name 		= "ROUTE",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_route_target_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_route_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_ROUTE.man iptables-1.3.0/extensions/libip6t_ROUTE.man
--- iptables-1.2.11/extensions/libip6t_ROUTE.man	2004-01-22 16:04:24.000000000 +0100
+++ iptables-1.3.0/extensions/libip6t_ROUTE.man	2004-12-14 13:57:01.000000000 +0100
@@ -9,4 +9,7 @@
 Route the packet via this gateway
 .TP
 .BI "--continue "
-Behave like a non-terminating target and continue traversing the rules
+Behave like a non-terminating target and continue traversing the rules. Not valid in combination with `--tee'
+.TP
+.BI "--tee "
+Make a copy of the packet, and route that copy to the given destination. For the original, uncopied packet, behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--continue'
diff -urN iptables-1.2.11/extensions/libip6t_eui64.c iptables-1.3.0/extensions/libip6t_eui64.c
--- iptables-1.2.11/extensions/libip6t_eui64.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_eui64.c	2005-02-01 16:20:13.000000000 +0100
@@ -65,20 +65,18 @@
 
 }
 
-static
-struct ip6tables_match eui64
-= { NULL,
-    "eui64",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(int)),
-    IP6T_ALIGN(sizeof(int)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct ip6tables_match eui64 = {
+	.name 		= "eui64",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(int)),
+	.userspacesize	= IP6T_ALIGN(sizeof(int)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_hbh.c iptables-1.3.0/extensions/libip6t_hbh.c
--- iptables-1.2.11/extensions/libip6t_hbh.c	2002-06-14 09:38:16.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_hbh.c	2005-02-01 16:21:35.000000000 +0100
@@ -237,24 +237,22 @@
 
 }
 
-static
-struct ip6tables_match optstruct
-= { NULL,
+static struct ip6tables_match optstruct = {
 #if HOPBYHOP
-    "hbh",
+	.name 		= "hbh",
 #else
-    "dst",
+	.name		= "dst",
 #endif
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_opts)),
-    IP6T_ALIGN(sizeof(struct ip6t_opts)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_opts)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_opts)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void
diff -urN iptables-1.2.11/extensions/libip6t_icmpv6.c iptables-1.3.0/extensions/libip6t_icmpv6.c
--- iptables-1.2.11/extensions/libip6t_icmpv6.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_icmpv6.c	2005-02-01 16:22:43.000000000 +0100
@@ -257,19 +257,18 @@
 {
 }
 
-static struct ip6tables_match icmpv6
-= { NULL,
-    "icmp6",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_icmp)),
-    IP6T_ALIGN(sizeof(struct ip6t_icmp)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct ip6tables_match icmpv6 = {
+	.name 		= "icmp6",
+	.version 	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_icmp)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_icmp)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_ipv6header.c iptables-1.3.0/extensions/libip6t_ipv6header.c
--- iptables-1.2.11/extensions/libip6t_ipv6header.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_ipv6header.c	2005-02-01 16:23:33.000000000 +0100
@@ -298,19 +298,18 @@
 }
 
 static
-struct ip6tables_match ipv6header
-= { NULL,
-    "ipv6header",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_ipv6header_info)),
-    IP6T_ALIGN(sizeof(struct ip6t_ipv6header_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct ip6tables_match ipv6header = {
+	.name		= "ipv6header",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_ipv6header_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_ipv6header_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_length.c iptables-1.3.0/extensions/libip6t_length.c
--- iptables-1.2.11/extensions/libip6t_length.c	2002-12-05 21:37:22.000000000 +0100
+++ iptables-1.3.0/extensions/libip6t_length.c	2005-02-01 16:24:27.000000000 +0100
@@ -140,19 +140,18 @@
 	print_length((struct ip6t_length_info *)match->data);
 }
 
-struct ip6tables_match length
-= { NULL,
-    "length",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_length_info)),
-    IP6T_ALIGN(sizeof(struct ip6t_length_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct ip6tables_match length = {
+	.name		= "length",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_length_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_length_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_limit.c iptables-1.3.0/extensions/libip6t_limit.c
--- iptables-1.2.11/extensions/libip6t_limit.c	2004-06-15 00:02:16.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_limit.c	2005-02-01 16:25:21.000000000 +0100
@@ -104,19 +104,14 @@
 
 	switch(c) {
 	case '%':
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM,
-				   "Unexpected `!' after --limit");
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
 		if (!parse_rate(optarg, &r->avg))
 			exit_error(PARAMETER_PROBLEM,
 				   "bad rate `%s'", optarg);
 		break;
 
 	case '$':
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM,
-				   "Unexpected `!' after --limit-burst");
-
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
 		if (string_to_number(optarg, 0, 10000, &num) == -1)
 			exit_error(PARAMETER_PROBLEM,
 				   "bad --limit-burst `%s'", optarg);
@@ -127,6 +122,10 @@
 		return 0;
 	}
 
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,
+			   "limit does not support invert");
+
 	return 1;
 }
 
@@ -178,20 +177,18 @@
 		printf("--limit-burst %u ", r->burst);
 }
 
-static
-struct ip6tables_match limit
-= { NULL,
-    "limit",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_rateinfo)),
-    offsetof(struct ip6t_rateinfo, prev),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct ip6tables_match limit = {
+	.name 		= "limit",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_rateinfo)),
+	.userspacesize	= offsetof(struct ip6t_rateinfo, prev),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_mac.c iptables-1.3.0/extensions/libip6t_mac.c
--- iptables-1.2.11/extensions/libip6t_mac.c	2003-06-14 16:27:51.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_mac.c	2005-02-01 16:26:13.000000000 +0100
@@ -128,20 +128,18 @@
 	print_mac(((struct ip6t_mac_info *)match->data)->srcaddr);
 }
 
-static
-struct ip6tables_match mac
-= { NULL,
-    "mac",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_mac_info)),
-    IP6T_ALIGN(sizeof(struct ip6t_mac_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct ip6tables_match mac = {
+	.name		= "mac",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_mac_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_mac_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_mark.c iptables-1.3.0/extensions/libip6t_mark.c
--- iptables-1.2.11/extensions/libip6t_mark.c	2004-06-15 00:02:16.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_mark.c	2005-02-01 16:27:09.000000000 +0100
@@ -131,20 +131,18 @@
 	print_mark(info->mark, info->mask, 0);
 }
 
-static
-struct ip6tables_match mark
-= { NULL,
-    "mark",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_mark_info)),
-    IP6T_ALIGN(sizeof(struct ip6t_mark_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct ip6tables_match mark = {
+	.name		= "mark",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_mark_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_mark_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_multiport.c iptables-1.3.0/extensions/libip6t_multiport.c
--- iptables-1.2.11/extensions/libip6t_multiport.c	2003-07-14 22:01:29.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_multiport.c	2005-02-01 16:38:05.000000000 +0100
@@ -112,6 +112,7 @@
 
 	switch (c) {
 	case '1':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
 		proto = check_proto(entry);
 		multiinfo->count = parse_multi_ports(argv[optind-1],
 						     multiinfo->ports, proto);
@@ -120,6 +121,7 @@
 		break;
 
 	case '2':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
 		proto = check_proto(entry);
 		multiinfo->count = parse_multi_ports(argv[optind-1],
 						     multiinfo->ports, proto);
@@ -128,6 +130,7 @@
 		break;
 
 	case '3':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
 		proto = check_proto(entry);
 		multiinfo->count = parse_multi_ports(argv[optind-1],
 						     multiinfo->ports, proto);
@@ -139,6 +142,10 @@
 		return 0;
 	}
 
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,
+			   "multiport does not support invert");
+
 	if (*flags)
 		exit_error(PARAMETER_PROBLEM,
 			   "multiport can only have one option");
@@ -242,20 +249,18 @@
 	printf(" ");
 }
 
-static
-struct ip6tables_match multiport
-= { NULL,
-    "multiport",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_multiport)),
-    IP6T_ALIGN(sizeof(struct ip6t_multiport)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct ip6tables_match multiport = {
+	.name		= "multiport",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_multiport)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_multiport)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void
diff -urN iptables-1.2.11/extensions/libip6t_nth.c iptables-1.3.0/extensions/libip6t_nth.c
--- iptables-1.2.11/extensions/libip6t_nth.c	2003-05-03 15:55:06.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_nth.c	2005-02-01 16:28:48.000000000 +0100
@@ -217,19 +217,18 @@
                 printf("--packet %u ", nthinfo->packet );
 }
 
-struct ip6tables_match nth
-= { NULL,
-    "nth",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_nth_info)),
-    IP6T_ALIGN(sizeof(struct ip6t_nth_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct ip6tables_match nth = {
+	.name 		= "nth",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_nth_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_nth_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_owner.c iptables-1.3.0/extensions/libip6t_owner.c
--- iptables-1.2.11/extensions/libip6t_owner.c	2004-02-19 19:04:14.000000000 +0100
+++ iptables-1.3.0/extensions/libip6t_owner.c	2005-02-01 16:29:37.000000000 +0100
@@ -237,20 +237,18 @@
 #endif
 }
 
-static
-struct ip6tables_match owner
-= { NULL,
-    "owner",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_owner_info)),
-    IP6T_ALIGN(sizeof(struct ip6t_owner_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct ip6tables_match owner = {
+	.name 		= "owner",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_owner_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_owner_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_owner.man iptables-1.3.0/extensions/libip6t_owner.man
--- iptables-1.2.11/extensions/libip6t_owner.man	2004-01-22 16:04:24.000000000 +0100
+++ iptables-1.3.0/extensions/libip6t_owner.man	2004-10-10 11:56:24.000000000 +0200
@@ -19,3 +19,5 @@
 .BI "--sid-owner " "sessionid"
 Matches if the packet was created by a process in the given session
 group.
+.TP
+.B NOTE: pid, sid and command matching are broken on SMP
diff -urN iptables-1.2.11/extensions/libip6t_physdev.c iptables-1.3.0/extensions/libip6t_physdev.c
--- iptables-1.2.11/extensions/libip6t_physdev.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/extensions/libip6t_physdev.c	2005-02-01 16:30:28.000000000 +0100
@@ -0,0 +1,230 @@
+/* Shared library add-on to iptables to add bridge port matching support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6t_physdev.h>
+#if defined(__GLIBC__) && __GLIBC__ == 2
+#include <net/ethernet.h>
+#else
+#include <linux/if_ether.h>
+#endif
+
+static void
+help(void)
+{
+	printf(
+"physdev v%s options:\n"
+" --physdev-in [!] input name[+]		bridge port name ([+] for wildcard)\n"
+" --physdev-out [!] output name[+]	bridge port name ([+] for wildcard)\n"
+" [!] --physdev-is-in			arrived on a bridge device\n"
+" [!] --physdev-is-out			will leave on a bridge device\n"
+" [!] --physdev-is-bridged		it's a bridged packet\n"
+"\n", IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "physdev-in", 1, 0, '1' },
+	{ "physdev-out", 1, 0, '2' },
+	{ "physdev-is-in", 0, 0, '3' },
+	{ "physdev-is-out", 0, 0, '4' },
+	{ "physdev-is-bridged", 0, 0, '5' },
+	{0}
+};
+
+/* copied from iptables.c */
+static void
+parse_interface(const char *arg, char *vianame, unsigned char *mask)
+{
+	int vialen = strlen(arg);
+	unsigned int i;
+
+	memset(mask, 0, IFNAMSIZ);
+	memset(vianame, 0, IFNAMSIZ);
+
+	if (vialen + 1 > IFNAMSIZ)
+		exit_error(PARAMETER_PROBLEM,
+			   "interface name `%s' must be shorter than IFNAMSIZ"
+			   " (%i)", arg, IFNAMSIZ-1);
+
+	strcpy(vianame, arg);
+	if (vialen == 0)
+		memset(mask, 0, IFNAMSIZ);
+	else if (vianame[vialen - 1] == '+') {
+		memset(mask, 0xFF, vialen - 1);
+		memset(mask + vialen - 1, 0, IFNAMSIZ - vialen + 1);
+		/* Don't remove `+' here! -HW */
+	} else {
+		/* Include nul-terminator in match */
+		memset(mask, 0xFF, vialen + 1);
+		memset(mask + vialen + 1, 0, IFNAMSIZ - vialen - 1);
+		for (i = 0; vianame[i]; i++) {
+			if (!isalnum(vianame[i])
+			    && vianame[i] != '_'
+			    && vianame[i] != '.') {
+				printf("Warning: wierd character in interface"
+				       " `%s' (No aliases, :, ! or *).\n",
+				       vianame);
+				break;
+			}
+		}
+	}
+}
+
+static void
+init(struct ip6t_entry_match *m, unsigned int *nfcache)
+{
+}
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct ip6t_physdev_info *info =
+		(struct ip6t_physdev_info*)(*match)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags & IP6T_PHYSDEV_OP_IN)
+			goto multiple_use;
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_interface(argv[optind-1], info->physindev, info->in_mask);
+		if (invert)
+			info->invert |= IP6T_PHYSDEV_OP_IN;
+		info->bitmask |= IP6T_PHYSDEV_OP_IN;
+		*flags |= IP6T_PHYSDEV_OP_IN;
+		break;
+
+	case '2':
+		if (*flags & IP6T_PHYSDEV_OP_OUT)
+			goto multiple_use;
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_interface(argv[optind-1], info->physoutdev,
+				info->out_mask);
+		if (invert)
+			info->invert |= IP6T_PHYSDEV_OP_OUT;
+		info->bitmask |= IP6T_PHYSDEV_OP_OUT;
+		*flags |= IP6T_PHYSDEV_OP_OUT;
+		break;
+
+	case '3':
+		if (*flags & IP6T_PHYSDEV_OP_ISIN)
+			goto multiple_use;
+		check_inverse(optarg, &invert, &optind, 0);
+		info->bitmask |= IP6T_PHYSDEV_OP_ISIN;
+		if (invert)
+			info->invert |= IP6T_PHYSDEV_OP_ISIN;
+		*flags |= IP6T_PHYSDEV_OP_ISIN;
+		break;
+
+	case '4':
+		if (*flags & IP6T_PHYSDEV_OP_ISOUT)
+			goto multiple_use;
+		check_inverse(optarg, &invert, &optind, 0);
+		info->bitmask |= IP6T_PHYSDEV_OP_ISOUT;
+		if (invert)
+			info->invert |= IP6T_PHYSDEV_OP_ISOUT;
+		*flags |= IP6T_PHYSDEV_OP_ISOUT;
+		break;
+
+	case '5':
+		if (*flags & IP6T_PHYSDEV_OP_BRIDGED)
+			goto multiple_use;
+		check_inverse(optarg, &invert, &optind, 0);
+		if (invert)
+			info->invert |= IP6T_PHYSDEV_OP_BRIDGED;
+		*flags |= IP6T_PHYSDEV_OP_BRIDGED;
+		info->bitmask |= IP6T_PHYSDEV_OP_BRIDGED;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+multiple_use:
+	exit_error(PARAMETER_PROBLEM,
+	   "multiple use of the same physdev option is not allowed");
+
+}
+
+static void final_check(unsigned int flags)
+{
+	if (flags == 0)
+		exit_error(PARAMETER_PROBLEM, "PHYSDEV: no physdev option specified");
+}
+
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	struct ip6t_physdev_info *info =
+		(struct ip6t_physdev_info*)match->data;
+
+	printf("PHYSDEV match");
+	if (info->bitmask & IP6T_PHYSDEV_OP_ISIN)
+		printf("%s --physdev-is-in",
+		       info->invert & IP6T_PHYSDEV_OP_ISIN ? " !":"");
+	if (info->bitmask & IP6T_PHYSDEV_OP_IN)
+		printf("%s --physdev-in %s",
+		(info->invert & IP6T_PHYSDEV_OP_IN) ? " !":"", info->physindev);
+
+	if (info->bitmask & IP6T_PHYSDEV_OP_ISOUT)
+		printf("%s --physdev-is-out",
+		       info->invert & IP6T_PHYSDEV_OP_ISOUT ? " !":"");
+	if (info->bitmask & IP6T_PHYSDEV_OP_OUT)
+		printf("%s --physdev-out %s",
+		(info->invert & IP6T_PHYSDEV_OP_OUT) ? " !":"", info->physoutdev);
+	if (info->bitmask & IP6T_PHYSDEV_OP_BRIDGED)
+		printf("%s --physdev-is-bridged",
+		       info->invert & IP6T_PHYSDEV_OP_BRIDGED ? " !":"");
+	printf(" ");
+}
+
+static void save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+	struct ip6t_physdev_info *info =
+		(struct ip6t_physdev_info*)match->data;
+
+	if (info->bitmask & IP6T_PHYSDEV_OP_ISIN)
+		printf("%s --physdev-is-in",
+		       info->invert & IP6T_PHYSDEV_OP_ISIN ? " !":"");
+	if (info->bitmask & IP6T_PHYSDEV_OP_IN)
+		printf("%s --physdev-in %s",
+		(info->invert & IP6T_PHYSDEV_OP_IN) ? " !":"", info->physindev);
+
+	if (info->bitmask & IP6T_PHYSDEV_OP_ISOUT)
+		printf("%s --physdev-is-out",
+		       info->invert & IP6T_PHYSDEV_OP_ISOUT ? " !":"");
+	if (info->bitmask & IP6T_PHYSDEV_OP_OUT)
+		printf("%s --physdev-out %s",
+		(info->invert & IP6T_PHYSDEV_OP_OUT) ? " !":"", info->physoutdev);
+	if (info->bitmask & IP6T_PHYSDEV_OP_BRIDGED)
+		printf("%s --physdev-is-bridged",
+		       info->invert & IP6T_PHYSDEV_OP_BRIDGED ? " !":"");
+	printf(" ");
+}
+
+static struct ip6tables_match physdev = {
+	.name		= "physdev",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_physdev_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_physdev_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
+};
+
+void _init(void)
+{
+	register_match6(&physdev);
+}
diff -urN iptables-1.2.11/extensions/libip6t_physdev.man iptables-1.3.0/extensions/libip6t_physdev.man
--- iptables-1.2.11/extensions/libip6t_physdev.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/extensions/libip6t_physdev.man	2004-10-10 11:56:25.000000000 +0200
@@ -0,0 +1,42 @@
+This module matches on the bridge port input and output devices enslaved
+to a bridge device. This module is a part of the infrastructure that enables
+a transparent bridging IP firewall and is only useful for kernel versions
+above version 2.5.44.
+.TP
+.B --physdev-in name
+Name of a bridge port via which a packet is received (only for
+packets entering the
+.BR INPUT ,
+.B FORWARD
+and
+.B PREROUTING
+chains). If the interface name ends in a "+", then any
+interface which begins with this name will match. If the packet didn't arrive
+through a bridge device, this packet won't match this option, unless '!' is used.
+.TP
+.B --physdev-out name
+Name of a bridge port via which a packet is going to be sent (for packets
+entering the
+.BR FORWARD ,
+.B OUTPUT
+and
+.B POSTROUTING
+chains).  If the interface name ends in a "+", then any
+interface which begins with this name will match. Note that in the
+.BR nat " and " mangle
+.B OUTPUT
+chains one cannot match on the bridge output port, however one can in the
+.B "filter OUTPUT"
+chain. If the packet won't leave by a bridge device or it is yet unknown what
+the output device will be, then the packet won't match this option, unless
+'!' is used.
+.TP
+.B --physdev-is-in
+Matches if the packet has entered through a bridge interface.
+.TP
+.B --physdev-is-out
+Matches if the packet will leave through a bridge interface.
+.TP
+.B --physdev-is-bridged
+Matches if the packet is being bridged and therefore is not being routed.
+This is only useful in the FORWARD and POSTROUTING chains.
diff -urN iptables-1.2.11/extensions/libip6t_random.c iptables-1.3.0/extensions/libip6t_random.c
--- iptables-1.2.11/extensions/libip6t_random.c	2003-05-03 15:46:18.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_random.c	2005-02-01 16:31:19.000000000 +0100
@@ -131,19 +131,18 @@
 	printf("--average %u ", result.quot);
 }
 
-struct ip6tables_match rand_match
-= { NULL,
-    "random",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_rand_info)),
-    IP6T_ALIGN(sizeof(struct ip6t_rand_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct ip6tables_match rand_match = {
+	.name		= "random",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_rand_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_rand_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_rt.c iptables-1.3.0/extensions/libip6t_rt.c
--- iptables-1.2.11/extensions/libip6t_rt.c	2002-06-14 09:38:16.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_rt.c	2005-02-01 16:32:10.000000000 +0100
@@ -341,20 +341,18 @@
 
 }
 
-static
-struct ip6tables_match rt
-= { NULL,
-    "rt",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_rt)),
-    IP6T_ALIGN(sizeof(struct ip6t_rt)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct ip6tables_match rt = {
+	.name		= "rt",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_rt)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_rt)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void
diff -urN iptables-1.2.11/extensions/libip6t_standard.c iptables-1.3.0/extensions/libip6t_standard.c
--- iptables-1.2.11/extensions/libip6t_standard.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_standard.c	2005-02-01 16:33:02.000000000 +0100
@@ -47,20 +47,17 @@
 {
 }
 
-static
-struct ip6tables_target standard
-= { NULL,
-    "standard",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(int)),
-    IP6T_ALIGN(sizeof(int)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    NULL, /* print */
-    &save,
-    opts
+static struct ip6tables_target standard = {
+	.name		= "standard",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(int)),
+	.userspacesize	= IP6T_ALIGN(sizeof(int)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_tcp.c iptables-1.3.0/extensions/libip6t_tcp.c
--- iptables-1.2.11/extensions/libip6t_tcp.c	2003-03-30 20:29:56.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_tcp.c	2005-02-01 16:38:57.000000000 +0100
@@ -424,20 +424,19 @@
 	}
 }
 
-static
-struct ip6tables_match tcp
-= { NULL,
-    "tcp",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_tcp)),
-    IP6T_ALIGN(sizeof(struct ip6t_tcp)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts };
+static struct ip6tables_match tcp = {
+	.name 		= "tcp",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_tcp)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_tcp)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
+};
 
 void
 _init(void)
diff -urN iptables-1.2.11/extensions/libip6t_udp.c iptables-1.3.0/extensions/libip6t_udp.c
--- iptables-1.2.11/extensions/libip6t_udp.c	2003-10-02 21:59:27.000000000 +0200
+++ iptables-1.3.0/extensions/libip6t_udp.c	2005-02-01 16:34:51.000000000 +0100
@@ -233,20 +233,18 @@
 	}
 }
 
-static
-struct ip6tables_match udp
-= { NULL,
-    "udp",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_udp)),
-    IP6T_ALIGN(sizeof(struct ip6t_udp)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct ip6tables_match udp = {
+	.name		= "udp",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_udp)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_udp)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
 };
 
 void
diff -urN iptables-1.2.11/extensions/libipt_BALANCE.c iptables-1.3.0/extensions/libipt_BALANCE.c
--- iptables-1.2.11/extensions/libipt_BALANCE.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_BALANCE.c	2005-01-04 11:38:37.000000000 +0100
@@ -131,20 +131,19 @@
 	printf("-%s ", addr_to_dotted(&a));
 }
 
-static
-struct iptables_target balance
-= { NULL,
-    "BALANCE",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
-    IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target balance = { 
+	.next		= NULL,
+	.name		= "BALANCE",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_CLASSIFY.c iptables-1.3.0/extensions/libipt_CLASSIFY.c
--- iptables-1.2.11/extensions/libipt_CLASSIFY.c	2003-04-11 12:14:10.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_CLASSIFY.c	2005-01-04 11:38:34.000000000 +0100
@@ -108,20 +108,19 @@
 	       TC_H_MAJ(clinfo->priority)>>16, TC_H_MIN(clinfo->priority));
 }
 
-static
-struct iptables_target classify
-= { NULL,
-    "CLASSIFY",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_classify_target_info)),
-    IPT_ALIGN(sizeof(struct ipt_classify_target_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target classify = { 
+	.next		= NULL,
+	.name		= "CLASSIFY",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_classify_target_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_classify_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_CLUSTERIP.c iptables-1.3.0/extensions/libipt_CLUSTERIP.c
--- iptables-1.2.11/extensions/libipt_CLUSTERIP.c	2003-11-26 13:50:38.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_CLUSTERIP.c	2005-02-01 16:49:35.000000000 +0100
@@ -182,7 +182,7 @@
 	return retstr;
 }
 
-static char *mac2str(u_int8_t mac[ETH_ALEN])
+static char *mac2str(const u_int8_t mac[ETH_ALEN])
 {
 	static char buf[ETH_ALEN*3];
 	sprintf(buf, "%02X:%02X:%02X:%02X:%02X:%02X",
@@ -237,20 +237,19 @@
 	*/
 }
 
-static
-struct iptables_target clusterip
-= { NULL,
-    "CLUSTERIP",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_clusterip_tgt_info)),
-    IPT_ALIGN(sizeof(struct ipt_clusterip_tgt_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target clusterip = { 
+	.next		= NULL,
+	.name		= "CLUSTERIP",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_clusterip_tgt_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_clusterip_tgt_info)),
+ 	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_DNAT.c iptables-1.3.0/extensions/libipt_DNAT.c
--- iptables-1.2.11/extensions/libipt_DNAT.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_DNAT.c	2005-02-01 13:51:01.000000000 +0100
@@ -65,7 +65,7 @@
 parse_to(char *arg, int portok, struct ipt_natinfo *info)
 {
 	struct ip_nat_range range;
-	char *colon, *dash;
+	char *colon, *dash, *error;
 	struct in_addr *ip;
 
 	memset(&range, 0, sizeof(range));
@@ -85,6 +85,11 @@
 			exit_error(PARAMETER_PROBLEM,
 				   "Port `%s' not valid\n", colon+1);
 
+		error = strchr(colon+1, ':');
+		if (error)
+			exit_error(PARAMETER_PROBLEM,
+				   "Invalid port:port syntax - use dash\n");
+
 		dash = strchr(colon, '-');
 		if (!dash) {
 			range.min.tcp.port
@@ -224,20 +229,19 @@
 	}
 }
 
-static
-struct iptables_target dnat
-= { NULL,
-    "DNAT",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
-    IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target dnat = { 
+	.next		= NULL,
+	.name		= "DNAT",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_DSCP.c iptables-1.3.0/extensions/libipt_DSCP.c
--- iptables-1.2.11/extensions/libipt_DSCP.c	2004-03-04 08:35:30.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_DSCP.c	2005-01-04 11:38:34.000000000 +0100
@@ -143,20 +143,19 @@
 	printf("--set-dscp 0x%02x ", dinfo->dscp);
 }
 
-static
-struct iptables_target dscp
-= { NULL,
-    "DSCP",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_DSCP_info)),
-    IPT_ALIGN(sizeof(struct ipt_DSCP_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target dscp = { 
+	.next		= NULL,
+	.name		= "DSCP",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_DSCP_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_DSCP_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_ECN.c iptables-1.3.0/extensions/libipt_ECN.c
--- iptables-1.2.11/extensions/libipt_ECN.c	2003-01-13 13:35:28.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_ECN.c	2005-01-04 11:38:36.000000000 +0100
@@ -6,7 +6,7 @@
  *
  * libipt_ECN.c borrowed heavily from libipt_DSCP.c
  *
- * $Id: libipt_ECN.c,v 1.12 2003/01/13 12:35:28 laforge Exp $
+ * $Id: libipt_ECN.c 3507 2004-12-28 13:11:59Z /C=DE/ST=Berlin/L=Berlin/O=Netfilter Project/OU=Development/CN=rusty/emailAddress=rusty@netfilter.org $
  */
 #include <stdio.h>
 #include <string.h>
@@ -164,19 +164,19 @@
 }
 
 static
-struct iptables_target ecn
-= { NULL,
-    "ECN",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_ECN_info)),
-    IPT_ALIGN(sizeof(struct ipt_ECN_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct iptables_target ecn = { 
+	.next		= NULL,
+	.name		= "ECN",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_ECN_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_ECN_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_FTOS.c iptables-1.3.0/extensions/libipt_FTOS.c
--- iptables-1.2.11/extensions/libipt_FTOS.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_FTOS.c	2005-01-04 11:38:34.000000000 +0100
@@ -112,20 +112,19 @@
 	printf("--set-ftos 0x%02x ", finfo->ftos);
 }
 
-static
-struct iptables_target ftos
-= { NULL,
-    "FTOS",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_FTOS_info)),
-    IPT_ALIGN(sizeof(struct ipt_FTOS_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target ftos = {
+	.next		= NULL,
+	.name		= "FTOS",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_FTOS_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_FTOS_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_IPMARK.c iptables-1.3.0/extensions/libipt_IPMARK.c
--- iptables-1.2.11/extensions/libipt_IPMARK.c	2003-06-19 13:58:06.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_IPMARK.c	2005-01-04 11:38:35.000000000 +0100
@@ -148,20 +148,19 @@
 	  printf("--or-mask 0x%lx ", ipmarkinfo->ormask);
 }
 
-static
-struct iptables_target ipmark
-= { NULL,
-    "IPMARK",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_ipmark_target_info)),
-    IPT_ALIGN(sizeof(struct ipt_ipmark_target_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target ipmark = { 
+	.next		= NULL,
+	.name		= "IPMARK",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_ipmark_target_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_ipmark_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_IPV4OPTSSTRIP.c iptables-1.3.0/extensions/libipt_IPV4OPTSSTRIP.c
--- iptables-1.2.11/extensions/libipt_IPV4OPTSSTRIP.c	2002-10-22 12:15:20.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_IPV4OPTSSTRIP.c	2005-01-04 11:38:34.000000000 +0100
@@ -59,20 +59,19 @@
 	/* nothing to print, we don't take option... */
 }
 
-static
-struct iptables_target IPV4OPTSSTRIP
-= { NULL,
-    "IPV4OPTSSTRIP",
-    IPTABLES_VERSION,
-    IPT_ALIGN(0),
-    IPT_ALIGN(0),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target IPV4OPTSSTRIP = { 
+	.next		= NULL,
+	.name		= "IPV4OPTSSTRIP",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(0),
+	.userspacesize	= IPT_ALIGN(0),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_LOG.c iptables-1.3.0/extensions/libipt_LOG.c
--- iptables-1.2.11/extensions/libipt_LOG.c	2004-06-15 00:02:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_LOG.c	2005-01-14 10:01:35.000000000 +0100
@@ -11,6 +11,12 @@
 
 #define LOG_DEFAULT_LEVEL LOG_WARNING
 
+#ifndef IPT_LOG_UID /* Old kernel */
+#define IPT_LOG_UID	0x08	/* Log UID owning local socket */
+#undef  IPT_LOG_MASK
+#define IPT_LOG_MASK	0x0f
+#endif
+
 /* Function which prints out usage message. */
 static void
 help(void)
@@ -21,7 +27,8 @@
 " --log-prefix prefix		Prefix log messages with this prefix.\n\n"
 " --log-tcp-sequence		Log TCP sequence numbers.\n\n"
 " --log-tcp-options		Log TCP options.\n\n"
-" --log-ip-options		Log IP options.\n\n",
+" --log-ip-options		Log IP options.\n\n"
+" --log-uid			Log UID owning the local socket.\n\n",
 IPTABLES_VERSION);
 }
 
@@ -31,6 +38,7 @@
 	{ .name = "log-tcp-sequence", .has_arg = 0, .flag = 0, .val = '1' },
 	{ .name = "log-tcp-options",  .has_arg = 0, .flag = 0, .val = '2' },
 	{ .name = "log-ip-options",   .has_arg = 0, .flag = 0, .val = '3' },
+	{ .name = "log-uid",          .has_arg = 0, .flag = 0, .val = '4' },
 	{ .name = 0 }
 };
 
@@ -98,6 +106,7 @@
 #define IPT_LOG_OPT_TCPSEQ 0x04
 #define IPT_LOG_OPT_TCPOPT 0x08
 #define IPT_LOG_OPT_IPOPT 0x10
+#define IPT_LOG_OPT_UID 0x20
 
 /* Function which parses command options; returns true if it
    ate an option */
@@ -168,6 +177,15 @@
 		*flags |= IPT_LOG_OPT_IPOPT;
 		break;
 
+	case '4':
+		if (*flags & IPT_LOG_OPT_UID)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --log-uid twice");
+
+		loginfo->logflags |= IPT_LOG_UID;
+		*flags |= IPT_LOG_OPT_UID;
+		break;
+
 	default:
 		return 0;
 	}
@@ -211,6 +229,8 @@
 			printf("tcp-options ");
 		if (loginfo->logflags & IPT_LOG_IPOPT)
 			printf("ip-options ");
+		if (loginfo->logflags & IPT_LOG_UID)
+			printf("uid ");
 		if (loginfo->logflags & ~(IPT_LOG_MASK))
 			printf("unknown-flags ");
 	}
@@ -238,6 +258,8 @@
 		printf("--log-tcp-options ");
 	if (loginfo->logflags & IPT_LOG_IPOPT)
 		printf("--log-ip-options ");
+	if (loginfo->logflags & IPT_LOG_UID)
+		printf("--log-uid ");
 }
 
 static
diff -urN iptables-1.2.11/extensions/libipt_LOG.man iptables-1.3.0/extensions/libipt_LOG.man
--- iptables-1.2.11/extensions/libipt_LOG.man	2004-01-22 16:04:24.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_LOG.man	2005-01-04 11:38:37.000000000 +0100
@@ -26,3 +26,6 @@
 .TP
 .B --log-ip-options
 Log options from the IP packet header.
+.TP
+.B --log-uid
+Log the userid of the process which generated the packet.
diff -urN iptables-1.2.11/extensions/libipt_MARK.c iptables-1.3.0/extensions/libipt_MARK.c
--- iptables-1.2.11/extensions/libipt_MARK.c	2004-06-15 00:02:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_MARK.c	2005-01-04 11:38:34.000000000 +0100
@@ -16,12 +16,16 @@
 	printf(
 "MARK target v%s options:\n"
 "  --set-mark value                   Set nfmark value\n"
+"  --and-mark value                   Binary AND the nfmark with value\n"
+"  --or-mark  value                   Binary OR  the nfmark with value\n"
 "\n",
 IPTABLES_VERSION);
 }
 
 static struct option opts[] = {
 	{ "set-mark", 1, 0, '1' },
+	{ "and-mark", 1, 0, '2' },
+	{ "or-mark", 1, 0, '3' },
 	{ 0 }
 };
 
@@ -34,9 +38,9 @@
 /* Function which parses command options; returns true if it
    ate an option */
 static int
-parse(int c, char **argv, int invert, unsigned int *flags,
-      const struct ipt_entry *entry,
-      struct ipt_entry_target **target)
+parse_v0(int c, char **argv, int invert, unsigned int *flags,
+	 const struct ipt_entry *entry,
+	 struct ipt_entry_target **target)
 {
 	struct ipt_mark_target_info *markinfo
 		= (struct ipt_mark_target_info *)(*target)->data;
@@ -56,7 +60,12 @@
 			           "MARK target: Can't specify --set-mark twice");
 		*flags = 1;
 		break;
-
+	case '2':
+		exit_error(PARAMETER_PROBLEM,
+			   "MARK target: kernel too old for --and-mark");
+	case '3':
+		exit_error(PARAMETER_PROBLEM,
+			   "MARK target: kernel too old for --or-mark");
 	default:
 		return 0;
 	}
@@ -69,7 +78,47 @@
 {
 	if (!flags)
 		exit_error(PARAMETER_PROBLEM,
-		           "MARK target: Parameter --set-mark is required");
+		           "MARK target: Parameter --set/and/or-mark"
+			   " is required");
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse_v1(int c, char **argv, int invert, unsigned int *flags,
+	 const struct ipt_entry *entry,
+	 struct ipt_entry_target **target)
+{
+	struct ipt_mark_target_info_v1 *markinfo
+		= (struct ipt_mark_target_info_v1 *)(*target)->data;
+
+	switch (c) {
+	case '1':
+	        markinfo->mode = IPT_MARK_SET;
+		break;
+	case '2':
+	        markinfo->mode = IPT_MARK_AND;
+		break;
+	case '3':
+	        markinfo->mode = IPT_MARK_OR;
+		break;
+	default:
+		return 0;
+	}
+
+#ifdef KERNEL_64_USERSPACE_32
+	if (string_to_number_ll(optarg, 0, 0,  &markinfo->mark))
+#else
+	if (string_to_number_l(optarg, 0, 0, &markinfo->mark))
+#endif
+		exit_error(PARAMETER_PROBLEM, "Bad MARK value `%s'", optarg);
+
+	if (*flags)
+		exit_error(PARAMETER_PROBLEM,
+			   "MARK target: Can't specify --set-mark twice");
+
+	*flags = 1;
+	return 1;
 }
 
 #ifdef KERNEL_64_USERSPACE_32
@@ -88,9 +137,9 @@
 
 /* Prints out the targinfo. */
 static void
-print(const struct ipt_ip *ip,
-      const struct ipt_entry_target *target,
-      int numeric)
+print_v0(const struct ipt_ip *ip,
+	 const struct ipt_entry_target *target,
+	 int numeric)
 {
 	const struct ipt_mark_target_info *markinfo =
 		(const struct ipt_mark_target_info *)target->data;
@@ -100,7 +149,7 @@
 
 /* Saves the union ipt_targinfo in parsable form to stdout. */
 static void
-save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+save_v0(const struct ipt_ip *ip, const struct ipt_entry_target *target)
 {
 	const struct ipt_mark_target_info *markinfo =
 		(const struct ipt_mark_target_info *)target->data;
@@ -109,23 +158,86 @@
 	print_mark(markinfo->mark);
 }
 
+/* Prints out the targinfo. */
+static void
+print_v1(const struct ipt_ip *ip,
+	 const struct ipt_entry_target *target,
+	 int numeric)
+{
+	const struct ipt_mark_target_info_v1 *markinfo =
+		(const struct ipt_mark_target_info_v1 *)target->data;
+
+	switch (markinfo->mode) {
+	case IPT_MARK_SET:
+		printf("MARK set ");
+		break;
+	case IPT_MARK_AND:
+		printf("MARK and ");
+		break;
+	case IPT_MARK_OR: 
+		printf("MARK or ");
+		break;
+	}
+	print_mark(markinfo->mark);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save_v1(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	const struct ipt_mark_target_info_v1 *markinfo =
+		(const struct ipt_mark_target_info_v1 *)target->data;
+
+	switch (markinfo->mode) {
+	case IPT_MARK_SET:
+		printf("--set-mark ");
+		break;
+	case IPT_MARK_AND:
+		printf("--and-mark ");
+		break;
+	case IPT_MARK_OR: 
+		printf("--or-mark ");
+		break;
+	}
+	print_mark(markinfo->mark);
+}
+
+static
+struct iptables_target mark_v0 = {
+	.next		= NULL,
+	.name		= "MARK",
+	.version	= IPTABLES_VERSION,
+	.revision	= 0,
+	.size		= IPT_ALIGN(sizeof(struct ipt_mark_target_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_mark_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse_v0,
+	.final_check	= &final_check,
+	.print		= &print_v0,
+	.save		= &save_v0,
+	.extra_opts	= opts
+};
+
 static
-struct iptables_target mark
-= { NULL,
-    "MARK",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_mark_target_info)),
-    IPT_ALIGN(sizeof(struct ipt_mark_target_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct iptables_target mark_v1 = {
+	.next		= NULL,
+	.name		= "MARK",
+	.version	= IPTABLES_VERSION,
+	.revision	= 1,
+	.size		= IPT_ALIGN(sizeof(struct ipt_mark_target_info_v1)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_mark_target_info_v1)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse_v1,
+	.final_check	= &final_check,
+	.print		= &print_v1,
+	.save		= &save_v1,
+	.extra_opts	= opts
 };
 
 void _init(void)
 {
-	register_target(&mark);
+	register_target(&mark_v0);
+	register_target(&mark_v1);
 }
diff -urN iptables-1.2.11/extensions/libipt_MASQUERADE.c iptables-1.3.0/extensions/libipt_MASQUERADE.c
--- iptables-1.2.11/extensions/libipt_MASQUERADE.c	2003-10-30 07:36:49.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_MASQUERADE.c	2005-01-04 11:38:34.000000000 +0100
@@ -146,20 +146,18 @@
 	}
 }
 
-static
-struct iptables_target masq
-= { NULL,
-    "MASQUERADE",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
-    IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target masq = { NULL,
+	.name		= "MASQUERADE",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_MIRROR.c iptables-1.3.0/extensions/libipt_MIRROR.c
--- iptables-1.2.11/extensions/libipt_MIRROR.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_MIRROR.c	2005-01-04 11:38:34.000000000 +0100
@@ -41,20 +41,19 @@
 {
 }
 
-static
-struct iptables_target mirror
-= { NULL,
-    "MIRROR",
-    IPTABLES_VERSION,
-    IPT_ALIGN(0),
-    IPT_ALIGN(0),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    NULL, /* print */
-    NULL, /* save */
-    opts
+static struct iptables_target mirror = {
+	.next		= NULL,
+	.name		= "MIRROR",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(0),
+	.userspacesize	= IPT_ALIGN(0),
+ 	.help		= &help,
+	.init		= &init,
+ 	.parse		= &parse,
+	.final_check 	= &final_check,
+	.print		= NULL,
+	.save		= NULL,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_NETLINK.c iptables-1.3.0/extensions/libipt_NETLINK.c
--- iptables-1.2.11/extensions/libipt_NETLINK.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_NETLINK.c	2005-01-04 11:38:36.000000000 +0100
@@ -136,19 +136,19 @@
 		printf("nlsize %i ", nld->size);
 }
 
-static
-struct iptables_target netlink = { NULL,
-	"NETLINK",
-	IPTABLES_VERSION,
-	IPT_ALIGN(sizeof(struct ipt_nldata)),
-	IPT_ALIGN(sizeof(struct ipt_nldata)),
-	&help,
-	&init,
-	&parse,
-	&final_check,
-	&print,
-	&save,
-	opts
+static struct iptables_target netlink = {
+	.next		= NULL,
+	.name		= "NETLINK",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_nldata)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_nldata)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_NETMAP.c iptables-1.3.0/extensions/libipt_NETMAP.c
--- iptables-1.2.11/extensions/libipt_NETMAP.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_NETMAP.c	2005-01-04 11:38:37.000000000 +0100
@@ -179,20 +179,19 @@
 	print(ip, target, 0);
 }
 
-static
-struct iptables_target target_module
-= { NULL,
-    MODULENAME,
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
-    IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target target_module = {
+	.next		= NULL,
+	.name		= MODULENAME,
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_POOL.c iptables-1.3.0/extensions/libipt_POOL.c
--- iptables-1.2.11/extensions/libipt_POOL.c	2002-06-04 19:25:38.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_POOL.c	2005-01-04 11:38:34.000000000 +0100
@@ -133,20 +133,19 @@
 	}
 }
 
-static
-struct iptables_target ipt_pool_target
-= { NULL,
-    "POOL",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_pool_info)),
-    IPT_ALIGN(sizeof(struct ipt_pool_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target ipt_pool_target = { 
+	.next		= NULL,
+	.name		= "POOL",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_pool_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_pool_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_REDIRECT.c iptables-1.3.0/extensions/libipt_REDIRECT.c
--- iptables-1.2.11/extensions/libipt_REDIRECT.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_REDIRECT.c	2005-01-04 11:38:34.000000000 +0100
@@ -147,20 +147,19 @@
 	}
 }
 
-static
-struct iptables_target redir
-= { NULL,
-    "REDIRECT",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
-    IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target redir = { 
+	.next		= NULL,
+	.name		= "REDIRECT",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.help		= &help,
+	.init		= &init,
+ 	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_REJECT.c iptables-1.3.0/extensions/libipt_REJECT.c
--- iptables-1.2.11/extensions/libipt_REJECT.c	2003-05-24 13:44:18.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_REJECT.c	2005-01-04 11:38:37.000000000 +0100
@@ -170,20 +170,19 @@
 	printf("--reject-with %s ", reject_table[i].name);
 }
 
-static
-struct iptables_target reject
-= { NULL,
-    "REJECT",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_reject_info)),
-    IPT_ALIGN(sizeof(struct ipt_reject_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target reject = { 
+	.next		= NULL,
+	.name		= "REJECT",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_reject_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_reject_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_ROUTE.c iptables-1.3.0/extensions/libipt_ROUTE.c
--- iptables-1.2.11/extensions/libipt_ROUTE.c	2003-07-25 13:35:56.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_ROUTE.c	2005-01-04 11:38:33.000000000 +0100
@@ -1,6 +1,6 @@
 /* Shared library add-on to iptables to add ROUTE target support.
  * Author : Cedric de Launois, <delaunois@info.ucl.ac.be>
- * v 1.8 2003/06/24
+ * v 1.11 2004/11/23
  */
 
 #include <stdio.h>
@@ -15,19 +15,27 @@
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/netfilter_ipv4/ipt_ROUTE.h>
 
+/* compile IPT_ROUTE_TEE support even if kernel headers are unpatched */
+#ifndef IPT_ROUTE_TEE
+#define IPT_ROUTE_TEE		0x02
+#endif
+
 /* Function which prints out usage message. */
 static void
 help(void)
 {
 	printf(
 "ROUTE target v%s options:\n"
-"    --oif   \tifname \t\tRoute the packet through `ifname' network interface\n"
-"    --iif   \tifname \t\tChange the packet's incoming interface to `ifname'\n"
-"    --gw    \tip     \t\tRoute the packet via this gateway\n"
-"    --continue\t     \t\tRoute the packet and continue traversing the\n"
-"            \t       \t\trules. Not valid with --iif.\n"
+"    --oif   \tifname \t\tRoute packet through `ifname' network interface\n"
+"    --iif   \tifname \t\tChange packet's incoming interface to `ifname'\n"
+"    --gw    \tip     \t\tRoute packet via this gateway `ip'\n"
+"    --continue\t     \t\tRoute packet and continue traversing the\n"
+"            \t       \t\trules. Not valid with --iif or --tee.\n"
+"    --tee\t  \t\tDuplicate packet, route the duplicate,\n"
+"            \t       \t\tcontinue traversing with original packet.\n"
+"            \t       \t\tNot valid with --iif or --continue.\n"
 "\n",
-"1.8");
+"1.11");
 }
 
 static struct option opts[] = {
@@ -35,6 +43,7 @@
 	{ "iif", 1, 0, '2' },
 	{ "gw", 1, 0, '3' },
 	{ "continue", 0, 0, '4' },
+	{ "tee", 0, 0, '5' },
 	{ 0 }
 };
 
@@ -56,6 +65,7 @@
 #define IPT_ROUTE_OPT_IIF      0x02
 #define IPT_ROUTE_OPT_GW       0x04
 #define IPT_ROUTE_OPT_CONTINUE 0x08
+#define IPT_ROUTE_OPT_TEE      0x10
 
 /* Function which parses command options; returns true if it
    ate an option */
@@ -134,12 +144,28 @@
 		if (*flags & IPT_ROUTE_OPT_CONTINUE)
 			exit_error(PARAMETER_PROBLEM,
 				   "Can't specify --continue twice");
+		if (*flags & IPT_ROUTE_OPT_TEE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue AND --tee");
 
 		route_info->flags |= IPT_ROUTE_CONTINUE;
 		*flags |= IPT_ROUTE_OPT_CONTINUE;
 
 		break;
 
+	case '5':
+		if (*flags & IPT_ROUTE_OPT_TEE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee twice");
+		if (*flags & IPT_ROUTE_OPT_CONTINUE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee AND --continue");
+
+		route_info->flags |= IPT_ROUTE_TEE;
+		*flags |= IPT_ROUTE_OPT_TEE;
+
+		break;
+
 	default:
 		return 0;
 	}
@@ -155,7 +181,7 @@
 		exit_error(PARAMETER_PROBLEM,
 		           "ROUTE target: oif, iif or gw option required");
 
-	if ((flags & IPT_ROUTE_OPT_CONTINUE) && (flags & IPT_ROUTE_OPT_IIF))
+	if ((flags & (IPT_ROUTE_OPT_CONTINUE|IPT_ROUTE_OPT_TEE)) && (flags & IPT_ROUTE_OPT_IIF))
 		exit_error(PARAMETER_PROBLEM,
 			   "ROUTE target: can't continue traversing the rules with iif option");
 }
@@ -186,6 +212,9 @@
 	if (route_info->flags & IPT_ROUTE_CONTINUE)
 		printf("continue");
 
+	if (route_info->flags & IPT_ROUTE_TEE)
+		printf("tee");
+
 }
 
 
@@ -208,23 +237,25 @@
 
 	if (route_info->flags & IPT_ROUTE_CONTINUE)
 		printf("--continue ");
+
+	if (route_info->flags & IPT_ROUTE_TEE)
+		printf("--tee ");
 }
 
 
-static
-struct iptables_target route
-= { NULL,
-    "ROUTE",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_route_target_info)),
-    IPT_ALIGN(sizeof(struct ipt_route_target_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target route = { 
+	.next		= NULL,
+	.name		= "ROUTE",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_route_target_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_route_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_ROUTE.man iptables-1.3.0/extensions/libipt_ROUTE.man
--- iptables-1.2.11/extensions/libipt_ROUTE.man	2004-01-22 16:04:24.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_ROUTE.man	2004-12-14 13:57:00.000000000 +0100
@@ -12,4 +12,7 @@
 Route the packet via this gateway
 .TP
 .BI "--continue "
-Behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--iif'
+Behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--iif' or `--tee'
+.TP
+.BI "--tee "
+Make a copy of the packet, and route that copy to the given destination. For the original, uncopied packet, behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--iif' or `--continue'
diff -urN iptables-1.2.11/extensions/libipt_SAME.c iptables-1.3.0/extensions/libipt_SAME.c
--- iptables-1.2.11/extensions/libipt_SAME.c	2004-06-15 00:02:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_SAME.c	2005-01-04 11:38:36.000000000 +0100
@@ -189,20 +189,19 @@
 		printf("--nodst ");
 }
 
-static
-struct iptables_target same
-= { NULL,
-    "SAME",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_same_info)),
-    IPT_ALIGN(sizeof(struct ipt_same_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target same = {
+	.next		= NULL,
+	.name		= "SAME",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_same_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_same_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_SET.c iptables-1.3.0/extensions/libipt_SET.c
--- iptables-1.2.11/extensions/libipt_SET.c	2004-02-09 14:47:01.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_SET.c	2004-12-14 13:57:01.000000000 +0100
@@ -1,3 +1,13 @@
+/* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
+ *                         Patrick Schaaf <bof@bof.de>
+ *                         Martin Josefsson <gandalf@wlug.westbo.se>
+ * Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.  
+ */
+
 /* Shared library add-on to iptables to add IP set mangling target. */
 #include <stdio.h>
 #include <netdb.h>
@@ -11,14 +21,14 @@
 #include <linux/netfilter_ipv4/ip_nat_rule.h>
 #include <linux/netfilter_ipv4/ip_set.h>
 #include <linux/netfilter_ipv4/ipt_set.h>
-#include "../ipset/libipt_set.h"
+#include "libipt_set.h"
 
 /* Function which prints out usage message. */
 static void help(void)
 {
 	printf("SET v%s options:\n"
-	       " --add-set name[:flags] flags\n"
-	       " --del-set name[:flags] flags\n"
+	       " --add-set name flags\n"
+	       " --del-set name flags\n"
 	       "		add/del src/dst IP/port from/to named sets,\n"
 	       "		where flags are the comma separated list of\n"
 	       "		'src' and 'dst'.\n"
@@ -38,13 +48,42 @@
 	    (struct ipt_set_info_target *) target->data;
 
 	memset(info, 0, sizeof(struct ipt_set_info_target));
-	info->add_set.id = -1;
-	info->del_set.id = -1;
+	info->add_set.index =
+	info->del_set.index = IP_SET_INVALID_ID;
 
 	/* Can't cache this */
 	*nfcache |= NFC_UNKNOWN;
 }
 
+static void
+parse_target(char **argv, int invert, unsigned int *flags,
+             struct ipt_set_info *info, const char *what)
+{
+	if (info->flags[0])
+		exit_error(PARAMETER_PROBLEM,
+			   "--%s can be specified only once", what);
+
+	if (check_inverse(optarg, &invert, NULL, 0))
+		exit_error(PARAMETER_PROBLEM,
+			   "Unexpected `!' after --%s", what);
+
+	if (!argv[optind]
+	    || argv[optind][0] == '-' || argv[optind][0] == '!')
+		exit_error(PARAMETER_PROBLEM,
+			   "--%s requires two args.", what);
+
+	if (strlen(argv[optind-1]) > IP_SET_MAXNAMELEN - 1)
+		exit_error(PARAMETER_PROBLEM,
+			   "setname `%s' too long, max %d characters.",
+			   argv[optind-1], IP_SET_MAXNAMELEN - 1);
+
+	get_set_byname(argv[optind - 1], info);
+	parse_bindings(argv[optind], info);
+	optind++;
+	
+	*flags = 1;
+}
+
 /* Function which parses command options; returns true if it
    ate an option */
 static int
@@ -53,44 +92,15 @@
 {
 	struct ipt_set_info_target *myinfo =
 	    (struct ipt_set_info_target *) (*target)->data;
-	struct ipt_set_info *info;
 
 	switch (c) {
-	case '1':		/* --add-set <set>[:<flags>] <flags> */
-		info = &myinfo->add_set;
-
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM,
-				   "Unexpected `!' after --add-set");
-
-		if (!argv[optind]
-		    || argv[optind][0] == '-' || argv[optind][0] == '!')
-			exit_error(PARAMETER_PROBLEM,
-				   "--add-set requires two args.");
-
-		parse_pool(argv[optind - 1], info);
-		parse_ipflags(argv[optind++], info);
-		
-		*flags = 1;
+	case '1':		/* --add-set <set> <flags> */
+		parse_target(argv, invert, flags,
+			     &myinfo->add_set, "add-set");
 		break;
 	case '2':		/* --del-set <set>[:<flags>] <flags> */
-		info = &myinfo->del_set;
-
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM,
-				   "Unexpected `!' after --del-set");
-
-		if (!argv[optind]
-		    || argv[optind][0] == '-' || argv[optind][0] == '!')
-			exit_error(PARAMETER_PROBLEM,
-				   "--del-set requires two args.");
-
-		parse_pool(argv[optind - 1], info);
-		if (parse_ipflags(argv[optind++], info))
-			exit_error(PARAMETER_PROBLEM,
-				   "Can't use overwrite flag with --del-set.");
-		
-		*flags = 1;
+		parse_target(argv, invert, flags,
+			     &myinfo->del_set, "del-set");
 		break;
 
 	default:
@@ -112,21 +122,17 @@
 {
 	int i;
 	char setname[IP_SET_MAXNAMELEN];
-
-	if (info->id >= 0) {
-		get_set_byid(setname, info->id);
-		printf("%s %s", prefix, setname);
-		for (i = 0; i < info->set_level; i++)
-			printf("%s%s",
-			       i == 0 ? ":" : ",",
-			       info->flags[i] & IPSET_SRC ? "src" : "dst");
-		for (i = info->set_level; i < info->ip_level; i++)
-			printf("%s%s%s",
-			       i == info->set_level ? " " : ",",
-			       info->flags[i] & IPSET_ADD_OVERWRITE ? "+" : "",
-			       info->flags[i] & IPSET_SRC ? "src" : "dst");
-		printf(" ");
+	
+	get_set_byid(setname, info->index);
+	printf("%s %s", prefix, setname);
+	for (i = 0; i < IP_SET_MAX_BINDINGS; i++) {
+		if (!info->flags[i])
+			break;		
+		printf("%s%s",
+		       i == 0 ? " " : ",",
+		       info->flags[i] & IPSET_SRC ? "src" : "dst");
 	}
+	printf(" ");
 }
 
 /* Prints out the targinfo. */
diff -urN iptables-1.2.11/extensions/libipt_SET.man iptables-1.3.0/extensions/libipt_SET.man
--- iptables-1.2.11/extensions/libipt_SET.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_SET.man	2004-12-14 13:57:01.000000000 +0100
@@ -0,0 +1,16 @@
+This modules adds and/or deletes entries from IP sets which can be defined 
+by ipset(8).
+.TP
+.BR "--add-set " "setname flag[,flag...]"
+add the address(es)/port(s) of the packet to the sets
+.TP
+.BR "--del-set " "setname flag[,flag...]"
+delete the address(es)/port(s) of the packet from the sets,
+where flags are
+.BR "src"
+and/or
+.BR "dst"
+and there can be no more than six of them.
+.TP
+The bindings to follow must previously be defined in order to use 
+multilevel adding/deleting by the SET target.
diff -urN iptables-1.2.11/extensions/libipt_SNAT.c iptables-1.3.0/extensions/libipt_SNAT.c
--- iptables-1.2.11/extensions/libipt_SNAT.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_SNAT.c	2005-02-01 13:51:01.000000000 +0100
@@ -65,7 +65,7 @@
 parse_to(char *arg, int portok, struct ipt_natinfo *info)
 {
 	struct ip_nat_range range;
-	char *colon, *dash;
+	char *colon, *dash, *error;
 	struct in_addr *ip;
 
 	memset(&range, 0, sizeof(range));
@@ -85,6 +85,11 @@
 			exit_error(PARAMETER_PROBLEM,
 				   "Port `%s' not valid\n", colon+1);
 
+		error = strchr(colon+1, ':');
+		if (error)
+			exit_error(PARAMETER_PROBLEM,
+				   "Invalid port:port syntax - use dash\n");
+
 		dash = strchr(colon, '-');
 		if (!dash) {
 			range.min.tcp.port
@@ -224,20 +229,19 @@
 	}
 }
 
-static
-struct iptables_target snat
-= { NULL,
-    "SNAT",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
-    IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target snat = {
+	.next		= NULL,
+	.name		= "SNAT",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_TARPIT.c iptables-1.3.0/extensions/libipt_TARPIT.c
--- iptables-1.2.11/extensions/libipt_TARPIT.c	2002-12-05 21:50:09.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_TARPIT.c	2005-01-04 11:38:35.000000000 +0100
@@ -45,20 +45,19 @@
 {
 }
 
-static
-struct iptables_target tarpit
-= { NULL,
-    "TARPIT",
-    IPTABLES_VERSION,
-    IPT_ALIGN(0),
-    IPT_ALIGN(0),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target tarpit = {
+	.next		= NULL,
+	.name		= "TARPIT",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(0),
+	.userspacesize	= IPT_ALIGN(0),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_TCPMSS.c iptables-1.3.0/extensions/libipt_TCPMSS.c
--- iptables-1.2.11/extensions/libipt_TCPMSS.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_TCPMSS.c	2005-01-04 11:38:36.000000000 +0100
@@ -113,20 +113,19 @@
 		printf("--set-mss %u ", mssinfo->mss);
 }
 
-static
-struct iptables_target mss
-= { NULL,
-    "TCPMSS",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_tcpmss_info)),
-    IPT_ALIGN(sizeof(struct ipt_tcpmss_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target mss = {
+	.next		= NULL,
+	.name		= "TCPMSS",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_tcpmss_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_tcpmss_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_TOS.c iptables-1.3.0/extensions/libipt_TOS.c
--- iptables-1.2.11/extensions/libipt_TOS.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_TOS.c	2005-01-04 11:38:37.000000000 +0100
@@ -153,20 +153,19 @@
 	printf("--set-tos 0x%02x ", tosinfo->tos);
 }
 
-static
-struct iptables_target tos
-= { NULL,
-    "TOS",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_tos_target_info)),
-    IPT_ALIGN(sizeof(struct ipt_tos_target_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target tos = {
+	.next		= NULL,
+	.name		= "TOS",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_tos_target_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_tos_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_TTL.c iptables-1.3.0/extensions/libipt_TTL.c
--- iptables-1.2.11/extensions/libipt_TTL.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_TTL.c	2005-01-04 11:38:34.000000000 +0100
@@ -1,7 +1,7 @@
 /* Shared library add-on to iptables for the TTL target
  * (C) 2000 by Harald Welte <laforge@gnumonks.org>
  *
- * $Id: libipt_TTL.c,v 1.6 2002/05/29 13:08:16 laforge Exp $
+ * $Id: libipt_TTL.c 3507 2004-12-28 13:11:59Z /C=DE/ST=Berlin/L=Berlin/O=Netfilter Project/OU=Development/CN=rusty/emailAddress=rusty@netfilter.org $
  *
  * This program is distributed under the terms of GNU GPL
  */
@@ -24,9 +24,9 @@
 {
 	printf(
 "TTL target v%s options\n"
-"  --ttl-set value		Set TTL to <value>\n"
-"  --ttl-dec value		Decrement TTL by <value>\n"
-"  --ttl-inc value		Increment TTL by <value>\n"
+"  --ttl-set value		Set TTL to <value 0-255>\n"
+"  --ttl-dec value		Decrement TTL by <value 1-255>\n"
+"  --ttl-inc value		Increment TTL by <value 1-255>\n"
 , IPTABLES_VERSION);
 }
 
@@ -35,7 +35,7 @@
 		struct ipt_entry_target **target)
 {
 	struct ipt_TTL_info *info = (struct ipt_TTL_info *) (*target)->data;
-	u_int8_t value;
+	unsigned int value;
 
 	if (*flags & IPT_TTL_USED) {
 		exit_error(PARAMETER_PROBLEM, 
@@ -50,7 +50,9 @@
 		exit_error(PARAMETER_PROBLEM,
 				"TTL: unexpected `!'");
 	
-	value = atoi(optarg);
+	if (string_to_number(optarg, 0, 255, &value) == -1)
+		exit_error(PARAMETER_PROBLEM,
+		           "TTL: Expected value between 0 and 255");
 
 	switch (c) {
 
@@ -143,19 +145,19 @@
 	{ 0 }
 };
 
-static
-struct iptables_target TTL = { NULL, 
-	"TTL",
-	IPTABLES_VERSION,
-	IPT_ALIGN(sizeof(struct ipt_TTL_info)),
-	IPT_ALIGN(sizeof(struct ipt_TTL_info)),
-	&help,
-	&init,
-	&parse,
-	&final_check,
-	&print,
-	&save,
-	opts 
+static struct iptables_target TTL = {
+	.next		= NULL, 
+	.name		= "TTL",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_TTL_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_TTL_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts 
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_ULOG.c iptables-1.3.0/extensions/libipt_ULOG.c
--- iptables-1.2.11/extensions/libipt_ULOG.c	2004-06-15 00:02:17.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_ULOG.c	2005-01-04 11:38:36.000000000 +0100
@@ -208,19 +208,19 @@
 #endif
 }
 
-static
-struct iptables_target ulog = { NULL,
-	"ULOG",
-	IPTABLES_VERSION,
-	IPT_ALIGN(sizeof(struct ipt_ulog_info)),
-	IPT_ALIGN(sizeof(struct ipt_ulog_info)),
-	&help,
-	&init,
-	&parse,
-	&final_check,
-	&print,
-	&save,
-	opts
+static struct iptables_target ulog = {
+	.next		= NULL,
+	.name		= "ULOG",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_ulog_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_ulog_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_XOR.c iptables-1.3.0/extensions/libipt_XOR.c
--- iptables-1.2.11/extensions/libipt_XOR.c	2004-02-19 19:04:17.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_XOR.c	2005-01-04 11:38:36.000000000 +0100
@@ -93,18 +93,19 @@
 	{ 0 }
 };
 
-static struct iptables_target XOR = { NULL, 
-	"XOR",
-	IPTABLES_VERSION,
-	IPT_ALIGN(sizeof(struct ipt_XOR_info)),
-	IPT_ALIGN(sizeof(struct ipt_XOR_info)),
-	&help,
-	&init,
-	&parse,
-	&final_check,
-	&print,
-	&save,
-	opts 
+static struct iptables_target XOR = {
+	.next		= NULL, 
+	.name		= "XOR",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_XOR_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_XOR_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts 
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_account.c iptables-1.3.0/extensions/libipt_account.c
--- iptables-1.2.11/extensions/libipt_account.c	2004-03-17 15:27:08.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_account.c	2004-10-10 11:56:24.000000000 +0200
@@ -2,7 +2,7 @@
  * accounting match helper (libipt_account.c)
  * (C) 2003,2004 by Piotr Gasido (quaker@barbara.eu.org)
  *
- * Version: 0.1.5
+ * Version: 0.1.6
  *
  * This software is distributed under the terms of GNU GPL
  */
@@ -31,15 +31,18 @@
 			"--aname name\n"
 			"	defines name of list where statistics will be kept. If no is\n"
 			"	specified DEFAULT will be used.\n"
-
+			"--ashort\n"
+			"       table will colect only short statistics (only total counters\n"
+			"       without splitting it into protocols.\n"
 	, 
 	IPTABLES_VERSION);
 };
 
 static struct option opts[] = {
-	{ "aaddr", 1, NULL, 201 },
-	{ "aname", 1, NULL, 202 },
-	{ 0 }
+	{ .name = "aaddr",  .has_arg = 1, .flag = NULL, .val = 201 },
+	{ .name = "aname",  .has_arg = 1, .flag = NULL, .val = 202 },
+	{ .name = "ashort", .has_arg = 0, .flag = NULL, .val = 203 },
+	{ .name = 0, .has_arg = 0, .flag = 0, .val = 0 }
 };
 
 /* Helper functions for parse_network */
@@ -139,6 +142,26 @@
 	
 }
 
+/* validate netmask */
+inline int valid_netmask(u_int32_t netmask) {
+	while (netmask & 0x80000000)
+		netmask <<= 1;
+	if (netmask != 0)
+		return 0;
+        return 1;
+}
+
+/* validate network/netmask pair */
+inline int valid_network_and_netmask(struct t_ipt_account_info *info) {
+	if (!valid_netmask(info->netmask))
+		return 0;
+	if ((info->network & info->netmask) != info->network)
+		return 0;
+	return 1;
+}
+
+
+
 /* Function initializes match */
 static void init(struct ipt_entry_match *match, 
 		 unsigned int *nfcache) {
@@ -149,6 +172,7 @@
 
 	/* set default table name to DEFAULT */
 	strncpy(info->name, "DEFAULT", IPT_ACCOUNT_NAME_LEN);
+	info->shortlisting = 0;
 	
 }
 
@@ -166,7 +190,9 @@
 		
 		/* --aaddr */
 		case 201:
-			parse_network(optarg, info);			
+			parse_network(optarg, info);
+			if (!valid_network_and_netmask(info))
+				exit_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
 			*flags = 1;
 			break;
 			
@@ -175,8 +201,12 @@
 			if (strlen(optarg) < IPT_ACCOUNT_NAME_LEN)
 				strncpy(info->name, optarg, IPT_ACCOUNT_NAME_LEN);
 			else
-				exit_error(PARAMETER_PROBLEM, "account: Too long list name");			
+				exit_error(PARAMETER_PROBLEM, "account: Too long table name");			
 			break;	
+		/* --ashort */
+		case 203:
+			info->shortlisting = 1;
+			break;
 		default:
 			return 0;			
 	}
@@ -204,6 +234,8 @@
 	      );
 	
 	printf("name: %s ", info->name);
+	if (info->shortlisting)
+		printf("short-listing ");
 }
 
 /* Function used for saving rule containing account match */
@@ -219,21 +251,23 @@
 	       );
 	
 	printf("--aname %s ", info->name);
+	if (info->shortlisting)
+		printf("--ashort ");
 }
 	
 static struct iptables_match account = {
-	NULL,			/* struct iptables_match *next; */
-	"account",		/* ipt_chainlabel name; */
-	IPTABLES_VERSION,	/* const char *version; */
-	IPT_ALIGN(sizeof(struct t_ipt_account_info)),		/* Size of match data. */
-	IPT_ALIGN(sizeof(struct t_ipt_account_info)),		/* Size of match data relevent for userspace comparison purposes */
-	&help,			/* Function which prints out usage message. */
-	&init,			/* Initialize the match. */
-	&parse,			/* Function which parses command options; returns true if it ate an option */
-	&final_check,		/* Final check; exit if not ok. */
-	&print,			/* Prints out the match iff non-NULL: put space at end */
-	&save,			/* Saves the match info in parsable form to stdout. */
-	opts			/* Pointer to list of extra command-line options */
+	.next = NULL,
+	.name = "account",
+	.version = IPTABLES_VERSION,
+	.size = IPT_ALIGN(sizeof(struct t_ipt_account_info)),
+	.userspacesize = IPT_ALIGN(sizeof(struct t_ipt_account_info)),
+	.help = &help,
+	.init = &init,
+	.parse = &parse,
+	.final_check = &final_check,
+	.print = &print,
+	.save = &save,
+	.extra_opts = opts
 };
 
 /* Function which registers match */
diff -urN iptables-1.2.11/extensions/libipt_addrtype.c iptables-1.3.0/extensions/libipt_addrtype.c
--- iptables-1.2.11/extensions/libipt_addrtype.c	2003-05-07 18:51:40.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_addrtype.c	2005-01-04 11:38:34.000000000 +0100
@@ -193,18 +193,18 @@
 
 static
 struct iptables_match addrtype = {
-	NULL,
-	"addrtype",
-	IPTABLES_VERSION,
-	IPT_ALIGN(sizeof(struct ipt_addrtype_info)),
-	IPT_ALIGN(sizeof(struct ipt_addrtype_info)),
-	&help,
-	&init,
-	&parse,
-	&final_check,
-	&print,
-	&save,
-	opts
+	.next 		= NULL,
+	.name 		= "addrtype",
+	.version 	= IPTABLES_VERSION,
+	.size 		= IPT_ALIGN(sizeof(struct ipt_addrtype_info)),
+	.userspacesize 	= IPT_ALIGN(sizeof(struct ipt_addrtype_info)),
+	.help 		= &help,
+	.init 		= &init,
+	.parse 		= &parse,
+	.final_check 	= &final_check,
+	.print 		= &print,
+	.save 		= &save,
+	.extra_opts 	= opts
 };
 
 
diff -urN iptables-1.2.11/extensions/libipt_ah.c iptables-1.3.0/extensions/libipt_ah.c
--- iptables-1.2.11/extensions/libipt_ah.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_ah.c	2005-01-04 11:38:34.000000000 +0100
@@ -168,20 +168,19 @@
 
 }
 
-static
-struct iptables_match ah
-= { NULL,
-    "ah",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_ah)),
-    IPT_ALIGN(sizeof(struct ipt_ah)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match ah = { 
+	.next 		= NULL,
+	.name 		= "ah",
+	.version 	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_ah)),
+	.userspacesize 	= IPT_ALIGN(sizeof(struct ipt_ah)),
+	.help 		= &help,
+	.init 		= &init,
+	.parse 		= &parse,
+	.final_check 	= &final_check,
+	.print 		= &print,
+	.save 		= &save,
+	.extra_opts 	= opts
 };
 
 void
diff -urN iptables-1.2.11/extensions/libipt_comment.c iptables-1.3.0/extensions/libipt_comment.c
--- iptables-1.2.11/extensions/libipt_comment.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_comment.c	2005-01-04 11:38:37.000000000 +0100
@@ -0,0 +1,127 @@
+/* Shared library add-on to iptables to add comment match support.
+ *
+ * ChangeLog
+ *     2003-05-13: Brad Fisher <brad@info-link.net>
+ *         Initial comment match
+ *     2004-05-12: Brad Fisher <brad@info-link.net>
+ *         Port to patch-o-matic-ng
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_comment.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+		"COMMENT match options:\n"
+		"--comment COMMENT             Attach a comment to a rule\n\n"
+		);
+}
+
+static struct option opts[] = {
+	{ "comment", 1, 0, '1' },
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static void
+parse_comment(const unsigned char *s, struct ipt_comment_info *info)
+{	
+	int slen = strlen(s);
+
+	if (slen >= IPT_MAX_COMMENT_LEN) {
+		exit_error(PARAMETER_PROBLEM,
+			"COMMENT must be shorter than %i characters", IPT_MAX_COMMENT_LEN);
+	}
+	strcpy(info->comment, s);
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_comment_info *commentinfo = (struct ipt_comment_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
+		if (invert) {
+			exit_error(PARAMETER_PROBLEM,
+					"Sorry, you can't have an inverted comment");
+		}
+		parse_comment(argv[optind-1], commentinfo);
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; must have specified --comment. */
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+			   "COMMENT match: You must specify `--comment'");
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_comment_info *commentinfo = (struct ipt_comment_info *)match->data;
+
+	commentinfo->comment[IPT_MAX_COMMENT_LEN-1] = '\0';
+	printf("/* %s */ ", commentinfo->comment);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_comment_info *commentinfo = (struct ipt_comment_info *)match->data;
+
+	commentinfo->comment[IPT_MAX_COMMENT_LEN-1] = '\0';
+	printf("--comment \"%s\" ", commentinfo->comment);
+}
+
+static struct iptables_match comment = {
+    .next 		= NULL,
+    .name 		= "comment",
+    .version 		= IPTABLES_VERSION,
+    .size 		= IPT_ALIGN(sizeof(struct ipt_comment_info)),
+    .userspacesize	= IPT_ALIGN(sizeof(struct ipt_comment_info)),
+    .help		= &help,
+    .init 		= &init,
+    .parse 		= &parse,
+    .final_check 	= &final_check,
+    .print 		= &print,
+    .save 		= &save,
+    .extra_opts		= opts
+};
+
+void _init(void)
+{
+	register_match(&comment);
+}
diff -urN iptables-1.2.11/extensions/libipt_condition.c iptables-1.3.0/extensions/libipt_condition.c
--- iptables-1.2.11/extensions/libipt_condition.c	2003-04-27 15:07:18.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_condition.c	2005-01-04 11:38:36.000000000 +0100
@@ -94,17 +94,17 @@
 
 
 static struct iptables_match condition = {
-	.name = "condition",
-	.version = IPTABLES_VERSION,
-	.size = IPT_ALIGN(sizeof(struct condition_info)),
-	.userspacesize = IPT_ALIGN(sizeof(struct condition_info)),
-	.help = &help,
-	.init = &init,
-	.parse = &parse,
-	.final_check = &final_check,
-	.print = &print,
-	.save = &save,
-	.extra_opts = opts
+	.name 		= "condition",
+	.version 	= IPTABLES_VERSION,
+	.size 		= IPT_ALIGN(sizeof(struct condition_info)),
+	.userspacesize 	= IPT_ALIGN(sizeof(struct condition_info)),
+	.help 		= &help,
+	.init 		= &init,
+	.parse 		= &parse,
+	.final_check	= &final_check,
+	.print 		= &print,
+	.save 		= &save,
+	.extra_opts 	= opts
 };
 
 
diff -urN iptables-1.2.11/extensions/libipt_connbytes.c iptables-1.3.0/extensions/libipt_connbytes.c
--- iptables-1.2.11/extensions/libipt_connbytes.c	2004-05-16 10:48:03.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_connbytes.c	2005-01-04 11:38:34.000000000 +0100
@@ -15,12 +15,15 @@
 	printf(
 "connbytes v%s options:\n"
 " [!] --connbytes from:[to]\n"
-"				Transfered byte range to match\n"
+"     --connbytes-dir [original, reply, both]\n"
+"     --connbytes-mode [packets, bytes, avgpkt]\n"
 "\n", IPTABLES_VERSION);
 }
 
 static struct option opts[] = {
 	{ "connbytes", 1, 0, '1' },
+	{ "connbytes-dir", 1, 0, '2' },
+	{ "connbytes-mode", 1, 0, '3' },
 	{0}
 };
 
@@ -37,16 +40,17 @@
 {
 	char *colon,*p;
 
-	si->from = strtoul(arg,&colon,10);
+	si->count.from = strtoul(arg,&colon,10);
 	if (*colon != ':') 
 		exit_error(PARAMETER_PROBLEM, "Bad range `%s'", arg);
-	si->to = strtoul(colon+1,&p,10);
+	si->count.to = strtoul(colon+1,&p,10);
 	if (p == colon+1) {
 		/* second number omited */
-		si->to = 0xffffffff;
+		si->count.to = 0xffffffff;
 	}
-	if (si->from > si->to)
-		exit_error(PARAMETER_PROBLEM, "%lu should be less than %lu", si->from,si->to);
+	if (si->count.from > si->count.to)
+		exit_error(PARAMETER_PROBLEM, "%llu should be less than %llu",
+			   si->count.from, si->count.to);
 }
 
 /* Function which parses command options; returns true if it
@@ -62,18 +66,41 @@
 
 	switch (c) {
 	case '1':
-		if (check_inverse(optarg, &invert, optind, 0))
+		if (check_inverse(optarg, &invert, &optind, 0))
 			optind++;
 
 		parse_range(argv[optind-1], sinfo);
 		if (invert) {
-			i = sinfo->from;
-			sinfo->from = sinfo->to;
-			sinfo->to = i;
+			i = sinfo->count.from;
+			sinfo->count.from = sinfo->count.to;
+			sinfo->count.to = i;
 		}
-		*flags = 1;
+		*flags |= 1;
 		break;
+	case '2':
+		if (!strcmp(optarg, "original"))
+			sinfo->direction = IPT_CONNBYTES_DIR_ORIGINAL;
+		else if (!strcmp(optarg, "reply"))
+			sinfo->direction = IPT_CONNBYTES_DIR_REPLY;
+		else if (!strcmp(optarg, "both"))
+			sinfo->direction = IPT_CONNBYTES_DIR_BOTH;
+		else
+			exit_error(PARAMETER_PROBLEM,
+				   "Unknown --connbytes-dir `%s'", optarg);
 
+		*flags |= 2;
+		break;
+	case '3':
+		if (!strcmp(optarg, "packets"))
+			sinfo->what = IPT_CONNBYTES_WHAT_PKTS;
+		else if (!strcmp(optarg, "bytes"))
+			sinfo->what = IPT_CONNBYTES_WHAT_BYTES;
+		else if (!strcmp(optarg, "avgpkt"))
+			sinfo->what = IPT_CONNBYTES_WHAT_AVGPKT;
+		else
+			exit_error(PARAMETER_PROBLEM,
+				   "Unknown --connbytes-mode `%s'", optarg);
+		*flags |= 4;
 	default:
 		return 0;
 	}
@@ -83,8 +110,45 @@
 
 static void final_check(unsigned int flags)
 {
-	if (!flags)
-		exit_error(PARAMETER_PROBLEM, "You must specify `--connbytes'");
+	if (flags != 7)
+		exit_error(PARAMETER_PROBLEM, "You must specify `--connbytes'"
+			   "`--connbytes-direction' and `--connbytes-mode'");
+}
+
+static void print_mode(struct ipt_connbytes_info *sinfo)
+{
+	switch (sinfo->what) {
+		case IPT_CONNBYTES_WHAT_PKTS:
+			fputs("packets ", stdout);
+			break;
+		case IPT_CONNBYTES_WHAT_BYTES:
+			fputs("bytes ", stdout);
+			break;
+		case IPT_CONNBYTES_WHAT_AVGPKT:
+			fputs("avgpkt ", stdout);
+			break;
+		default:
+			fputs("unknown ", stdout);
+			break;
+	}
+}
+
+static void print_direction(struct ipt_connbytes_info *sinfo)
+{
+	switch (sinfo->direction) {
+		case IPT_CONNBYTES_DIR_ORIGINAL:
+			fputs("original ", stdout);
+			break;
+		case IPT_CONNBYTES_DIR_REPLY:
+			fputs("reply ", stdout);
+			break;
+		case IPT_CONNBYTES_DIR_BOTH:
+			fputs("both ", stdout);
+			break;
+		default:
+			fputs("unknown ", stdout);
+			break;
+	}
 }
 
 /* Prints out the matchinfo. */
@@ -95,10 +159,18 @@
 {
 	struct ipt_connbytes_info *sinfo = (struct ipt_connbytes_info *)match->data;
 
-	if (sinfo->from > sinfo->to) 
-		printf("connbytes ! %lu:%lu",sinfo->to,sinfo->from);
+	if (sinfo->count.from > sinfo->count.to) 
+		printf("connbytes ! %llu:%llu ", sinfo->count.to,
+			sinfo->count.from);
 	else
-		printf("connbytes %lu:%lu",sinfo->from,sinfo->to);
+		printf("connbytes %llu:%llu ",sinfo->count.from,
+			sinfo->count.to);
+
+	fputs("connbytes mode ", stdout);
+	print_mode(sinfo);
+
+	fputs("connbytes direction ", stdout);
+	print_direction(sinfo);
 }
 
 /* Saves the matchinfo in parsable form to stdout. */
@@ -106,26 +178,33 @@
 {
 	struct ipt_connbytes_info *sinfo = (struct ipt_connbytes_info *)match->data;
 
-	if (sinfo->from > sinfo->to) 
-		printf("! --connbytes %lu:%lu",sinfo->to,sinfo->from);
+	if (sinfo->count.from > sinfo->count.to) 
+		printf("! --connbytes %llu:%llu ", sinfo->count.to,
+			sinfo->count.from);
 	else
-		printf("--connbytes %lu:%lu",sinfo->from,sinfo->to);
+		printf("--connbytes %llu:%llu ", sinfo->count.from,
+			sinfo->count.to);
+
+	fputs("--connbytes-mode ", stdout);
+	print_mode(sinfo);
+
+	fputs("--connbytes-direction ", stdout);
+	print_direction(sinfo);
 }
 
-static
-struct iptables_match state
-= { NULL,
-    "connbytes",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_connbytes_info)),
-    IPT_ALIGN(sizeof(struct ipt_connbytes_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match state = {
+	.next 		= NULL,
+	.name 		= "connbytes",
+	.version 	= IPTABLES_VERSION,
+	.size 		= IPT_ALIGN(sizeof(struct ipt_connbytes_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_connbytes_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save 		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_connlimit.c iptables-1.3.0/extensions/libipt_connlimit.c
--- iptables-1.2.11/extensions/libipt_connlimit.c	2004-02-19 19:04:17.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_connlimit.c	2005-01-04 11:38:33.000000000 +0100
@@ -122,17 +122,17 @@
 }
 
 static struct iptables_match connlimit = {
-	name:		"connlimit",
-	version:	IPTABLES_VERSION,
-	size:		IPT_ALIGN(sizeof(struct ipt_connlimit_info)),
-	userspacesize:	offsetof(struct ipt_connlimit_info,data),
-	help:		help,
-	init:		init,
-	parse:		parse,
-	final_check:	final_check,
-	print:		print,
-	save: 		save,
-	extra_opts:	opts
+	.name		= "connlimit",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_connlimit_info)),
+	.userspacesize 	= offsetof(struct ipt_connlimit_info,data),
+	.help		= help,
+	.init		= init,
+	.parse 		= parse,
+	.final_check	= final_check,
+	.print		= print,
+	.save		= save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_connrate.c iptables-1.3.0/extensions/libipt_connrate.c
--- iptables-1.2.11/extensions/libipt_connrate.c	2004-04-18 19:33:26.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_connrate.c	2005-01-04 11:38:35.000000000 +0100
@@ -167,20 +167,19 @@
 	printf(" ");
 }
 
-static
-struct iptables_match state
-= { NULL,
-    "connrate",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_connrate_info)),
-    IPT_ALIGN(sizeof(struct ipt_connrate_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match state = { 
+	.next 		= NULL,
+	.name		= "connrate",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_connrate_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_connrate_info)),
+	.help 		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_conntrack.c iptables-1.3.0/extensions/libipt_conntrack.c
--- iptables-1.2.11/extensions/libipt_conntrack.c	2004-06-15 00:02:17.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_conntrack.c	2005-01-04 11:38:34.000000000 +0100
@@ -492,7 +492,7 @@
 
 	if(sinfo->flags & IPT_CONNTRACK_STATUS) {
 		printf("%sctstatus ", optpfx);
-        	if (sinfo->invflags & IPT_CONNTRACK_STATE)
+        	if (sinfo->invflags & IPT_CONNTRACK_STATUS)
                 	printf("! ");
 		print_status(sinfo->statusmask);
 	}
@@ -531,20 +531,19 @@
 	matchinfo_print(ip, match, 1, "--");
 }
 
-static
-struct iptables_match conntrack
-= { NULL,
-    "conntrack",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_conntrack_info)),
-    IPT_ALIGN(sizeof(struct ipt_conntrack_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match conntrack = { 
+	.next 		= NULL,
+	.name		= "conntrack",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_conntrack_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_conntrack_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_dscp.c iptables-1.3.0/extensions/libipt_dscp.c
--- iptables-1.2.11/extensions/libipt_dscp.c	2002-08-07 11:55:37.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_dscp.c	2005-01-04 11:38:37.000000000 +0100
@@ -157,20 +157,19 @@
 	print_dscp(dinfo->dscp, dinfo->invert, 1);
 }
 
-static
-struct iptables_match dscp
-= { NULL,
-    "dscp",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_dscp_info)),
-    IPT_ALIGN(sizeof(struct ipt_dscp_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match dscp = { 
+	.next 		= NULL,
+	.name 		= "dscp",
+	.version 	= IPTABLES_VERSION,
+	.size 		= IPT_ALIGN(sizeof(struct ipt_dscp_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_dscp_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_dstlimit.c iptables-1.3.0/extensions/libipt_dstlimit.c
--- iptables-1.2.11/extensions/libipt_dstlimit.c	2004-02-23 12:10:55.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_dstlimit.c	2005-01-22 14:45:26.000000000 +0100
@@ -132,9 +132,7 @@
 
 	switch(c) {
 	case '%':
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM,
-				   "Unexpected `!' after --dstlimit");
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
 		if (!parse_rate(optarg, &r->cfg.avg))
 			exit_error(PARAMETER_PROBLEM,
 				   "bad rate `%s'", optarg);
@@ -142,10 +140,7 @@
 		break;
 
 	case '$':
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM,
-				   "Unexpected `!' after --dstlimit-burst");
-
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
 		if (string_to_number(optarg, 0, 10000, &num) == -1)
 			exit_error(PARAMETER_PROBLEM,
 				   "bad --dstlimit-burst `%s'", optarg);
@@ -153,10 +148,7 @@
 		*flags |= PARAM_BURST;
 		break;
 	case '&':
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM,
-				"Unexpected `!' after --dstlimit-htable-size");
-
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
 		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
 			exit_error(PARAMETER_PROBLEM,
 				"bad --dstlimit-htable-size: `%s'", optarg);
@@ -164,9 +156,7 @@
 		*flags |= PARAM_SIZE;
 		break;
 	case '*':
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM,
-				"Unexpected `!' after --dstlimit-htable-max");
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
 		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
 			exit_error(PARAMETER_PROBLEM,
 				"bad --dstlimit-htable-max: `%s'", optarg);
@@ -174,9 +164,7 @@
 		*flags |= PARAM_MAX;
 		break;
 	case '(':
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM, "Unexpected `!' after "
-					"--dstlimit-htable-gcinterval");
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
 		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
 			exit_error(PARAMETER_PROBLEM,
 				"bad --dstlimit-htable-gcinterval: `%s'", 
@@ -186,9 +174,7 @@
 		*flags |= PARAM_GCINTERVAL;
 		break;
 	case ')':
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM, "Unexpected `!' after " 
-					"--dstlimit-htable-expire");
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
 		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
 			exit_error(PARAMETER_PROBLEM,
 				"bad --dstlimit-htable-expire: `%s'", optarg);
@@ -197,9 +183,7 @@
 		*flags |= PARAM_EXPIRE;
 		break;
 	case '_':
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM, "Unexpected `!' after "
-					"--dstlimit-mode");
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
 		if (!strcmp(optarg, "dstip"))
 			r->cfg.mode = IPT_DSTLIMIT_HASH_DIP;
 		else if (!strcmp(optarg, "dstip-destport") ||
@@ -216,9 +200,7 @@
 		*flags |= PARAM_MODE;
 		break;
 	case '"':
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM, "Unexpected `!' after "
-					"--dstlimit-name");
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
 		if (strlen(optarg) == 0)
 			exit_error(PARAMETER_PROBLEM, "Zero-length name?");
 		strncpy(r->name, optarg, sizeof(r->name));
@@ -228,6 +210,10 @@
 		return 0;
 	}
 
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,
+			   "dstlimit does not support invert");
+
 	return 1;
 }
 
@@ -334,21 +320,20 @@
 		printf("--dstlimit-htable-expire %u ", r->cfg.expire);
 }
 
-static
-struct iptables_match dstlimit
-= { NULL,
-    "dstlimit",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_dstlimit_info)),
-    IPT_ALIGN(sizeof(struct ipt_dstlimit_info)),
-    //offsetof(struct ipt_dstlimit_info, prev),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match dstlimit = { 
+	.next		= NULL,
+	.name 		= "dstlimit",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_dstlimit_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_dstlimit_info)),
+	//offsetof(struct ipt_dstlimit_info, prev),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print 		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_esp.c iptables-1.3.0/extensions/libipt_esp.c
--- iptables-1.2.11/extensions/libipt_esp.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_esp.c	2005-01-04 11:38:35.000000000 +0100
@@ -168,20 +168,19 @@
 
 }
 
-static
-struct iptables_match esp
-= { NULL,
-    "esp",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_esp)),
-    IPT_ALIGN(sizeof(struct ipt_esp)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match esp = { 
+	.next 		= NULL,
+	.name 		= "esp",
+	.version 	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_esp)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_esp)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void
diff -urN iptables-1.2.11/extensions/libipt_fuzzy.c iptables-1.3.0/extensions/libipt_fuzzy.c
--- iptables-1.2.11/extensions/libipt_fuzzy.c	2003-06-14 16:08:53.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_fuzzy.c	2005-01-04 11:38:34.000000000 +0100
@@ -138,19 +138,19 @@
 
 }
 
-struct iptables_match fuzzy_match
-= { NULL,
-    "fuzzy",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_fuzzy_info)),
-    IPT_ALIGN(sizeof(struct ipt_fuzzy_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match fuzzy_match = { 
+	.next 		= NULL,
+	.name		= "fuzzy",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_fuzzy_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_fuzzy_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_hashlimit.c iptables-1.3.0/extensions/libipt_hashlimit.c
--- iptables-1.2.11/extensions/libipt_hashlimit.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_hashlimit.c	2005-02-12 21:03:28.000000000 +0100
@@ -0,0 +1,371 @@
+/* iptables match extension for limiting packets per destination
+ *
+ * (C) 2003-2004 by Harald Welte <laforge@netfilter.org>
+ *
+ * Development of this code was funded by Astaro AG, http://www.astaro.com/
+ *
+ * Based on ipt_limit.c by
+ * Jrme de Vivie   <devivie@info.enserb.u-bordeaux.fr>
+ * Herv Eychenne    <rv@wallfire.org>
+ * 
+ * Error corections by nmalykh@bilim.com (22.01.2005)
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <stddef.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_hashlimit.h>
+
+#define IPT_HASHLIMIT_BURST	5
+
+/* miliseconds */
+#define IPT_HASHLIMIT_GCINTERVAL	1000
+#define IPT_HASHLIMIT_EXPIRE	10000
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"hashlimit v%s options:\n"
+"--hashlimit <avg>		max average match rate\n"
+"                                [Packets per second unless followed by \n"
+"                                /sec /minute /hour /day postfixes]\n"
+"--hashlimit-mode <mode>		mode is a comma-separated list of\n"
+"					dstip,srcip,dstport,srcport\n"
+"--hashlimit-name <name>		name for /proc/net/ipt_hashlimit/\n"
+"[--hashlimit-burst <num>]	number to match in a burst, default %u\n"
+"[--hashlimit-htable-size <num>]	number of hashtable buckets\n"
+"[--hashlimit-htable-max <num>]	number of hashtable entries\n"
+"[--hashlimit-htable-gcinterval]	interval between garbage collection runs\n"
+"[--hashlimit-htable-expire]	after which time are idle entries expired?\n"
+"\n", IPTABLES_VERSION, IPT_HASHLIMIT_BURST);
+}
+
+static struct option opts[] = {
+	{ "hashlimit", 1, 0, '%' },
+	{ "hashlimit-burst", 1, 0, '$' },
+	{ "hashlimit-htable-size", 1, 0, '&' },
+	{ "hashlimit-htable-max", 1, 0, '*' },
+	{ "hashlimit-htable-gcinterval", 1, 0, '(' },
+	{ "hashlimit-htable-expire", 1, 0, ')' },
+	{ "hashlimit-mode", 1, 0, '_' },
+	{ "hashlimit-name", 1, 0, '"' },
+	{ 0 }
+};
+
+static
+int parse_rate(const char *rate, u_int32_t *val)
+{
+	const char *delim;
+	u_int32_t r;
+	u_int32_t mult = 1;  /* Seconds by default. */
+
+	delim = strchr(rate, '/');
+	if (delim) {
+		if (strlen(delim+1) == 0)
+			return 0;
+
+		if (strncasecmp(delim+1, "second", strlen(delim+1)) == 0)
+			mult = 1;
+		else if (strncasecmp(delim+1, "minute", strlen(delim+1)) == 0)
+			mult = 60;
+		else if (strncasecmp(delim+1, "hour", strlen(delim+1)) == 0)
+			mult = 60*60;
+		else if (strncasecmp(delim+1, "day", strlen(delim+1)) == 0)
+			mult = 24*60*60;
+		else
+			return 0;
+	}
+	r = atoi(rate);
+	if (!r)
+		return 0;
+
+	/* This would get mapped to infinite (1/day is minimum they
+           can specify, so we're ok at that end). */
+	if (r / mult > IPT_HASHLIMIT_SCALE)
+		exit_error(PARAMETER_PROBLEM, "Rate too fast `%s'\n", rate);
+
+	*val = IPT_HASHLIMIT_SCALE * mult / r;
+	return 1;
+}
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_hashlimit_info *r = (struct ipt_hashlimit_info *)m->data;
+
+	r->cfg.burst = IPT_HASHLIMIT_BURST;
+	r->cfg.gc_interval = IPT_HASHLIMIT_GCINTERVAL;
+	r->cfg.expire = IPT_HASHLIMIT_EXPIRE;
+
+	/* Can't cache this */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+
+/* Parse a 'mode' parameter into the required bitmask */
+static int parse_mode(struct ipt_hashlimit_info *r, char *optarg)
+{
+	char *tok;
+	char *arg = strdup(optarg);
+
+	if (!arg)
+		return -1;
+
+	r->cfg.mode = 0;
+
+	for (tok = strtok(arg, ",|");
+	     tok;
+	     tok = strtok(NULL, ",|")) {
+		if (!strcmp(tok, "dstip"))
+			r->cfg.mode |= IPT_HASHLIMIT_HASH_DIP;
+		else if (!strcmp(tok, "srcip"))
+			r->cfg.mode |= IPT_HASHLIMIT_HASH_SIP;
+		else if (!strcmp(tok, "srcport"))
+			r->cfg.mode |= IPT_HASHLIMIT_HASH_SPT;
+		else if (!strcmp(tok, "dstport"))
+			r->cfg.mode |= IPT_HASHLIMIT_HASH_DPT;
+		else {
+			free(arg);
+			return -1;
+		}
+	}
+	free(arg);
+	return 0;
+}
+
+#define PARAM_LIMIT		0x00000001
+#define PARAM_BURST		0x00000002
+#define PARAM_MODE		0x00000004
+#define PARAM_NAME		0x00000008
+#define PARAM_SIZE		0x00000010
+#define PARAM_MAX		0x00000020
+#define PARAM_GCINTERVAL	0x00000040
+#define PARAM_EXPIRE		0x00000080
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_hashlimit_info *r = 
+			(struct ipt_hashlimit_info *)(*match)->data;
+	unsigned int num;
+
+	switch(c) {
+	case '%':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (!parse_rate(optarg, &r->cfg.avg))
+			exit_error(PARAMETER_PROBLEM,
+				   "bad rate `%s'", optarg);
+		*flags |= PARAM_LIMIT;
+		break;
+
+	case '$':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (string_to_number(optarg, 0, 10000, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				   "bad --hashlimit-burst `%s'", optarg);
+		r->cfg.burst = num;
+		*flags |= PARAM_BURST;
+		break;
+	case '&':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				"bad --hashlimit-htable-size: `%s'", optarg);
+		r->cfg.size = num;
+		*flags |= PARAM_SIZE;
+		break;
+	case '*':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				"bad --hashlimit-htable-max: `%s'", optarg);
+		r->cfg.max = num;
+		*flags |= PARAM_MAX;
+		break;
+	case '(':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				"bad --hashlimit-htable-gcinterval: `%s'", 
+				optarg);
+		/* FIXME: not HZ dependent!! */
+		r->cfg.gc_interval = num;
+		*flags |= PARAM_GCINTERVAL;
+		break;
+	case ')':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				"bad --hashlimit-htable-expire: `%s'", optarg);
+		/* FIXME: not HZ dependent */
+		r->cfg.expire = num;
+		*flags |= PARAM_EXPIRE;
+		break;
+	case '_':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (parse_mode(r, optarg) < 0)
+			exit_error(PARAMETER_PROBLEM, 
+				   "bad --hashlimit-mode: `%s'\n", optarg);
+		*flags |= PARAM_MODE;
+		break;
+	case '"':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (strlen(optarg) == 0)
+			exit_error(PARAMETER_PROBLEM, "Zero-length name?");
+		strncpy(r->name, optarg, sizeof(r->name));
+		*flags |= PARAM_NAME;
+		break;
+	default:
+		return 0;
+	}
+
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,
+			   "hashlimit does not support invert");
+
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+	if (!(flags & PARAM_LIMIT))
+		exit_error(PARAMETER_PROBLEM,
+				"You have to specify --hashlimit");
+	if (!(flags & PARAM_MODE))
+		exit_error(PARAMETER_PROBLEM,
+				"You have to specify --hashlimit-mode");
+	if (!(flags & PARAM_NAME))
+		exit_error(PARAMETER_PROBLEM,
+				"You have to specify --hashlimit-name");
+}
+
+static struct rates
+{
+	const char *name;
+	u_int32_t mult;
+} rates[] = { { "day", IPT_HASHLIMIT_SCALE*24*60*60 },
+	      { "hour", IPT_HASHLIMIT_SCALE*60*60 },
+	      { "min", IPT_HASHLIMIT_SCALE*60 },
+	      { "sec", IPT_HASHLIMIT_SCALE } };
+
+static void print_rate(u_int32_t period)
+{
+	unsigned int i;
+
+	for (i = 1; i < sizeof(rates)/sizeof(struct rates); i++) {
+		if (period > rates[i].mult
+            || rates[i].mult/period < rates[i].mult%period)
+			break;
+	}
+
+	printf("%u/%s ", rates[i-1].mult / period, rates[i-1].name);
+}
+
+static void print_mode(const struct ipt_hashlimit_info *r, char separator)
+{
+	int prevmode = 0;
+
+	if (r->cfg.mode & IPT_HASHLIMIT_HASH_SIP) {
+		if (prevmode)
+			putchar(separator);
+		fputs("srcip", stdout);
+		prevmode = 1;
+	}
+	if (r->cfg.mode & IPT_HASHLIMIT_HASH_SPT) {
+		if (prevmode)
+			putchar(separator);
+		fputs("srcport", stdout);
+		prevmode = 1;
+	}
+	if (r->cfg.mode & IPT_HASHLIMIT_HASH_DIP) {
+		if (prevmode)
+			putchar(separator);
+		fputs("dstip", stdout);
+		prevmode = 1;
+	}
+	if (r->cfg.mode & IPT_HASHLIMIT_HASH_DPT) {
+		if (prevmode)
+			putchar(separator);
+		fputs("dstport", stdout);
+	}
+	putchar(' ');
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_hashlimit_info *r = 
+		(struct ipt_hashlimit_info *)match->data;
+	fputs("limit: avg ", stdout); print_rate(r->cfg.avg);
+	printf("burst %u ", r->cfg.burst);
+	fputs("mode ", stdout);
+	print_mode(r, '-');
+	if (r->cfg.size)
+		printf("htable-size %u ", r->cfg.size);
+	if (r->cfg.max)
+		printf("htable-max %u ", r->cfg.max);
+	if (r->cfg.gc_interval != IPT_HASHLIMIT_GCINTERVAL)
+		printf("htable-gcinterval %u ", r->cfg.gc_interval);
+	if (r->cfg.expire != IPT_HASHLIMIT_EXPIRE)
+		printf("htable-expire %u ", r->cfg.expire);
+}
+
+/* FIXME: Make minimalist: only print rate if not default --RR */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_hashlimit_info *r = 
+		(struct ipt_hashlimit_info *)match->data;
+
+	fputs("--hashlimit ", stdout); print_rate(r->cfg.avg);
+	if (r->cfg.burst != IPT_HASHLIMIT_BURST)
+		printf("--hashlimit-burst %u ", r->cfg.burst);
+
+	fputs("--hashlimit-mode ", stdout);
+	print_mode(r, ',');
+	
+	printf("--hashlimit-name %s ", r->name);
+
+	if (r->cfg.size)
+		printf("--hashlimit-htable-size %u ", r->cfg.size);
+	if (r->cfg.max)
+		printf("--hashlimit-htable-max %u ", r->cfg.max);
+	if (r->cfg.gc_interval != IPT_HASHLIMIT_GCINTERVAL)
+		printf("--hashlimit-htable-gcinterval %u", r->cfg.gc_interval);
+	if (r->cfg.expire != IPT_HASHLIMIT_EXPIRE)
+		printf("--hashlimit-htable-expire %u ", r->cfg.expire);
+}
+
+static struct iptables_match hashlimit = { NULL,
+	.name		= "hashlimit",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_hashlimit_info)),
+	.userspacesize	= offsetof(struct ipt_hashlimit_info, hinfo),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&hashlimit);
+}
diff -urN iptables-1.2.11/extensions/libipt_helper.c iptables-1.3.0/extensions/libipt_helper.c
--- iptables-1.2.11/extensions/libipt_helper.c	2004-02-19 19:04:18.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_helper.c	2005-01-04 11:38:37.000000000 +0100
@@ -44,6 +44,9 @@
 
 	switch (c) {
 	case '1':
+		if (*flags)
+			exit_error(PARAMETER_PROBLEM,
+					"helper match: Only use --helper ONCE!");
 		check_inverse(optarg, &invert, &invert, 0);
 		strncpy(info->name, optarg, 29);
 		info->name[29] = '\0';
@@ -87,20 +90,18 @@
 	printf("%s--helper \"%s\" ",info->invert ? "! " : "", info->name);
 }
 
-static
-struct iptables_match helper
-= { NULL,
-    "helper",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_helper_info)),
-    IPT_ALIGN(sizeof(struct ipt_helper_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match helper = { 
+	.next		= NULL,
+	.name		= "helper",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_helper_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_icmp.c iptables-1.3.0/extensions/libipt_icmp.c
--- iptables-1.2.11/extensions/libipt_icmp.c	2004-02-19 19:04:18.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_icmp.c	2005-01-04 11:38:36.000000000 +0100
@@ -287,20 +287,19 @@
 {
 }
 
-static
-struct iptables_match icmp
-= { NULL,
-    "icmp",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_icmp)),
-    IPT_ALIGN(sizeof(struct ipt_icmp)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match icmp = { 
+	.next		= NULL,
+	.name		= "icmp",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_icmp)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_icmp)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_iprange.c iptables-1.3.0/extensions/libipt_iprange.c
--- iptables-1.2.11/extensions/libipt_iprange.c	2003-04-23 15:27:09.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_iprange.c	2005-01-04 11:38:37.000000000 +0100
@@ -99,7 +99,7 @@
 			info->flags |= IPRANGE_DST_INV;
 
 		parse_iprange(optarg, &info->dst);		
-		*flags = 1;
+
 		break;
 
 	default:
@@ -173,20 +173,19 @@
 	}
 }
 
-static
-struct iptables_match iprange
-= { NULL,
-    "iprange",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_iprange_info)),
-    IPT_ALIGN(sizeof(struct ipt_iprange_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match iprange = { 
+	.next		= NULL,
+	.name		= "iprange",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_iprange_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_iprange_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_ipv4options.c iptables-1.3.0/extensions/libipt_ipv4options.c
--- iptables-1.2.11/extensions/libipt_ipv4options.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_ipv4options.c	2005-01-04 11:38:37.000000000 +0100
@@ -299,20 +299,19 @@
 	printf(" ");
 }
 
-static
-struct iptables_match ipv4options_struct
-= { NULL,
-    "ipv4options",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_ipv4options_info)),
-    IPT_ALIGN(sizeof(struct ipt_ipv4options_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match ipv4options_struct = { 
+	.next		= NULL,
+	.name		= "ipv4options",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_ipv4options_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_ipv4options_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_length.c iptables-1.3.0/extensions/libipt_length.c
--- iptables-1.2.11/extensions/libipt_length.c	2002-12-05 21:37:22.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_length.c	2005-01-04 11:38:34.000000000 +0100
@@ -138,20 +138,19 @@
 	print_length((struct ipt_length_info *)match->data);
 }
 
-static
-struct iptables_match length
-= { NULL,
-    "length",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_length_info)),
-    IPT_ALIGN(sizeof(struct ipt_length_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match length = { 
+	.next		= NULL,
+	.name		= "length",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_length_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_length_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_limit.c iptables-1.3.0/extensions/libipt_limit.c
--- iptables-1.2.11/extensions/libipt_limit.c	2004-06-15 00:02:17.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_limit.c	2005-01-04 11:38:37.000000000 +0100
@@ -104,19 +104,14 @@
 
 	switch(c) {
 	case '%':
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM,
-				   "Unexpected `!' after --limit");
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
 		if (!parse_rate(optarg, &r->avg))
 			exit_error(PARAMETER_PROBLEM,
 				   "bad rate `%s'", optarg);
 		break;
 
 	case '$':
-		if (check_inverse(optarg, &invert, NULL, 0))
-			exit_error(PARAMETER_PROBLEM,
-				   "Unexpected `!' after --limit-burst");
-
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
 		if (string_to_number(optarg, 0, 10000, &num) == -1)
 			exit_error(PARAMETER_PROBLEM,
 				   "bad --limit-burst `%s'", optarg);
@@ -127,6 +122,10 @@
 		return 0;
 	}
 
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,
+			   "limit does not support invert");
+
 	return 1;
 }
 
@@ -178,20 +177,19 @@
 		printf("--limit-burst %u ", r->burst);
 }
 
-static
-struct iptables_match limit
-= { NULL,
-    "limit",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_rateinfo)),
-    offsetof(struct ipt_rateinfo, prev),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match limit = { 
+	.next		= NULL,
+	.name		= "limit",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_rateinfo)),
+	.userspacesize	= offsetof(struct ipt_rateinfo, prev),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_mac.c iptables-1.3.0/extensions/libipt_mac.c
--- iptables-1.2.11/extensions/libipt_mac.c	2003-06-14 16:27:51.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_mac.c	2005-01-04 11:38:35.000000000 +0100
@@ -128,20 +128,19 @@
 	print_mac(((struct ipt_mac_info *)match->data)->srcaddr);
 }
 
-static
-struct iptables_match mac
-= { NULL,
-    "mac",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_mac_info)),
-    IPT_ALIGN(sizeof(struct ipt_mac_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match mac = { 
+	.next		= NULL,
+ 	.name		= "mac",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_mac_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_mac_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_mark.c iptables-1.3.0/extensions/libipt_mark.c
--- iptables-1.2.11/extensions/libipt_mark.c	2004-06-15 00:02:17.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_mark.c	2005-01-04 11:38:37.000000000 +0100
@@ -131,20 +131,19 @@
 	print_mark(info->mark, info->mask, 0);
 }
 
-static
-struct iptables_match mark
-= { NULL,
-    "mark",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_mark_info)),
-    IPT_ALIGN(sizeof(struct ipt_mark_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match mark = { 
+	.next		= NULL,
+	.name		= "mark",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_mark_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_mark_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_mport.c iptables-1.3.0/extensions/libipt_mport.c
--- iptables-1.2.11/extensions/libipt_mport.c	2003-07-14 22:01:29.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_mport.c	2005-01-04 11:38:35.000000000 +0100
@@ -136,6 +136,7 @@
 
 	switch (c) {
 	case '1':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
 		proto = check_proto(entry);
 		parse_multi_ports(argv[optind-1], minfo, proto);
 		minfo->flags = IPT_MPORT_SOURCE;
@@ -143,6 +144,7 @@
 		break;
 
 	case '2':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
 		proto = check_proto(entry);
 		parse_multi_ports(argv[optind-1], minfo, proto);
 		minfo->flags = IPT_MPORT_DESTINATION;
@@ -150,6 +152,7 @@
 		break;
 
 	case '3':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
 		proto = check_proto(entry);
 		parse_multi_ports(argv[optind-1], minfo, proto);
 		minfo->flags = IPT_MPORT_EITHER;
@@ -160,6 +163,10 @@
 		return 0;
 	}
 
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,
+			   "multiport does not support invert");
+
 	if (*flags)
 		exit_error(PARAMETER_PROBLEM,
 			   "multiport can only have one option");
@@ -285,19 +292,19 @@
 	printf(" ");
 }
 
-struct iptables_match mport
-= { NULL,
-    "mport",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_mport)),
-    IPT_ALIGN(sizeof(struct ipt_mport)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match mport = { 
+	.next		= NULL,
+	.name		= "mport",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_mport)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_mport)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void
diff -urN iptables-1.2.11/extensions/libipt_multiport.c iptables-1.3.0/extensions/libipt_multiport.c
--- iptables-1.2.11/extensions/libipt_multiport.c	2003-07-14 22:01:29.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_multiport.c	2005-02-12 21:03:28.000000000 +0100
@@ -5,7 +5,8 @@
 #include <stdlib.h>
 #include <getopt.h>
 #include <iptables.h>
-#include <linux/netfilter_ipv4/ipt_multiport.h>
+/* To ensure that iptables compiles with an old kernel */
+#include "../include/linux/netfilter_ipv4/ipt_multiport.h"
 
 /* Function which prints out usage message. */
 static void
@@ -20,6 +21,23 @@
 " --dports ...\n"
 "				match destination port(s)\n"
 " --ports port[,port,port]\n"
+"				match both source and destination port(s)\n"
+" NOTE: this kernel does not support port ranges in multiport.\n",
+IPTABLES_VERSION);
+}
+
+static void
+help_v1(void)
+{
+	printf(
+"multiport v%s options:\n"
+" --source-ports [!] port[,port:port,port...]\n"
+" --sports ...\n"
+"				match source port(s)\n"
+" --destination-ports [!] port[,port:port,port...]\n"
+" --dports ...\n"
+"				match destination port(s)\n"
+" --ports [!] port[,port:port,port]\n"
 "				match both source and destination port(s)\n",
 IPTABLES_VERSION);
 }
@@ -77,6 +95,46 @@
 	return i;
 }
 
+static void
+parse_multi_ports_v1(const char *portstring, 
+		     struct ipt_multiport_v1 *multiinfo,
+		     const char *proto)
+{
+	char *buffer, *cp, *next, *range;
+	unsigned int i;
+	u_int16_t m;
+
+	buffer = strdup(portstring);
+	if (!buffer) exit_error(OTHER_PROBLEM, "strdup failed");
+
+	for (i=0; i<IPT_MULTI_PORTS; i++)
+		multiinfo->pflags[i] = 0;
+ 
+	for (cp=buffer, i=0; cp && i<IPT_MULTI_PORTS; cp=next, i++) {
+		next=strchr(cp, ',');
+ 		if (next) *next++='\0';
+		range = strchr(cp, ':');
+		if (range) {
+			if (i == IPT_MULTI_PORTS-1)
+				exit_error(PARAMETER_PROBLEM,
+					   "too many ports specified");
+			*range++ = '\0';
+		}
+		multiinfo->ports[i] = parse_port(cp, proto);
+		if (range) {
+			multiinfo->pflags[i] = 1;
+			multiinfo->ports[++i] = parse_port(range, proto);
+			if (multiinfo->ports[i-1] >= multiinfo->ports[i])
+				exit_error(PARAMETER_PROBLEM,
+					   "invalid portrange specified");
+			m <<= 1;
+		}
+ 	}
+	multiinfo->count = i;
+ 	if (cp) exit_error(PARAMETER_PROBLEM, "too many ports specified");
+ 	free(buffer);
+}
+
 /* Initialize the match. */
 static void
 init(struct ipt_entry_match *m, unsigned int *nfcache)
@@ -86,6 +144,10 @@
 static const char *
 check_proto(const struct ipt_entry *entry)
 {
+	if (entry->ip.invflags & IPT_INV_PROTO)
+		exit_error(PARAMETER_PROBLEM,
+			   "multiport only works with TCP or UDP");
+
 	if (entry->ip.proto == IPPROTO_TCP)
 		return "tcp";
 	else if (entry->ip.proto == IPPROTO_UDP)
@@ -112,6 +174,7 @@
 
 	switch (c) {
 	case '1':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
 		proto = check_proto(entry);
 		multiinfo->count = parse_multi_ports(argv[optind-1],
 						     multiinfo->ports, proto);
@@ -120,6 +183,7 @@
 		break;
 
 	case '2':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
 		proto = check_proto(entry);
 		multiinfo->count = parse_multi_ports(argv[optind-1],
 						     multiinfo->ports, proto);
@@ -128,6 +192,7 @@
 		break;
 
 	case '3':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
 		proto = check_proto(entry);
 		multiinfo->count = parse_multi_ports(argv[optind-1],
 						     multiinfo->ports, proto);
@@ -139,6 +204,59 @@
 		return 0;
 	}
 
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,
+			   "multiport does not support invert");
+
+	if (*flags)
+		exit_error(PARAMETER_PROBLEM,
+			   "multiport can only have one option");
+	*flags = 1;
+	return 1;
+}
+
+static int
+parse_v1(int c, char **argv, int invert, unsigned int *flags,
+	 const struct ipt_entry *entry,
+	 unsigned int *nfcache,
+	 struct ipt_entry_match **match)
+{
+	const char *proto;
+	struct ipt_multiport_v1 *multiinfo
+		= (struct ipt_multiport_v1 *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
+		proto = check_proto(entry);
+		parse_multi_ports_v1(argv[optind-1], multiinfo, proto);
+		multiinfo->flags = IPT_MULTIPORT_SOURCE;
+		*nfcache |= NFC_IP_SRC_PT;
+		break;
+
+	case '2':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
+		proto = check_proto(entry);
+		parse_multi_ports_v1(argv[optind-1], multiinfo, proto);
+		multiinfo->flags = IPT_MULTIPORT_DESTINATION;
+		*nfcache |= NFC_IP_DST_PT;
+		break;
+
+	case '3':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
+		proto = check_proto(entry);
+		parse_multi_ports_v1(argv[optind-1], multiinfo, proto);
+		multiinfo->flags = IPT_MULTIPORT_EITHER;
+		*nfcache |= NFC_IP_SRC_PT | NFC_IP_DST_PT;
+		break;
+
+	default:
+		return 0;
+	}
+
+	if (invert)
+		multiinfo->invert = 1;
+
 	if (*flags)
 		exit_error(PARAMETER_PROBLEM,
 			   "multiport can only have one option");
@@ -214,6 +332,49 @@
 	printf(" ");
 }
 
+static void
+print_v1(const struct ipt_ip *ip,
+	 const struct ipt_entry_match *match,
+	 int numeric)
+{
+	const struct ipt_multiport_v1 *multiinfo
+		= (const struct ipt_multiport_v1 *)match->data;
+	unsigned int i;
+
+	printf("multiport ");
+
+	switch (multiinfo->flags) {
+	case IPT_MULTIPORT_SOURCE:
+		printf("sports ");
+		break;
+
+	case IPT_MULTIPORT_DESTINATION:
+		printf("dports ");
+		break;
+
+	case IPT_MULTIPORT_EITHER:
+		printf("ports ");
+		break;
+
+	default:
+		printf("ERROR ");
+		break;
+	}
+
+	if (multiinfo->invert)
+		printf("! ");
+
+	for (i=0; i < multiinfo->count; i++) {
+		printf("%s", i ? "," : "");
+		print_port(multiinfo->ports[i], ip->proto, numeric);
+		if (multiinfo->pflags[i]) {
+			printf(":");
+			print_port(multiinfo->ports[++i], ip->proto, numeric);
+		}
+	}
+	printf(" ");
+}
+
 /* Saves the union ipt_matchinfo in parsable form to stdout. */
 static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
 {
@@ -242,24 +403,76 @@
 	printf(" ");
 }
 
-static
-struct iptables_match multiport
-= { NULL,
-    "multiport",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_multiport)),
-    IPT_ALIGN(sizeof(struct ipt_multiport)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static void save_v1(const struct ipt_ip *ip, 
+		    const struct ipt_entry_match *match)
+{
+	const struct ipt_multiport_v1 *multiinfo
+		= (const struct ipt_multiport_v1 *)match->data;
+	unsigned int i;
+
+	switch (multiinfo->flags) {
+	case IPT_MULTIPORT_SOURCE:
+		printf("--sports ");
+		break;
+
+	case IPT_MULTIPORT_DESTINATION:
+		printf("--dports ");
+		break;
+
+	case IPT_MULTIPORT_EITHER:
+		printf("--ports ");
+		break;
+	}
+
+	if (multiinfo->invert)
+		printf("! ");
+
+	for (i=0; i < multiinfo->count; i++) {
+		printf("%s", i ? "," : "");
+		print_port(multiinfo->ports[i], ip->proto, 1);
+		if (multiinfo->pflags[i]) {
+			printf(":");
+			print_port(multiinfo->ports[++i], ip->proto, 1);
+		}
+	}
+	printf(" ");
+}
+
+static struct iptables_match multiport = { 
+	.next		= NULL,
+	.name		= "multiport",
+	.revision	= 0,
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_multiport)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_multiport)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+static struct iptables_match multiport_v1 = { 
+	.next		= NULL,
+	.name		= "multiport",
+	.version	= IPTABLES_VERSION,
+	.revision	= 1,
+	.size		= IPT_ALIGN(sizeof(struct ipt_multiport_v1)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_multiport_v1)),
+	.help		= &help_v1,
+	.init		= &init,
+	.parse		= &parse_v1,
+	.final_check	= &final_check,
+	.print		= &print_v1,
+	.save		= &save_v1,
+	.extra_opts	= opts
 };
 
 void
 _init(void)
 {
 	register_match(&multiport);
+	register_match(&multiport_v1);
 }
diff -urN iptables-1.2.11/extensions/libipt_nth.c iptables-1.3.0/extensions/libipt_nth.c
--- iptables-1.2.11/extensions/libipt_nth.c	2002-10-22 12:15:20.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_nth.c	2005-01-04 11:38:35.000000000 +0100
@@ -30,10 +30,10 @@
 	printf(
 "nth v%s options:\n"
 "   --every     Nth              Match every Nth packet\n"
-"  [--counter]  num              Use counter 0-%u (default:0)\n"
-"  [--start]    num              Initialize the counter at the number 'num'\n"
+"  [--counter   num ]            Use counter 0-%u (default:0)\n"
+"  [--start     num ]            Initialize the counter at the number 'num'\n"
 "                                instead of 0. Must be between 0 and Nth-1\n"
-"  [--packet]   num              Match on 'num' packet. Must be between 0\n"
+"  [--packet    num ]            Match on 'num' packet. Must be between 0\n"
 "                                and Nth-1.\n\n"
 "                                If --packet is used for a counter than\n"
 "                                there must be Nth number of --packet\n"
@@ -217,19 +217,19 @@
                 printf("--packet %u ", nthinfo->packet );
 }
 
-struct iptables_match nth
-= { NULL,
-    "nth",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_nth_info)),
-    IPT_ALIGN(sizeof(struct ipt_nth_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match nth = { 
+	.next		= NULL,
+	.name		= "nth",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_nth_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_nth_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_owner.c iptables-1.3.0/extensions/libipt_owner.c
--- iptables-1.2.11/extensions/libipt_owner.c	2004-06-15 00:02:17.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_owner.c	2005-01-04 11:38:35.000000000 +0100
@@ -22,6 +22,7 @@
 "[!] --pid-owner processid  Match local pid\n"
 "[!] --sid-owner sessionid  Match local sid\n"
 "[!] --cmd-owner name       Match local command name\n"
+"NOTE: pid, sid and command matching are broken on SMP\n"
 "\n",
 IPTABLES_VERSION);
 #else
@@ -31,6 +32,7 @@
 "[!] --gid-owner groupid    Match local gid\n"
 "[!] --pid-owner processid  Match local pid\n"
 "[!] --sid-owner sessionid  Match local sid\n"
+"NOTE: pid and sid matching are broken on SMP\n"
 "\n",
 IPTABLES_VERSION);
 #endif /* IPT_OWNER_COMM */
@@ -236,20 +238,19 @@
 #endif
 }
 
-static
-struct iptables_match owner
-= { NULL,
-    "owner",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_owner_info)),
-    IPT_ALIGN(sizeof(struct ipt_owner_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match owner = { 
+	.next		= NULL,
+	.name		= "owner",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_owner_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_owner_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_owner.man iptables-1.3.0/extensions/libipt_owner.man
--- iptables-1.2.11/extensions/libipt_owner.man	2004-01-22 16:04:25.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_owner.man	2004-10-10 11:56:26.000000000 +0200
@@ -24,3 +24,5 @@
 Matches if the packet was created by a process with the given command name.
 (this option is present only if iptables was compiled under a kernel
 supporting this feature)
+.TP
+.B NOTE: pid, sid and command matching are broken on SMP
diff -urN iptables-1.2.11/extensions/libipt_physdev.c iptables-1.3.0/extensions/libipt_physdev.c
--- iptables-1.2.11/extensions/libipt_physdev.c	2003-04-27 12:01:44.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_physdev.c	2005-01-04 11:38:34.000000000 +0100
@@ -210,20 +210,19 @@
 	printf(" ");
 }
 
-static
-struct iptables_match physdev
-= { NULL,
-    "physdev",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_physdev_info)),
-    IPT_ALIGN(sizeof(struct ipt_physdev_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match physdev = { 
+	.next		= NULL,
+	.name		= "physdev",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_physdev_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_physdev_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_pkttype.c iptables-1.3.0/extensions/libipt_pkttype.c
--- iptables-1.2.11/extensions/libipt_pkttype.c	2002-08-07 11:54:45.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_pkttype.c	2005-01-04 11:38:33.000000000 +0100
@@ -152,20 +152,19 @@
 	print_pkttype(info);
 }
 
-static
-struct iptables_match pkttype = {
-    NULL,
-    "pkttype",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_pkttype_info)),
-    IPT_ALIGN(sizeof(struct ipt_pkttype_info)),
-    &help,
-    &init,
-    &parse, 
-    &final_check, 
-    &print,
-    &save, 
-    opts
+static struct iptables_match pkttype = {
+	.next		= NULL,
+	.name		= "pkttype",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_pkttype_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_pkttype_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse, 
+	.final_check	= &final_check, 
+	.print		= &print,
+	.save		= &save, 
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_pool.c iptables-1.3.0/extensions/libipt_pool.c
--- iptables-1.2.11/extensions/libipt_pool.c	2002-12-05 20:41:11.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_pool.c	2005-01-04 11:38:37.000000000 +0100
@@ -122,20 +122,19 @@
 			ip_pool_get_name(buf, sizeof(buf), info->dst, 0));
 }
 
-static
-struct iptables_match pool
-= { NULL,
-    "pool",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_pool_info)),
-    IPT_ALIGN(sizeof(struct ipt_pool_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match pool = { 
+	.next		= NULL,
+	.name		= "pool",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_pool_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_pool_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_psd.c iptables-1.3.0/extensions/libipt_psd.c
--- iptables-1.2.11/extensions/libipt_psd.c	2003-07-14 22:01:29.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_psd.c	2005-01-04 11:38:38.000000000 +0100
@@ -84,11 +84,6 @@
 	struct ipt_psd_info *psdinfo = (struct ipt_psd_info *)(*match)->data;
 	unsigned int num;
 	
-	if (!optarg)
-		exit_error(PARAMETER_PROBLEM, "missing optarg");
-
-	/* string_to_number needs a leading space */
-
 	switch (c) {
 	/* PSD-weight-threshold */
 	case '1':
@@ -180,20 +175,19 @@
 	printf("--psd-hi-ports-weight %u ", psdinfo->hi_ports_weight);
 }
 
-static
-struct iptables_match psd
-= { NULL,
-    "psd",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_psd_info)),
-    IPT_ALIGN(sizeof(struct ipt_psd_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match psd = { 
+	.next		= NULL,
+	.name		= "psd",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_psd_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_psd_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_quota.c iptables-1.3.0/extensions/libipt_quota.c
--- iptables-1.2.11/extensions/libipt_quota.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_quota.c	2005-01-04 11:38:36.000000000 +0100
@@ -93,18 +93,19 @@
 {
 }
 
-struct iptables_match quota = { NULL,
-        "quota",
-        IPTABLES_VERSION,
-        IPT_ALIGN(sizeof (struct ipt_quota_info)),
-        IPT_ALIGN(sizeof (struct ipt_quota_info)),
-        &help,
-        &init,
-        &parse,
-        &final_check,
-        &print,
-        &save,
-        opts
+struct iptables_match quota = { 
+	.next		= NULL,
+	.name		= "quota",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof (struct ipt_quota_info)),
+	.userspacesize	= IPT_ALIGN(sizeof (struct ipt_quota_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void
diff -urN iptables-1.2.11/extensions/libipt_random.c iptables-1.3.0/extensions/libipt_random.c
--- iptables-1.2.11/extensions/libipt_random.c	2002-10-22 12:15:20.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_random.c	2005-01-04 11:38:34.000000000 +0100
@@ -35,7 +35,7 @@
 {
 	printf(
 "random v%s options:\n"
-"  [--average]     percent      The probability in percentage of the match\n"
+"  [--average      percent ]    The probability in percentage of the match\n"
 "                               If ommited, a probability of 50%% percent is set.\n"
 "                               Percentage must be within : 1 <= percent <= 99.\n\n",
 IPTABLES_VERSION);
@@ -130,19 +130,19 @@
 	printf("--average %u ", result.quot);
 }
 
-struct iptables_match rand_match
-= { NULL,
-    "random",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_rand_info)),
-    IPT_ALIGN(sizeof(struct ipt_rand_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct iptables_match rand_match = { 
+	.next		= NULL,
+	.name		= "random",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_rand_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_rand_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_realm.c iptables-1.3.0/extensions/libipt_realm.c
--- iptables-1.2.11/extensions/libipt_realm.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_realm.c	2005-02-12 21:03:29.000000000 +0100
@@ -49,7 +49,8 @@
 	switch (c) {
 		char *end;
 	case '1':
-		check_inverse(optarg, &invert, &optind, 0);
+		check_inverse(argv[optind], &invert, &optind, 0);
+		optarg = argv[optind-1];
 		realminfo->id = strtoul(optarg, &end, 0);
 		if (*end == '/') {
 			realminfo->mask = strtoul(end+1, &end, 0);
@@ -69,12 +70,9 @@
 }
 
 static void
-print_realm(unsigned long id, unsigned long mask, int invert, int numeric)
+print_realm(unsigned long id, unsigned long mask)
 {
-	if (invert)
-		fputc('!', stdout);
-
-	if(mask != 0xffffffff)
+	if (mask != 0xffffffff)
 		printf("0x%lx/0x%lx ", id, mask);
 	else
 		printf("0x%lx ", id);
@@ -86,10 +84,13 @@
       const struct ipt_entry_match *match,
       int numeric)
 {
+	struct ipt_realm_info *ri = (struct ipt_realm_info *) match->data;
+
+	if (ri->invert)
+		printf("! ");
+
 	printf("REALM match ");
-	print_realm(((struct ipt_realm_info *)match->data)->id,
-		   ((struct ipt_realm_info *)match->data)->mask,
-		   ((struct ipt_realm_info *)match->data)->invert, numeric);
+	print_realm(ri->id, ri->mask);
 }
 
 
@@ -97,10 +98,13 @@
 static void
 save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
 {
+	struct ipt_realm_info *ri = (struct ipt_realm_info *) match->data;
+
+	if (ri->invert)
+		printf("! ");
+
 	printf("--realm ");
-	print_realm(((struct ipt_realm_info *)match->data)->id,
-		   ((struct ipt_realm_info *)match->data)->mask,
-		   ((struct ipt_realm_info *)match->data)->invert, 0);
+	print_realm(ri->id, ri->mask);
 }
 
 /* Final check; must have specified --mark. */
@@ -112,19 +116,18 @@
 			   "REALM match: You must specify `--realm'");
 }
 
-struct iptables_match realm
-= { NULL,
-    "realm",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_realm_info)),
-    IPT_ALIGN(sizeof(struct ipt_realm_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match realm = { NULL,
+	.name		= "realm",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_realm_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_realm_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_rpc.c iptables-1.3.0/extensions/libipt_rpc.c
--- iptables-1.2.11/extensions/libipt_rpc.c	2003-03-30 22:26:58.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_rpc.c	2005-01-04 11:38:36.000000000 +0100
@@ -352,18 +352,19 @@
 }
 
 
-static struct iptables_match rpcstruct = { NULL,
-    "rpc",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_rpc_info)),
-    IPT_ALIGN(sizeof(struct ipt_rpc_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match rpcstruct = { 
+	.next		= NULL,
+	.name		= "rpc",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_rpc_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_rpc_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 
diff -urN iptables-1.2.11/extensions/libipt_set.c iptables-1.3.0/extensions/libipt_set.c
--- iptables-1.2.11/extensions/libipt_set.c	2004-02-09 14:47:01.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_set.c	2004-12-14 13:57:00.000000000 +0100
@@ -1,4 +1,14 @@
-/* Shared library add-on to iptables to add IP address set matching. */
+/* Copyright (C) 2000-2002 Joakim Axelsson <gozem@linux.nu>
+ *                         Patrick Schaaf <bof@bof.de>
+ *                         Martin Josefsson <gandalf@wlug.westbo.se>
+ * Copyright (C) 2003-2004 Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.  
+ */
+
+/* Shared library add-on to iptables to add IP set matching. */
 #include <stdio.h>
 #include <netdb.h>
 #include <string.h>
@@ -10,14 +20,14 @@
 #include <iptables.h>
 #include <linux/netfilter_ipv4/ip_conntrack.h>
 #include <linux/netfilter_ipv4/ipt_set.h>
-#include "../ipset/libipt_set.h"
+#include "libipt_set.h"
 
 /* Function which prints out usage message. */
 static void help(void)
 {
 	printf("set v%s options:\n"
-	       " [!] --set     name[:flags] flags\n"
-	       "		'name' is the set name from to match.\n" 
+	       " [!] --set     name flags\n"
+	       "		'name' is the set name from to match,\n" 
 	       "		'flags' are the comma separated list of\n"
 	       "		'src' and 'dst'.\n"
 	       "\n", IPTABLES_VERSION);
@@ -36,7 +46,6 @@
 	
 
 	memset(info, 0, sizeof(struct ipt_set_info_match));
-	info->match.id = -1;
 
 	/* Can't cache this - XXX */
 	*nfcache |= NFC_UNKNOWN;
@@ -50,23 +59,33 @@
 {
 	struct ipt_set_info_match *myinfo = 
 		(struct ipt_set_info_match *) (*match)->data;
-	struct ipt_set_info *info = &myinfo->match;
+	struct ipt_set_info *info = &myinfo->match_set;
 
 	switch (c) {
-	case '1':		/* --set <set>[:<flags>] <flags> */
+	case '1':		/* --set <set> <flag>[,<flag> */
+		if (info->flags[0])
+			exit_error(PARAMETER_PROBLEM,
+				   "--set can be specified only once");
+
 		check_inverse(optarg, &invert, &optind, 0);
 		if (invert)
 			info->flags[0] |= IPSET_MATCH_INV;
 
 		if (!argv[optind]
-		    || argv[optind][0] == '-' || argv[optind][0] == '!')
+		    || argv[optind][0] == '-'
+		    || argv[optind][0] == '!')
 			exit_error(PARAMETER_PROBLEM,
 				   "--set requires two args.");
 
-		parse_pool(argv[optind - 1], info);
-		if (parse_ipflags(argv[optind++], info))
+		if (strlen(argv[optind-1]) > IP_SET_MAXNAMELEN - 1)
 			exit_error(PARAMETER_PROBLEM,
-				   "Can't use overwrite flag with --set.");
+				   "setname `%s' too long, max %d characters.",
+				   argv[optind-1], IP_SET_MAXNAMELEN - 1);
+
+		get_set_byname(argv[optind - 1], info);
+		parse_bindings(argv[optind], info);
+		DEBUGP("parse: set index %u\n", info->index);
+		optind++;
 		
 		*flags = 1;
 		break;
@@ -83,7 +102,8 @@
 {
 	if (!flags)
 		exit_error(PARAMETER_PROBLEM,
-			   "You must specify either `--set'");
+			   "You must specify `--set' with proper arguments");
+	DEBUGP("final check OK\n");
 }
 
 static void
@@ -92,22 +112,19 @@
 	int i;
 	char setname[IP_SET_MAXNAMELEN];
 
-	if (info->id >= 0) {
-		get_set_byid(setname, info->id);
-		printf("%s%s %s", 
-		       (info->flags[0] & IPSET_MATCH_INV) ? "!" : "",
-		       prefix,
-		       setname); 
-		for (i = 0; i < info->set_level; i++)
-			printf("%s%s",
-			       i == 0 ? ":" : ",",
-			       info->flags[i] & IPSET_SRC ? "src" : "dst");
-		for (i = info->set_level; i < info->ip_level; i++)
-			printf("%s%s",
-			       i == info->set_level ? " " : ",",
-			       info->flags[i] & IPSET_SRC ? "src" : "dst");
-		printf(" ");
+	get_set_byid(setname, info->index);
+	printf("%s%s %s", 
+	       (info->flags[0] & IPSET_MATCH_INV) ? "!" : "",
+	       prefix,
+	       setname); 
+	for (i = 0; i < IP_SET_MAX_BINDINGS; i++) {
+		if (!info->flags[i])
+			break;		
+		printf("%s%s",
+		       i == 0 ? " " : ",",
+		       info->flags[i] & IPSET_SRC ? "src" : "dst");
 	}
+	printf(" ");
 }
 
 /* Prints out the matchinfo. */
@@ -118,7 +135,7 @@
 	struct ipt_set_info_match *info = 
 		(struct ipt_set_info_match *) match->data;
 
-	print_match("set", &info->match);
+	print_match("set", &info->match_set);
 }
 
 /* Saves the matchinfo in parsable form to stdout. */
@@ -128,11 +145,11 @@
 	struct ipt_set_info_match *info = 
 		(struct ipt_set_info_match *) match->data;
 
-	print_match("--set", &info->match);
+	print_match("--set", &info->match_set);
 }
 
 static
-struct iptables_match set = { NULL,
+struct iptables_match set = {
 	.name		= "set",
 	.version	= IPTABLES_VERSION,
 	.size		= IPT_ALIGN(sizeof(struct ipt_set_info_match)),
diff -urN iptables-1.2.11/extensions/libipt_set.h iptables-1.3.0/extensions/libipt_set.h
--- iptables-1.2.11/extensions/libipt_set.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_set.h	2004-12-14 13:57:01.000000000 +0100
@@ -0,0 +1,104 @@
+#ifndef _LIBIPT_SET_H
+#define _LIBIPT_SET_H
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <errno.h>
+
+#ifdef DEBUG
+#define DEBUGP(x, args...) fprintf(stderr, x, ## args)
+#else
+#define DEBUGP(x, args...) 
+#endif
+
+static void
+parse_bindings(const char *optarg, struct ipt_set_info *info)
+{
+	char *saved = strdup(optarg);
+	char *ptr, *tmp = saved;
+	int i = 0;
+	
+	while (i < (IP_SET_MAX_BINDINGS - 1) && tmp != NULL) {
+		ptr = strsep(&tmp, ",");
+		if (strncmp(ptr, "src", 3) == 0)
+			info->flags[i++] |= IPSET_SRC;
+		else if (strncmp(ptr, "dst", 3) == 0)
+			info->flags[i++] |= IPSET_DST;
+		else
+			exit_error(PARAMETER_PROBLEM,
+				   "You must spefify (the comma separated list of) 'src' or 'dst'.");
+	}
+
+	if (tmp)
+		exit_error(PARAMETER_PROBLEM,
+			   "Can't follow bindings deeper than %i.", 
+			   IP_SET_MAX_BINDINGS - 1);
+
+	free(saved);
+}
+
+static int get_set_getsockopt(void *data, size_t * size)
+{
+	int sockfd = -1;
+	sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+	if (sockfd < 0)
+		exit_error(OTHER_PROBLEM,
+			   "Can't open socket to ipset.\n");
+	/* Send! */
+	return getsockopt(sockfd, SOL_IP, SO_IP_SET, data, size);
+}
+
+static void get_set_byname(const char *setname, struct ipt_set_info *info)
+{
+	struct ip_set_req_get_set req;
+	int size = sizeof(struct ip_set_req_get_set);
+	int res;
+
+	req.op = IP_SET_OP_GET_BYNAME;
+	req.version = IP_SET_PROTOCOL_VERSION;
+	strncpy(req.set.name, setname, IP_SET_MAXNAMELEN);
+	req.set.name[IP_SET_MAXNAMELEN - 1] = '\0';
+	res = get_set_getsockopt(&req, &size);
+	if (res != 0)
+		exit_error(OTHER_PROBLEM,
+			   "Problem when communicating with ipset, errno=%d.\n",
+			   errno);
+	if (size != sizeof(struct ip_set_req_get_set))
+		exit_error(OTHER_PROBLEM,
+			   "Incorrect return size from kernel during ipset lookup, "
+			   "(want %d, got %d)\n",
+			   sizeof(struct ip_set_req_get_set), size);
+	if (req.set.index == IP_SET_INVALID_ID)
+		exit_error(PARAMETER_PROBLEM,
+			   "Set %s doesn't exist.\n", setname);
+
+	info->index = req.set.index;
+}
+
+static void get_set_byid(char * setname, ip_set_id_t index)
+{
+	struct ip_set_req_get_set req;
+	int size = sizeof(struct ip_set_req_get_set);
+	int res;
+
+	req.op = IP_SET_OP_GET_BYINDEX;
+	req.version = IP_SET_PROTOCOL_VERSION;
+	req.set.index = index;
+	res = get_set_getsockopt(&req, &size);
+	if (res != 0)
+		exit_error(OTHER_PROBLEM,
+			   "Problem when communicating with ipset, errno=%d.\n",
+			   errno);
+	if (size != sizeof(struct ip_set_req_get_set))
+		exit_error(OTHER_PROBLEM,
+			   "Incorrect return size from kernel during ipset lookup, "
+			   "(want %d, got %d)\n",
+			   sizeof(struct ip_set_req_get_set), size);
+	if (req.set.name[0] == '\0')
+		exit_error(PARAMETER_PROBLEM,
+			   "Set id %i in kernel doesn't exist.\n", index);
+
+	strncpy(setname, req.set.name, IP_SET_MAXNAMELEN);
+}
+
+#endif /*_LIBIPT_SET_H*/
diff -urN iptables-1.2.11/extensions/libipt_set.man iptables-1.3.0/extensions/libipt_set.man
--- iptables-1.2.11/extensions/libipt_set.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_set.man	2004-12-14 13:57:01.000000000 +0100
@@ -0,0 +1,17 @@
+This modules macthes IP sets which can be defined by ipset(8).
+.TP
+.BR "--set " "setname flag[,flag...]"
+where flags are
+.BR "src"
+and/or
+.BR "dst" 
+and there can be no more than six of them. Hence the command
+.nf
+ iptables -A FORWARD -m set --set test src,dst
+.fi
+will match packets, for which (depending on the type of the set) the source
+address or port number of the packet can be found in the specified set. If 
+there is a binding belonging to the mached set element or there is a default 
+binding for the given set, then the rule will match the packet only if 
+additionally (depending on the type of the set) the destination address or 
+port number of the packet can be found in the set according to the binding.
diff -urN iptables-1.2.11/extensions/libipt_standard.c iptables-1.3.0/extensions/libipt_standard.c
--- iptables-1.2.11/extensions/libipt_standard.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_standard.c	2005-01-04 11:38:34.000000000 +0100
@@ -48,19 +48,19 @@
 }
 
 static
-struct iptables_target standard
-= { NULL,
-    "standard",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(int)),
-    IPT_ALIGN(sizeof(int)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    NULL, /* print */
-    &save,
-    opts
+struct iptables_target standard = { 
+	.next		= NULL,
+	.name		= "standard",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(int)),
+	.userspacesize	= IPT_ALIGN(sizeof(int)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= NULL,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_state.c iptables-1.3.0/extensions/libipt_state.c
--- iptables-1.2.11/extensions/libipt_state.c	2003-10-07 20:55:13.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_state.c	2005-01-04 11:38:35.000000000 +0100
@@ -151,20 +151,19 @@
 	print_state(sinfo->statemask);
 }
 
-static
-struct iptables_match state
-= { NULL,
-    "state",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_state_info)),
-    IPT_ALIGN(sizeof(struct ipt_state_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match state = { 
+	.next		= NULL,
+	.name		= "state",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_state_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_state_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_tcp.c iptables-1.3.0/extensions/libipt_tcp.c
--- iptables-1.2.11/extensions/libipt_tcp.c	2003-03-30 20:29:56.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_tcp.c	2005-01-04 11:38:37.000000000 +0100
@@ -423,20 +423,20 @@
 	}
 }
 
-static
-struct iptables_match tcp
-= { NULL,
-    "tcp",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_tcp)),
-    IPT_ALIGN(sizeof(struct ipt_tcp)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts };
+static struct iptables_match tcp = { 
+	.next		= NULL,
+	.name		= "tcp",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_tcp)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_tcp)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
 
 void
 _init(void)
diff -urN iptables-1.2.11/extensions/libipt_tcpmss.c iptables-1.3.0/extensions/libipt_tcpmss.c
--- iptables-1.2.11/extensions/libipt_tcpmss.c	2002-09-05 11:51:22.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_tcpmss.c	2005-01-04 11:38:35.000000000 +0100
@@ -139,20 +139,19 @@
 		     mssinfo->invert, 0);
 }
 
-static
-struct iptables_match tcpmss
-= { NULL,
-    "tcpmss",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_tcpmss_match_info)),
-    IPT_ALIGN(sizeof(struct ipt_tcpmss_match_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match tcpmss = {
+	.next		= NULL,
+	.name		= "tcpmss",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_tcpmss_match_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_tcpmss_match_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_time.c iptables-1.3.0/extensions/libipt_time.c
--- iptables-1.2.11/extensions/libipt_time.c	2004-05-16 10:48:04.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_time.c	2005-01-04 11:38:37.000000000 +0100
@@ -21,6 +21,7 @@
 " [ --timestart value ] [ --timestop value] [ --days listofdays ] [ --datestart value ] [ --datestop value ]\n"
 "          timestart value : HH:MM (default 00:00)\n"
 "          timestop  value : HH:MM (default 23:59)\n"
+"                            Note: daylight savings time changes are not tracked\n"
 "          listofdays value: a list of days to apply\n"
 "                            from Mon,Tue,Wed,Thu,Fri,Sat,Sun\n"
 "                            Coma speparated, no space, case sensitive.\n"
@@ -452,10 +453,11 @@
 static void
 print_date(time_t date, char *command)
 {
+	struct tm *t;
+
 	/* If it's default value, don't print..*/
 	if (((date == 0) || (date == LONG_MAX)) && (command != NULL))
 		return;
-	struct tm *t;
 	t = localtime(&date);
 	if (command != NULL)
 		printf("%s %d:%d:%d:%d:%d:%d ", command, (t->tm_year + 1900), (t->tm_mon + 1),
@@ -528,19 +530,19 @@
 /* have to use offsetof() instead of IPT_ALIGN(), since kerneltime must not
  * be compared when user deletes rule with '-D' */
 static
-struct iptables_match timestruct
-= { NULL,
-    "time",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_time_info)),
-    offsetof(struct ipt_time_info, kerneltime),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct iptables_match timestruct = {
+	.next		= NULL,
+	.name		= "time",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_time_info)),
+	.userspacesize	= offsetof(struct ipt_time_info, kerneltime),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_tos.c iptables-1.3.0/extensions/libipt_tos.c
--- iptables-1.2.11/extensions/libipt_tos.c	2002-12-05 20:39:10.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_tos.c	2005-01-04 11:38:34.000000000 +0100
@@ -91,6 +91,11 @@
 
 	switch (c) {
 	case '1':
+		/* Ensure that `--tos' haven't been used yet. */
+		if (*flags == 1)
+			exit_error(PARAMETER_PROBLEM,
+					"tos match: only use --tos once!");
+
 		check_inverse(optarg, &invert, &optind, 0);
 		parse_tos(argv[optind-1], tosinfo);
 		if (invert)
@@ -154,20 +159,19 @@
 	print_tos(info->tos, 0);
 }
 
-static
-struct iptables_match tos
-= { NULL,
-    "tos",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_tos_info)),
-    IPT_ALIGN(sizeof(struct ipt_tos_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match tos = { 
+	.next		= NULL,
+	.name		= "tos",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_tos_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_tos_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/libipt_ttl.c iptables-1.3.0/extensions/libipt_ttl.c
--- iptables-1.2.11/extensions/libipt_ttl.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_ttl.c	2005-01-04 11:38:35.000000000 +0100
@@ -1,7 +1,7 @@
 /* Shared library add-on to iptables to add TTL matching support 
  * (C) 2000 by Harald Welte <laforge@gnumonks.org>
  *
- * $Id: libipt_ttl.c,v 1.6 2002/05/29 13:08:16 laforge Exp $
+ * $Id: libipt_ttl.c 3507 2004-12-28 13:11:59Z /C=DE/ST=Berlin/L=Berlin/O=Netfilter Project/OU=Development/CN=rusty/emailAddress=rusty@netfilter.org $
  *
  * This program is released under the terms of GNU GPL */
 
@@ -35,18 +35,14 @@
 		struct ipt_entry_match **match)
 {
 	struct ipt_ttl_info *info = (struct ipt_ttl_info *) (*match)->data;
-	u_int8_t value;
+	int value;
 
 	check_inverse(optarg, &invert, &optind, 0);
-	value = atoi(argv[optind-1]);
 
-	if (*flags) 
-		exit_error(PARAMETER_PROBLEM, 
-				"Can't specify TTL option twice");
-
-	if (!optarg)
+	if (string_to_number(optarg, 0, 255, &value) == -1)
 		exit_error(PARAMETER_PROBLEM,
-				"ttl: You must specify a value");
+		           "ttl: Expected value between 0 and 255");
+
 	switch (c) {
 		case '2':
 			if (invert)
@@ -56,8 +52,6 @@
 
 			/* is 0 allowed? */
 			info->ttl = value;
-			*flags = 1;
-
 			break;
 		case '3':
 			if (invert) 
@@ -66,8 +60,6 @@
 
 			info->mode = IPT_TTL_LT;
 			info->ttl = value;
-			*flags = 1;
-
 			break;
 		case '4':
 			if (invert)
@@ -76,14 +68,17 @@
 
 			info->mode = IPT_TTL_GT;
 			info->ttl = value;
-			*flags = 1;
-
 			break;
 		default:
 			return 0;
 
 	}
 
+	if (*flags) 
+		exit_error(PARAMETER_PROBLEM, 
+				"Can't specify TTL option twice");
+	*flags = 1;
+
 	return 1;
 }
 
@@ -154,20 +149,19 @@
 	{ 0 }
 };
 
-static
-struct iptables_match ttl = {
-	NULL,
-	"ttl",
-	IPTABLES_VERSION,
-	IPT_ALIGN(sizeof(struct ipt_ttl_info)),
-	IPT_ALIGN(sizeof(struct ipt_ttl_info)),
-	&help,
-	&init,
-	&parse,
-	&final_check,
-	&print,
-	&save,
-	opts
+static struct iptables_match ttl = {
+	.next		= NULL,
+	.name		= "ttl",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_ttl_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_ttl_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 
diff -urN iptables-1.2.11/extensions/libipt_u32.c iptables-1.3.0/extensions/libipt_u32.c
--- iptables-1.2.11/extensions/libipt_u32.c	2003-02-01 10:08:57.000000000 +0100
+++ iptables-1.3.0/extensions/libipt_u32.c	2005-01-04 11:38:36.000000000 +0100
@@ -85,7 +85,7 @@
 	char *end;
 	errno = 0;
 
-	number = strtol(*s, &end, 0);
+	number = strtoul(*s, &end, 0);
 	if (end == *s)
 		exit_error(PARAMETER_PROBLEM, 
 			   "u32: at char %d expected number", pos);
@@ -250,19 +250,19 @@
 	print_u32((struct ipt_u32 *)match->data);
 }
 
-struct iptables_match u32
-= { NULL,
-    "u32",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_u32)),
-    IPT_ALIGN(sizeof(struct ipt_u32)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct iptables_match u32 = {
+	.next		= NULL,
+	.name		= "u32",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_u32)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_u32)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void
diff -urN iptables-1.2.11/extensions/libipt_udp.c iptables-1.3.0/extensions/libipt_udp.c
--- iptables-1.2.11/extensions/libipt_udp.c	2002-07-26 18:27:57.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_udp.c	2005-01-04 11:38:37.000000000 +0100
@@ -234,19 +234,19 @@
 }
 
 static
-struct iptables_match udp
-= { NULL,
-    "udp",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_udp)),
-    IPT_ALIGN(sizeof(struct ipt_udp)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct iptables_match udp = { 
+	.next		= NULL,
+	.name		= "udp",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_udp)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_udp)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
 };
 
 void
diff -urN iptables-1.2.11/extensions/libipt_unclean.c iptables-1.3.0/extensions/libipt_unclean.c
--- iptables-1.2.11/extensions/libipt_unclean.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.3.0/extensions/libipt_unclean.c	2005-01-04 11:38:34.000000000 +0100
@@ -42,19 +42,19 @@
 }
 
 static
-struct iptables_match unclean
-= { NULL,
-    "unclean",
-    IPTABLES_VERSION,
-    IPT_ALIGN(0),
-    IPT_ALIGN(0),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    NULL, /* print */
-    NULL, /* save */
-    opts
+struct iptables_match unclean = { 
+	.next		= NULL,
+	.name		= "unclean",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(0),
+	.userspacesize	= IPT_ALIGN(0),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= NULL,
+	.save		= NULL,
+	.extra_opts	= opts
 };
 
 void _init(void)
diff -urN iptables-1.2.11/extensions/svn-commit.tmp iptables-1.3.0/extensions/svn-commit.tmp
--- iptables-1.2.11/extensions/svn-commit.tmp	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/extensions/svn-commit.tmp	2005-02-12 21:03:21.000000000 +0100
@@ -0,0 +1,4 @@
+fix cut'n'paste error with SPT/DPT (Closes: #298)
+--This line, and those below, will be ignored--
+
+M    libipt_hashlimit.c
diff -urN iptables-1.2.11/include/ip6tables.h iptables-1.3.0/include/ip6tables.h
--- iptables-1.2.11/include/ip6tables.h	2004-02-19 19:04:20.000000000 +0100
+++ iptables-1.3.0/include/ip6tables.h	2005-01-04 11:38:28.000000000 +0100
@@ -4,6 +4,10 @@
 #include "iptables_common.h"
 #include "libiptc/libip6tc.h"
 
+#ifndef IP6T_LIB_DIR
+#define IP6T_LIB_DIR "/usr/local/lib/iptables"
+#endif
+
 struct ip6tables_rule_match
 {
 	struct ip6tables_rule_match *next;
diff -urN iptables-1.2.11/include/iptables.h iptables-1.3.0/include/iptables.h
--- iptables-1.2.11/include/iptables.h	2004-03-04 08:36:18.000000000 +0100
+++ iptables-1.3.0/include/iptables.h	2005-01-04 11:38:28.000000000 +0100
@@ -4,10 +4,26 @@
 #include "iptables_common.h"
 #include "libiptc/libiptc.h"
 
+#ifndef IPT_LIB_DIR
+#define IPT_LIB_DIR "/usr/local/lib/iptables"
+#endif
+
 #ifndef IPPROTO_SCTP
 #define IPPROTO_SCTP 132
 #endif
 
+#ifndef IPT_SO_GET_REVISION_MATCH /* Old kernel source. */
+#define IPT_SO_GET_REVISION_MATCH	(IPT_BASE_CTL + 2)
+#define IPT_SO_GET_REVISION_TARGET	(IPT_BASE_CTL + 3)
+
+struct ipt_get_revision
+{
+	char name[IPT_FUNCTION_MAXNAMELEN-1];
+
+	u_int8_t revision;
+};
+#endif /* IPT_SO_GET_REVISION_MATCH   Old kernel source */
+
 struct iptables_rule_match
 {
 	struct iptables_rule_match *next;
@@ -22,6 +38,9 @@
 
 	ipt_chainlabel name;
 
+	/* Revision of match (0 by default). */
+	u_int8_t revision;
+
 	const char *version;
 
 	/* Size of match data. */
@@ -72,6 +91,9 @@
 
 	ipt_chainlabel name;
 
+	/* Revision of target (0 by default). */
+	u_int8_t revision;
+
 	const char *version;
 
 	/* Size of target data. */
diff -urN iptables-1.2.11/include/iptables_common.h iptables-1.3.0/include/iptables_common.h
--- iptables-1.2.11/include/iptables_common.h	2004-06-15 00:02:17.000000000 +0200
+++ iptables-1.3.0/include/iptables_common.h	2005-01-04 11:38:28.000000000 +0100
@@ -26,6 +26,7 @@
 void exit_error(enum exittype, char *, ...)__attribute__((noreturn,
 							  format(printf,2,3)));
 extern const char *program_name, *program_version;
+extern char *lib_dir;
 
 #ifdef NO_SHARED_LIBS
 # ifdef _INIT
diff -urN iptables-1.2.11/include/linux/netfilter_ipv4/ipt_MARK.h iptables-1.3.0/include/linux/netfilter_ipv4/ipt_MARK.h
--- iptables-1.2.11/include/linux/netfilter_ipv4/ipt_MARK.h	2004-05-26 23:56:26.000000000 +0200
+++ iptables-1.3.0/include/linux/netfilter_ipv4/ipt_MARK.h	2005-01-04 11:38:28.000000000 +0100
@@ -9,4 +9,19 @@
 #endif
 };
 
+enum {
+	IPT_MARK_SET=0,
+	IPT_MARK_AND,
+	IPT_MARK_OR
+};
+
+struct ipt_mark_target_info_v1 {
+#ifdef KERNEL_64_USERSPACE_32
+	unsigned long long mark;
+#else
+	unsigned long mark;
+#endif
+	u_int8_t mode;
+};
+
 #endif /*_IPT_MARK_H_target*/
diff -urN iptables-1.2.11/include/linux/netfilter_ipv4/ipt_addrtype.h iptables-1.3.0/include/linux/netfilter_ipv4/ipt_addrtype.h
--- iptables-1.2.11/include/linux/netfilter_ipv4/ipt_addrtype.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/include/linux/netfilter_ipv4/ipt_addrtype.h	2004-10-10 11:56:23.000000000 +0200
@@ -0,0 +1,11 @@
+#ifndef _IPT_ADDRTYPE_H
+#define _IPT_ADDRTYPE_H
+
+struct ipt_addrtype_info {
+	u_int16_t	source;		/* source-type mask */
+	u_int16_t	dest;		/* dest-type mask */
+	u_int32_t	invert_source;
+	u_int32_t	invert_dest;
+};
+
+#endif
diff -urN iptables-1.2.11/include/linux/netfilter_ipv4/ipt_comment.h iptables-1.3.0/include/linux/netfilter_ipv4/ipt_comment.h
--- iptables-1.2.11/include/linux/netfilter_ipv4/ipt_comment.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/include/linux/netfilter_ipv4/ipt_comment.h	2004-10-10 11:56:23.000000000 +0200
@@ -0,0 +1,10 @@
+#ifndef _IPT_COMMENT_H
+#define _IPT_COMMENT_H
+
+#define IPT_MAX_COMMENT_LEN 256
+
+struct ipt_comment_info {
+	unsigned char comment[IPT_MAX_COMMENT_LEN];
+};
+
+#endif /* _IPT_COMMENT_H */
diff -urN iptables-1.2.11/include/linux/netfilter_ipv4/ipt_hashlimit.h iptables-1.3.0/include/linux/netfilter_ipv4/ipt_hashlimit.h
--- iptables-1.2.11/include/linux/netfilter_ipv4/ipt_hashlimit.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/include/linux/netfilter_ipv4/ipt_hashlimit.h	2004-10-20 16:00:43.000000000 +0200
@@ -0,0 +1,40 @@
+#ifndef _IPT_HASHLIMIT_H
+#define _IPT_HASHLIMIT_H
+
+/* timings are in milliseconds. */
+#define IPT_HASHLIMIT_SCALE 10000
+/* 1/10,000 sec period => max of 10,000/sec.  Min rate is then 429490
+   seconds, or one every 59 hours. */
+
+/* details of this structure hidden by the implementation */
+struct ipt_hashlimit_htable;
+
+#define IPT_HASHLIMIT_HASH_DIP	0x0001
+#define IPT_HASHLIMIT_HASH_DPT	0x0002
+#define IPT_HASHLIMIT_HASH_SIP	0x0004
+#define IPT_HASHLIMIT_HASH_SPT	0x0008
+
+struct hashlimit_cfg {
+	u_int32_t mode;	  /* bitmask of IPT_HASHLIMIT_HASH_* */
+	u_int32_t avg;    /* Average secs between packets * scale */
+	u_int32_t burst;  /* Period multiplier for upper limit. */
+
+	/* user specified */
+	u_int32_t size;		/* how many buckets */
+	u_int32_t max;		/* max number of entries */
+	u_int32_t gc_interval;	/* gc interval */
+	u_int32_t expire;	/* when do entries expire? */
+};
+
+struct ipt_hashlimit_info {
+	char name [IFNAMSIZ];		/* name */
+	struct hashlimit_cfg cfg;
+	struct ipt_hashlimit_htable *hinfo;
+
+	/* Used internally by the kernel */
+	union {
+		void *ptr;
+		struct ipt_hashlimit_info *master;
+	} u;
+};
+#endif /*_IPT_HASHLIMIT_H*/
diff -urN iptables-1.2.11/include/linux/netfilter_ipv4/ipt_multiport.h iptables-1.3.0/include/linux/netfilter_ipv4/ipt_multiport.h
--- iptables-1.2.11/include/linux/netfilter_ipv4/ipt_multiport.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/include/linux/netfilter_ipv4/ipt_multiport.h	2005-02-12 21:05:33.000000000 +0100
@@ -0,0 +1,29 @@
+#ifndef _IPT_MULTIPORT_H
+#define _IPT_MULTIPORT_H
+
+enum ipt_multiport_flags
+{
+	IPT_MULTIPORT_SOURCE,
+	IPT_MULTIPORT_DESTINATION,
+	IPT_MULTIPORT_EITHER
+};
+
+#define IPT_MULTI_PORTS	15
+
+/* Must fit inside union ipt_matchinfo: 16 bytes */
+struct ipt_multiport
+{
+	u_int8_t flags;				/* Type of comparison */
+	u_int8_t count;				/* Number of ports */
+	u_int16_t ports[IPT_MULTI_PORTS];	/* Ports */
+};
+
+struct ipt_multiport_v1
+{
+	u_int8_t flags;				/* Type of comparison */
+	u_int8_t count;				/* Number of ports */
+	u_int16_t ports[IPT_MULTI_PORTS];	/* Ports */
+	u_int8_t pflags[IPT_MULTI_PORTS];	/* Port flags */
+	u_int8_t invert;			/* Invert flag */
+};
+#endif /*_IPT_MULTIPORT_H*/
diff -urN iptables-1.2.11/include/linux/netfilter_ipv6/ip6t_physdev.h iptables-1.3.0/include/linux/netfilter_ipv6/ip6t_physdev.h
--- iptables-1.2.11/include/linux/netfilter_ipv6/ip6t_physdev.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/include/linux/netfilter_ipv6/ip6t_physdev.h	2004-10-10 11:56:23.000000000 +0200
@@ -0,0 +1,24 @@
+#ifndef _IP6T_PHYSDEV_H
+#define _IP6T_PHYSDEV_H
+
+#ifdef __KERNEL__
+#include <linux/if.h>
+#endif
+
+#define IP6T_PHYSDEV_OP_IN		0x01
+#define IP6T_PHYSDEV_OP_OUT		0x02
+#define IP6T_PHYSDEV_OP_BRIDGED		0x04
+#define IP6T_PHYSDEV_OP_ISIN		0x08
+#define IP6T_PHYSDEV_OP_ISOUT		0x10
+#define IP6T_PHYSDEV_OP_MASK		(0x20 - 1)
+
+struct ip6t_physdev_info {
+	char physindev[IFNAMSIZ];
+	char in_mask[IFNAMSIZ];
+	char physoutdev[IFNAMSIZ];
+	char out_mask[IFNAMSIZ];
+	u_int8_t invert;
+	u_int8_t bitmask;
+};
+
+#endif /*_IP6T_PHYSDEV_H*/
diff -urN iptables-1.2.11/ip6tables-restore.c iptables-1.3.0/ip6tables-restore.c
--- iptables-1.2.11/ip6tables-restore.c	2004-06-15 00:02:16.000000000 +0200
+++ iptables-1.3.0/ip6tables-restore.c	2005-01-04 11:38:39.000000000 +0100
@@ -7,7 +7,7 @@
  * 	Rusty Russell <rusty@linuxcare.com.au>
  * This code is distributed under the terms of GNU GPL v2
  *
- * $Id: ip6tables-restore.c,v 1.22 2004/05/26 16:04:48 gandalf Exp $
+ * $Id: ip6tables-restore.c 3504 2004-12-27 19:49:28Z /C=DE/ST=Berlin/L=Berlin/O=Netfilter Project/OU=Development/CN=gandalf/emailAddress=gandalf@netfilter.org $
  */
 
 #include <getopt.h>
@@ -116,6 +116,10 @@
 	program_version = IPTABLES_VERSION;
 	line = 0;
 
+	lib_dir = getenv("IP6TABLES_LIB_DIR");
+	if (!lib_dir)
+		lib_dir = IP6T_LIB_DIR;
+
 #ifdef NO_SHARED_LIBS
 	init_extensions();
 #endif
@@ -228,7 +232,7 @@
 				exit(1);
 			}
 
-			if (!ip6tc_builtin(chain, handle)) {
+			if (ip6tc_builtin(chain, handle) <= 0) {
 				DEBUGP("Creating new chain '%s'\n", chain);
 				if (!ip6tc_create_chain(chain, &handle))
 					exit_error(PARAMETER_PROBLEM,
diff -urN iptables-1.2.11/ip6tables-save.c iptables-1.3.0/ip6tables-save.c
--- iptables-1.2.11/ip6tables-save.c	2004-06-15 00:02:16.000000000 +0200
+++ iptables-1.3.0/ip6tables-save.c	2005-01-04 11:38:39.000000000 +0100
@@ -322,6 +322,10 @@
 	program_name = "ip6tables-save";
 	program_version = IPTABLES_VERSION;
 
+	lib_dir = getenv("IP6TABLES_LIB_DIR");
+	if (!lib_dir)
+		lib_dir = IP6T_LIB_DIR;
+
 #ifdef NO_SHARED_LIBS
 	init_extensions();
 #endif
diff -urN iptables-1.2.11/ip6tables-standalone.c iptables-1.3.0/ip6tables-standalone.c
--- iptables-1.2.11/ip6tables-standalone.c	2002-08-07 11:07:41.000000000 +0200
+++ iptables-1.3.0/ip6tables-standalone.c	2005-01-04 11:38:39.000000000 +0100
@@ -46,6 +46,10 @@
 	program_name = "ip6tables";
 	program_version = IPTABLES_VERSION;
 
+	lib_dir = getenv("IP6TABLES_LIB_DIR");
+	if (!lib_dir)
+		lib_dir = IP6T_LIB_DIR;
+
 #ifdef NO_SHARED_LIBS
 	init_extensions();
 #endif
diff -urN iptables-1.2.11/ip6tables.c iptables-1.3.0/ip6tables.c
--- iptables-1.2.11/ip6tables.c	2004-06-15 00:02:16.000000000 +0200
+++ iptables-1.3.0/ip6tables.c	2005-01-04 11:38:39.000000000 +0100
@@ -50,10 +50,6 @@
 #define FALSE 0
 #endif
 
-#ifndef IP6T_LIB_DIR
-#define IP6T_LIB_DIR "/usr/local/lib/iptables"
-#endif
-
 #ifndef PROC_SYS_MODPROBE
 #define PROC_SYS_MODPROBE "/proc/sys/kernel/modprobe"
 #endif
@@ -148,14 +144,6 @@
  * magic number of -1 */
 int line = -1;
 
-#ifndef __OPTIMIZE__
-struct ip6t_entry_target *
-ip6t_get_target(struct ip6t_entry *e)
-{
-	return (void *)e + e->target_offset;
-}
-#endif
-
 static struct option *opts = original_opts;
 static unsigned int global_option_offset = 0;
 
@@ -203,6 +191,7 @@
 
 const char *program_version;
 const char *program_name;
+char *lib_dir;
 
 /* Keeping track of external matches and targets: linked lists.  */
 struct ip6tables_match *ip6tables_matches = NULL;
@@ -732,12 +721,12 @@
 
 #ifndef NO_SHARED_LIBS
 	if (!ptr && tryload != DONT_LOAD) {
-		char path[sizeof(IP6T_LIB_DIR) + sizeof("/libip6t_.so")
+		char path[strlen(lib_dir) + sizeof("/libip6t_.so")
 			 + strlen(name)];
 		if (!icmphack)
-			sprintf(path, IP6T_LIB_DIR "/libip6t_%s.so", name);
+			sprintf(path, "%s/libip6t_%s.so", lib_dir, name);
 		else
-			sprintf(path, IP6T_LIB_DIR "/libip6t_%s.so", "icmpv6");
+			sprintf(path, "%s/libip6t_%s.so", lib_dir, "icmpv6");
 		if (dlopen(path, RTLD_NOW)) {
 			/* Found library.  If it didn't register itself,
 			   maybe they specified target as match. */
@@ -985,9 +974,9 @@
 
 #ifndef NO_SHARED_LIBS
 	if (!ptr && tryload != DONT_LOAD) {
-		char path[sizeof(IP6T_LIB_DIR) + sizeof("/libip6t_.so")
+		char path[strlen(lib_dir) + sizeof("/libip6t_.so")
 			 + strlen(name)];
-		sprintf(path, IP6T_LIB_DIR "/libip6t_%s.so", name);
+		sprintf(path, "%s/libip6t_%s.so", lib_dir, name);
 		if (dlopen(path, RTLD_NOW)) {
 			/* Found library.  If it didn't register itself,
 			   maybe they specified match as a target. */
@@ -1492,7 +1481,7 @@
 	for (i = 0; i < chaincount; i++) {
 		if (!builtinstoo
 		    && ip6tc_builtin(chains + i*sizeof(ip6t_chainlabel),
-				    *handle))
+				    *handle) == 1)
 			continue;
 	        ret &= fn(chains + i*sizeof(ip6t_chainlabel), verbose, handle);
 	}
@@ -1595,15 +1584,17 @@
 	int procfile;
 	char *ret;
 
+#define PROCFILE_BUFSIZ 1024
 	procfile = open(PROC_SYS_MODPROBE, O_RDONLY);
 	if (procfile < 0)
 		return NULL;
 
-	ret = malloc(1024);
+	ret = malloc(PROCFILE_BUFSIZ);
 	if (ret) {
-		switch (read(procfile, ret, 1024)) {
+		memset(ret, 0, PROCFILE_BUFSIZ);
+		switch (read(procfile, ret, PROCFILE_BUFSIZ)) {
 		case -1: goto fail;
-		case 1024: goto fail; /* Partial read.  Wierd */
+		case PROCFILE_BUFSIZ: goto fail; /* Partial read.  Wierd */
 		}
 		if (ret[strlen(ret)-1]=='\n') 
 			ret[strlen(ret)-1]=0;
@@ -1620,6 +1611,7 @@
 {
 	char *buf = NULL;
 	char *argv[3];
+	int status;
 
 	/* If they don't explicitly set it, read out of kernel */
 	if (!modprobe) {
@@ -1637,16 +1629,18 @@
 		execv(argv[0], argv);
 
 		/* not usually reached */
-		exit(0);
+		exit(1);
 	case -1:
 		return -1;
 
 	default: /* parent */
-		wait(NULL);
+		wait(&status);
 	}
 
 	free(buf);
-	return 0;
+	if (WIFEXITED(status) && WEXITSTATUS(status) == 0)
+		return 0;
+	return -1;
 }
 
 static struct ip6t_entry *
@@ -2185,11 +2179,9 @@
 	if (!*handle)
 		*handle = ip6tc_init(*table);
 
-	if (!*handle) {
-		/* try to insmod the module if iptc_init failed */
-		ip6tables_insmod("ip6_tables", modprobe);
+	/* try to insmod the module if iptc_init failed */
+	if (!*handle && ip6tables_insmod("ip6_tables", modprobe) != -1)
 		*handle = ip6tc_init(*table);
-	}
 
 	if (!*handle)
 		exit_error(VERSION_PROBLEM,
diff -urN iptables-1.2.11/iptables-multi.c iptables-1.3.0/iptables-multi.c
--- iptables-1.2.11/iptables-multi.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/iptables-multi.c	2004-10-10 11:56:28.000000000 +0200
@@ -0,0 +1,31 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <libgen.h>
+
+int iptables_main(int argc, char **argv);
+int iptables_save_main(int argc, char **argv);
+int iptables_restore_main(int argc, char **argv);
+
+int main(int argc, char **argv) {
+  char *progname;
+
+  if (argc == 0) {
+    fprintf(stderr, "no argv[0]?");
+    exit(1);
+  } else {
+    progname = basename(argv[0]);
+
+    if (!strcmp(progname, "iptables"))
+      return iptables_main(argc, argv);
+    
+    if (!strcmp(progname, "iptables-save"))
+      return iptables_save_main(argc, argv);
+    
+    if (!strcmp(progname, "iptables-restore"))
+      return iptables_restore_main(argc, argv);
+    
+    fprintf(stderr, "iptables multi-purpose version: unknown applet name %s\n", progname);
+    exit(1);
+  }
+}
diff -urN iptables-1.2.11/iptables-restore.c iptables-1.3.0/iptables-restore.c
--- iptables-1.2.11/iptables-restore.c	2004-06-15 00:02:16.000000000 +0200
+++ iptables-1.3.0/iptables-restore.c	2005-01-04 11:38:39.000000000 +0100
@@ -4,7 +4,7 @@
  *
  * This code is distributed under the terms of GNU GPL v2
  *
- * $Id: iptables-restore.c,v 1.34 2004/05/26 16:04:48 gandalf Exp $
+ * $Id: iptables-restore.c 3504 2004-12-27 19:49:28Z /C=DE/ST=Berlin/L=Berlin/O=Netfilter Project/OU=Development/CN=gandalf/emailAddress=gandalf@netfilter.org $
  */
 
 #include <getopt.h>
@@ -99,7 +99,13 @@
 		free(newargv[i]);
 }
 
-int main(int argc, char *argv[])
+#ifdef IPTABLES_MULTI
+int
+iptables_restore_main(int argc, char *argv[])
+#else
+int
+main(int argc, char *argv[])
+#endif
 {
 	iptc_handle_t handle = NULL;
 	char buffer[10240];
@@ -113,6 +119,10 @@
 	program_version = IPTABLES_VERSION;
 	line = 0;
 
+	lib_dir = getenv("IPTABLES_LIB_DIR");
+	if (!lib_dir)
+		lib_dir = IPT_LIB_DIR;
+
 #ifdef NO_SHARED_LIBS
 	init_extensions();
 #endif
@@ -225,7 +235,7 @@
 				exit(1);
 			}
 
-			if (!iptc_builtin(chain, handle)) {
+			if (iptc_builtin(chain, handle) <= 0) {
 				DEBUGP("Creating new chain '%s'\n", chain);
 				if (!iptc_create_chain(chain, &handle)) 
 					exit_error(PARAMETER_PROBLEM, 
diff -urN iptables-1.2.11/iptables-save.c iptables-1.3.0/iptables-save.c
--- iptables-1.2.11/iptables-save.c	2004-06-15 00:02:16.000000000 +0200
+++ iptables-1.3.0/iptables-save.c	2005-01-04 11:38:38.000000000 +0100
@@ -321,7 +321,13 @@
  * :Chain name POLICY packets bytes
  * rule
  */
-int main(int argc, char *argv[])
+#ifdef IPTABLES_MULTI
+int
+iptables_save_main(int argc, char *argv[])
+#else
+int
+main(int argc, char *argv[])
+#endif
 {
 	const char *tablename = NULL;
 	int c;
@@ -329,6 +335,10 @@
 	program_name = "iptables-save";
 	program_version = IPTABLES_VERSION;
 
+	lib_dir = getenv("IPTABLES_LIB_DIR");
+	if (!lib_dir)
+		lib_dir = IPT_LIB_DIR;
+
 #ifdef NO_SHARED_LIBS
 	init_extensions();
 #endif
diff -urN iptables-1.2.11/iptables-standalone.c iptables-1.3.0/iptables-standalone.c
--- iptables-1.2.11/iptables-standalone.c	2002-08-07 11:07:41.000000000 +0200
+++ iptables-1.3.0/iptables-standalone.c	2005-01-04 11:38:39.000000000 +0100
@@ -37,8 +37,13 @@
 #include <string.h>
 #include <iptables.h>
 
+#ifdef IPTABLES_MULTI
+int
+iptables_main(int argc, char *argv[])
+#else
 int
 main(int argc, char *argv[])
+#endif
 {
 	int ret;
 	char *table = "filter";
@@ -47,6 +52,10 @@
 	program_name = "iptables";
 	program_version = IPTABLES_VERSION;
 
+	lib_dir = getenv("IPTABLES_LIB_DIR");
+	if (!lib_dir)
+		lib_dir = IPT_LIB_DIR;
+
 #ifdef NO_SHARED_LIBS
 	init_extensions();
 #endif
diff -urN iptables-1.2.11/iptables.8.in iptables-1.3.0/iptables.8.in
--- iptables-1.2.11/iptables.8.in	2004-03-17 15:15:00.000000000 +0100
+++ iptables-1.3.0/iptables.8.in	2005-02-12 21:05:34.000000000 +0100
@@ -97,7 +97,7 @@
 This is the default table (if no -t option is passed).  It contains
 the built-in chains
 .B INPUT
-(for packets coming into the box itself),
+(for packets destined to local sockets),
 .B FORWARD
 (for packets being routed through the box), and
 .B OUTPUT
@@ -127,6 +127,16 @@
 (for altering packets being routed through the box), and
 .B POSTROUTING
 (for altering packets as they are about to go out).
+.TP
+.BR "raw" :
+This table is used mainly for configuring exemptions from connection
+tracking in combination with the NOTRACK target.  It registers at the netfilter
+hooks with higher priority and is thus called before ip_conntrack, or any other
+IP tables.  It provides the following built-in chains:
+.B PREROUTING
+(for packets arriving via any network interface)
+.B OUTPUT
+(for packets generated by local processes)
 .RE
 .SH OPTIONS
 The options that are recognized by
diff -urN iptables-1.2.11/iptables.c iptables-1.3.0/iptables.c
--- iptables-1.2.11/iptables.c	2004-06-15 00:02:16.000000000 +0200
+++ iptables-1.3.0/iptables.c	2005-01-04 11:38:38.000000000 +0100
@@ -47,10 +47,6 @@
 #define FALSE 0
 #endif
 
-#ifndef IPT_LIB_DIR
-#define IPT_LIB_DIR "/usr/local/lib/iptables"
-#endif
-
 #ifndef PROC_SYS_MODPROBE
 #define PROC_SYS_MODPROBE "/proc/sys/kernel/modprobe"
 #endif
@@ -147,14 +143,6 @@
  * magic number of -1 */
 int line = -1;
 
-#ifndef __OPTIMIZE__
-struct ipt_entry_target *
-ipt_get_target(struct ipt_entry *e)
-{
-	return (void *)e + e->target_offset;
-}
-#endif
-
 static struct option *opts = original_opts;
 static unsigned int global_option_offset = 0;
 
@@ -203,6 +191,7 @@
 
 const char *program_version;
 const char *program_name;
+char *lib_dir;
 
 /* Keeping track of external matches and targets: linked lists.  */
 struct iptables_match *iptables_matches = NULL;
@@ -551,7 +540,7 @@
 
 		while (host->h_addr_list[*naddr] != (char *) NULL)
 			(*naddr)++;
-		addr = fw_calloc(*naddr, sizeof(struct in_addr));
+		addr = fw_calloc(*naddr, sizeof(struct in_addr) * *naddr);
 		for (i = 0; i < *naddr; i++)
 			inaddrcpy(&(addr[i]),
 				  (struct in_addr *) host->h_addr_list[i]);
@@ -675,9 +664,9 @@
 
 #ifndef NO_SHARED_LIBS
 	if (!ptr && tryload != DONT_LOAD) {
-		char path[sizeof(IPT_LIB_DIR) + sizeof("/libipt_.so")
+		char path[strlen(lib_dir) + sizeof("/libipt_.so")
 			 + strlen(name)];
-		sprintf(path, IPT_LIB_DIR "/libipt_%s.so", name);
+		sprintf(path, "%s/libipt_%s.so", lib_dir, name);
 		if (dlopen(path, RTLD_NOW)) {
 			/* Found library.  If it didn't register itself,
 			   maybe they specified target as match. */
@@ -985,9 +974,9 @@
 
 #ifndef NO_SHARED_LIBS
 	if (!ptr && tryload != DONT_LOAD) {
-		char path[sizeof(IPT_LIB_DIR) + sizeof("/libipt_.so")
+		char path[strlen(lib_dir) + sizeof("/libipt_.so")
 			 + strlen(name)];
-		sprintf(path, IPT_LIB_DIR "/libipt_%s.so", name);
+		sprintf(path, "%s/libipt_%s.so", lib_dir, name);
 		if (dlopen(path, RTLD_NOW)) {
 			/* Found library.  If it didn't register itself,
 			   maybe they specified match as a target. */
@@ -1044,10 +1033,56 @@
 	return merge;
 }
 
+static int compatible_revision(const char *name, u_int8_t revision, int opt)
+{
+	struct ipt_get_revision rev;
+	socklen_t s = sizeof(rev);
+	int max_rev, sockfd;
+
+	sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+	if (sockfd < 0) {
+		fprintf(stderr, "Could not open socket to kernel: %s\n",
+			strerror(errno));
+		exit(1);
+	}
+
+	strcpy(rev.name, name);
+	rev.revision = revision;
+
+	max_rev = getsockopt(sockfd, IPPROTO_IP, opt, &rev, &s);
+	if (max_rev < 0) {
+		/* Definitely don't support this? */
+		if (errno == EPROTONOSUPPORT) {
+			close(sockfd);
+			return 0;
+		} else if (errno == ENOPROTOOPT) {
+			close(sockfd);
+			/* Assume only revision 0 support (old kernel) */
+			return (revision == 0);
+		} else {
+			fprintf(stderr, "getsockopt failed strangely: %s\n",
+				strerror(errno));
+			exit(1);
+		}
+	}
+	close(sockfd);
+	return 1;
+}
+
+static int compatible_match_revision(const char *name, u_int8_t revision)
+{
+	return compatible_revision(name, revision, IPT_SO_GET_REVISION_MATCH);
+}
+
+static int compatible_target_revision(const char *name, u_int8_t revision)
+{
+	return compatible_revision(name, revision, IPT_SO_GET_REVISION_TARGET);
+}
+
 void
 register_match(struct iptables_match *me)
 {
-	struct iptables_match **i;
+	struct iptables_match **i, *old;
 
 	if (strcmp(me->version, program_version) != 0) {
 		fprintf(stderr, "%s: match `%s' v%s (I'm v%s).\n",
@@ -1055,12 +1090,36 @@
 		exit(1);
 	}
 
-	if (find_match(me->name, DONT_LOAD, NULL)) {
-		fprintf(stderr, "%s: match `%s' already registered.\n",
+	/* Revision field stole a char from name. */
+	if (strlen(me->name) >= IPT_FUNCTION_MAXNAMELEN-1) {
+		fprintf(stderr, "%s: target `%s' has invalid name\n",
 			program_name, me->name);
 		exit(1);
 	}
 
+	old = find_match(me->name, DONT_LOAD, NULL);
+	if (old) {
+		if (old->revision == me->revision) {
+			fprintf(stderr,
+				"%s: match `%s' already registered.\n",
+				program_name, me->name);
+			exit(1);
+		}
+
+		/* Now we have two (or more) options, check compatibility. */
+		if (compatible_match_revision(old->name, old->revision)
+		    && old->revision > me->revision)
+			return;
+
+		/* Replace if compatible. */
+		if (!compatible_match_revision(me->name, me->revision))
+			return;
+
+		/* Delete old one. */
+		for (i = &iptables_matches; *i!=old; i = &(*i)->next);
+		*i = old->next;
+	}
+
 	if (me->size != IPT_ALIGN(me->size)) {
 		fprintf(stderr, "%s: match `%s' has invalid size %u.\n",
 			program_name, me->name, (unsigned int)me->size);
@@ -1079,18 +1138,46 @@
 void
 register_target(struct iptables_target *me)
 {
+	struct iptables_target *old;
+
 	if (strcmp(me->version, program_version) != 0) {
 		fprintf(stderr, "%s: target `%s' v%s (I'm v%s).\n",
 			program_name, me->name, me->version, program_version);
 		exit(1);
 	}
 
-	if (find_target(me->name, DONT_LOAD)) {
-		fprintf(stderr, "%s: target `%s' already registered.\n",
+	/* Revision field stole a char from name. */
+	if (strlen(me->name) >= IPT_FUNCTION_MAXNAMELEN-1) {
+		fprintf(stderr, "%s: target `%s' has invalid name\n",
 			program_name, me->name);
 		exit(1);
 	}
 
+	old = find_target(me->name, DONT_LOAD);
+	if (old) {
+		struct iptables_target **i;
+
+		if (old->revision == me->revision) {
+			fprintf(stderr,
+				"%s: target `%s' already registered.\n",
+				program_name, me->name);
+			exit(1);
+		}
+
+		/* Now we have two (or more) options, check compatibility. */
+		if (compatible_target_revision(old->name, old->revision)
+		    && old->revision > me->revision)
+			return;
+
+		/* Replace if compatible. */
+		if (!compatible_target_revision(me->name, me->revision))
+			return;
+
+		/* Delete old one. */
+		for (i = &iptables_targets; *i!=old; i = &(*i)->next);
+		*i = old->next;
+	}
+
 	if (me->size != IPT_ALIGN(me->size)) {
 		fprintf(stderr, "%s: target `%s' has invalid size %u.\n",
 			program_name, me->name, (unsigned int)me->size);
@@ -1490,7 +1577,7 @@
 	for (i = 0; i < chaincount; i++) {
 		if (!builtinstoo
 		    && iptc_builtin(chains + i*sizeof(ipt_chainlabel),
-				    *handle))
+				    *handle) == 1)
 			continue;
 	        ret &= fn(chains + i*sizeof(ipt_chainlabel), verbose, handle);
 	}
@@ -1593,15 +1680,17 @@
 	int procfile;
 	char *ret;
 
+#define PROCFILE_BUFSIZ	1024
 	procfile = open(PROC_SYS_MODPROBE, O_RDONLY);
 	if (procfile < 0)
 		return NULL;
 
-	ret = malloc(1024);
+	ret = (char *) malloc(PROCFILE_BUFSIZ);
 	if (ret) {
-		switch (read(procfile, ret, 1024)) {
+		memset(ret, 0, PROCFILE_BUFSIZ);
+		switch (read(procfile, ret, PROCFILE_BUFSIZ)) {
 		case -1: goto fail;
-		case 1024: goto fail; /* Partial read.  Wierd */
+		case PROCFILE_BUFSIZ: goto fail; /* Partial read.  Wierd */
 		}
 		if (ret[strlen(ret)-1]=='\n') 
 			ret[strlen(ret)-1]=0;
@@ -1618,6 +1707,7 @@
 {
 	char *buf = NULL;
 	char *argv[3];
+	int status;
 
 	/* If they don't explicitly set it, read out of kernel */
 	if (!modprobe) {
@@ -1635,16 +1725,18 @@
 		execv(argv[0], argv);
 
 		/* not usually reached */
-		exit(0);
+		exit(1);
 	case -1:
 		return -1;
 
 	default: /* parent */
-		wait(NULL);
+		wait(&status);
 	}
 
 	free(buf);
-	return 0;
+	if (WIFEXITED(status) && WEXITSTATUS(status) == 0)
+		return 0;
+	return -1;
 }
 
 static struct ipt_entry *
@@ -1690,6 +1782,14 @@
 	*matches = NULL;
 }
 
+static void set_revision(char *name, u_int8_t revision)
+{
+	/* Old kernel sources don't have ".revision" field,
+	   but we stole a byte from name. */
+	name[IPT_FUNCTION_MAXNAMELEN - 2] = '\0';
+	name[IPT_FUNCTION_MAXNAMELEN - 1] = revision;
+}
+
 int do_command(int argc, char *argv[], char **table, iptc_handle_t *handle)
 {
 	struct ipt_entry fw, *e = NULL;
@@ -1922,6 +2022,8 @@
 				target->t = fw_calloc(1, size);
 				target->t->u.target_size = size;
 				strcpy(target->t->u.user.name, jumpto);
+				set_revision(target->t->u.user.name,
+					     target->revision);
 				target->init(target->t, &fw.nfcache);
 				opts = merge_options(opts, target->extra_opts, &target->option_offset);
 			}
@@ -1975,6 +2077,7 @@
 			m->m = fw_calloc(1, size);
 			m->m->u.match_size = size;
 			strcpy(m->m->u.user.name, m->name);
+			set_revision(m->m->u.user.name, m->revision);
 			m->init(m->m, &fw.nfcache);
 			opts = merge_options(opts, m->extra_opts, &m->option_offset);
 		}
@@ -2116,6 +2219,8 @@
 					m->m = fw_calloc(1, size);
 					m->m->u.match_size = size;
 					strcpy(m->m->u.user.name, m->name);
+					set_revision(m->m->u.user.name,
+						     m->revision);
 					m->init(m->m, &fw.nfcache);
 
 					opts = merge_options(opts,
@@ -2185,11 +2290,9 @@
 	if (!*handle)
 		*handle = iptc_init(*table);
 
-	if (!*handle) {
-		/* try to insmod the module if iptc_init failed */
-		iptables_insmod("ip_tables", modprobe);
+	/* try to insmod the module if iptc_init failed */
+	if (!*handle && iptables_insmod("ip_tables", modprobe) != -1)
 		*handle = iptc_init(*table);
-	}
 
 	if (!*handle)
 		exit_error(VERSION_PROBLEM,
@@ -2245,6 +2348,7 @@
 			target->t = fw_calloc(1, size);
 			target->t->u.target_size = size;
 			strcpy(target->t->u.user.name, jumpto);
+			set_revision(target->t->u.user.name, target->revision);
 			target->init(target->t, &fw.nfcache);
 		}
 
@@ -2339,11 +2443,8 @@
 		e = NULL;
 	}
 
-	for (c = 0; c < nsaddrs; c++)
-		free(&saddrs[c]);
-
-	for (c = 0; c < ndaddrs; c++)
-		free(&daddrs[c]);
+	free(saddrs);
+	free(daddrs);
 
 	if (opts != original_opts) {
 		free(opts);
diff -urN iptables-1.2.11/libipq/ipq_create_handle.3 iptables-1.3.0/libipq/ipq_create_handle.3
--- iptables-1.2.11/libipq/ipq_create_handle.3	2001-11-24 16:09:20.000000000 +0100
+++ iptables-1.3.0/libipq/ipq_create_handle.3	2004-10-10 11:56:23.000000000 +0200
@@ -1,6 +1,6 @@
 .TH IPQ_CREATE_HANDLE 3 "16 October 2001" "Linux iptables 1.2" "Linux Programmer's Manual" 
 .\"
-\" $Id: ipq_create_handle.3,v 1.3 2001/11/24 15:09:20 jamesm Exp $
+\" $Id: ipq_create_handle.3 1056 2001-11-24 15:09:19Z jamesm $
 .\"
 .\"     Copyright (c) 2000-2001 Netfilter Core Team
 .\"
diff -urN iptables-1.2.11/libipq/ipq_errstr.3 iptables-1.3.0/libipq/ipq_errstr.3
--- iptables-1.2.11/libipq/ipq_errstr.3	2001-10-16 16:41:02.000000000 +0200
+++ iptables-1.3.0/libipq/ipq_errstr.3	2004-10-10 11:56:23.000000000 +0200
@@ -1,6 +1,6 @@
 .TH IPQ_ERRSTR 3 "16 October 2001" "Linux iptables 1.2" "Linux Programmer's Manual" 
 .\"
-.\" $Id: ipq_errstr.3,v 1.2 2001/10/16 14:41:02 jamesm Exp $
+.\" $Id: ipq_errstr.3 1041 2001-10-16 14:41:02Z jamesm $
 .\"
 .\"     Copyright (c) 2000 Netfilter Core Team
 .\"
diff -urN iptables-1.2.11/libipq/ipq_message_type.3 iptables-1.3.0/libipq/ipq_message_type.3
--- iptables-1.2.11/libipq/ipq_message_type.3	2001-10-16 16:41:02.000000000 +0200
+++ iptables-1.3.0/libipq/ipq_message_type.3	2004-10-10 11:56:23.000000000 +0200
@@ -1,6 +1,6 @@
 .TH IPQ_MESSAGE_TYPE 3 "16 October 2001" "Linux iptables 1.2" "Linux Programmer's Manual" 
 .\"
-.\" $Id: ipq_message_type.3,v 1.2 2001/10/16 14:41:02 jamesm Exp $
+.\" $Id: ipq_message_type.3 1041 2001-10-16 14:41:02Z jamesm $
 .\"
 .\"     Copyright (c) 2000-2001 Netfilter Core Team
 .\"
diff -urN iptables-1.2.11/libipq/ipq_read.3 iptables-1.3.0/libipq/ipq_read.3
--- iptables-1.2.11/libipq/ipq_read.3	2001-10-16 18:58:25.000000000 +0200
+++ iptables-1.3.0/libipq/ipq_read.3	2004-10-10 11:56:23.000000000 +0200
@@ -1,6 +1,6 @@
 .TH IPQ_READ 3 "16 October 2001" "Linux iptables 1.2" "Linux Programmer's Manual" 
 .\"
-.\" $Id: ipq_read.3,v 1.3 2001/10/16 16:58:25 jamesm Exp $
+.\" $Id: ipq_read.3 1042 2001-10-16 16:58:25Z jamesm $
 .\"
 .\"     Copyright (c) 2000-2001 Netfilter Core Team
 .\"
diff -urN iptables-1.2.11/libipq/ipq_set_mode.3 iptables-1.3.0/libipq/ipq_set_mode.3
--- iptables-1.2.11/libipq/ipq_set_mode.3	2001-10-16 16:41:02.000000000 +0200
+++ iptables-1.3.0/libipq/ipq_set_mode.3	2004-10-10 11:56:23.000000000 +0200
@@ -1,6 +1,6 @@
 .TH IPQ_SET_MODE 3 "16 October 2001" "Linux iptables 1.2" "Linux Programmer's Manual" 
 .\"
-.\" $Id: ipq_set_mode.3,v 1.2 2001/10/16 14:41:02 jamesm Exp $
+.\" $Id: ipq_set_mode.3 1041 2001-10-16 14:41:02Z jamesm $
 .\"
 .\"     Copyright (c) 2000-2001 Netfilter Core Team
 .\"
diff -urN iptables-1.2.11/libipq/ipq_set_verdict.3 iptables-1.3.0/libipq/ipq_set_verdict.3
--- iptables-1.2.11/libipq/ipq_set_verdict.3	2001-10-16 16:41:02.000000000 +0200
+++ iptables-1.3.0/libipq/ipq_set_verdict.3	2004-10-10 11:56:23.000000000 +0200
@@ -1,6 +1,6 @@
 .TH IPQ_SET_VERDICT 3 "16 October 2001" "Linux iptables 1.2" "Linux Programmer's Manual" 
 .\"
-.\" $Id: ipq_set_verdict.3,v 1.2 2001/10/16 14:41:02 jamesm Exp $
+.\" $Id: ipq_set_verdict.3 1041 2001-10-16 14:41:02Z jamesm $
 .\"
 .\"     Copyright (c) 2000-2001 Netfilter Core Team
 .\"
diff -urN iptables-1.2.11/libipq/libipq.3 iptables-1.3.0/libipq/libipq.3
--- iptables-1.2.11/libipq/libipq.3	2001-11-24 16:09:20.000000000 +0100
+++ iptables-1.3.0/libipq/libipq.3	2004-10-10 11:56:23.000000000 +0200
@@ -1,6 +1,6 @@
 .TH LIBIPQ 3 "16 October 2001" "Linux iptables 1.2" "Linux Programmer's Manual" 
 .\"
-.\" $Id: libipq.3,v 1.5 2001/11/24 15:09:20 jamesm Exp $
+.\" $Id: libipq.3 1056 2001-11-24 15:09:19Z jamesm $
 .\"
 .\"     Copyright (c) 2000-2001 Netfilter Core Team
 .\"
diff -urN iptables-1.2.11/libiptc/libip4tc.c iptables-1.3.0/libiptc/libip4tc.c
--- iptables-1.2.11/libiptc/libip4tc.c	2004-06-15 00:02:18.000000000 +0200
+++ iptables-1.3.0/libiptc/libip4tc.c	2004-12-16 16:44:11.000000000 +0100
@@ -129,8 +129,8 @@
 	size_t i;
 	STRUCT_ENTRY_TARGET *t;
 
-	printf("Entry %u (%lu):\n", entry2index(handle, e),
-	       entry2offset(handle, e));
+	printf("Entry %u (%lu):\n", iptcb_entry2index(handle, e),
+	       iptcb_entry2offset(handle, e));
 	printf("SRC IP: %u.%u.%u.%u/%u.%u.%u.%u\n",
 	       IP_PARTS(e->ip.src.s_addr),IP_PARTS(e->ip.smsk.s_addr));
 	printf("DST IP: %u.%u.%u.%u/%u.%u.%u.%u\n",
@@ -184,11 +184,10 @@
 	return 0;
 }
 
-static int
+static unsigned char *
 is_same(const STRUCT_ENTRY *a, const STRUCT_ENTRY *b, unsigned char *matchmask)
 {
 	unsigned int i;
-	STRUCT_ENTRY_TARGET *ta, *tb;
 	unsigned char *mptr;
 
 	/* Always compare head structures: ignore mask here. */
@@ -199,45 +198,34 @@
 	    || a->ip.proto != b->ip.proto
 	    || a->ip.flags != b->ip.flags
 	    || a->ip.invflags != b->ip.invflags)
-		return 0;
+		return NULL;
 
 	for (i = 0; i < IFNAMSIZ; i++) {
 		if (a->ip.iniface_mask[i] != b->ip.iniface_mask[i])
-			return 0;
+			return NULL;
 		if ((a->ip.iniface[i] & a->ip.iniface_mask[i])
 		    != (b->ip.iniface[i] & b->ip.iniface_mask[i]))
-			return 0;
+			return NULL;
 		if (a->ip.outiface_mask[i] != b->ip.outiface_mask[i])
-			return 0;
+			return NULL;
 		if ((a->ip.outiface[i] & a->ip.outiface_mask[i])
 		    != (b->ip.outiface[i] & b->ip.outiface_mask[i]))
-			return 0;
+			return NULL;
 	}
 
 	if (a->nfcache != b->nfcache
 	    || a->target_offset != b->target_offset
 	    || a->next_offset != b->next_offset)
-		return 0;
+		return NULL;
 
 	mptr = matchmask + sizeof(STRUCT_ENTRY);
 	if (IPT_MATCH_ITERATE(a, match_different, a->elems, b->elems, &mptr))
-		return 0;
+		return NULL;
 
-	ta = GET_TARGET((STRUCT_ENTRY *)a);
-	tb = GET_TARGET((STRUCT_ENTRY *)b);
-	if (ta->u.target_size != tb->u.target_size)
-		return 0;
-	if (strcmp(ta->u.user.name, tb->u.user.name) != 0)
-		return 0;
-
-	mptr += sizeof(*ta);
-	if (target_different(ta->data, tb->data,
-			     ta->u.target_size - sizeof(*ta), mptr))
-		return 0;
-
-   	return 1;
+	return mptr;
 }
 
+#if 0
 /***************************** DEBUGGING ********************************/
 static inline int
 unconditional(const struct ipt_ip *ip)
@@ -292,20 +280,20 @@
 		assert(t->verdict == -NF_DROP-1
 		       || t->verdict == -NF_ACCEPT-1
 		       || t->verdict == RETURN
-		       || t->verdict < (int)h->entries.size);
+		       || t->verdict < (int)h->entries->size);
 
 		if (t->verdict >= 0) {
 			STRUCT_ENTRY *te = get_entry(h, t->verdict);
 			int idx;
 
-			idx = entry2index(h, te);
+			idx = iptcb_entry2index(h, te);
 			assert(strcmp(GET_TARGET(te)->u.user.name,
 				      IPT_ERROR_TARGET)
 			       != 0);
 			assert(te != e);
 
 			/* Prior node must be error node, or this node. */
-			assert(t->verdict == entry2offset(h, e)+e->next_offset
+			assert(t->verdict == iptcb_entry2offset(h, e)+e->next_offset
 			       || strcmp(GET_TARGET(index2entry(h, idx-1))
 					 ->u.user.name, IPT_ERROR_TARGET)
 			       == 0);
@@ -518,3 +506,5 @@
 		      ERROR_TARGET) == 0);
 }
 #endif /*IPTC_DEBUG*/
+
+#endif
diff -urN iptables-1.2.11/libiptc/libip6tc.c iptables-1.3.0/libiptc/libip6tc.c
--- iptables-1.2.11/libiptc/libip6tc.c	2004-06-15 00:02:18.000000000 +0200
+++ iptables-1.3.0/libiptc/libip6tc.c	2004-12-16 16:44:11.000000000 +0100
@@ -136,8 +136,8 @@
 	int len;
 	struct ip6t_entry_target *t;
 	
-	printf("Entry %u (%lu):\n", entry2index(handle, e),
-	       entry2offset(handle, e));
+	printf("Entry %u (%lu):\n", iptcb_entry2index(handle, e),
+	       iptcb_entry2offset(handle, e));
 	puts("SRC IP: ");
 	inet_ntop(AF_INET6, &e->ipv6.src, buf, sizeof buf);
 	puts(buf);
@@ -214,12 +214,11 @@
 	return 0;
 }
 
-static int
+static unsigned char *
 is_same(const STRUCT_ENTRY *a, const STRUCT_ENTRY *b,
 	unsigned char *matchmask)
 {
 	unsigned int i;
-	STRUCT_ENTRY_TARGET *ta, *tb;
 	unsigned char *mptr;
 
 	/* Always compare head structures: ignore mask here. */
@@ -231,43 +230,31 @@
 	    || a->ipv6.tos != b->ipv6.tos
 	    || a->ipv6.flags != b->ipv6.flags
 	    || a->ipv6.invflags != b->ipv6.invflags)
-		return 0;
+		return NULL;
 
 	for (i = 0; i < IFNAMSIZ; i++) {
 		if (a->ipv6.iniface_mask[i] != b->ipv6.iniface_mask[i])
-			return 0;
+			return NULL;
 		if ((a->ipv6.iniface[i] & a->ipv6.iniface_mask[i])
 		    != (b->ipv6.iniface[i] & b->ipv6.iniface_mask[i]))
-			return 0;
+			return NULL;
 		if (a->ipv6.outiface_mask[i] != b->ipv6.outiface_mask[i])
-			return 0;
+			return NULL;
 		if ((a->ipv6.outiface[i] & a->ipv6.outiface_mask[i])
 		    != (b->ipv6.outiface[i] & b->ipv6.outiface_mask[i]))
-			return 0;
+			return NULL;
 	}
 
 	if (a->nfcache != b->nfcache
 	    || a->target_offset != b->target_offset
 	    || a->next_offset != b->next_offset)
-		return 0;
+		return NULL;
 
 	mptr = matchmask + sizeof(STRUCT_ENTRY);
 	if (IP6T_MATCH_ITERATE(a, match_different, a->elems, b->elems, &mptr))
-		return 0;
+		return NULL;
 
-	ta = GET_TARGET((STRUCT_ENTRY *)a);
-	tb = GET_TARGET((STRUCT_ENTRY *)b);
-	if (ta->u.target_size != tb->u.target_size)
-		return 0;
-	if (strcmp(ta->u.user.name, tb->u.user.name) != 0)
-		return 0;
-	mptr += sizeof(*ta);
-
-	if (target_different(ta->data, tb->data,
-			     ta->u.target_size - sizeof(*ta), mptr))
-		return 0;
-
-	return 1;
+	return mptr;
 }
 
 /* All zeroes == unconditional rule. */
@@ -428,8 +415,8 @@
 		assert(t->verdict == -NF_DROP-1 || t->verdict == -NF_ACCEPT-1);
 
 		/* Hooks and underflows must be valid entries */
-		entry2index(h, get_entry(h, h->info.hook_entry[i]));
-		entry2index(h, get_entry(h, h->info.underflow[i]));
+		iptcb_entry2index(h, get_entry(h, h->info.hook_entry[i]));
+		iptcb_entry2index(h, get_entry(h, h->info.underflow[i]));
 	}
 
 	assert(h->info.size
diff -urN iptables-1.2.11/libiptc/libiptc.c iptables-1.3.0/libiptc/libiptc.c
--- iptables-1.2.11/libiptc/libiptc.c	2004-06-15 00:02:18.000000000 +0200
+++ iptables-1.3.0/libiptc/libiptc.c	2005-02-12 21:05:32.000000000 +0100
@@ -1,4 +1,4 @@
-/* Library which manipulates firewall rules.  Version $Revision: 1.47 $ */
+/* Library which manipulates firewall rules.  Version $Revision: 3652 $ */
 
 /* Architecture of firewall rules is as follows:
  *
@@ -10,7 +10,7 @@
 
 /* (C) 1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
  * COPYING for details). 
- * (C) 2000-2003 by the Netfilter Core Team <coreteam@netfilter.org>
+ * (C) 2000-2004 by the Netfilter Core Team <coreteam@netfilter.org>
  *
  * 2003-Jun-20: Harald Welte <laforge@netfilter.org>:
  *	- Reimplementation of chain cache to use offsets instead of entries
@@ -18,24 +18,34 @@
  * 	- performance optimization, sponsored by Astaro AG (http://www.astaro.com/)
  * 	  don't rebuild the chain cache after every operation, instead fix it
  * 	  up after a ruleset change.  
+ * 2004-Aug-18: Harald Welte <laforge@netfilter.org>:
+ * 	- futher performance work: total reimplementation of libiptc.
+ * 	- libiptc now has a real internal (linked-list) represntation of the
+ * 	  ruleset and a parser/compiler from/to this internal representation
+ * 	- again sponsored by Astaro AG (http://www.astaro.com/)
  */
-
 #include <sys/types.h>
 #include <sys/socket.h>
 
-#ifndef IPT_LIB_DIR
-#define IPT_LIB_DIR "/usr/local/lib/iptables"
+#include "linux_list.h"
+
+//#define IPTC_DEBUG2 1
+
+#ifdef IPTC_DEBUG2
+#include <fcntl.h>
+#define DEBUGP(x, args...)	fprintf(stderr, "%s: " x, __FUNCTION__, ## args)
+#define DEBUGP_C(x, args...)	fprintf(stderr, x, ## args)
+#else
+#define DEBUGP(x, args...)
+#define DEBUGP_C(x, args...)
 #endif
 
-#ifndef __OPTIMIZE__
-STRUCT_ENTRY_TARGET *
-GET_TARGET(STRUCT_ENTRY *e)
-{
-	return (void *)e + e->target_offset;
-}
+#ifndef IPT_LIB_DIR
+#define IPT_LIB_DIR "/usr/local/lib/iptables"
 #endif
 
 static int sockfd = -1;
+static int sockfd_use = 0;
 static void *iptc_fn = NULL;
 
 static const char *hooknames[]
@@ -49,6 +59,16 @@
 #endif
 };
 
+/* Convenience structures */
+struct ipt_error_target
+{
+	STRUCT_ENTRY_TARGET t;
+	char error[TABLE_MAXNAMELEN];
+};
+
+struct chain_head;
+struct rule_head;
+
 struct counter_map
 {
 	enum {
@@ -60,49 +80,92 @@
 	unsigned int mappos;
 };
 
-/* Convenience structures */
-struct ipt_error_target
+enum iptcc_rule_type {
+	IPTCC_R_STANDARD,		/* standard target (ACCEPT, ...) */
+	IPTCC_R_MODULE,			/* extension module (SNAT, ...) */
+	IPTCC_R_FALLTHROUGH,		/* fallthrough rule */
+	IPTCC_R_JUMP,			/* jump to other chain */
+};
+
+struct rule_head
 {
-	STRUCT_ENTRY_TARGET t;
-	char error[TABLE_MAXNAMELEN];
+	struct list_head list;
+	struct chain_head *chain;
+	struct counter_map counter_map;
+
+	unsigned int index;		/* index (needed for counter_map) */
+	unsigned int offset;		/* offset in rule blob */
+
+	enum iptcc_rule_type type;
+	struct chain_head *jump;	/* jump target, if IPTCC_R_JUMP */
+
+	unsigned int size;		/* size of entry data */
+	STRUCT_ENTRY entry[0];
 };
 
-struct chain_cache
+struct chain_head
 {
+	struct list_head list;
 	char name[TABLE_MAXNAMELEN];
-	/* This is the first rule in chain. */
-	unsigned int start_off;
-	/* Last rule in chain */
-	unsigned int end_off;
+	unsigned int hooknum;		/* hook number+1 if builtin */
+	unsigned int references;	/* how many jumps reference us */
+	int verdict;			/* verdict if builtin */
+
+	STRUCT_COUNTERS counters;	/* per-chain counters */
+	struct counter_map counter_map;
+
+	unsigned int num_rules;		/* number of rules in list */
+	struct list_head rules;		/* list of rules */
+
+	unsigned int index;		/* index (needed for jump resolval) */
+	unsigned int head_offset;	/* offset in rule blob */
+	unsigned int foot_index;	/* index (needed for counter_map) */
+	unsigned int foot_offset;	/* offset in rule blob */
 };
 
 STRUCT_TC_HANDLE
 {
-	/* Have changes been made? */
-	int changed;
-	/* Size in here reflects original state. */
-	STRUCT_GETINFO info;
+	int changed;			 /* Have changes been made? */
+
+	struct list_head chains;
+	
+	struct chain_head *chain_iterator_cur;
+	struct rule_head *rule_iterator_cur;
 
-	struct counter_map *counter_map;
-	/* Array of hook names */
-	const char **hooknames;
-
-	/* Cached position of chain heads (NULL = no cache). */
-	unsigned int cache_num_chains;
-	unsigned int cache_num_builtins;
-	struct chain_cache *cache_chain_heads;
-
-	/* Chain iterator: current chain cache entry. */
-	struct chain_cache *cache_chain_iteration;
-
-	/* Rule iterator: terminal rule */
-	STRUCT_ENTRY *cache_rule_end;
-
-	/* Number in here reflects current state. */
-	unsigned int new_number;
-	STRUCT_GET_ENTRIES entries;
+	STRUCT_GETINFO info;
+	STRUCT_GET_ENTRIES *entries;
 };
 
+/* allocate a new chain head for the cache */
+static struct chain_head *iptcc_alloc_chain_head(const char *name, int hooknum)
+{
+	struct chain_head *c = malloc(sizeof(*c));
+	if (!c)
+		return NULL;
+	memset(c, 0, sizeof(*c));
+
+	strncpy(c->name, name, TABLE_MAXNAMELEN);
+	c->hooknum = hooknum;
+	INIT_LIST_HEAD(&c->rules);
+
+	return c;
+}
+
+/* allocate and initialize a new rule for the cache */
+static struct rule_head *iptcc_alloc_rule(struct chain_head *c, unsigned int size)
+{
+	struct rule_head *r = malloc(sizeof(*r)+size);
+	if (!r)
+		return NULL;
+	memset(r, 0, sizeof(*r));
+
+	r->chain = c;
+	r->size = size;
+
+	return r;
+}
+
+/* notify us that the ruleset has been modified by the user */
 static void
 set_changed(TC_HANDLE_T h)
 {
@@ -116,8 +179,13 @@
 #define CHECK(h)
 #endif
 
+
+/**********************************************************************
+ * iptc blob utility functions (iptcb_*)
+ **********************************************************************/
+
 static inline int
-get_number(const STRUCT_ENTRY *i,
+iptcb_get_number(const STRUCT_ENTRY *i,
 	   const STRUCT_ENTRY *seek,
 	   unsigned int *pos)
 {
@@ -127,92 +195,567 @@
 	return 0;
 }
 
+static inline int
+iptcb_get_entry_n(STRUCT_ENTRY *i,
+	    unsigned int number,
+	    unsigned int *pos,
+	    STRUCT_ENTRY **pe)
+{
+	if (*pos == number) {
+		*pe = i;
+		return 1;
+	}
+	(*pos)++;
+	return 0;
+}
+
+static inline STRUCT_ENTRY *
+iptcb_get_entry(TC_HANDLE_T h, unsigned int offset)
+{
+	return (STRUCT_ENTRY *)((char *)h->entries->entrytable + offset);
+}
+
 static unsigned int
-entry2index(const TC_HANDLE_T h, const STRUCT_ENTRY *seek)
+iptcb_entry2index(const TC_HANDLE_T h, const STRUCT_ENTRY *seek)
 {
 	unsigned int pos = 0;
 
-	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-			  get_number, seek, &pos) == 0) {
+	if (ENTRY_ITERATE(h->entries->entrytable, h->entries->size,
+			  iptcb_get_number, seek, &pos) == 0) {
 		fprintf(stderr, "ERROR: offset %u not an entry!\n",
-			(unsigned int)((char *)seek - (char *)h->entries.entrytable));
+			(unsigned int)((char *)seek - (char *)h->entries->entrytable));
 		abort();
 	}
 	return pos;
 }
 
-static inline int
-get_entry_n(STRUCT_ENTRY *i,
-	    unsigned int number,
-	    unsigned int *pos,
-	    STRUCT_ENTRY **pe)
+static inline STRUCT_ENTRY *
+iptcb_offset2entry(TC_HANDLE_T h, unsigned int offset)
 {
-	if (*pos == number) {
-		*pe = i;
+	return (STRUCT_ENTRY *) ((void *)h->entries->entrytable+offset);
+}
+
+
+static inline unsigned long
+iptcb_entry2offset(const TC_HANDLE_T h, const STRUCT_ENTRY *e)
+{
+	return (void *)e - (void *)h->entries->entrytable;
+}
+
+static inline unsigned int
+iptcb_offset2index(const TC_HANDLE_T h, unsigned int offset)
+{
+	return iptcb_entry2index(h, iptcb_offset2entry(h, offset));
+}
+
+/* Returns 0 if not hook entry, else hooknumber + 1 */
+static inline unsigned int
+iptcb_ent_is_hook_entry(STRUCT_ENTRY *e, TC_HANDLE_T h)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUMHOOKS; i++) {
+		if ((h->info.valid_hooks & (1 << i))
+		    && iptcb_get_entry(h, h->info.hook_entry[i]) == e)
+			return i+1;
+	}
+	return 0;
+}
+
+
+/**********************************************************************
+ * iptc cache utility functions (iptcc_*)
+ **********************************************************************/
+
+/* Is the given chain builtin (1) or user-defined (0) */
+static unsigned int iptcc_is_builtin(struct chain_head *c)
+{
+	return (c->hooknum ? 1 : 0);
+}
+
+/* Get a specific rule within a chain */
+static struct rule_head *iptcc_get_rule_num(struct chain_head *c,
+					    unsigned int rulenum)
+{
+	struct rule_head *r;
+	unsigned int num = 0;
+
+	list_for_each_entry(r, &c->rules, list) {
+		num++;
+		if (num == rulenum)
+			return r;
+	}
+	return NULL;
+}
+
+/* Get a specific rule within a chain backwards */
+static struct rule_head *iptcc_get_rule_num_reverse(struct chain_head *c,
+					    unsigned int rulenum)
+{
+	struct rule_head *r;
+	unsigned int num = 0;
+
+	list_for_each_entry_reverse(r, &c->rules, list) {
+		num++;
+		if (num == rulenum)
+			return r;
+	}
+	return NULL;
+}
+
+/* Returns chain head if found, otherwise NULL. */
+static struct chain_head *
+iptcc_find_chain_by_offset(TC_HANDLE_T handle, unsigned int offset)
+{
+	struct list_head *pos;
+
+	if (list_empty(&handle->chains))
+		return NULL;
+
+	list_for_each(pos, &handle->chains) {
+		struct chain_head *c = list_entry(pos, struct chain_head, list);
+		if (offset >= c->head_offset && offset <= c->foot_offset)
+			return c;
+	}
+
+	return NULL;
+}
+/* Returns chain head if found, otherwise NULL. */
+static struct chain_head *
+iptcc_find_label(const char *name, TC_HANDLE_T handle)
+{
+	struct list_head *pos;
+
+	if (list_empty(&handle->chains))
+		return NULL;
+
+	list_for_each(pos, &handle->chains) {
+		struct chain_head *c = list_entry(pos, struct chain_head, list);
+		if (!strcmp(c->name, name))
+			return c;
+	}
+
+	return NULL;
+}
+
+/* called when rule is to be removed from cache */
+static void iptcc_delete_rule(struct rule_head *r)
+{
+	DEBUGP("deleting rule %p (offset %u)\n", r, r->offset);
+	/* clean up reference count of called chain */
+	if (r->type == IPTCC_R_JUMP
+	    && r->jump)
+		r->jump->references--;
+
+	list_del(&r->list);
+	free(r);
+}
+
+
+/**********************************************************************
+ * RULESET PARSER (blob -> cache)
+ **********************************************************************/
+
+/* Delete policy rule of previous chain, since cache doesn't contain
+ * chain policy rules.
+ * WARNING: This function has ugly design and relies on a lot of context, only
+ * to be called from specific places within the parser */
+static int __iptcc_p_del_policy(TC_HANDLE_T h, unsigned int num)
+{
+	if (h->chain_iterator_cur) {
+		/* policy rule is last rule */
+		struct rule_head *pr = (struct rule_head *)
+			h->chain_iterator_cur->rules.prev;
+
+		/* save verdict */
+		h->chain_iterator_cur->verdict = 
+			*(int *)GET_TARGET(pr->entry)->data;
+
+		/* save counter and counter_map information */
+		h->chain_iterator_cur->counter_map.maptype = 
+						COUNTER_MAP_NORMAL_MAP;
+		h->chain_iterator_cur->counter_map.mappos = num-1;
+		memcpy(&h->chain_iterator_cur->counters, &pr->entry->counters, 
+			sizeof(h->chain_iterator_cur->counters));
+
+		/* foot_offset points to verdict rule */
+		h->chain_iterator_cur->foot_index = num;
+		h->chain_iterator_cur->foot_offset = pr->offset;
+
+		/* delete rule from cache */
+		iptcc_delete_rule(pr);
+		h->chain_iterator_cur->num_rules--;
+
 		return 1;
 	}
-	(*pos)++;
 	return 0;
 }
 
-static STRUCT_ENTRY *
-index2entry(TC_HANDLE_T h, unsigned int index)
+/* alphabetically insert a chain into the list */
+static inline void iptc_insert_chain(TC_HANDLE_T h, struct chain_head *c)
 {
-	unsigned int pos = 0;
-	STRUCT_ENTRY *ret = NULL;
+	struct chain_head *tmp;
 
-	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-		      get_entry_n, index, &pos, &ret);
+	list_for_each_entry(tmp, &h->chains, list) {
+		if (strcmp(c->name, tmp->name) <= 0) {
+			list_add(&c->list, tmp->list.prev);
+			return;
+		}
+	}
 
-	return ret;
+	/* survived till end of list: add at tail */
+	list_add_tail(&c->list, &h->chains);
 }
 
-static inline STRUCT_ENTRY *
-get_entry(TC_HANDLE_T h, unsigned int offset)
+/* Another ugly helper function split out of cache_add_entry to make it less
+ * spaghetti code */
+static void __iptcc_p_add_chain(TC_HANDLE_T h, struct chain_head *c,
+				unsigned int offset, unsigned int *num)
 {
-	return (STRUCT_ENTRY *)((char *)h->entries.entrytable + offset);
+	__iptcc_p_del_policy(h, *num);
+
+	c->head_offset = offset;
+	c->index = *num;
+
+	iptc_insert_chain(h, c);
+	
+	h->chain_iterator_cur = c;
 }
 
-static inline unsigned long
-entry2offset(const TC_HANDLE_T h, const STRUCT_ENTRY *e)
+/* main parser function: add an entry from the blob to the cache */
+static int cache_add_entry(STRUCT_ENTRY *e, 
+			   TC_HANDLE_T h, 
+			   STRUCT_ENTRY **prev,
+			   unsigned int *num)
 {
-	return (void *)e - (void *)h->entries.entrytable;
+	unsigned int builtin;
+	unsigned int offset = (char *)e - (char *)h->entries->entrytable;
+
+	DEBUGP("entering...");
+
+	/* Last entry ("policy rule"). End it.*/
+	if (iptcb_entry2offset(h,e) + e->next_offset == h->entries->size) {
+		/* This is the ERROR node at the end of the chain */
+		DEBUGP_C("%u:%u: end of table:\n", *num, offset);
+
+		__iptcc_p_del_policy(h, *num);
+
+		h->chain_iterator_cur = NULL;
+		goto out_inc;
+	}
+
+	/* We know this is the start of a new chain if it's an ERROR
+	 * target, or a hook entry point */
+
+	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) == 0) {
+		struct chain_head *c = 
+			iptcc_alloc_chain_head((const char *)GET_TARGET(e)->data, 0);
+		DEBUGP_C("%u:%u:new userdefined chain %s: %p\n", *num, offset, 
+			(char *)c->name, c);
+		if (!c) {
+			errno = -ENOMEM;
+			return -1;
+		}
+
+		__iptcc_p_add_chain(h, c, offset, num);
+
+	} else if ((builtin = iptcb_ent_is_hook_entry(e, h)) != 0) {
+		struct chain_head *c =
+			iptcc_alloc_chain_head((char *)hooknames[builtin-1], 
+						builtin);
+		DEBUGP_C("%u:%u new builtin chain: %p (rules=%p)\n", 
+			*num, offset, c, &c->rules);
+		if (!c) {
+			errno = -ENOMEM;
+			return -1;
+		}
+
+		c->hooknum = builtin;
+
+		__iptcc_p_add_chain(h, c, offset, num);
+
+		/* FIXME: this is ugly. */
+		goto new_rule;
+	} else {
+		/* has to be normal rule */
+		struct rule_head *r;
+new_rule:
+
+		if (!(r = iptcc_alloc_rule(h->chain_iterator_cur, 
+					   e->next_offset))) {
+			errno = ENOMEM;
+			return -1;
+		}
+		DEBUGP_C("%u:%u normal rule: %p: ", *num, offset, r);
+
+		r->index = *num;
+		r->offset = offset;
+		memcpy(r->entry, e, e->next_offset);
+		r->counter_map.maptype = COUNTER_MAP_NORMAL_MAP;
+		r->counter_map.mappos = r->index;
+
+		/* handling of jumps, etc. */
+		if (!strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET)) {
+			STRUCT_STANDARD_TARGET *t;
+
+			t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+			if (t->target.u.target_size
+			    != ALIGN(sizeof(STRUCT_STANDARD_TARGET))) {
+				errno = EINVAL;
+				return -1;
+			}
+
+			if (t->verdict < 0) {
+				DEBUGP_C("standard, verdict=%d\n", t->verdict);
+				r->type = IPTCC_R_STANDARD;
+			} else if (t->verdict == r->offset+e->next_offset) {
+				DEBUGP_C("fallthrough\n");
+				r->type = IPTCC_R_FALLTHROUGH;
+			} else {
+				DEBUGP_C("jump, target=%u\n", t->verdict);
+				r->type = IPTCC_R_JUMP;
+				/* Jump target fixup has to be deferred
+				 * until second pass, since we migh not
+				 * yet have parsed the target */
+			}
+		} else {
+			DEBUGP_C("module, target=%s\n", GET_TARGET(e)->u.user.name);
+			r->type = IPTCC_R_MODULE;
+		}
+
+		list_add_tail(&r->list, &h->chain_iterator_cur->rules);
+		h->chain_iterator_cur->num_rules++;
+	}
+out_inc:
+	(*num)++;
+	return 0;
 }
 
-static inline unsigned long
-index2offset(TC_HANDLE_T h, unsigned int index)
+
+/* parse an iptables blob into it's pieces */
+static int parse_table(TC_HANDLE_T h)
 {
-	return entry2offset(h, index2entry(h, index));
+	STRUCT_ENTRY *prev;
+	unsigned int num = 0;
+	struct chain_head *c;
+
+	/* First pass: over ruleset blob */
+	ENTRY_ITERATE(h->entries->entrytable, h->entries->size,
+			cache_add_entry, h, &prev, &num);
+
+	/* Second pass: fixup parsed data from first pass */
+	list_for_each_entry(c, &h->chains, list) {
+		struct rule_head *r;
+		list_for_each_entry(r, &c->rules, list) {
+			struct chain_head *c;
+			STRUCT_STANDARD_TARGET *t;
+
+			if (r->type != IPTCC_R_JUMP)
+				continue;
+
+			t = (STRUCT_STANDARD_TARGET *)GET_TARGET(r->entry);
+			c = iptcc_find_chain_by_offset(h, t->verdict);
+			if (!c)
+				return -1;
+			r->jump = c;
+			c->references++;
+		}
+	}
+
+	/* FIXME: sort chains */
+
+	return 1;
 }
 
-static inline STRUCT_ENTRY *
-offset2entry(TC_HANDLE_T h, unsigned int offset)
+
+/**********************************************************************
+ * RULESET COMPILATION (cache -> blob)
+ **********************************************************************/
+
+/* Convenience structures */
+struct iptcb_chain_start{
+	STRUCT_ENTRY e;
+	struct ipt_error_target name;
+};
+#define IPTCB_CHAIN_START_SIZE	(sizeof(STRUCT_ENTRY) +			\
+				 ALIGN(sizeof(struct ipt_error_target)))
+
+struct iptcb_chain_foot {
+	STRUCT_ENTRY e;
+	STRUCT_STANDARD_TARGET target;
+};
+#define IPTCB_CHAIN_FOOT_SIZE	(sizeof(STRUCT_ENTRY) +			\
+				 ALIGN(sizeof(STRUCT_STANDARD_TARGET)))
+
+struct iptcb_chain_error {
+	STRUCT_ENTRY entry;
+	struct ipt_error_target target;
+};
+#define IPTCB_CHAIN_ERROR_SIZE	(sizeof(STRUCT_ENTRY) +			\
+				 ALIGN(sizeof(struct ipt_error_target)))
+
+
+
+/* compile rule from cache into blob */
+static inline int iptcc_compile_rule (TC_HANDLE_T h, STRUCT_REPLACE *repl, struct rule_head *r)
 {
-	return (STRUCT_ENTRY *) ((void *)h->entries.entrytable+offset);
+	/* handle jumps */
+	if (r->type == IPTCC_R_JUMP) {
+		STRUCT_STANDARD_TARGET *t;
+		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(r->entry);
+		/* memset for memcmp convenience on delete/replace */
+		memset(t->target.u.user.name, 0, FUNCTION_MAXNAMELEN);
+		strcpy(t->target.u.user.name, STANDARD_TARGET);
+		/* Jumps can only happen to builtin chains, so we
+		 * can safely assume that they always have a header */
+		t->verdict = r->jump->head_offset + IPTCB_CHAIN_START_SIZE;
+	} else if (r->type == IPTCC_R_FALLTHROUGH) {
+		STRUCT_STANDARD_TARGET *t;
+		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(r->entry);
+		t->verdict = r->offset + r->size;
+	}
+	
+	/* copy entry from cache to blob */
+	memcpy((char *)repl->entries+r->offset, r->entry, r->size);
+
+	return 1;
 }
 
-static inline unsigned int
-offset2index(const TC_HANDLE_T h, unsigned int offset)
+/* compile chain from cache into blob */
+static int iptcc_compile_chain(TC_HANDLE_T h, STRUCT_REPLACE *repl, struct chain_head *c)
 {
-	return entry2index(h, offset2entry(h, offset));
+	int ret;
+	struct rule_head *r;
+	struct iptcb_chain_start *head;
+	struct iptcb_chain_foot *foot;
+
+	/* only user-defined chains have heaer */
+	if (!iptcc_is_builtin(c)) {
+		/* put chain header in place */
+		head = (void *)repl->entries + c->head_offset;
+		head->e.target_offset = sizeof(STRUCT_ENTRY);
+		head->e.next_offset = IPTCB_CHAIN_START_SIZE;
+		strcpy(head->name.t.u.user.name, ERROR_TARGET);
+		head->name.t.u.target_size = 
+				ALIGN(sizeof(struct ipt_error_target));
+		strcpy(head->name.error, c->name);
+	} else {
+		repl->hook_entry[c->hooknum-1] = c->head_offset;	
+		repl->underflow[c->hooknum-1] = c->foot_offset;
+	}
+
+	/* iterate over rules */
+	list_for_each_entry(r, &c->rules, list) {
+		ret = iptcc_compile_rule(h, repl, r);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* put chain footer in place */
+	foot = (void *)repl->entries + c->foot_offset;
+	foot->e.target_offset = sizeof(STRUCT_ENTRY);
+	foot->e.next_offset = IPTCB_CHAIN_FOOT_SIZE;
+	strcpy(foot->target.target.u.user.name, STANDARD_TARGET);
+	foot->target.target.u.target_size =
+				ALIGN(sizeof(STRUCT_STANDARD_TARGET));
+	/* builtin targets have verdict, others return */
+	if (iptcc_is_builtin(c))
+		foot->target.verdict = c->verdict;
+	else
+		foot->target.verdict = RETURN;
+	/* set policy-counters */
+	memcpy(&foot->e.counters, &c->counters, sizeof(STRUCT_COUNTERS));
+
+	return 0;
 }
 
+/* calculate offset and number for every rule in the cache */
+static int iptcc_compile_chain_offsets(TC_HANDLE_T h, struct chain_head *c,
+				       int *offset, int *num)
+{
+	struct rule_head *r;
+
+	c->head_offset = *offset;
+	DEBUGP("%s: chain_head %u, offset=%u\n", c->name, *num, *offset);
+
+	if (!iptcc_is_builtin(c))  {
+		/* Chain has header */
+		*offset += sizeof(STRUCT_ENTRY) 
+			     + ALIGN(sizeof(struct ipt_error_target));
+		(*num)++;
+	}
+
+	list_for_each_entry(r, &c->rules, list) {
+		DEBUGP("rule %u, offset=%u, index=%u\n", *num, *offset, *num);
+		r->offset = *offset;
+		r->index = *num;
+		*offset += r->size;
+		(*num)++;
+	}
+
+	DEBUGP("%s; chain_foot %u, offset=%u, index=%u\n", c->name, *num, 
+		*offset, *num);
+	c->foot_offset = *offset;
+	c->foot_index = *num;
+	*offset += sizeof(STRUCT_ENTRY)
+		   + ALIGN(sizeof(STRUCT_STANDARD_TARGET));
+	(*num)++;
 
-static const char *
-get_errorlabel(TC_HANDLE_T h, unsigned int offset)
+	return 1;
+}
+
+/* put the pieces back together again */
+static int iptcc_compile_table_prep(TC_HANDLE_T h, unsigned int *size)
 {
-	STRUCT_ENTRY *e;
+	struct chain_head *c;
+	unsigned int offset = 0, num = 0;
+	int ret = 0;
+
+	/* First pass: calculate offset for every rule */
+	list_for_each_entry(c, &h->chains, list) {
+		ret = iptcc_compile_chain_offsets(h, c, &offset, &num);
+		if (ret < 0)
+			return ret;
+	}
 
-	e = get_entry(h, offset);
-	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) != 0) {
-		fprintf(stderr, "ERROR: offset %u not an error node!\n",
-			offset);
-		abort();
+	/* Append one error rule at end of chain */
+	num++;
+	offset += sizeof(STRUCT_ENTRY)
+		  + ALIGN(sizeof(struct ipt_error_target));
+
+	/* ruleset size is now in offset */
+	*size = offset;
+	return num;
+}
+
+static int iptcc_compile_table(TC_HANDLE_T h, STRUCT_REPLACE *repl)
+{
+	struct chain_head *c;
+	struct iptcb_chain_error *error;
+
+	/* Second pass: copy from cache to offsets, fill in jumps */
+	list_for_each_entry(c, &h->chains, list) {
+		int ret = iptcc_compile_chain(h, repl, c);
+		if (ret < 0)
+			return ret;
 	}
 
-	return (const char *)GET_TARGET(e)->data;
+	/* Append error rule at end of chain */
+	error = (void *)repl->entries + repl->size - IPTCB_CHAIN_ERROR_SIZE;
+	error->entry.target_offset = sizeof(STRUCT_ENTRY);
+	error->entry.next_offset = IPTCB_CHAIN_ERROR_SIZE;
+	error->target.t.u.user.target_size = 
+		ALIGN(sizeof(struct ipt_error_target));
+	strcpy((char *)&error->target.t.u.user.name, ERROR_TARGET);
+	strcpy((char *)&error->target.error, "ERROR");
+
+	return 1;
 }
 
+/**********************************************************************
+ * EXTERNAL API (operates on cache only)
+ **********************************************************************/
+
 /* Allocate handle of given size */
 static TC_HANDLE_T
 alloc_handle(const char *tablename, unsigned int size, unsigned int num_rules)
@@ -220,113 +763,138 @@
 	size_t len;
 	TC_HANDLE_T h;
 
-	len = sizeof(STRUCT_TC_HANDLE)
-		+ size
-		+ num_rules * sizeof(struct counter_map);
+	len = sizeof(STRUCT_TC_HANDLE) + size;
 
-	if ((h = malloc(len)) == NULL) {
+	h = malloc(sizeof(STRUCT_TC_HANDLE));
+	if (!h) {
 		errno = ENOMEM;
 		return NULL;
 	}
-
-	h->changed = 0;
-	h->cache_num_chains = 0;
-	h->cache_chain_heads = NULL;
-	h->counter_map = (void *)h
-		+ sizeof(STRUCT_TC_HANDLE)
-		+ size;
+	memset(h, 0, sizeof(*h));
+	INIT_LIST_HEAD(&h->chains);
 	strcpy(h->info.name, tablename);
-	strcpy(h->entries.name, tablename);
+
+	h->entries = malloc(sizeof(STRUCT_GET_ENTRIES) + size);
+	if (!h->entries)
+		goto out_free_handle;
+
+	strcpy(h->entries->name, tablename);
+	h->entries->size = size;
 
 	return h;
+
+out_free_handle:
+	free(h);
+
+	return NULL;
 }
 
+
 TC_HANDLE_T
 TC_INIT(const char *tablename)
 {
 	TC_HANDLE_T h;
 	STRUCT_GETINFO info;
-	unsigned int i;
 	int tmp;
 	socklen_t s;
 
 	iptc_fn = TC_INIT;
 
-	if (sockfd != -1) {
-		close(sockfd);
-		sockfd = -1;
-	}
-
 	if (strlen(tablename) >= TABLE_MAXNAMELEN) {
 		errno = EINVAL;
 		return NULL;
 	}
 	
-	sockfd = socket(TC_AF, SOCK_RAW, IPPROTO_RAW);
-	if (sockfd < 0)
-		return NULL;
+	if (sockfd_use == 0) {
+		sockfd = socket(TC_AF, SOCK_RAW, IPPROTO_RAW);
+		if (sockfd < 0)
+			return NULL;
+	}
+	sockfd_use++;
 
 	s = sizeof(info);
 
 	strcpy(info.name, tablename);
-	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_INFO, &info, &s) < 0)
+	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_INFO, &info, &s) < 0) {
+		if (--sockfd_use == 0) {
+			close(sockfd);
+			sockfd = -1;
+		}
 		return NULL;
+	}
+
+	DEBUGP("valid_hooks=0x%08x, num_entries=%u, size=%u\n",
+		info.valid_hooks, info.num_entries, info.size);
 
 	if ((h = alloc_handle(info.name, info.size, info.num_entries))
 	    == NULL) {
-		close(sockfd);
-		sockfd = -1;
-		return NULL;
-	}
-
-/* Too hard --RR */
-#if 0
-	sprintf(pathname, "%s/%s", IPT_LIB_DIR, info.name);
-	dynlib = dlopen(pathname, RTLD_NOW);
-	if (!dynlib) {
-		errno = ENOENT;
-		return NULL;
-	}
-	h->hooknames = dlsym(dynlib, "hooknames");
-	if (!h->hooknames) {
-		errno = ENOENT;
+		if (--sockfd_use == 0) {
+			close(sockfd);
+			sockfd = -1;
+		}
 		return NULL;
 	}
-#else
-	h->hooknames = hooknames;
-#endif
 
 	/* Initialize current state */
 	h->info = info;
-	h->new_number = h->info.num_entries;
-	for (i = 0; i < h->info.num_entries; i++)
-		h->counter_map[i]
-			= ((struct counter_map){COUNTER_MAP_NORMAL_MAP, i});
 
-	h->entries.size = h->info.size;
+	h->entries->size = h->info.size;
 
 	tmp = sizeof(STRUCT_GET_ENTRIES) + h->info.size;
 
-	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_ENTRIES, &h->entries,
-		       &tmp) < 0) {
-		close(sockfd);
-		sockfd = -1;
-		free(h);
-		return NULL;
+	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_ENTRIES, h->entries,
+		       &tmp) < 0)
+		goto error;
+
+#ifdef IPTC_DEBUG2
+	{
+		int fd = open("/tmp/libiptc-so_get_entries.blob", 
+				O_CREAT|O_WRONLY);
+		if (fd >= 0) {
+			write(fd, h->entries, tmp);
+			close(fd);
+		}
 	}
+#endif
+
+	if (parse_table(h) < 0)
+		goto error;
 
 	CHECK(h);
 	return h;
+error:
+	if (--sockfd_use == 0) {
+		close(sockfd);
+		sockfd = -1;
+	}
+	TC_FREE(&h);
+	return NULL;
 }
 
 void
 TC_FREE(TC_HANDLE_T *h)
 {
-	close(sockfd);
-	sockfd = -1;
-	if ((*h)->cache_chain_heads)
-		free((*h)->cache_chain_heads);
+	struct chain_head *c, *tmp;
+
+	iptc_fn = TC_FREE;
+	if (--sockfd_use == 0) {
+		close(sockfd);
+		sockfd = -1;
+	}
+
+	list_for_each_entry_safe(c, tmp, &(*h)->chains, list) {
+		struct rule_head *r, *rtmp;
+
+		list_for_each_entry_safe(r, rtmp, &c->rules, list) {
+			free(r);
+		}
+
+		free(c);
+	}
+
+	free((*h)->entries);
 	free(*h);
+
 	*h = NULL;
 }
 
@@ -342,11 +910,11 @@
 void
 TC_DUMP_ENTRIES(const TC_HANDLE_T handle)
 {
+	iptc_fn = TC_DUMP_ENTRIES;
 	CHECK(handle);
-
-	printf("libiptc v%s.  %u entries, %u bytes.\n",
-	       IPTABLES_VERSION,
-	       handle->new_number, handle->entries.size);
+#if 0
+	printf("libiptc v%s. %u bytes.\n",
+	       IPTABLES_VERSION, handle->entries->size);
 	printf("Table `%s'\n", handle->info.name);
 	printf("Hooks: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
 	       handle->info.hook_entry[HOOK_PRE_ROUTING],
@@ -361,605 +929,277 @@
 	       handle->info.underflow[HOOK_LOCAL_OUT],
 	       handle->info.underflow[HOOK_POST_ROUTING]);
 
-	ENTRY_ITERATE(handle->entries.entrytable, handle->entries.size,
+	ENTRY_ITERATE(handle->entries->entrytable, handle->entries->size,
 		      dump_entry, handle);
-}
-
-/* Returns 0 if not hook entry, else hooknumber + 1 */
-static inline unsigned int
-is_hook_entry(STRUCT_ENTRY *e, TC_HANDLE_T h)
-{
-	unsigned int i;
-
-	for (i = 0; i < NUMHOOKS; i++) {
-		if ((h->info.valid_hooks & (1 << i))
-		    && get_entry(h, h->info.hook_entry[i]) == e)
-			return i+1;
-	}
-	return 0;
-}
-
-static inline int
-add_chain(STRUCT_ENTRY *e, TC_HANDLE_T h, STRUCT_ENTRY **prev)
-{
-	unsigned int builtin;
-
-	/* Last entry.  End it. */
-	if (entry2offset(h, e) + e->next_offset == h->entries.size) {
-		/* This is the ERROR node at end of the table */
-		h->cache_chain_heads[h->cache_num_chains-1].end_off = 
-			entry2offset(h, *prev);
-		return 0;
-	}
-
-	/* We know this is the start of a new chain if it's an ERROR
-	   target, or a hook entry point */
-	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) == 0) {
-		/* prev was last entry in previous chain */
-		h->cache_chain_heads[h->cache_num_chains-1].end_off
-			= entry2offset(h, *prev);
-
-		strcpy(h->cache_chain_heads[h->cache_num_chains].name,
-		       (const char *)GET_TARGET(e)->data);
-		h->cache_chain_heads[h->cache_num_chains].start_off
-			= entry2offset(h, (void *)e + e->next_offset);
-		h->cache_num_chains++;
-	} else if ((builtin = is_hook_entry(e, h)) != 0) {
-		if (h->cache_num_chains > 0)
-			/* prev was last entry in previous chain */
-			h->cache_chain_heads[h->cache_num_chains-1].end_off
-				= entry2offset(h, *prev);
-
-		strcpy(h->cache_chain_heads[h->cache_num_chains].name,
-		       h->hooknames[builtin-1]);
-		h->cache_chain_heads[h->cache_num_chains].start_off
-			= entry2offset(h, (void *)e);
-		h->cache_num_chains++;
-	}
-
-	*prev = e;
-	return 0;
-}
-
-static int alphasort(const void *a, const void *b)
-{
-	return strcmp(((struct chain_cache *)a)->name,
-		      ((struct chain_cache *)b)->name);
-}
-
-static int populate_cache(TC_HANDLE_T h)
-{
-	unsigned int i;
-	STRUCT_ENTRY *prev;
-
-	/* # chains < # rules / 2 + num builtins - 1 */
-	h->cache_chain_heads = malloc((h->new_number / 2 + 4)
-				      * sizeof(struct chain_cache));
-	if (!h->cache_chain_heads) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	h->cache_num_chains = 0;
-	h->cache_num_builtins = 0;
-
-	/* Count builtins */
-	for (i = 0; i < NUMHOOKS; i++) {
-		if (h->info.valid_hooks & (1 << i))
-			h->cache_num_builtins++;
-	}
-
-	prev = NULL;
-	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-		      add_chain, h, &prev);
-
-	qsort(h->cache_chain_heads + h->cache_num_builtins,
-	      h->cache_num_chains - h->cache_num_builtins,
-	      sizeof(struct chain_cache), alphasort);
-
-	return 1;
-}
-
-static int 
-correct_cache(TC_HANDLE_T h, unsigned int offset, int delta)
-{
-	int i;		/* needs to be signed because deleting first
-			   chain can make it drop to -1 */
-
-	if (!delta)
-		return 1;
-
-	for (i = 0; i < h->cache_num_chains; i++) {
-		struct chain_cache *cc = &h->cache_chain_heads[i];
-
-		if (delta < 0) {
-			/* take care about deleted chains */
-			if (cc->start_off > offset+delta
-			    && cc->end_off < offset) {
-				/* this chain is within the deleted range,
-				 * let's remove it from the cache */
-				void *start;
-				unsigned int size;
-
-				h->cache_num_chains--;
-
-				/* no need for memmove since we are 
-				 * removing the last entry */
-				if (i >= h->cache_num_chains)
-					continue;
-
-				start = &h->cache_chain_heads[i+1];
-				size = (h->cache_num_chains-i)
-					* sizeof(struct chain_cache);
-				memmove(cc, start, size);
-
-				/* iterate over same index again, since
-				 * it is now a different chain */
-				i--;
-				continue;
-			}
-		}
-
-		if (cc->start_off > offset)
-			cc->start_off += delta;
-
-		if (cc->end_off >= offset)
-			cc->end_off += delta;
-	}
-	/* HW_FIXME: sorting might be needed, but just in case a new chain was
-	 * added */
-
-	return 1;
-}
-
-static int
-add_chain_cache(TC_HANDLE_T h, const char *name, unsigned int start_off,
-		unsigned int end_off)
-{
-	struct chain_cache *ccs = realloc(h->cache_chain_heads, 
-					  (h->new_number / 2 + 4 + 1)
-					   * sizeof(struct chain_cache));
-	struct chain_cache *newcc;
-	
-	if (!ccs)
-		return 0;
-
-	h->cache_chain_heads = ccs;
-	newcc = &h->cache_chain_heads[h->cache_num_chains];
-	h->cache_num_chains++;
-
-	strncpy(newcc->name, name, TABLE_MAXNAMELEN-1);
-	newcc->name[TABLE_MAXNAMELEN-1] = '\0';
-	newcc->start_off = start_off;
-	newcc->end_off = end_off;
-
-	return 1;
-}
-
-/* Returns cache ptr if found, otherwise NULL. */
-static struct chain_cache *
-find_label(const char *name, TC_HANDLE_T handle)
-{
-	unsigned int i;
-
-	if (handle->cache_chain_heads == NULL
-	    && !populate_cache(handle))
-		return NULL;
-
-	/* FIXME: Linear search through builtins, then binary --RR */
-	for (i = 0; i < handle->cache_num_chains; i++) {
-		if (strcmp(handle->cache_chain_heads[i].name, name) == 0)
-			return &handle->cache_chain_heads[i];
-	}
-
-	return NULL;
+#endif
 }
 
 /* Does this chain exist? */
 int TC_IS_CHAIN(const char *chain, const TC_HANDLE_T handle)
 {
-	return find_label(chain, handle) != NULL;
+	iptc_fn = TC_IS_CHAIN;
+	return iptcc_find_label(chain, handle) != NULL;
 }
 
-/* Returns the position of the final (ie. unconditional) element. */
-static unsigned int
-get_chain_end(const TC_HANDLE_T handle, unsigned int start)
+static void iptcc_chain_iterator_advance(TC_HANDLE_T handle)
 {
-	unsigned int last_off, off;
-	STRUCT_ENTRY *e;
+	struct chain_head *c = handle->chain_iterator_cur;
 
-	last_off = start;
-	e = get_entry(handle, start);
-
-	/* Terminate when we meet a error label or a hook entry. */
-	for (off = start + e->next_offset;
-	     off < handle->entries.size;
-	     last_off = off, off += e->next_offset) {
-		STRUCT_ENTRY_TARGET *t;
-		unsigned int i;
-
-		e = get_entry(handle, off);
-
-		/* We hit an entry point. */
-		for (i = 0; i < NUMHOOKS; i++) {
-			if ((handle->info.valid_hooks & (1 << i))
-			    && off == handle->info.hook_entry[i])
-				return last_off;
-		}
-
-		/* We hit a user chain label */
-		t = GET_TARGET(e);
-		if (strcmp(t->u.user.name, ERROR_TARGET) == 0)
-			return last_off;
-	}
-	/* SHOULD NEVER HAPPEN */
-	fprintf(stderr, "ERROR: Off end (%u) of chain from %u!\n",
-		handle->entries.size, off);
-	abort();
+	if (c->list.next == &handle->chains)
+		handle->chain_iterator_cur = NULL;
+	else
+		handle->chain_iterator_cur = 
+			list_entry(c->list.next, struct chain_head, list);
 }
 
 /* Iterator functions to run through the chains. */
 const char *
 TC_FIRST_CHAIN(TC_HANDLE_T *handle)
 {
-	if ((*handle)->cache_chain_heads == NULL
-	    && !populate_cache(*handle))
+	struct chain_head *c = list_entry((*handle)->chains.next,
+					  struct chain_head, list);
+
+	iptc_fn = TC_FIRST_CHAIN;
+
+
+	if (list_empty(&(*handle)->chains)) {
+		DEBUGP(": no chains\n");
 		return NULL;
+	}
 
-	(*handle)->cache_chain_iteration
-		= &(*handle)->cache_chain_heads[0];
+	(*handle)->chain_iterator_cur = c;
+	iptcc_chain_iterator_advance(*handle);
 
-	return (*handle)->cache_chain_iteration->name;
+	DEBUGP(": returning `%s'\n", c->name);
+	return c->name;
 }
 
 /* Iterator functions to run through the chains.  Returns NULL at end. */
 const char *
 TC_NEXT_CHAIN(TC_HANDLE_T *handle)
 {
-	(*handle)->cache_chain_iteration++;
+	struct chain_head *c = (*handle)->chain_iterator_cur;
+
+	iptc_fn = TC_NEXT_CHAIN;
 
-	if ((*handle)->cache_chain_iteration - (*handle)->cache_chain_heads
-	    == (*handle)->cache_num_chains)
+	if (!c) {
+		DEBUGP(": no more chains\n");
 		return NULL;
+	}
 
-	return (*handle)->cache_chain_iteration->name;
+	iptcc_chain_iterator_advance(*handle);
+	
+	DEBUGP(": returning `%s'\n", c->name);
+	return c->name;
 }
 
 /* Get first rule in the given chain: NULL for empty chain. */
 const STRUCT_ENTRY *
 TC_FIRST_RULE(const char *chain, TC_HANDLE_T *handle)
 {
-	struct chain_cache *c;
+	struct chain_head *c;
+	struct rule_head *r;
+
+	iptc_fn = TC_FIRST_RULE;
+
+	DEBUGP("first rule(%s): ", chain);
 
-	c = find_label(chain, *handle);
+	c = iptcc_find_label(chain, *handle);
 	if (!c) {
 		errno = ENOENT;
 		return NULL;
 	}
 
 	/* Empty chain: single return/policy rule */
-	if (c->start_off == c->end_off)
+	if (list_empty(&c->rules)) {
+		DEBUGP_C("no rules, returning NULL\n");
 		return NULL;
+	}
+
+	r = list_entry(c->rules.next, struct rule_head, list);
+	(*handle)->rule_iterator_cur = r;
+	DEBUGP_C("%p\n", r);
 
-	(*handle)->cache_rule_end = offset2entry(*handle, c->end_off);
-	return offset2entry(*handle, c->start_off);
+	return r->entry;
 }
 
 /* Returns NULL when rules run out. */
 const STRUCT_ENTRY *
 TC_NEXT_RULE(const STRUCT_ENTRY *prev, TC_HANDLE_T *handle)
 {
-	if ((void *)prev + prev->next_offset
-	    == (void *)(*handle)->cache_rule_end)
+	struct rule_head *r;
+
+	iptc_fn = TC_NEXT_RULE;
+	DEBUGP("rule_iterator_cur=%p...", (*handle)->rule_iterator_cur);
+
+	if (!(*handle)->rule_iterator_cur) {
+		DEBUGP_C("returning NULL\n");
+		return NULL;
+	}
+	
+	r = list_entry((*handle)->rule_iterator_cur->list.next, 
+			struct rule_head, list);
+
+	iptc_fn = TC_NEXT_RULE;
+
+	DEBUGP_C("next=%p, head=%p...", &r->list, 
+		&(*handle)->rule_iterator_cur->chain->rules);
+
+	if (&r->list == &(*handle)->rule_iterator_cur->chain->rules) {
+		(*handle)->rule_iterator_cur = NULL;
+		DEBUGP_C("finished, returning NULL\n");
 		return NULL;
+	}
 
-	return (void *)prev + prev->next_offset;
+	(*handle)->rule_iterator_cur = r;
+
+	/* NOTE: prev is without any influence ! */
+	DEBUGP_C("returning rule %p\n", r);
+	return r->entry;
 }
 
-#if 0
 /* How many rules in this chain? */
 unsigned int
 TC_NUM_RULES(const char *chain, TC_HANDLE_T *handle)
 {
-	unsigned int off = 0;
-	STRUCT_ENTRY *start, *end;
-
+	struct chain_head *c;
+	iptc_fn = TC_NUM_RULES;
 	CHECK(*handle);
-	if (!find_label(&off, chain, *handle)) {
+
+	c = iptcc_find_label(chain, *handle);
+	if (!c) {
 		errno = ENOENT;
 		return (unsigned int)-1;
 	}
-
-	start = get_entry(*handle, off);
-	end = get_entry(*handle, get_chain_end(*handle, off));
-
-	return entry2index(*handle, end) - entry2index(*handle, start);
+	
+	return c->num_rules;
 }
 
-/* Get n'th rule in this chain. */
 const STRUCT_ENTRY *TC_GET_RULE(const char *chain,
 				unsigned int n,
 				TC_HANDLE_T *handle)
 {
-	unsigned int pos = 0, chainindex;
+	struct chain_head *c;
+	struct rule_head *r;
+	
+	iptc_fn = TC_GET_RULE;
 
 	CHECK(*handle);
-	if (!find_label(&pos, chain, *handle)) {
+
+	c = iptcc_find_label(chain, *handle);
+	if (!c) {
 		errno = ENOENT;
 		return NULL;
 	}
 
-	chainindex = entry2index(*handle, get_entry(*handle, pos));
-
-	return index2entry(*handle, chainindex + n);
+	r = iptcc_get_rule_num(c, n);
+	if (!r)
+		return NULL;
+	return r->entry;
 }
-#endif
 
-static const char *
-target_name(TC_HANDLE_T handle, const STRUCT_ENTRY *ce)
+/* Returns a pointer to the target name of this position. */
+const char *standard_target_map(int verdict)
 {
-	int spos;
-	unsigned int labelidx;
-	STRUCT_ENTRY *jumpto;
-
-	/* To avoid const warnings */
-	STRUCT_ENTRY *e = (STRUCT_ENTRY *)ce;
-
-	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) != 0)
-		return GET_TARGET(e)->u.user.name;
-
-	/* Standard target: evaluate */
-	spos = *(int *)GET_TARGET(e)->data;
-	if (spos < 0) {
-		if (spos == RETURN)
+	switch (verdict) {
+		case RETURN:
 			return LABEL_RETURN;
-		else if (spos == -NF_ACCEPT-1)
+			break;
+		case -NF_ACCEPT-1:
 			return LABEL_ACCEPT;
-		else if (spos == -NF_DROP-1)
+			break;
+		case -NF_DROP-1:
 			return LABEL_DROP;
-		else if (spos == -NF_QUEUE-1)
+			break;
+		case -NF_QUEUE-1:
 			return LABEL_QUEUE;
-
-		fprintf(stderr, "ERROR: off %lu/%u not a valid target (%i)\n",
-			entry2offset(handle, e), handle->entries.size,
-			spos);
-		abort();
+			break;
+		default:
+			fprintf(stderr, "ERROR: %d not a valid target)\n",
+				verdict);
+			abort();
+			break;
 	}
-
-	jumpto = get_entry(handle, spos);
-
-	/* Fall through rule */
-	if (jumpto == (void *)e + e->next_offset)
-		return "";
-
-	/* Must point to head of a chain: ie. after error rule */
-	labelidx = entry2index(handle, jumpto) - 1;
-	return get_errorlabel(handle, index2offset(handle, labelidx));
+	/* not reached */
+	return NULL;
 }
 
 /* Returns a pointer to the target name of this position. */
-const char *TC_GET_TARGET(const STRUCT_ENTRY *e,
-			  TC_HANDLE_T *handle)
-{
-	return target_name(*handle, e);
-}
-
-/* Is this a built-in chain?  Actually returns hook + 1. */
-int
-TC_BUILTIN(const char *chain, const TC_HANDLE_T handle)
-{
-	unsigned int i;
-
-	for (i = 0; i < NUMHOOKS; i++) {
-		if ((handle->info.valid_hooks & (1 << i))
-		    && handle->hooknames[i]
-		    && strcmp(handle->hooknames[i], chain) == 0)
-			return i+1;
-	}
-	return 0;
-}
-
-/* Get the policy of a given built-in chain */
-const char *
-TC_GET_POLICY(const char *chain,
-	      STRUCT_COUNTERS *counters,
-	      TC_HANDLE_T *handle)
-{
-	unsigned int start;
-	STRUCT_ENTRY *e;
-	int hook;
-
-	hook = TC_BUILTIN(chain, *handle);
-	if (hook != 0)
-		start = (*handle)->info.hook_entry[hook-1];
-	else
-		return NULL;
-
-	e = get_entry(*handle, get_chain_end(*handle, start));
-	*counters = e->counters;
-
-	return target_name(*handle, e);
-}
-
-static inline int
-correct_verdict(STRUCT_ENTRY *e,
-		char *base,
-		unsigned int offset, int delta_offset)
-{
-	STRUCT_STANDARD_TARGET *t = (void *)GET_TARGET(e);
-	unsigned int curr = (char *)e - base;
-
-	/* Trap: insert of fall-through rule.  Don't change fall-through
-	   verdict to jump-over-next-rule. */
-	if (strcmp(t->target.u.user.name, STANDARD_TARGET) == 0
-	    && t->verdict > (int)offset
-	    && !(curr == offset &&
-		 t->verdict == curr + e->next_offset)) {
-		t->verdict += delta_offset;
-	}
-
-	return 0;
-}
-
-/* Adjusts standard verdict jump positions after an insertion/deletion. */
-static int
-set_verdict(unsigned int offset, int delta_offset, TC_HANDLE_T *handle)
-{
-	ENTRY_ITERATE((*handle)->entries.entrytable,
-		      (*handle)->entries.size,
-		      correct_verdict, (char *)(*handle)->entries.entrytable,
-		      offset, delta_offset);
-
-	set_changed(*handle);
-	return 1;
-}
-
-/* If prepend is set, then we are prepending to a chain: if the
- * insertion position is an entry point, keep the entry point. */
-static int
-insert_rules(unsigned int num_rules, unsigned int rules_size,
-	     const STRUCT_ENTRY *insert,
-	     unsigned int offset, unsigned int num_rules_offset,
-	     int prepend,
-	     TC_HANDLE_T *handle)
+const char *TC_GET_TARGET(const STRUCT_ENTRY *ce,
+			  TC_HANDLE_T *handle)
 {
-	TC_HANDLE_T newh;
-	STRUCT_GETINFO newinfo;
-	unsigned int i;
+	STRUCT_ENTRY *e = (STRUCT_ENTRY *)ce;
+	struct rule_head *r = container_of(e, struct rule_head, entry[0]);
 
-	if (offset >= (*handle)->entries.size) {
-		errno = EINVAL;
-		return 0;
-	}
+	iptc_fn = TC_GET_TARGET;
 
-	newinfo = (*handle)->info;
+	switch(r->type) {
+		int spos;
+		case IPTCC_R_FALLTHROUGH:
+			return "";
+			break;
+		case IPTCC_R_JUMP:
+			DEBUGP("r=%p, jump=%p, name=`%s'\n", r, r->jump, r->jump->name);
+			return r->jump->name;
+			break;
+		case IPTCC_R_STANDARD:
+			spos = *(int *)GET_TARGET(e)->data;
+			DEBUGP("r=%p, spos=%d'\n", r, spos);
+			return standard_target_map(spos);
+			break;
+		case IPTCC_R_MODULE:
+			return GET_TARGET(e)->u.user.name;
+			break;
+	}
+	return NULL;
+}
+/* Is this a built-in chain?  Actually returns hook + 1. */
+int
+TC_BUILTIN(const char *chain, const TC_HANDLE_T handle)
+{
+	struct chain_head *c;
+	
+	iptc_fn = TC_BUILTIN;
 
-	/* Fix up entry points. */
-	for (i = 0; i < NUMHOOKS; i++) {
-		/* Entry points to START of chain, so keep same if
-                   inserting on at that point. */
-		if ((*handle)->info.hook_entry[i] > offset)
-			newinfo.hook_entry[i] += rules_size;
-
-		/* Underflow always points to END of chain (policy),
-		   so if something is inserted at same point, it
-		   should be advanced. */
-		if ((*handle)->info.underflow[i] >= offset)
-			newinfo.underflow[i] += rules_size;
-	}
-
-	newh = alloc_handle((*handle)->info.name,
-			    (*handle)->entries.size + rules_size,
-			    (*handle)->new_number + num_rules);
-	if (!newh)
-		return 0;
-	newh->info = newinfo;
-
-	/* Copy pre... */
-	memcpy(newh->entries.entrytable, (*handle)->entries.entrytable,offset);
-	/* ... Insert new ... */
-	memcpy((char *)newh->entries.entrytable + offset, insert, rules_size);
-	/* ... copy post */
-	memcpy((char *)newh->entries.entrytable + offset + rules_size,
-	       (char *)(*handle)->entries.entrytable + offset,
-	       (*handle)->entries.size - offset);
-
-	/* Move counter map. */
-	/* Copy pre... */
-	memcpy(newh->counter_map, (*handle)->counter_map,
-	       sizeof(struct counter_map) * num_rules_offset);
-	/* ... copy post */
-	memcpy(newh->counter_map + num_rules_offset + num_rules,
-	       (*handle)->counter_map + num_rules_offset,
-	       sizeof(struct counter_map) * ((*handle)->new_number
-					     - num_rules_offset));
-	/* Set intermediates to no counter copy */
-	for (i = 0; i < num_rules; i++)
-		newh->counter_map[num_rules_offset+i]
-			= ((struct counter_map){ COUNTER_MAP_SET, 0 });
-
-	newh->new_number = (*handle)->new_number + num_rules;
-	newh->entries.size = (*handle)->entries.size + rules_size;
-	newh->hooknames = (*handle)->hooknames;
-
-	newh->cache_chain_heads = (*handle)->cache_chain_heads;
-	newh->cache_num_builtins = (*handle)->cache_num_builtins;
-	newh->cache_num_chains = (*handle)->cache_num_chains;
-	newh->cache_rule_end = (*handle)->cache_rule_end;
-	newh->cache_chain_iteration = (*handle)->cache_chain_iteration;
-	if (!correct_cache(newh, offset, rules_size)) {
-		free(newh);
+	c = iptcc_find_label(chain, handle);
+	if (!c) {
+		errno = ENOENT;
 		return 0;
 	}
 
-	free(*handle);
-	*handle = newh;
-
-	return set_verdict(offset, rules_size, handle);
+	return iptcc_is_builtin(c);
 }
 
-static int
-delete_rules(unsigned int num_rules, unsigned int rules_size,
-	     unsigned int offset, unsigned int num_rules_offset,
-	     TC_HANDLE_T *handle)
+/* Get the policy of a given built-in chain */
+const char *
+TC_GET_POLICY(const char *chain,
+	      STRUCT_COUNTERS *counters,
+	      TC_HANDLE_T *handle)
 {
-	unsigned int i;
+	struct chain_head *c;
 
-	if (offset + rules_size > (*handle)->entries.size) {
-		errno = EINVAL;
-		return 0;
-	}
+	iptc_fn = TC_GET_POLICY;
 
-	/* Fix up entry points. */
-	for (i = 0; i < NUMHOOKS; i++) {
-		/* In practice, we never delete up to a hook entry,
-		   since the built-in chains are always first,
-		   so these two are never equal */
-		if ((*handle)->info.hook_entry[i] >= offset + rules_size)
-			(*handle)->info.hook_entry[i] -= rules_size;
-		else if ((*handle)->info.hook_entry[i] > offset) {
-			fprintf(stderr, "ERROR: Deleting entry %u %u %u\n",
-				i, (*handle)->info.hook_entry[i], offset);
-			abort();
-		}
+	DEBUGP("called for chain %s\n", chain);
 
-		/* Underflow points to policy (terminal) rule in
-                   built-in, so sequality is valid here (when deleting
-                   the last rule). */
-		if ((*handle)->info.underflow[i] >= offset + rules_size)
-			(*handle)->info.underflow[i] -= rules_size;
-		else if ((*handle)->info.underflow[i] > offset) {
-			fprintf(stderr, "ERROR: Deleting uflow %u %u %u\n",
-				i, (*handle)->info.underflow[i], offset);
-			abort();
-		}
+	c = iptcc_find_label(chain, *handle);
+	if (!c) {
+		errno = ENOENT;
+		return NULL;
 	}
 
-	/* Move the rules down. */
-	memmove((char *)(*handle)->entries.entrytable + offset,
-		(char *)(*handle)->entries.entrytable + offset + rules_size,
-		(*handle)->entries.size - (offset + rules_size));
-
-	/* Move the counter map down. */
-	memmove(&(*handle)->counter_map[num_rules_offset],
-		&(*handle)->counter_map[num_rules_offset + num_rules],
-		sizeof(struct counter_map)
-		* ((*handle)->new_number - (num_rules + num_rules_offset)));
-
-	/* Fix numbers */
-	(*handle)->new_number -= num_rules;
-	(*handle)->entries.size -= rules_size;
+	if (!iptcc_is_builtin(c))
+		return NULL;
 
-	/* Fix the chain cache */
-	if (!correct_cache(*handle, offset+rules_size, -(int)rules_size))
-		return 0;
+	*counters = c->counters;
 
-	return set_verdict(offset, -(int)rules_size, handle);
+	return standard_target_map(c->verdict);
 }
 
 static int
-standard_map(STRUCT_ENTRY *e, int verdict)
+iptcc_standard_map(struct rule_head *r, int verdict)
 {
+	STRUCT_ENTRY *e = r->entry;
 	STRUCT_STANDARD_TARGET *t;
 
 	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
@@ -974,64 +1214,62 @@
 	strcpy(t->target.u.user.name, STANDARD_TARGET);
 	t->verdict = verdict;
 
+	r->type = IPTCC_R_STANDARD;
+
 	return 1;
 }
 
 static int
-map_target(const TC_HANDLE_T handle,
-	   STRUCT_ENTRY *e,
-	   unsigned int offset,
-	   STRUCT_ENTRY_TARGET *old)
+iptcc_map_target(const TC_HANDLE_T handle,
+	   struct rule_head *r)
 {
+	STRUCT_ENTRY *e = r->entry;
 	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
 
-	/* Save old target (except data, which we don't change, except for
-	   standard case, where we don't care). */
-	*old = *t;
-
 	/* Maybe it's empty (=> fall through) */
-	if (strcmp(t->u.user.name, "") == 0)
-		return standard_map(e, offset + e->next_offset);
+	if (strcmp(t->u.user.name, "") == 0) {
+		r->type = IPTCC_R_FALLTHROUGH;
+		return 1;
+	}
 	/* Maybe it's a standard target name... */
 	else if (strcmp(t->u.user.name, LABEL_ACCEPT) == 0)
-		return standard_map(e, -NF_ACCEPT - 1);
+		return iptcc_standard_map(r, -NF_ACCEPT - 1);
 	else if (strcmp(t->u.user.name, LABEL_DROP) == 0)
-		return standard_map(e, -NF_DROP - 1);
+		return iptcc_standard_map(r, -NF_DROP - 1);
 	else if (strcmp(t->u.user.name, LABEL_QUEUE) == 0)
-		return standard_map(e, -NF_QUEUE - 1);
+		return iptcc_standard_map(r, -NF_QUEUE - 1);
 	else if (strcmp(t->u.user.name, LABEL_RETURN) == 0)
-		return standard_map(e, RETURN);
+		return iptcc_standard_map(r, RETURN);
 	else if (TC_BUILTIN(t->u.user.name, handle)) {
 		/* Can't jump to builtins. */
 		errno = EINVAL;
 		return 0;
 	} else {
 		/* Maybe it's an existing chain name. */
-		struct chain_cache *c;
+		struct chain_head *c;
+		DEBUGP("trying to find chain `%s': ", t->u.user.name);
 
-		c = find_label(t->u.user.name, handle);
-		if (c)
-			return standard_map(e, c->start_off);
+		c = iptcc_find_label(t->u.user.name, handle);
+		if (c) {
+			DEBUGP_C("found!\n");
+			r->type = IPTCC_R_JUMP;
+			r->jump = c;
+			c->references++;
+			return 1;
+		}
+		DEBUGP_C("not found :(\n");
 	}
 
 	/* Must be a module?  If not, kernel will reject... */
-	/* memset to all 0 for your memcmp convenience. */
+	/* memset to all 0 for your memcmp convenience: don't clear version */
 	memset(t->u.user.name + strlen(t->u.user.name),
 	       0,
-	       FUNCTION_MAXNAMELEN - strlen(t->u.user.name));
+	       FUNCTION_MAXNAMELEN - 1 - strlen(t->u.user.name));
+	r->type = IPTCC_R_MODULE;
+	set_changed(handle);
 	return 1;
 }
 
-static void
-unmap_target(STRUCT_ENTRY *e, STRUCT_ENTRY_TARGET *old)
-{
-	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
-
-	/* Save old target (except data, which we don't change, except for
-	   standard case, where we don't care). */
-	*t = *old;
-}
-
 /* Insert the entry `fw' in chain `chain' into position `rulenum'. */
 int
 TC_INSERT_ENTRY(const IPT_CHAINLABEL chain,
@@ -1039,36 +1277,56 @@
 		unsigned int rulenum,
 		TC_HANDLE_T *handle)
 {
-	unsigned int chainindex, offset;
-	STRUCT_ENTRY_TARGET old;
-	struct chain_cache *c;
-	STRUCT_ENTRY *tmp;
-	int ret;
+	struct chain_head *c;
+	struct rule_head *r;
+	struct list_head *prev;
 
 	iptc_fn = TC_INSERT_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
+
+	if (!(c = iptcc_find_label(chain, *handle))) {
 		errno = ENOENT;
 		return 0;
 	}
 
-	chainindex = offset2index(*handle, c->start_off);
-
-	tmp = index2entry(*handle, chainindex + rulenum);
-	if (!tmp || tmp > offset2entry(*handle, c->end_off)) {
+	/* first rulenum index = 0
+	   first c->num_rules index = 1 */
+	if (rulenum > c->num_rules) {
 		errno = E2BIG;
 		return 0;
 	}
-	offset = index2offset(*handle, chainindex + rulenum);
 
-	/* Mapping target actually alters entry, but that's
-           transparent to the caller. */
-	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
+	/* If we are inserting at the end just take advantage of the
+	   double linked list, insert will happen before the entry
+	   prev points to. */
+	if (rulenum == c->num_rules) {
+		prev = &c->rules;
+	} else if (rulenum + 1 <= c->num_rules/2) {
+		r = iptcc_get_rule_num(c, rulenum + 1);
+		prev = &r->list;
+	} else {
+		r = iptcc_get_rule_num_reverse(c, c->num_rules - rulenum);
+		prev = &r->list;
+	}
+
+	if (!(r = iptcc_alloc_rule(c, e->next_offset))) {
+		errno = ENOMEM;
+		return 0;
+	}
+
+	memcpy(r->entry, e, e->next_offset);
+	r->counter_map.maptype = COUNTER_MAP_SET;
+
+	if (!iptcc_map_target(*handle, r)) {
+		free(r);
 		return 0;
+	}
+
+	list_add_tail(&r->list, prev);
+	c->num_rules++;
+
+	set_changed(*handle);
 
-	ret = insert_rules(1, e->next_offset, e, offset,
-			   chainindex + rulenum, rulenum == 0, handle);
-	unmap_target((STRUCT_ENTRY *)e, &old);
-	return ret;
+	return 1;
 }
 
 /* Atomically replace rule `rulenum' in `chain' with `fw'. */
@@ -1078,40 +1336,47 @@
 		 unsigned int rulenum,
 		 TC_HANDLE_T *handle)
 {
-	unsigned int chainindex, offset;
-	STRUCT_ENTRY_TARGET old;
-	struct chain_cache *c;
-	STRUCT_ENTRY *tmp;
-	int ret;
+	struct chain_head *c;
+	struct rule_head *r, *old;
 
 	iptc_fn = TC_REPLACE_ENTRY;
 
-	if (!(c = find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, *handle))) {
 		errno = ENOENT;
 		return 0;
 	}
 
-	chainindex = offset2index(*handle, c->start_off);
-
-	tmp = index2entry(*handle, chainindex + rulenum);
-	if (!tmp || tmp >= offset2entry(*handle, c->end_off)) {
+	if (rulenum >= c->num_rules) {
 		errno = E2BIG;
 		return 0;
 	}
 
-	offset = index2offset(*handle, chainindex + rulenum);
-	/* Replace = delete and insert. */
-	if (!delete_rules(1, get_entry(*handle, offset)->next_offset,
-			  offset, chainindex + rulenum, handle))
+	/* Take advantage of the double linked list if possible. */
+	if (rulenum + 1 <= c->num_rules/2) {
+		old = iptcc_get_rule_num(c, rulenum + 1);
+	} else {
+		old = iptcc_get_rule_num_reverse(c, c->num_rules - rulenum);
+	}
+
+	if (!(r = iptcc_alloc_rule(c, e->next_offset))) {
+		errno = ENOMEM;
 		return 0;
+	}
+
+	memcpy(r->entry, e, e->next_offset);
+	r->counter_map.maptype = COUNTER_MAP_SET;
 
-	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
+	if (!iptcc_map_target(*handle, r)) {
+		free(r);
 		return 0;
+	}
+
+	list_add(&r->list, &old->list);
+	iptcc_delete_rule(old);
 
-	ret = insert_rules(1, e->next_offset, e, offset,
-			   chainindex + rulenum, 1, handle);
-	unmap_target((STRUCT_ENTRY *)e, &old);
-	return ret;
+	set_changed(*handle);
+
+	return 1;
 }
 
 /* Append entry `fw' to chain `chain'.  Equivalent to insert with
@@ -1121,24 +1386,37 @@
 		const STRUCT_ENTRY *e,
 		TC_HANDLE_T *handle)
 {
-	struct chain_cache *c;
-	STRUCT_ENTRY_TARGET old;
-	int ret;
+	struct chain_head *c;
+	struct rule_head *r;
 
 	iptc_fn = TC_APPEND_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, *handle))) {
+		DEBUGP("unable to find chain `%s'\n", chain);
 		errno = ENOENT;
 		return 0;
 	}
 
-	if (!map_target(*handle, (STRUCT_ENTRY *)e,
-			c->end_off, &old))
+	if (!(r = iptcc_alloc_rule(c, e->next_offset))) {
+		DEBUGP("unable to allocate rule for chain `%s'\n", chain);
+		errno = ENOMEM;
+		return 0;
+	}
+
+	memcpy(r->entry, e, e->next_offset);
+	r->counter_map.maptype = COUNTER_MAP_SET;
+
+	if (!iptcc_map_target(*handle, r)) {
+		DEBUGP("unable to map target of rule for chain `%s'\n", chain);
+		free(r);
 		return 0;
+	}
+
+	list_add_tail(&r->list, &c->rules);
+	c->num_rules++;
+
+	set_changed(*handle);
 
-	ret = insert_rules(1, e->next_offset, e, c->end_off, 
-			   offset2index(*handle, c->end_off), 0, handle);
-	unmap_target((STRUCT_ENTRY *)e, &old);
-	return ret;
+	return 1;
 }
 
 static inline int
@@ -1169,20 +1447,42 @@
 }
 
 static inline int
-target_different(const unsigned char *a_targdata,
-		 const unsigned char *b_targdata,
-		 unsigned int tdatasize,
-		 const unsigned char *mask)
+target_same(struct rule_head *a, struct rule_head *b,const unsigned char *mask)
 {
 	unsigned int i;
-	for (i = 0; i < tdatasize; i++)
-		if (((a_targdata[i] ^ b_targdata[i]) & mask[i]) != 0)
-			return 1;
+	STRUCT_ENTRY_TARGET *ta, *tb;
 
-	return 0;
+	if (a->type != b->type)
+		return 0;
+
+	ta = GET_TARGET(a->entry);
+	tb = GET_TARGET(b->entry);
+
+	switch (a->type) {
+	case IPTCC_R_FALLTHROUGH:
+		return 1;
+	case IPTCC_R_JUMP:
+		return a->jump == b->jump;
+	case IPTCC_R_STANDARD:
+		return ((STRUCT_STANDARD_TARGET *)ta)->verdict
+			== ((STRUCT_STANDARD_TARGET *)tb)->verdict;
+	case IPTCC_R_MODULE:
+		if (ta->u.target_size != tb->u.target_size)
+			return 0;
+		if (strcmp(ta->u.user.name, tb->u.user.name) != 0)
+			return 0;
+
+		for (i = 0; i < ta->u.target_size - sizeof(*ta); i++)
+			if (((ta->data[i] ^ tb->data[i]) & mask[i]) != 0)
+				return 0;
+		return 1;
+	default:
+		fprintf(stderr, "ERROR: bad type %i\n", a->type);
+		abort();
+	}
 }
 
-static int
+static unsigned char *
 is_same(const STRUCT_ENTRY *a,
 	const STRUCT_ENTRY *b,
 	unsigned char *matchmask);
@@ -1194,87 +1494,106 @@
 		unsigned char *matchmask,
 		TC_HANDLE_T *handle)
 {
-	unsigned int offset;
-	struct chain_cache *c;
-	STRUCT_ENTRY *e, *fw;
+	struct chain_head *c;
+	struct rule_head *r, *i;
 
 	iptc_fn = TC_DELETE_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, *handle))) {
 		errno = ENOENT;
 		return 0;
 	}
 
-	fw = malloc(origfw->next_offset);
-	if (fw == NULL) {
+	/* Create a rule_head from origfw. */
+	r = iptcc_alloc_rule(c, origfw->next_offset);
+	if (!r) {
 		errno = ENOMEM;
 		return 0;
 	}
 
-	for (offset = c->start_off; offset < c->end_off;
-	     offset += e->next_offset) {
-		STRUCT_ENTRY_TARGET discard;
-
-		memcpy(fw, origfw, origfw->next_offset);
-
-		/* FIXME: handle this in is_same --RR */
-		if (!map_target(*handle, fw, offset, &discard)) {
-			free(fw);
-			return 0;
-		}
-		e = get_entry(*handle, offset);
+	memcpy(r->entry, origfw, origfw->next_offset);
+	r->counter_map.maptype = COUNTER_MAP_NOMAP;
+	if (!iptcc_map_target(*handle, r)) {
+		DEBUGP("unable to map target of rule for chain `%s'\n", chain);
+		free(r);
+		return 0;
+	}
 
-#if 0
-		printf("Deleting:\n");
-		dump_entry(newe);
-#endif
-		if (is_same(e, fw, matchmask)) {
-			int ret;
-			ret = delete_rules(1, e->next_offset,
-					   offset, entry2index(*handle, e),
-					   handle);
-			free(fw);
-			return ret;
+	list_for_each_entry(i, &c->rules, list) {
+		unsigned char *mask;
+
+		mask = is_same(r->entry, i->entry, matchmask);
+		if (!mask)
+			continue;
+
+		if (!target_same(r, i, mask))
+			continue;
+
+		/* If we are about to delete the rule that is the
+		 * current iterator, move rule iterator back.  next
+		 * pointer will then point to real next node */
+		if (i == (*handle)->rule_iterator_cur) {
+			(*handle)->rule_iterator_cur = 
+				list_entry((*handle)->rule_iterator_cur->list.prev,
+					   struct rule_head, list);
 		}
+
+		c->num_rules--;
+		iptcc_delete_rule(i);
+
+		set_changed(*handle);
+		free(r);
+		return 1;
 	}
 
-	free(fw);
+	free(r);
 	errno = ENOENT;
 	return 0;
 }
 
+
 /* Delete the rule in position `rulenum' in `chain'. */
 int
 TC_DELETE_NUM_ENTRY(const IPT_CHAINLABEL chain,
 		    unsigned int rulenum,
 		    TC_HANDLE_T *handle)
 {
-	unsigned int index;
-	int ret;
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
+	struct chain_head *c;
+	struct rule_head *r;
 
 	iptc_fn = TC_DELETE_NUM_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
+
+	if (!(c = iptcc_find_label(chain, *handle))) {
 		errno = ENOENT;
 		return 0;
 	}
 
-	index = offset2index(*handle, c->start_off) + rulenum;
-
-	if (index >= offset2index(*handle, c->end_off)) {
+	if (rulenum >= c->num_rules) {
 		errno = E2BIG;
 		return 0;
 	}
 
-	e = index2entry(*handle, index);
-	if (e == NULL) {
-		errno = EINVAL;
-		return 0;
+	/* Take advantage of the double linked list if possible. */
+	if (rulenum + 1 <= c->num_rules/2) {
+		r = iptcc_get_rule_num(c, rulenum + 1);
+	} else {
+		r = iptcc_get_rule_num_reverse(c, c->num_rules - rulenum);
+	}
+
+	/* If we are about to delete the rule that is the current
+	 * iterator, move rule iterator back.  next pointer will then
+	 * point to real next node */
+	if (r == (*handle)->rule_iterator_cur) {
+		(*handle)->rule_iterator_cur = 
+			list_entry((*handle)->rule_iterator_cur->list.prev,
+				   struct rule_head, list);
 	}
 
-	ret = delete_rules(1, e->next_offset, entry2offset(*handle, e),
-			   index, handle);
-	return ret;
+	c->num_rules--;
+	iptcc_delete_rule(r);
+
+	set_changed(*handle);
+
+	return 1;
 }
 
 /* Check the packet `fw' on chain `chain'.  Returns the verdict, or
@@ -1284,6 +1603,7 @@
 		STRUCT_ENTRY *entry,
 		TC_HANDLE_T *handle)
 {
+	iptc_fn = TC_CHECK_PACKET;
 	errno = ENOSYS;
 	return NULL;
 }
@@ -1292,47 +1612,44 @@
 int
 TC_FLUSH_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
 {
-	unsigned int startindex, endindex;
-	STRUCT_ENTRY *startentry, *endentry;
-	struct chain_cache *c;
-	int ret;
+	struct chain_head *c;
+	struct rule_head *r, *tmp;
 
 	iptc_fn = TC_FLUSH_ENTRIES;
-	if (!(c = find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, *handle))) {
 		errno = ENOENT;
 		return 0;
 	}
-	startindex = offset2index(*handle, c->start_off);
-	endindex = offset2index(*handle, c->end_off);
-	startentry = offset2entry(*handle, c->start_off);
-	endentry = offset2entry(*handle, c->end_off);
-
-	ret = delete_rules(endindex - startindex,
-			   (char *)endentry - (char *)startentry,
-			   c->start_off, startindex,
-			   handle);
-	return ret;
+
+	list_for_each_entry_safe(r, tmp, &c->rules, list) {
+		iptcc_delete_rule(r);
+	}
+
+	c->num_rules = 0;
+
+	set_changed(*handle);
+
+	return 1;
 }
 
 /* Zeroes the counters in a chain. */
 int
 TC_ZERO_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
 {
-	unsigned int i, end;
-	struct chain_cache *c;
+	struct chain_head *c;
+	struct rule_head *r;
 
-	if (!(c = find_label(chain, *handle))) {
+	iptc_fn = TC_ZERO_ENTRIES;
+	if (!(c = iptcc_find_label(chain, *handle))) {
 		errno = ENOENT;
 		return 0;
 	}
 
-	i = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	for (; i <= end; i++) {
-		if ((*handle)->counter_map[i].maptype ==COUNTER_MAP_NORMAL_MAP)
-			(*handle)->counter_map[i].maptype = COUNTER_MAP_ZEROED;
+	list_for_each_entry(r, &c->rules, list) {
+		if (r->counter_map.maptype == COUNTER_MAP_NORMAL_MAP)
+			r->counter_map.maptype = COUNTER_MAP_ZEROED;
 	}
+
 	set_changed(*handle);
 
 	return 1;
@@ -1343,29 +1660,23 @@
 		unsigned int rulenum,
 		TC_HANDLE_T *handle)
 {
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-	unsigned int chainindex, end;
+	struct chain_head *c;
+	struct rule_head *r;
 
 	iptc_fn = TC_READ_COUNTER;
 	CHECK(*handle);
 
-	if (!(c = find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, *handle))) {
 		errno = ENOENT;
 		return NULL;
 	}
 
-	chainindex = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	if (chainindex + rulenum > end) {
+	if (!(r = iptcc_get_rule_num(c, rulenum))) {
 		errno = E2BIG;
 		return NULL;
 	}
 
-	e = index2entry(*handle, chainindex + rulenum);
-
-	return &e->counters;
+	return &r->entry[0].counters;
 }
 
 int
@@ -1373,33 +1684,24 @@
 		unsigned int rulenum,
 		TC_HANDLE_T *handle)
 {
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-	unsigned int chainindex, end;
+	struct chain_head *c;
+	struct rule_head *r;
 	
 	iptc_fn = TC_ZERO_COUNTER;
 	CHECK(*handle);
 
-	if (!(c = find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, *handle))) {
 		errno = ENOENT;
 		return 0;
 	}
 
-	chainindex = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	if (chainindex + rulenum > end) {
+	if (!(r = iptcc_get_rule_num(c, rulenum))) {
 		errno = E2BIG;
 		return 0;
 	}
 
-	e = index2entry(*handle, chainindex + rulenum);
-
-	if ((*handle)->counter_map[chainindex + rulenum].maptype
-			== COUNTER_MAP_NORMAL_MAP) {
-		(*handle)->counter_map[chainindex + rulenum].maptype
-			 = COUNTER_MAP_ZEROED;
-	}
+	if (r->counter_map.maptype == COUNTER_MAP_NORMAL_MAP)
+		r->counter_map.maptype = COUNTER_MAP_ZEROED;
 
 	set_changed(*handle);
 
@@ -1412,30 +1714,25 @@
 	       STRUCT_COUNTERS *counters,
 	       TC_HANDLE_T *handle)
 {
+	struct chain_head *c;
+	struct rule_head *r;
 	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-	unsigned int chainindex, end;
 
 	iptc_fn = TC_SET_COUNTER;
 	CHECK(*handle);
 
-	if (!(c = find_label(chain, *handle))) {
+	if (!(c = iptcc_find_label(chain, *handle))) {
 		errno = ENOENT;
 		return 0;
 	}
 
-	chainindex = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	if (chainindex + rulenum > end) {
+	if (!(r = iptcc_get_rule_num(c, rulenum))) {
 		errno = E2BIG;
 		return 0;
 	}
 
-	e = index2entry(*handle, chainindex + rulenum);
-
-	(*handle)->counter_map[chainindex + rulenum].maptype
-		= COUNTER_MAP_SET;
+	e = r->entry;
+	r->counter_map.maptype = COUNTER_MAP_SET;
 
 	memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
 
@@ -1450,82 +1747,42 @@
 int
 TC_CREATE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
 {
-	int ret;
-	struct {
-		STRUCT_ENTRY head;
-		struct ipt_error_target name;
-		STRUCT_ENTRY ret;
-		STRUCT_STANDARD_TARGET target;
-	} newc;
-	unsigned int destination;
+	static struct chain_head *c;
 
 	iptc_fn = TC_CREATE_CHAIN;
 
 	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
            QUEUE, RETURN. */
-	if (find_label(chain, *handle)
+	if (iptcc_find_label(chain, *handle)
 	    || strcmp(chain, LABEL_DROP) == 0
 	    || strcmp(chain, LABEL_ACCEPT) == 0
 	    || strcmp(chain, LABEL_QUEUE) == 0
 	    || strcmp(chain, LABEL_RETURN) == 0) {
+		DEBUGP("Chain `%s' already exists\n", chain);
 		errno = EEXIST;
 		return 0;
 	}
 
 	if (strlen(chain)+1 > sizeof(IPT_CHAINLABEL)) {
+		DEBUGP("Chain name `%s' too long\n", chain);
 		errno = EINVAL;
 		return 0;
 	}
 
-	memset(&newc, 0, sizeof(newc));
-	newc.head.target_offset = sizeof(STRUCT_ENTRY);
-	newc.head.next_offset
-		= sizeof(STRUCT_ENTRY)
-		+ ALIGN(sizeof(struct ipt_error_target));
-	strcpy(newc.name.t.u.user.name, ERROR_TARGET);
-	newc.name.t.u.target_size = ALIGN(sizeof(struct ipt_error_target));
-	strcpy(newc.name.error, chain);
-
-	newc.ret.target_offset = sizeof(STRUCT_ENTRY);
-	newc.ret.next_offset
-		= sizeof(STRUCT_ENTRY)
-		+ ALIGN(sizeof(STRUCT_STANDARD_TARGET));
-	strcpy(newc.target.target.u.user.name, STANDARD_TARGET);
-	newc.target.target.u.target_size
-		= ALIGN(sizeof(STRUCT_STANDARD_TARGET));
-	newc.target.verdict = RETURN;
-
-	destination = index2offset(*handle, (*handle)->new_number -1);
-
-	/* Add just before terminal entry */
-	ret = insert_rules(2, sizeof(newc), &newc.head,
-			   destination,
-			   (*handle)->new_number - 1,
-			   0, handle);
-
-	set_changed(*handle);
-
-	/* add chain cache info for this chain */
-	add_chain_cache(*handle, chain, 
-			destination+newc.head.next_offset, 
-			destination+newc.head.next_offset);
-
-	return ret;
-}
+	c = iptcc_alloc_chain_head(chain, 0);
+	if (!c) {
+		DEBUGP("Cannot allocate memory for chain `%s'\n", chain);
+		errno = ENOMEM;
+		return 0;
 
-static int
-count_ref(STRUCT_ENTRY *e, unsigned int offset, unsigned int *ref)
-{
-	STRUCT_STANDARD_TARGET *t;
+	}
 
-	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) == 0) {
-		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+	DEBUGP("Creating chain `%s'\n", chain);
+	list_add_tail(&c->list, &(*handle)->chains);
 
-		if (t->verdict == offset)
-			(*ref)++;
-	}
+	set_changed(*handle);
 
-	return 0;
+	return 1;
 }
 
 /* Get the number of references to this chain. */
@@ -1533,17 +1790,16 @@
 TC_GET_REFERENCES(unsigned int *ref, const IPT_CHAINLABEL chain,
 		  TC_HANDLE_T *handle)
 {
-	struct chain_cache *c;
+	struct chain_head *c;
 
-	if (!(c = find_label(chain, *handle))) {
+	iptc_fn = TC_GET_REFERENCES;
+	if (!(c = iptcc_find_label(chain, *handle))) {
 		errno = ENOENT;
 		return 0;
 	}
 
-	*ref = 0;
-	ENTRY_ITERATE((*handle)->entries.entrytable,
-		      (*handle)->entries.size,
-		      count_ref, c->start_off, ref);
+	*ref = c->references;
+
 	return 1;
 }
 
@@ -1551,48 +1807,53 @@
 int
 TC_DELETE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
 {
-	unsigned int labelidx, labeloff;
 	unsigned int references;
-	struct chain_cache *c;
-	int ret;
-	STRUCT_ENTRY *start;
-
-	if (!TC_GET_REFERENCES(&references, chain, handle))
-		return 0;
+	struct chain_head *c;
 
 	iptc_fn = TC_DELETE_CHAIN;
 
+	if (!(c = iptcc_find_label(chain, *handle))) {
+		DEBUGP("cannot find chain `%s'\n", chain);
+		errno = ENOENT;
+		return 0;
+	}
+
 	if (TC_BUILTIN(chain, *handle)) {
+		DEBUGP("cannot remove builtin chain `%s'\n", chain);
 		errno = EINVAL;
 		return 0;
 	}
 
-	if (references > 0) {
-		errno = EMLINK;
+	if (!TC_GET_REFERENCES(&references, chain, handle)) {
+		DEBUGP("cannot get references on chain `%s'\n", chain);
 		return 0;
 	}
 
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
+	if (references > 0) {
+		DEBUGP("chain `%s' still has references\n", chain);
+		errno = EMLINK;
 		return 0;
 	}
 
-	if (c->start_off != c->end_off) {
+	if (c->num_rules) {
+		DEBUGP("chain `%s' is not empty\n", chain);
 		errno = ENOTEMPTY;
 		return 0;
 	}
 
-	/* Need label index: preceeds chain start */
-	labelidx = offset2index(*handle, c->start_off) - 1;
-	labeloff = index2offset(*handle, labelidx);
-
-	start = offset2entry(*handle, c->start_off);
-
-	ret = delete_rules(2,
-			   get_entry(*handle, labeloff)->next_offset
-			   + start->next_offset,
-			   labeloff, labelidx, handle);
-	return ret;
+	/* If we are about to delete the chain that is the current
+	 * iterator, move chain iterator firward. */
+	if (c == (*handle)->chain_iterator_cur)
+		iptcc_chain_iterator_advance(*handle);
+
+	list_del(&c->list);
+	free(c);
+
+	DEBUGP("chain `%s' deleted\n", chain);
+
+	set_changed(*handle);
+
+	return 1;
 }
 
 /* Renames a chain. */
@@ -1600,15 +1861,12 @@
 		    const IPT_CHAINLABEL newname,
 		    TC_HANDLE_T *handle)
 {
-	unsigned int labeloff, labelidx;
-	struct chain_cache *c;
-	struct ipt_error_target *t;
-
+	struct chain_head *c;
 	iptc_fn = TC_RENAME_CHAIN;
 
 	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
            QUEUE, RETURN. */
-	if (find_label(newname, *handle)
+	if (iptcc_find_label(newname, *handle)
 	    || strcmp(newname, LABEL_DROP) == 0
 	    || strcmp(newname, LABEL_ACCEPT) == 0
 	    || strcmp(newname, LABEL_QUEUE) == 0
@@ -1617,7 +1875,7 @@
 		return 0;
 	}
 
-	if (!(c = find_label(oldname, *handle))
+	if (!(c = iptcc_find_label(oldname, *handle))
 	    || TC_BUILTIN(oldname, *handle)) {
 		errno = ENOENT;
 		return 0;
@@ -1628,20 +1886,8 @@
 		return 0;
 	}
 
-	/* Need label index: preceeds chain start */
-	labelidx = offset2index(*handle, c->start_off) - 1;
-	labeloff = index2offset(*handle, labelidx);
-
-	t = (struct ipt_error_target *)
-		GET_TARGET(get_entry(*handle, labeloff));
-
-	memset(t->error, 0, sizeof(t->error));
-	strcpy(t->error, newname);
-
-	/* update chain cache */
-	memset(c->name, 0, sizeof(c->name));
-	strcpy(c->name, newname);
-
+	strncpy(c->name, newname, sizeof(IPT_CHAINLABEL));
+	
 	set_changed(*handle);
 
 	return 1;
@@ -1654,51 +1900,37 @@
 	      STRUCT_COUNTERS *counters,
 	      TC_HANDLE_T *handle)
 {
-	unsigned int hook;
-	unsigned int policyoff, ctrindex;
-	STRUCT_ENTRY *e;
-	STRUCT_STANDARD_TARGET *t;
+	struct chain_head *c;
 
 	iptc_fn = TC_SET_POLICY;
-	/* Figure out which chain. */
-	hook = TC_BUILTIN(chain, *handle);
-	if (hook == 0) {
+
+	if (!(c = iptcc_find_label(chain, *handle))) {
+		DEBUGP("cannot find chain `%s'\n", chain);
 		errno = ENOENT;
 		return 0;
-	} else
-		hook--;
+	}
 
-	policyoff = get_chain_end(*handle, (*handle)->info.hook_entry[hook]);
-	if (policyoff != (*handle)->info.underflow[hook]) {
-		printf("ERROR: Policy for `%s' offset %u != underflow %u\n",
-		       chain, policyoff, (*handle)->info.underflow[hook]);
+	if (!iptcc_is_builtin(c)) {
+		DEBUGP("cannot set policy of userdefinedchain `%s'\n", chain);
+		errno = ENOENT;
 		return 0;
 	}
 
-	e = get_entry(*handle, policyoff);
-	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-
 	if (strcmp(policy, LABEL_ACCEPT) == 0)
-		t->verdict = -NF_ACCEPT - 1;
+		c->verdict = -NF_ACCEPT - 1;
 	else if (strcmp(policy, LABEL_DROP) == 0)
-		t->verdict = -NF_DROP - 1;
+		c->verdict = -NF_DROP - 1;
 	else {
 		errno = EINVAL;
 		return 0;
 	}
 
-	ctrindex = entry2index(*handle, e);
-
 	if (counters) {
 		/* set byte and packet counters */
-		memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
-
-		(*handle)->counter_map[ctrindex].maptype
-			= COUNTER_MAP_SET;
-
+		memcpy(&c->counters, counters, sizeof(STRUCT_COUNTERS));
+		c->counter_map.maptype = COUNTER_MAP_SET;
 	} else {
-		(*handle)->counter_map[ctrindex]
-			= ((struct counter_map){ COUNTER_MAP_NOMAP, 0 });
+		c->counter_map.maptype = COUNTER_MAP_NOMAP;
 	}
 
 	set_changed(*handle);
@@ -1721,33 +1953,100 @@
 	answer->bcnt = a->bcnt - b->bcnt;
 }
 
+
+static void counters_nomap(STRUCT_COUNTERS_INFO *newcounters,
+			   unsigned int index)
+{
+	newcounters->counters[index] = ((STRUCT_COUNTERS) { 0, 0});
+	DEBUGP_C("NOMAP => zero\n");
+}
+
+static void counters_normal_map(STRUCT_COUNTERS_INFO *newcounters,
+				STRUCT_REPLACE *repl,
+				unsigned int index,
+				unsigned int mappos)
+{
+	/* Original read: X.
+	 * Atomic read on replacement: X + Y.
+	 * Currently in kernel: Z.
+	 * Want in kernel: X + Y + Z.
+	 * => Add in X + Y
+	 * => Add in replacement read.
+	 */
+	newcounters->counters[index] = repl->counters[mappos];
+	DEBUGP_C("NORMAL_MAP => mappos %u \n", mappos);
+}
+
+static void counters_map_zeroed(STRUCT_COUNTERS_INFO *newcounters,
+				STRUCT_REPLACE *repl,
+				unsigned int index,
+				unsigned int mappos,
+				STRUCT_COUNTERS *counters)
+{
+	/* Original read: X.
+	 * Atomic read on replacement: X + Y.
+	 * Currently in kernel: Z.
+	 * Want in kernel: Y + Z.
+	 * => Add in Y.
+	 * => Add in (replacement read - original read).
+	 */
+	subtract_counters(&newcounters->counters[index],
+			  &repl->counters[mappos],
+			  counters);
+	DEBUGP_C("ZEROED => mappos %u\n", mappos);
+}
+
+static void counters_map_set(STRUCT_COUNTERS_INFO *newcounters,
+			     unsigned int index,
+			     STRUCT_COUNTERS *counters)
+{
+	/* Want to set counter (iptables-restore) */
+
+	memcpy(&newcounters->counters[index], counters,
+		sizeof(STRUCT_COUNTERS));
+
+	DEBUGP_C("SET\n");
+}
+
+
 int
 TC_COMMIT(TC_HANDLE_T *handle)
 {
 	/* Replace, then map back the counters. */
 	STRUCT_REPLACE *repl;
 	STRUCT_COUNTERS_INFO *newcounters;
-	unsigned int i;
+	struct chain_head *c;
+	int ret;
 	size_t counterlen;
+	int new_number;
+	unsigned int new_size;
 
+	iptc_fn = TC_COMMIT;
 	CHECK(*handle);
 
-	counterlen = sizeof(STRUCT_COUNTERS_INFO)
-			+ sizeof(STRUCT_COUNTERS) * (*handle)->new_number;
-
-#if 0
-	TC_DUMP_ENTRIES(*handle);
-#endif
-
 	/* Don't commit if nothing changed. */
 	if (!(*handle)->changed)
 		goto finished;
 
-	repl = malloc(sizeof(*repl) + (*handle)->entries.size);
+	new_number = iptcc_compile_table_prep(*handle, &new_size);
+	if (new_number < 0) {
+		errno = ENOMEM;
+		return 0;
+	}
+
+	repl = malloc(sizeof(*repl) + new_size);
 	if (!repl) {
 		errno = ENOMEM;
 		return 0;
 	}
+	memset(repl, 0, sizeof(*repl) + new_size);
+
+#if 0
+	TC_DUMP_ENTRIES(*handle);
+#endif
+
+	counterlen = sizeof(STRUCT_COUNTERS_INFO)
+			+ sizeof(STRUCT_COUNTERS) * new_number;
 
 	/* These are the old counters we will get from kernel */
 	repl->counters = malloc(sizeof(STRUCT_COUNTERS)
@@ -1757,7 +2056,6 @@
 		errno = ENOMEM;
 		return 0;
 	}
-
 	/* These are the counters we're going to put back, later. */
 	newcounters = malloc(counterlen);
 	if (!newcounters) {
@@ -1766,21 +2064,40 @@
 		errno = ENOMEM;
 		return 0;
 	}
+	memset(newcounters, 0, counterlen);
 
 	strcpy(repl->name, (*handle)->info.name);
-	repl->num_entries = (*handle)->new_number;
-	repl->size = (*handle)->entries.size;
-	memcpy(repl->hook_entry, (*handle)->info.hook_entry,
-	       sizeof(repl->hook_entry));
-	memcpy(repl->underflow, (*handle)->info.underflow,
-	       sizeof(repl->underflow));
+	repl->num_entries = new_number;
+	repl->size = new_size;
+
 	repl->num_counters = (*handle)->info.num_entries;
 	repl->valid_hooks = (*handle)->info.valid_hooks;
-	memcpy(repl->entries, (*handle)->entries.entrytable,
-	       (*handle)->entries.size);
+
+	DEBUGP("num_entries=%u, size=%u, num_counters=%u\n",
+		repl->num_entries, repl->size, repl->num_counters);
+
+	ret = iptcc_compile_table(*handle, repl);
+	if (ret < 0) {
+		errno = ret;
+		free(repl->counters);
+		free(repl);
+		return 0;
+	}
+
+
+#ifdef IPTC_DEBUG2
+	{
+		int fd = open("/tmp/libiptc-so_set_replace.blob", 
+				O_CREAT|O_WRONLY);
+		if (fd >= 0) {
+			write(fd, repl, sizeof(*repl) + repl->size);
+			close(fd);
+		}
+	}
+#endif
 
 	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_REPLACE, repl,
-		       sizeof(*repl) + (*handle)->entries.size) < 0) {
+		       sizeof(*repl) + repl->size) < 0) {
 		free(repl->counters);
 		free(repl);
 		free(newcounters);
@@ -1789,50 +2106,65 @@
 
 	/* Put counters back. */
 	strcpy(newcounters->name, (*handle)->info.name);
-	newcounters->num_counters = (*handle)->new_number;
-	for (i = 0; i < (*handle)->new_number; i++) {
-		unsigned int mappos = (*handle)->counter_map[i].mappos;
-		switch ((*handle)->counter_map[i].maptype) {
-		case COUNTER_MAP_NOMAP:
-			newcounters->counters[i]
-				= ((STRUCT_COUNTERS){ 0, 0 });
-			break;
-
-		case COUNTER_MAP_NORMAL_MAP:
-			/* Original read: X.
-			 * Atomic read on replacement: X + Y.
-			 * Currently in kernel: Z.
-			 * Want in kernel: X + Y + Z.
-			 * => Add in X + Y
-			 * => Add in replacement read.
-			 */
-			newcounters->counters[i] = repl->counters[mappos];
-			break;
+	newcounters->num_counters = new_number;
 
-		case COUNTER_MAP_ZEROED:
-			/* Original read: X.
-			 * Atomic read on replacement: X + Y.
-			 * Currently in kernel: Z.
-			 * Want in kernel: Y + Z.
-			 * => Add in Y.
-			 * => Add in (replacement read - original read).
-			 */
-			subtract_counters(&newcounters->counters[i],
-					  &repl->counters[mappos],
-					  &index2entry(*handle, i)->counters);
-			break;
-
-		case COUNTER_MAP_SET:
-			/* Want to set counter (iptables-restore) */
+	list_for_each_entry(c, &(*handle)->chains, list) {
+		struct rule_head *r;
 
-			memcpy(&newcounters->counters[i],
-			       &index2entry(*handle, i)->counters,
-			       sizeof(STRUCT_COUNTERS));
+		/* Builtin chains have their own counters */
+		if (iptcc_is_builtin(c)) {
+			DEBUGP("counter for chain-index %u: ", c->foot_index);
+			switch(c->counter_map.maptype) {
+			case COUNTER_MAP_NOMAP:
+				counters_nomap(newcounters, c->foot_index);
+				break;
+			case COUNTER_MAP_NORMAL_MAP:
+				counters_normal_map(newcounters, repl,
+						    c->foot_index, 
+						    c->counter_map.mappos);
+				break;
+			case COUNTER_MAP_ZEROED:
+				counters_map_zeroed(newcounters, repl,
+						    c->foot_index, 
+						    c->counter_map.mappos,
+						    &c->counters);
+				break;
+			case COUNTER_MAP_SET:
+				counters_map_set(newcounters, c->foot_index,
+						 &c->counters);
+				break;
+			}
+		}
 
-			break;
+		list_for_each_entry(r, &c->rules, list) {
+			DEBUGP("counter for index %u: ", r->index);
+			switch (r->counter_map.maptype) {
+			case COUNTER_MAP_NOMAP:
+				counters_nomap(newcounters, r->index);
+				break;
+
+			case COUNTER_MAP_NORMAL_MAP:
+				counters_normal_map(newcounters, repl,
+						    r->index, 
+						    r->counter_map.mappos);
+				break;
+
+			case COUNTER_MAP_ZEROED:
+				counters_map_zeroed(newcounters, repl,
+						    r->index,
+						    r->counter_map.mappos,
+						    &r->entry->counters);
+				break;
+
+			case COUNTER_MAP_SET:
+				counters_map_set(newcounters, r->index,
+						 &r->entry->counters);
+				break;
+			}
 		}
 	}
 
+
 #ifdef KERNEL_64_USERSPACE_32
 	{
 		/* Kernel will think that pointer should be 64-bits, and get
@@ -1848,6 +2180,17 @@
 	}
 #endif /* KERNEL_64_USERSPACE_32 */
 
+#ifdef IPTC_DEBUG2
+	{
+		int fd = open("/tmp/libiptc-so_set_add_counters.blob", 
+				O_CREAT|O_WRONLY);
+		if (fd >= 0) {
+			write(fd, newcounters, counterlen);
+			close(fd);
+		}
+	}
+#endif
+
 	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_ADD_COUNTERS,
 		       newcounters, counterlen) < 0) {
 		free(repl->counters);
diff -urN iptables-1.2.11/libiptc/linux_list.h iptables-1.3.0/libiptc/linux_list.h
--- iptables-1.2.11/libiptc/linux_list.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/libiptc/linux_list.h	2004-10-10 11:56:23.000000000 +0200
@@ -0,0 +1,723 @@
+#ifndef _LINUX_LIST_H
+#define _LINUX_LIST_H
+
+#undef offsetof
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+
+/**
+ * container_of - cast a member of a structure out to the containing structure
+ *
+ * @ptr:	the pointer to the member.
+ * @type:	the type of the container struct this is embedded in.
+ * @member:	the name of the member within the struct.
+ *
+ */
+#define container_of(ptr, type, member) ({			\
+        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        (type *)( (char *)__mptr - offsetof(type,member) );})
+
+/*
+ * Check at compile time that something is of a particular type.
+ * Always evaluates to 1 so you may use it easily in comparisons.
+ */
+#define typecheck(type,x) \
+({	type __dummy; \
+	typeof(x) __dummy2; \
+	(void)(&__dummy == &__dummy2); \
+	1; \
+})
+
+#define prefetch(x)		1
+
+/* empty define to make this work in userspace -HW */
+#define smp_wmb()
+
+/*
+ * These are non-NULL pointers that will result in page faults
+ * under normal circumstances, used to verify that nobody uses
+ * non-initialized list entries.
+ */
+#define LIST_POISON1  ((void *) 0x00100100)
+#define LIST_POISON2  ((void *) 0x00200200)
+
+/*
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+	struct list_head name = LIST_HEAD_INIT(name)
+
+#define INIT_LIST_HEAD(ptr) do { \
+	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/*
+ * Insert a new entry between two known consecutive entries.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_add(struct list_head *new,
+			      struct list_head *prev,
+			      struct list_head *next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+/**
+ * list_add - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static inline void list_add(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head, head->next);
+}
+
+/**
+ * list_add_tail - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static inline void list_add_tail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+/*
+ * Insert a new entry between two known consecutive entries.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_add_rcu(struct list_head * new,
+		struct list_head * prev, struct list_head * next)
+{
+	new->next = next;
+	new->prev = prev;
+	smp_wmb();
+	next->prev = new;
+	prev->next = new;
+}
+
+/**
+ * list_add_rcu - add a new entry to rcu-protected list
+ * @new: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ *
+ * The caller must take whatever precautions are necessary
+ * (such as holding appropriate locks) to avoid racing
+ * with another list-mutation primitive, such as list_add_rcu()
+ * or list_del_rcu(), running on this same list.
+ * However, it is perfectly legal to run concurrently with
+ * the _rcu list-traversal primitives, such as
+ * list_for_each_entry_rcu().
+ */
+static inline void list_add_rcu(struct list_head *new, struct list_head *head)
+{
+	__list_add_rcu(new, head, head->next);
+}
+
+/**
+ * list_add_tail_rcu - add a new entry to rcu-protected list
+ * @new: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ *
+ * The caller must take whatever precautions are necessary
+ * (such as holding appropriate locks) to avoid racing
+ * with another list-mutation primitive, such as list_add_tail_rcu()
+ * or list_del_rcu(), running on this same list.
+ * However, it is perfectly legal to run concurrently with
+ * the _rcu list-traversal primitives, such as
+ * list_for_each_entry_rcu().
+ */
+static inline void list_add_tail_rcu(struct list_head *new,
+					struct list_head *head)
+{
+	__list_add_rcu(new, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_del(struct list_head * prev, struct list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * list_del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: list_empty on entry does not return true after this, the entry is
+ * in an undefined state.
+ */
+static inline void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	entry->next = LIST_POISON1;
+	entry->prev = LIST_POISON2;
+}
+
+/**
+ * list_del_rcu - deletes entry from list without re-initialization
+ * @entry: the element to delete from the list.
+ *
+ * Note: list_empty on entry does not return true after this,
+ * the entry is in an undefined state. It is useful for RCU based
+ * lockfree traversal.
+ *
+ * In particular, it means that we can not poison the forward
+ * pointers that may still be used for walking the list.
+ *
+ * The caller must take whatever precautions are necessary
+ * (such as holding appropriate locks) to avoid racing
+ * with another list-mutation primitive, such as list_del_rcu()
+ * or list_add_rcu(), running on this same list.
+ * However, it is perfectly legal to run concurrently with
+ * the _rcu list-traversal primitives, such as
+ * list_for_each_entry_rcu().
+ *
+ * Note that the caller is not permitted to immediately free
+ * the newly deleted entry.  Instead, either synchronize_kernel()
+ * or call_rcu() must be used to defer freeing until an RCU
+ * grace period has elapsed.
+ */
+static inline void list_del_rcu(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	entry->prev = LIST_POISON2;
+}
+
+/**
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @entry: the element to delete from the list.
+ */
+static inline void list_del_init(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	INIT_LIST_HEAD(entry);
+}
+
+/**
+ * list_move - delete from one list and add as another's head
+ * @list: the entry to move
+ * @head: the head that will precede our entry
+ */
+static inline void list_move(struct list_head *list, struct list_head *head)
+{
+        __list_del(list->prev, list->next);
+        list_add(list, head);
+}
+
+/**
+ * list_move_tail - delete from one list and add as another's tail
+ * @list: the entry to move
+ * @head: the head that will follow our entry
+ */
+static inline void list_move_tail(struct list_head *list,
+				  struct list_head *head)
+{
+        __list_del(list->prev, list->next);
+        list_add_tail(list, head);
+}
+
+/**
+ * list_empty - tests whether a list is empty
+ * @head: the list to test.
+ */
+static inline int list_empty(const struct list_head *head)
+{
+	return head->next == head;
+}
+
+/**
+ * list_empty_careful - tests whether a list is
+ * empty _and_ checks that no other CPU might be
+ * in the process of still modifying either member
+ *
+ * NOTE: using list_empty_careful() without synchronization
+ * can only be safe if the only activity that can happen
+ * to the list entry is list_del_init(). Eg. it cannot be used
+ * if another CPU could re-list_add() it.
+ *
+ * @head: the list to test.
+ */
+static inline int list_empty_careful(const struct list_head *head)
+{
+	struct list_head *next = head->next;
+	return (next == head) && (next == head->prev);
+}
+
+static inline void __list_splice(struct list_head *list,
+				 struct list_head *head)
+{
+	struct list_head *first = list->next;
+	struct list_head *last = list->prev;
+	struct list_head *at = head->next;
+
+	first->prev = head;
+	head->next = first;
+
+	last->next = at;
+	at->prev = last;
+}
+
+/**
+ * list_splice - join two lists
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ */
+static inline void list_splice(struct list_head *list, struct list_head *head)
+{
+	if (!list_empty(list))
+		__list_splice(list, head);
+}
+
+/**
+ * list_splice_init - join two lists and reinitialise the emptied list.
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ *
+ * The list at @list is reinitialised
+ */
+static inline void list_splice_init(struct list_head *list,
+				    struct list_head *head)
+{
+	if (!list_empty(list)) {
+		__list_splice(list, head);
+		INIT_LIST_HEAD(list);
+	}
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:	the &struct list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member) \
+	container_of(ptr, type, member)
+
+/**
+ * list_for_each	-	iterate over a list
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each(pos, head) \
+	for (pos = (head)->next, prefetch(pos->next); pos != (head); \
+        	pos = pos->next, prefetch(pos->next))
+
+/**
+ * __list_for_each	-	iterate over a list
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ *
+ * This variant differs from list_for_each() in that it's the
+ * simplest possible list iteration code, no prefetching is done.
+ * Use this for code that knows the list to be very short (empty
+ * or 1 entry) most of the time.
+ */
+#define __list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+
+/**
+ * list_for_each_prev	-	iterate over a list backwards
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each_prev(pos, head) \
+	for (pos = (head)->prev, prefetch(pos->prev); pos != (head); \
+        	pos = pos->prev, prefetch(pos->prev))
+
+/**
+ * list_for_each_safe	-	iterate over a list safe against removal of list entry
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @n:		another &struct list_head to use as temporary storage
+ * @head:	the head for your list.
+ */
+#define list_for_each_safe(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); \
+		pos = n, n = pos->next)
+
+/**
+ * list_for_each_entry	-	iterate over list of given type
+ * @pos:	the type * to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry(pos, head, member)				\
+	for (pos = list_entry((head)->next, typeof(*pos), member),	\
+		     prefetch(pos->member.next);			\
+	     &pos->member != (head); 					\
+	     pos = list_entry(pos->member.next, typeof(*pos), member),	\
+		     prefetch(pos->member.next))
+
+/**
+ * list_for_each_entry_reverse - iterate backwards over list of given type.
+ * @pos:	the type * to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry_reverse(pos, head, member)			\
+	for (pos = list_entry((head)->prev, typeof(*pos), member),	\
+		     prefetch(pos->member.prev);			\
+	     &pos->member != (head); 					\
+	     pos = list_entry(pos->member.prev, typeof(*pos), member),	\
+		     prefetch(pos->member.prev))
+
+/**
+ * list_prepare_entry - prepare a pos entry for use as a start point in
+ *			list_for_each_entry_continue
+ * @pos:	the type * to use as a start point
+ * @head:	the head of the list
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_prepare_entry(pos, head, member) \
+	((pos) ? : list_entry(head, typeof(*pos), member))
+
+/**
+ * list_for_each_entry_continue -	iterate over list of given type
+ *			continuing after existing point
+ * @pos:	the type * to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry_continue(pos, head, member) 		\
+	for (pos = list_entry(pos->member.next, typeof(*pos), member),	\
+		     prefetch(pos->member.next);			\
+	     &pos->member != (head);					\
+	     pos = list_entry(pos->member.next, typeof(*pos), member),	\
+		     prefetch(pos->member.next))
+
+/**
+ * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
+ * @pos:	the type * to use as a loop counter.
+ * @n:		another type * to use as temporary storage
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry_safe(pos, n, head, member)			\
+	for (pos = list_entry((head)->next, typeof(*pos), member),	\
+		n = list_entry(pos->member.next, typeof(*pos), member);	\
+	     &pos->member != (head); 					\
+	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
+
+/**
+ * list_for_each_rcu	-	iterate over an rcu-protected list
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ *
+ * This list-traversal primitive may safely run concurrently with
+ * the _rcu list-mutation primitives such as list_add_rcu()
+ * as long as the traversal is guarded by rcu_read_lock().
+ */
+#define list_for_each_rcu(pos, head) \
+	for (pos = (head)->next, prefetch(pos->next); pos != (head); \
+        	pos = pos->next, ({ smp_read_barrier_depends(); 0;}), prefetch(pos->next))
+
+#define __list_for_each_rcu(pos, head) \
+	for (pos = (head)->next; pos != (head); \
+        	pos = pos->next, ({ smp_read_barrier_depends(); 0;}))
+
+/**
+ * list_for_each_safe_rcu	-	iterate over an rcu-protected list safe
+ *					against removal of list entry
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @n:		another &struct list_head to use as temporary storage
+ * @head:	the head for your list.
+ *
+ * This list-traversal primitive may safely run concurrently with
+ * the _rcu list-mutation primitives such as list_add_rcu()
+ * as long as the traversal is guarded by rcu_read_lock().
+ */
+#define list_for_each_safe_rcu(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); \
+		pos = n, ({ smp_read_barrier_depends(); 0;}), n = pos->next)
+
+/**
+ * list_for_each_entry_rcu	-	iterate over rcu list of given type
+ * @pos:	the type * to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ *
+ * This list-traversal primitive may safely run concurrently with
+ * the _rcu list-mutation primitives such as list_add_rcu()
+ * as long as the traversal is guarded by rcu_read_lock().
+ */
+#define list_for_each_entry_rcu(pos, head, member)			\
+	for (pos = list_entry((head)->next, typeof(*pos), member),	\
+		     prefetch(pos->member.next);			\
+	     &pos->member != (head); 					\
+	     pos = list_entry(pos->member.next, typeof(*pos), member),	\
+		     ({ smp_read_barrier_depends(); 0;}),		\
+		     prefetch(pos->member.next))
+
+
+/**
+ * list_for_each_continue_rcu	-	iterate over an rcu-protected list
+ *			continuing after existing point.
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ *
+ * This list-traversal primitive may safely run concurrently with
+ * the _rcu list-mutation primitives such as list_add_rcu()
+ * as long as the traversal is guarded by rcu_read_lock().
+ */
+#define list_for_each_continue_rcu(pos, head) \
+	for ((pos) = (pos)->next, prefetch((pos)->next); (pos) != (head); \
+        	(pos) = (pos)->next, ({ smp_read_barrier_depends(); 0;}), prefetch((pos)->next))
+
+/*
+ * Double linked lists with a single pointer list head.
+ * Mostly useful for hash tables where the two pointer list head is
+ * too wasteful.
+ * You lose the ability to access the tail in O(1).
+ */
+
+struct hlist_head {
+	struct hlist_node *first;
+};
+
+struct hlist_node {
+	struct hlist_node *next, **pprev;
+};
+
+#define HLIST_HEAD_INIT { .first = NULL }
+#define HLIST_HEAD(name) struct hlist_head name = {  .first = NULL }
+#define INIT_HLIST_HEAD(ptr) ((ptr)->first = NULL)
+#define INIT_HLIST_NODE(ptr) ((ptr)->next = NULL, (ptr)->pprev = NULL)
+
+static inline int hlist_unhashed(const struct hlist_node *h)
+{
+	return !h->pprev;
+}
+
+static inline int hlist_empty(const struct hlist_head *h)
+{
+	return !h->first;
+}
+
+static inline void __hlist_del(struct hlist_node *n)
+{
+	struct hlist_node *next = n->next;
+	struct hlist_node **pprev = n->pprev;
+	*pprev = next;
+	if (next)
+		next->pprev = pprev;
+}
+
+static inline void hlist_del(struct hlist_node *n)
+{
+	__hlist_del(n);
+	n->next = LIST_POISON1;
+	n->pprev = LIST_POISON2;
+}
+
+/**
+ * hlist_del_rcu - deletes entry from hash list without re-initialization
+ * @n: the element to delete from the hash list.
+ *
+ * Note: list_unhashed() on entry does not return true after this,
+ * the entry is in an undefined state. It is useful for RCU based
+ * lockfree traversal.
+ *
+ * In particular, it means that we can not poison the forward
+ * pointers that may still be used for walking the hash list.
+ *
+ * The caller must take whatever precautions are necessary
+ * (such as holding appropriate locks) to avoid racing
+ * with another list-mutation primitive, such as hlist_add_head_rcu()
+ * or hlist_del_rcu(), running on this same list.
+ * However, it is perfectly legal to run concurrently with
+ * the _rcu list-traversal primitives, such as
+ * hlist_for_each_entry().
+ */
+static inline void hlist_del_rcu(struct hlist_node *n)
+{
+	__hlist_del(n);
+	n->pprev = LIST_POISON2;
+}
+
+static inline void hlist_del_init(struct hlist_node *n)
+{
+	if (n->pprev)  {
+		__hlist_del(n);
+		INIT_HLIST_NODE(n);
+	}
+}
+
+#define hlist_del_rcu_init hlist_del_init
+
+static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
+{
+	struct hlist_node *first = h->first;
+	n->next = first;
+	if (first)
+		first->pprev = &n->next;
+	h->first = n;
+	n->pprev = &h->first;
+}
+
+
+/**
+ * hlist_add_head_rcu - adds the specified element to the specified hlist,
+ * while permitting racing traversals.
+ * @n: the element to add to the hash list.
+ * @h: the list to add to.
+ *
+ * The caller must take whatever precautions are necessary
+ * (such as holding appropriate locks) to avoid racing
+ * with another list-mutation primitive, such as hlist_add_head_rcu()
+ * or hlist_del_rcu(), running on this same list.
+ * However, it is perfectly legal to run concurrently with
+ * the _rcu list-traversal primitives, such as
+ * hlist_for_each_entry(), but only if smp_read_barrier_depends()
+ * is used to prevent memory-consistency problems on Alpha CPUs.
+ * Regardless of the type of CPU, the list-traversal primitive
+ * must be guarded by rcu_read_lock().
+ *
+ * OK, so why don't we have an hlist_for_each_entry_rcu()???
+ */
+static inline void hlist_add_head_rcu(struct hlist_node *n,
+					struct hlist_head *h)
+{
+	struct hlist_node *first = h->first;
+	n->next = first;
+	n->pprev = &h->first;
+	smp_wmb();
+	if (first)
+		first->pprev = &n->next;
+	h->first = n;
+}
+
+/* next must be != NULL */
+static inline void hlist_add_before(struct hlist_node *n,
+					struct hlist_node *next)
+{
+	n->pprev = next->pprev;
+	n->next = next;
+	next->pprev = &n->next;
+	*(n->pprev) = n;
+}
+
+static inline void hlist_add_after(struct hlist_node *n,
+					struct hlist_node *next)
+{
+	next->next = n->next;
+	n->next = next;
+	next->pprev = &n->next;
+
+	if(next->next)
+		next->next->pprev  = &next->next;
+}
+
+#define hlist_entry(ptr, type, member) container_of(ptr,type,member)
+
+#define hlist_for_each(pos, head) \
+	for (pos = (head)->first; pos && ({ prefetch(pos->next); 1; }); \
+	     pos = pos->next)
+
+#define hlist_for_each_safe(pos, n, head) \
+	for (pos = (head)->first; pos && ({ n = pos->next; 1; }); \
+	     pos = n)
+
+/**
+ * hlist_for_each_entry	- iterate over list of given type
+ * @tpos:	the type * to use as a loop counter.
+ * @pos:	the &struct hlist_node to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the hlist_node within the struct.
+ */
+#define hlist_for_each_entry(tpos, pos, head, member)			 \
+	for (pos = (head)->first;					 \
+	     pos && ({ prefetch(pos->next); 1;}) &&			 \
+		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+	     pos = pos->next)
+
+/**
+ * hlist_for_each_entry_continue - iterate over a hlist continuing after existing point
+ * @tpos:	the type * to use as a loop counter.
+ * @pos:	the &struct hlist_node to use as a loop counter.
+ * @member:	the name of the hlist_node within the struct.
+ */
+#define hlist_for_each_entry_continue(tpos, pos, member)		 \
+	for (pos = (pos)->next;						 \
+	     pos && ({ prefetch(pos->next); 1;}) &&			 \
+		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+	     pos = pos->next)
+
+/**
+ * hlist_for_each_entry_from - iterate over a hlist continuing from existing point
+ * @tpos:	the type * to use as a loop counter.
+ * @pos:	the &struct hlist_node to use as a loop counter.
+ * @member:	the name of the hlist_node within the struct.
+ */
+#define hlist_for_each_entry_from(tpos, pos, member)			 \
+	for (; pos && ({ prefetch(pos->next); 1;}) &&			 \
+		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+	     pos = pos->next)
+
+/**
+ * hlist_for_each_entry_safe - iterate over list of given type safe against removal of list entry
+ * @tpos:	the type * to use as a loop counter.
+ * @pos:	the &struct hlist_node to use as a loop counter.
+ * @n:		another &struct hlist_node to use as temporary storage
+ * @head:	the head for your list.
+ * @member:	the name of the hlist_node within the struct.
+ */
+#define hlist_for_each_entry_safe(tpos, pos, n, head, member) 		 \
+	for (pos = (head)->first;					 \
+	     pos && ({ n = pos->next; 1; }) && 				 \
+		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+	     pos = n)
+
+/**
+ * hlist_for_each_entry_rcu - iterate over rcu list of given type
+ * @pos:	the type * to use as a loop counter.
+ * @pos:	the &struct hlist_node to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the hlist_node within the struct.
+ *
+ * This list-traversal primitive may safely run concurrently with
+ * the _rcu list-mutation primitives such as hlist_add_rcu()
+ * as long as the traversal is guarded by rcu_read_lock().
+ */
+#define hlist_for_each_entry_rcu(tpos, pos, head, member)		 \
+	for (pos = (head)->first;					 \
+	     pos && ({ prefetch(pos->next); 1;}) &&			 \
+		({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
+	     pos = pos->next, ({ smp_read_barrier_depends(); 0; }) )
+
+#endif
diff -urN iptables-1.2.11/libiptc/linux_stddef.h iptables-1.3.0/libiptc/linux_stddef.h
--- iptables-1.2.11/libiptc/linux_stddef.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.0/libiptc/linux_stddef.h	2004-10-10 11:56:24.000000000 +0200
@@ -0,0 +1,39 @@
+#ifndef _LINUX_STDDEF_H
+#define _LINUX_STDDEF_H
+
+#undef NULL
+#if defined(__cplusplus)
+#define NULL 0
+#else
+#define NULL ((void *)0)
+#endif
+
+#undef offsetof
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+
+
+/**
+ * container_of - cast a member of a structure out to the containing structure
+ *
+ * @ptr:	the pointer to the member.
+ * @type:	the type of the container struct this is embedded in.
+ * @member:	the name of the member within the struct.
+ *
+ */
+#define container_of(ptr, type, member) ({			\
+        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        (type *)( (char *)__mptr - offsetof(type,member) );})
+
+/*
+ * Check at compile time that something is of a particular type.
+ * Always evaluates to 1 so you may use it easily in comparisons.
+ */
+#define typecheck(type,x) \
+({	type __dummy; \
+	typeof(x) __dummy2; \
+	(void)(&__dummy == &__dummy2); \
+	1; \
+})
+
+
+#endif
