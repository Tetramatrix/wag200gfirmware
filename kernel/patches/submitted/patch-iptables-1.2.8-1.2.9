diff -urN iptables-1.2.8/.#iptables.c.1.54 iptables-1.2.9/.#iptables.c.1.54
--- iptables-1.2.8/.#iptables.c.1.54	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/.#iptables.c.1.54	2003-03-05 08:34:35.000000000 +0100
@@ -0,0 +1,2298 @@
+/* Code to take an iptables-style command line and do it. */
+
+/*
+ * Author: Paul.Russell@rustcorp.com.au and mneuling@radlogic.com.au
+ *
+ * (C) 2000-2002 by the netfilter coreteam <coreteam@netfilter.org>:
+ * 		    Paul 'Rusty' Russell <rusty@rustcorp.com.au>
+ * 		    Marc Boucher <marc+nf@mbsi.ca>
+ * 		    James Morris <jmorris@intercode.com.au>
+ * 		    Harald Welte <laforge@gnumonks.org>
+ * 		    Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <getopt.h>
+#include <string.h>
+#include <netdb.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <ctype.h>
+#include <stdarg.h>
+#include <limits.h>
+#include <unistd.h>
+#include <iptables.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef IPT_LIB_DIR
+#define IPT_LIB_DIR "/usr/local/lib/iptables"
+#endif
+
+#ifndef PROC_SYS_MODPROBE
+#define PROC_SYS_MODPROBE "/proc/sys/kernel/modprobe"
+#endif
+
+#define FMT_NUMERIC	0x0001
+#define FMT_NOCOUNTS	0x0002
+#define FMT_KILOMEGAGIGA 0x0004
+#define FMT_OPTIONS	0x0008
+#define FMT_NOTABLE	0x0010
+#define FMT_NOTARGET	0x0020
+#define FMT_VIA		0x0040
+#define FMT_NONEWLINE	0x0080
+#define FMT_LINENUMBERS 0x0100
+
+#define FMT_PRINT_RULE (FMT_NOCOUNTS | FMT_OPTIONS | FMT_VIA \
+			| FMT_NUMERIC | FMT_NOTABLE)
+#define FMT(tab,notab) ((format) & FMT_NOTABLE ? (notab) : (tab))
+
+
+#define CMD_NONE		0x0000U
+#define CMD_INSERT		0x0001U
+#define CMD_DELETE		0x0002U
+#define CMD_DELETE_NUM		0x0004U
+#define CMD_REPLACE		0x0008U
+#define CMD_APPEND		0x0010U
+#define CMD_LIST		0x0020U
+#define CMD_FLUSH		0x0040U
+#define CMD_ZERO		0x0080U
+#define CMD_NEW_CHAIN		0x0100U
+#define CMD_DELETE_CHAIN	0x0200U
+#define CMD_SET_POLICY		0x0400U
+#define CMD_CHECK		0x0800U
+#define CMD_RENAME_CHAIN	0x1000U
+#define NUMBER_OF_CMD	13
+static const char cmdflags[] = { 'I', 'D', 'D', 'R', 'A', 'L', 'F', 'Z',
+				 'N', 'X', 'P', 'E' };
+
+#define OPTION_OFFSET 256
+
+#define OPT_NONE	0x00000U
+#define OPT_NUMERIC	0x00001U
+#define OPT_SOURCE	0x00002U
+#define OPT_DESTINATION	0x00004U
+#define OPT_PROTOCOL	0x00008U
+#define OPT_JUMP	0x00010U
+#define OPT_VERBOSE	0x00020U
+#define OPT_EXPANDED	0x00040U
+#define OPT_VIANAMEIN	0x00080U
+#define OPT_VIANAMEOUT	0x00100U
+#define OPT_FRAGMENT    0x00200U
+#define OPT_LINENUMBERS 0x00400U
+#define OPT_COUNTERS	0x00800U
+#define NUMBER_OF_OPT	12
+static const char optflags[NUMBER_OF_OPT]
+= { 'n', 's', 'd', 'p', 'j', 'v', 'x', 'i', 'o', 'f', '3', 'c'};
+
+static struct option original_opts[] = {
+	{ "append", 1, 0, 'A' },
+	{ "delete", 1, 0,  'D' },
+	{ "insert", 1, 0,  'I' },
+	{ "replace", 1, 0,  'R' },
+	{ "list", 2, 0,  'L' },
+	{ "flush", 2, 0,  'F' },
+	{ "zero", 2, 0,  'Z' },
+	{ "new-chain", 1, 0,  'N' },
+	{ "delete-chain", 2, 0,  'X' },
+	{ "rename-chain", 1, 0,  'E' },
+	{ "policy", 1, 0,  'P' },
+	{ "source", 1, 0, 's' },
+	{ "destination", 1, 0,  'd' },
+	{ "src", 1, 0,  's' }, /* synonym */
+	{ "dst", 1, 0,  'd' }, /* synonym */
+	{ "protocol", 1, 0,  'p' },
+	{ "in-interface", 1, 0, 'i' },
+	{ "jump", 1, 0, 'j' },
+	{ "table", 1, 0, 't' },
+	{ "match", 1, 0, 'm' },
+	{ "numeric", 0, 0, 'n' },
+	{ "out-interface", 1, 0, 'o' },
+	{ "verbose", 0, 0, 'v' },
+	{ "exact", 0, 0, 'x' },
+	{ "fragments", 0, 0, 'f' },
+	{ "version", 0, 0, 'V' },
+	{ "help", 2, 0, 'h' },
+	{ "line-numbers", 0, 0, '0' },
+	{ "modprobe", 1, 0, 'M' },
+	{ "set-counters", 1, 0, 'c' },
+	{ 0 }
+};
+
+/* we need this for iptables-restore.  iptables-restore.c sets line to the
+ * current line of the input file, in order  to give a more precise error
+ * message.  iptables itself doesn't need this, so it is initialized to the
+ * magic number of -1 */
+int line = -1;
+
+#ifndef __OPTIMIZE__
+struct ipt_entry_target *
+ipt_get_target(struct ipt_entry *e)
+{
+	return (void *)e + e->target_offset;
+}
+#endif
+
+static struct option *opts = original_opts;
+static unsigned int global_option_offset = 0;
+
+/* Table of legal combinations of commands and options.  If any of the
+ * given commands make an option legal, that option is legal (applies to
+ * CMD_LIST and CMD_ZERO only).
+ * Key:
+ *  +  compulsory
+ *  x  illegal
+ *     optional
+ */
+
+static char commands_v_options[NUMBER_OF_CMD][NUMBER_OF_OPT] =
+/* Well, it's better than "Re: Linux vs FreeBSD" */
+{
+	/*     -n  -s  -d  -p  -j  -v  -x  -i  -o  -f  --line */
+/*INSERT*/    {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
+/*DELETE*/    {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
+/*DELETE_NUM*/{'x','x','x','x','x',' ','x','x','x','x','x'},
+/*REPLACE*/   {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
+/*APPEND*/    {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
+/*LIST*/      {' ','x','x','x','x',' ',' ','x','x','x',' '},
+/*FLUSH*/     {'x','x','x','x','x',' ','x','x','x','x','x'},
+/*ZERO*/      {'x','x','x','x','x',' ','x','x','x','x','x'},
+/*NEW_CHAIN*/ {'x','x','x','x','x',' ','x','x','x','x','x'},
+/*DEL_CHAIN*/ {'x','x','x','x','x',' ','x','x','x','x','x'},
+/*SET_POLICY*/{'x','x','x','x','x',' ','x','x','x','x','x'},
+/*CHECK*/     {'x','+','+','+','x',' ','x',' ',' ',' ','x'},
+/*RENAME*/    {'x','x','x','x','x',' ','x','x','x','x','x'}
+};
+
+static int inverse_for_options[NUMBER_OF_OPT] =
+{
+/* -n */ 0,
+/* -s */ IPT_INV_SRCIP,
+/* -d */ IPT_INV_DSTIP,
+/* -p */ IPT_INV_PROTO,
+/* -j */ 0,
+/* -v */ 0,
+/* -x */ 0,
+/* -i */ IPT_INV_VIA_IN,
+/* -o */ IPT_INV_VIA_OUT,
+/* -f */ IPT_INV_FRAG,
+/*--line*/ 0
+};
+
+const char *program_version;
+const char *program_name;
+
+/* Keeping track of external matches and targets: linked lists.  */
+struct iptables_match *iptables_matches = NULL;
+struct iptables_target *iptables_targets = NULL;
+
+/* Extra debugging from libiptc */
+extern void dump_entries(const iptc_handle_t handle);
+
+/* A few hardcoded protocols for 'all' and in case the user has no
+   /etc/protocols */
+struct pprot {
+	char *name;
+	u_int8_t num;
+};
+
+/* Primitive headers... */
+/* defined in netinet/in.h */
+#if 0
+#ifndef IPPROTO_ESP
+#define IPPROTO_ESP 50
+#endif
+#ifndef IPPROTO_AH
+#define IPPROTO_AH 51
+#endif
+#endif
+
+static const struct pprot chain_protos[] = {
+	{ "tcp", IPPROTO_TCP },
+	{ "udp", IPPROTO_UDP },
+	{ "icmp", IPPROTO_ICMP },
+	{ "esp", IPPROTO_ESP },
+	{ "ah", IPPROTO_AH },
+	{ "all", 0 },
+};
+
+static char *
+proto_to_name(u_int8_t proto, int nolookup)
+{
+	unsigned int i;
+
+	if (proto && !nolookup) {
+		struct protoent *pent = getprotobynumber(proto);
+		if (pent)
+			return pent->p_name;
+	}
+
+	for (i = 0; i < sizeof(chain_protos)/sizeof(struct pprot); i++)
+		if (chain_protos[i].num == proto)
+			return chain_protos[i].name;
+
+	return NULL;
+}
+
+struct in_addr *
+dotted_to_addr(const char *dotted)
+{
+	static struct in_addr addr;
+	unsigned char *addrp;
+	char *p, *q;
+	unsigned int onebyte;
+	int i;
+	char buf[20];
+
+	/* copy dotted string, because we need to modify it */
+	strncpy(buf, dotted, sizeof(buf) - 1);
+	addrp = (unsigned char *) &(addr.s_addr);
+
+	p = buf;
+	for (i = 0; i < 3; i++) {
+		if ((q = strchr(p, '.')) == NULL)
+			return (struct in_addr *) NULL;
+
+		*q = '\0';
+		if (string_to_number(p, 0, 255, &onebyte) == -1)
+			return (struct in_addr *) NULL;
+
+		addrp[i] = (unsigned char) onebyte;
+		p = q + 1;
+	}
+
+	/* we've checked 3 bytes, now we check the last one */
+	if (string_to_number(p, 0, 255, &onebyte) == -1)
+		return (struct in_addr *) NULL;
+
+	addrp[3] = (unsigned char) onebyte;
+
+	return &addr;
+}
+
+static struct in_addr *
+network_to_addr(const char *name)
+{
+	struct netent *net;
+	static struct in_addr addr;
+
+	if ((net = getnetbyname(name)) != NULL) {
+		if (net->n_addrtype != AF_INET)
+			return (struct in_addr *) NULL;
+		addr.s_addr = htonl((unsigned long) net->n_net);
+		return &addr;
+	}
+
+	return (struct in_addr *) NULL;
+}
+
+static void
+inaddrcpy(struct in_addr *dst, struct in_addr *src)
+{
+	/* memcpy(dst, src, sizeof(struct in_addr)); */
+	dst->s_addr = src->s_addr;
+}
+
+void
+exit_error(enum exittype status, char *msg, ...)
+{
+	va_list args;
+
+	va_start(args, msg);
+	fprintf(stderr, "%s v%s: ", program_name, program_version);
+	vfprintf(stderr, msg, args);
+	va_end(args);
+	fprintf(stderr, "\n");
+	if (status == PARAMETER_PROBLEM)
+		exit_tryhelp(status);
+	if (status == VERSION_PROBLEM)
+		fprintf(stderr,
+			"Perhaps iptables or your kernel needs to be upgraded.\n");
+	exit(status);
+}
+
+void
+exit_tryhelp(int status)
+{
+	if (line != -1)
+		fprintf(stderr, "Error occurred at line: %d\n", line);
+	fprintf(stderr, "Try `%s -h' or '%s --help' for more information.\n",
+			program_name, program_name );
+	exit(status);
+}
+
+void
+exit_printhelp(void)
+{
+	struct iptables_match *m = NULL;
+	struct iptables_target *t = NULL;
+
+	printf("%s v%s\n\n"
+"Usage: %s -[AD] chain rule-specification [options]\n"
+"       %s -[RI] chain rulenum rule-specification [options]\n"
+"       %s -D chain rulenum [options]\n"
+"       %s -[LFZ] [chain] [options]\n"
+"       %s -[NX] chain\n"
+"       %s -E old-chain-name new-chain-name\n"
+"       %s -P chain target [options]\n"
+"       %s -h (print this help information)\n\n",
+	       program_name, program_version, program_name, program_name,
+	       program_name, program_name, program_name, program_name,
+	       program_name, program_name);
+
+	printf(
+"Commands:\n"
+"Either long or short options are allowed.\n"
+"  --append  -A chain		Append to chain\n"
+"  --delete  -D chain		Delete matching rule from chain\n"
+"  --delete  -D chain rulenum\n"
+"				Delete rule rulenum (1 = first) from chain\n"
+"  --insert  -I chain [rulenum]\n"
+"				Insert in chain as rulenum (default 1=first)\n"
+"  --replace -R chain rulenum\n"
+"				Replace rule rulenum (1 = first) in chain\n"
+"  --list    -L [chain]		List the rules in a chain or all chains\n"
+"  --flush   -F [chain]		Delete all rules in  chain or all chains\n"
+"  --zero    -Z [chain]		Zero counters in chain or all chains\n"
+"  --new     -N chain		Create a new user-defined chain\n"
+"  --delete-chain\n"
+"            -X [chain]		Delete a user-defined chain\n"
+"  --policy  -P chain target\n"
+"				Change policy on chain to target\n"
+"  --rename-chain\n"
+"            -E old-chain new-chain\n"
+"				Change chain name, (moving any references)\n"
+
+"Options:\n"
+"  --proto	-p [!] proto	protocol: by number or name, eg. `tcp'\n"
+"  --source	-s [!] address[/mask]\n"
+"				source specification\n"
+"  --destination -d [!] address[/mask]\n"
+"				destination specification\n"
+"  --in-interface -i [!] input name[+]\n"
+"				network interface name ([+] for wildcard)\n"
+"  --jump	-j target\n"
+"				target for rule (may load target extension)\n"
+"  --match	-m match\n"
+"				extended match (may load extension)\n"
+"  --numeric	-n		numeric output of addresses and ports\n"
+"  --out-interface -o [!] output name[+]\n"
+"				network interface name ([+] for wildcard)\n"
+"  --table	-t table	table to manipulate (default: `filter')\n"
+"  --verbose	-v		verbose mode\n"
+"  --line-numbers		print line numbers when listing\n"
+"  --exact	-x		expand numbers (display exact values)\n"
+"[!] --fragment	-f		match second or further fragments only\n"
+"  --modprobe=<command>		try to insert modules using this command\n"
+"  --set-counters PKTS BYTES	set the counter during insert/append\n"
+"[!] --version	-V		print package version.\n");
+
+	/* Print out any special helps. A user might like to be able
+	   to add a --help to the commandline, and see expected
+	   results. So we call help for all matches & targets */
+	for (t=iptables_targets;t;t=t->next) {
+		printf("\n");
+		t->help();
+	}
+	for (m=iptables_matches;m;m=m->next) {
+		printf("\n");
+		m->help();
+	}
+	exit(0);
+}
+
+static void
+generic_opt_check(int command, int options)
+{
+	int i, j, legal = 0;
+
+	/* Check that commands are valid with options.  Complicated by the
+	 * fact that if an option is legal with *any* command given, it is
+	 * legal overall (ie. -z and -l).
+	 */
+	for (i = 0; i < NUMBER_OF_OPT; i++) {
+		legal = 0; /* -1 => illegal, 1 => legal, 0 => undecided. */
+
+		for (j = 0; j < NUMBER_OF_CMD; j++) {
+			if (!(command & (1<<j)))
+				continue;
+
+			if (!(options & (1<<i))) {
+				if (commands_v_options[j][i] == '+')
+					exit_error(PARAMETER_PROBLEM,
+						   "You need to supply the `-%c' "
+						   "option for this command\n",
+						   optflags[i]);
+			} else {
+				if (commands_v_options[j][i] != 'x')
+					legal = 1;
+				else if (legal == 0)
+					legal = -1;
+			}
+		}
+		if (legal == -1)
+			exit_error(PARAMETER_PROBLEM,
+				   "Illegal option `-%c' with this command\n",
+				   optflags[i]);
+	}
+}
+
+static char
+opt2char(int option)
+{
+	const char *ptr;
+	for (ptr = optflags; option > 1; option >>= 1, ptr++);
+
+	return *ptr;
+}
+
+static char
+cmd2char(int option)
+{
+	const char *ptr;
+	for (ptr = cmdflags; option > 1; option >>= 1, ptr++);
+
+	return *ptr;
+}
+
+static void
+add_command(int *cmd, const int newcmd, const int othercmds, int invert)
+{
+	if (invert)
+		exit_error(PARAMETER_PROBLEM, "unexpected ! flag");
+	if (*cmd & (~othercmds))
+		exit_error(PARAMETER_PROBLEM, "Can't use -%c with -%c\n",
+			   cmd2char(newcmd), cmd2char(*cmd & (~othercmds)));
+	*cmd |= newcmd;
+}
+
+int
+check_inverse(const char option[], int *invert, int *optind, int argc)
+{
+	if (option && strcmp(option, "!") == 0) {
+		if (*invert)
+			exit_error(PARAMETER_PROBLEM,
+				   "Multiple `!' flags not allowed");
+		*invert = TRUE;
+		if (optind) {
+			*optind = *optind+1;
+			if (argc && *optind > argc)
+				exit_error(PARAMETER_PROBLEM,
+					   "no argument following `!'");
+		}
+
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static void *
+fw_calloc(size_t count, size_t size)
+{
+	void *p;
+
+	if ((p = calloc(count, size)) == NULL) {
+		perror("iptables: calloc failed");
+		exit(1);
+	}
+	return p;
+}
+
+static void *
+fw_malloc(size_t size)
+{
+	void *p;
+
+	if ((p = malloc(size)) == NULL) {
+		perror("iptables: malloc failed");
+		exit(1);
+	}
+	return p;
+}
+
+static struct in_addr *
+host_to_addr(const char *name, unsigned int *naddr)
+{
+	struct hostent *host;
+	struct in_addr *addr;
+	unsigned int i;
+
+	*naddr = 0;
+	if ((host = gethostbyname(name)) != NULL) {
+		if (host->h_addrtype != AF_INET ||
+		    host->h_length != sizeof(struct in_addr))
+			return (struct in_addr *) NULL;
+
+		while (host->h_addr_list[*naddr] != (char *) NULL)
+			(*naddr)++;
+		addr = fw_calloc(*naddr, sizeof(struct in_addr));
+		for (i = 0; i < *naddr; i++)
+			inaddrcpy(&(addr[i]),
+				  (struct in_addr *) host->h_addr_list[i]);
+		return addr;
+	}
+
+	return (struct in_addr *) NULL;
+}
+
+static char *
+addr_to_host(const struct in_addr *addr)
+{
+	struct hostent *host;
+
+	if ((host = gethostbyaddr((char *) addr,
+				  sizeof(struct in_addr), AF_INET)) != NULL)
+		return (char *) host->h_name;
+
+	return (char *) NULL;
+}
+
+/*
+ *	All functions starting with "parse" should succeed, otherwise
+ *	the program fails.
+ *	Most routines return pointers to static data that may change
+ *	between calls to the same or other routines with a few exceptions:
+ *	"host_to_addr", "parse_hostnetwork", and "parse_hostnetworkmask"
+ *	return global static data.
+*/
+
+static struct in_addr *
+parse_hostnetwork(const char *name, unsigned int *naddrs)
+{
+	struct in_addr *addrp, *addrptmp;
+
+	if ((addrptmp = dotted_to_addr(name)) != NULL ||
+	    (addrptmp = network_to_addr(name)) != NULL) {
+		addrp = fw_malloc(sizeof(struct in_addr));
+		inaddrcpy(addrp, addrptmp);
+		*naddrs = 1;
+		return addrp;
+	}
+	if ((addrp = host_to_addr(name, naddrs)) != NULL)
+		return addrp;
+
+	exit_error(PARAMETER_PROBLEM, "host/network `%s' not found", name);
+}
+
+static struct in_addr *
+parse_mask(char *mask)
+{
+	static struct in_addr maskaddr;
+	struct in_addr *addrp;
+	unsigned int bits;
+
+	if (mask == NULL) {
+		/* no mask at all defaults to 32 bits */
+		maskaddr.s_addr = 0xFFFFFFFF;
+		return &maskaddr;
+	}
+	if ((addrp = dotted_to_addr(mask)) != NULL)
+		/* dotted_to_addr already returns a network byte order addr */
+		return addrp;
+	if (string_to_number(mask, 0, 32, &bits) == -1)
+		exit_error(PARAMETER_PROBLEM,
+			   "invalid mask `%s' specified", mask);
+	if (bits != 0) {
+		maskaddr.s_addr = htonl(0xFFFFFFFF << (32 - bits));
+		return &maskaddr;
+	}
+
+	maskaddr.s_addr = 0L;
+	return &maskaddr;
+}
+
+void
+parse_hostnetworkmask(const char *name, struct in_addr **addrpp,
+		      struct in_addr *maskp, unsigned int *naddrs)
+{
+	struct in_addr *addrp;
+	char buf[256];
+	char *p;
+	int i, j, k, n;
+
+	strncpy(buf, name, sizeof(buf) - 1);
+	if ((p = strrchr(buf, '/')) != NULL) {
+		*p = '\0';
+		addrp = parse_mask(p + 1);
+	} else
+		addrp = parse_mask(NULL);
+	inaddrcpy(maskp, addrp);
+
+	/* if a null mask is given, the name is ignored, like in "any/0" */
+	if (maskp->s_addr == 0L)
+		strcpy(buf, "0.0.0.0");
+
+	addrp = *addrpp = parse_hostnetwork(buf, naddrs);
+	n = *naddrs;
+	for (i = 0, j = 0; i < n; i++) {
+		addrp[j++].s_addr &= maskp->s_addr;
+		for (k = 0; k < j - 1; k++) {
+			if (addrp[k].s_addr == addrp[j - 1].s_addr) {
+				(*naddrs)--;
+				j--;
+				break;
+			}
+		}
+	}
+}
+
+struct iptables_match *
+find_match(const char *name, enum ipt_tryload tryload)
+{
+	struct iptables_match *ptr;
+
+	for (ptr = iptables_matches; ptr; ptr = ptr->next) {
+		if (strcmp(name, ptr->name) == 0)
+			break;
+	}
+
+#ifndef NO_SHARED_LIBS
+	if (!ptr && tryload != DONT_LOAD) {
+		char path[sizeof(IPT_LIB_DIR) + sizeof("/libipt_.so")
+			 + strlen(name)];
+		sprintf(path, IPT_LIB_DIR "/libipt_%s.so", name);
+		if (dlopen(path, RTLD_NOW)) {
+			/* Found library.  If it didn't register itself,
+			   maybe they specified target as match. */
+			ptr = find_match(name, DONT_LOAD);
+
+			if (!ptr)
+				exit_error(PARAMETER_PROBLEM,
+					   "Couldn't load match `%s'\n",
+					   name);
+		} else if (tryload == LOAD_MUST_SUCCEED)
+			exit_error(PARAMETER_PROBLEM,
+				   "Couldn't load match `%s':%s\n",
+				   name, dlerror());
+	}
+#else
+	if (ptr && !ptr->loaded) {
+		if (tryload != DONT_LOAD)
+			ptr->loaded = 1;
+		else
+			ptr = NULL;
+	}
+	if(!ptr && (tryload == LOAD_MUST_SUCCEED)) {
+		exit_error(PARAMETER_PROBLEM,
+			   "Couldn't find match `%s'\n", name);
+	}
+#endif
+
+	if (ptr)
+		ptr->used = 1;
+
+	return ptr;
+}
+
+/* Christophe Burki wants `-p 6' to imply `-m tcp'.  */
+static struct iptables_match *
+find_proto(const char *pname, enum ipt_tryload tryload, int nolookup)
+{
+	unsigned int proto;
+
+	if (string_to_number(pname, 0, 255, &proto) != -1) {
+		char *protoname = proto_to_name(proto, nolookup);
+
+		if (protoname)
+			return find_match(protoname, tryload);
+	} else
+		return find_match(pname, tryload);
+
+	return NULL;
+}
+
+u_int16_t
+parse_protocol(const char *s)
+{
+	unsigned int proto;
+
+	if (string_to_number(s, 0, 255, &proto) == -1) {
+		struct protoent *pent;
+
+		if ((pent = getprotobyname(s)))
+			proto = pent->p_proto;
+		else {
+			unsigned int i;
+			for (i = 0;
+			     i < sizeof(chain_protos)/sizeof(struct pprot);
+			     i++) {
+				if (strcmp(s, chain_protos[i].name) == 0) {
+					proto = chain_protos[i].num;
+					break;
+				}
+			}
+			if (i == sizeof(chain_protos)/sizeof(struct pprot))
+				exit_error(PARAMETER_PROBLEM,
+					   "unknown protocol `%s' specified",
+					   s);
+		}
+	}
+
+	return (u_int16_t)proto;
+}
+
+static void
+parse_interface(const char *arg, char *vianame, unsigned char *mask)
+{
+	int vialen = strlen(arg);
+	unsigned int i;
+
+	memset(mask, 0, IFNAMSIZ);
+	memset(vianame, 0, IFNAMSIZ);
+
+	if (vialen + 1 > IFNAMSIZ)
+		exit_error(PARAMETER_PROBLEM,
+			   "interface name `%s' must be shorter than IFNAMSIZ"
+			   " (%i)", arg, IFNAMSIZ-1);
+
+	strcpy(vianame, arg);
+	if (vialen == 0)
+		memset(mask, 0, IFNAMSIZ);
+	else if (vianame[vialen - 1] == '+') {
+		memset(mask, 0xFF, vialen - 1);
+		memset(mask + vialen - 1, 0, IFNAMSIZ - vialen + 1);
+		/* Don't remove `+' here! -HW */
+	} else {
+		/* Include nul-terminator in match */
+		memset(mask, 0xFF, vialen + 1);
+		memset(mask + vialen + 1, 0, IFNAMSIZ - vialen - 1);
+		for (i = 0; vianame[i]; i++) {
+			if (!isalnum(vianame[i]) 
+			    && vianame[i] != '_' 
+			    && vianame[i] != '.') {
+				printf("Warning: wierd character in interface"
+				       " `%s' (No aliases, :, ! or *).\n",
+				       vianame);
+				break;
+			}
+		}
+	}
+}
+
+/* Can't be zero. */
+static int
+parse_rulenumber(const char *rule)
+{
+	unsigned int rulenum;
+
+	if (string_to_number(rule, 1, INT_MAX, &rulenum) == -1)
+		exit_error(PARAMETER_PROBLEM,
+			   "Invalid rule number `%s'", rule);
+
+	return rulenum;
+}
+
+static const char *
+parse_target(const char *targetname)
+{
+	const char *ptr;
+
+	if (strlen(targetname) < 1)
+		exit_error(PARAMETER_PROBLEM,
+			   "Invalid target name (too short)");
+
+	if (strlen(targetname)+1 > sizeof(ipt_chainlabel))
+		exit_error(PARAMETER_PROBLEM,
+			   "Invalid target name `%s' (%i chars max)",
+			   targetname, sizeof(ipt_chainlabel)-1);
+
+	for (ptr = targetname; *ptr; ptr++)
+		if (isspace(*ptr))
+			exit_error(PARAMETER_PROBLEM,
+				   "Invalid target name `%s'", targetname);
+	return targetname;
+}
+
+static char *
+addr_to_network(const struct in_addr *addr)
+{
+	struct netent *net;
+
+	if ((net = getnetbyaddr((long) ntohl(addr->s_addr), AF_INET)) != NULL)
+		return (char *) net->n_name;
+
+	return (char *) NULL;
+}
+
+char *
+addr_to_dotted(const struct in_addr *addrp)
+{
+	static char buf[20];
+	const unsigned char *bytep;
+
+	bytep = (const unsigned char *) &(addrp->s_addr);
+	sprintf(buf, "%d.%d.%d.%d", bytep[0], bytep[1], bytep[2], bytep[3]);
+	return buf;
+}
+
+char *
+addr_to_anyname(const struct in_addr *addr)
+{
+	char *name;
+
+	if ((name = addr_to_host(addr)) != NULL ||
+	    (name = addr_to_network(addr)) != NULL)
+		return name;
+
+	return addr_to_dotted(addr);
+}
+
+char *
+mask_to_dotted(const struct in_addr *mask)
+{
+	int i;
+	static char buf[20];
+	u_int32_t maskaddr, bits;
+
+	maskaddr = ntohl(mask->s_addr);
+
+	if (maskaddr == 0xFFFFFFFFL)
+		/* we don't want to see "/32" */
+		return "";
+
+	i = 32;
+	bits = 0xFFFFFFFEL;
+	while (--i >= 0 && maskaddr != bits)
+		bits <<= 1;
+	if (i >= 0)
+		sprintf(buf, "/%d", i);
+	else
+		/* mask was not a decent combination of 1's and 0's */
+		sprintf(buf, "/%s", addr_to_dotted(mask));
+
+	return buf;
+}
+
+int
+string_to_number(const char *s, unsigned int min, unsigned int max,
+		 unsigned int *ret)
+{
+	long number;
+	char *end;
+
+	/* Handle hex, octal, etc. */
+	errno = 0;
+	number = strtol(s, &end, 0);
+	if (*end == '\0' && end != s) {
+		/* we parsed a number, let's see if we want this */
+		if (errno != ERANGE && min <= number && number <= max) {
+			*ret = number;
+			return 0;
+		}
+	}
+	return -1;
+}
+
+static void
+set_option(unsigned int *options, unsigned int option, u_int8_t *invflg,
+	   int invert)
+{
+	if (*options & option)
+		exit_error(PARAMETER_PROBLEM, "multiple -%c flags not allowed",
+			   opt2char(option));
+	*options |= option;
+
+	if (invert) {
+		unsigned int i;
+		for (i = 0; 1 << i != option; i++);
+
+		if (!inverse_for_options[i])
+			exit_error(PARAMETER_PROBLEM,
+				   "cannot have ! before -%c",
+				   opt2char(option));
+		*invflg |= inverse_for_options[i];
+	}
+}
+
+struct iptables_target *
+find_target(const char *name, enum ipt_tryload tryload)
+{
+	struct iptables_target *ptr;
+
+	/* Standard target? */
+	if (strcmp(name, "") == 0
+	    || strcmp(name, IPTC_LABEL_ACCEPT) == 0
+	    || strcmp(name, IPTC_LABEL_DROP) == 0
+	    || strcmp(name, IPTC_LABEL_QUEUE) == 0
+	    || strcmp(name, IPTC_LABEL_RETURN) == 0)
+		name = "standard";
+
+	for (ptr = iptables_targets; ptr; ptr = ptr->next) {
+		if (strcmp(name, ptr->name) == 0)
+			break;
+	}
+
+#ifndef NO_SHARED_LIBS
+	if (!ptr && tryload != DONT_LOAD) {
+		char path[sizeof(IPT_LIB_DIR) + sizeof("/libipt_.so")
+			 + strlen(name)];
+		sprintf(path, IPT_LIB_DIR "/libipt_%s.so", name);
+		if (dlopen(path, RTLD_NOW)) {
+			/* Found library.  If it didn't register itself,
+			   maybe they specified match as a target. */
+			ptr = find_target(name, DONT_LOAD);
+			if (!ptr)
+				exit_error(PARAMETER_PROBLEM,
+					   "Couldn't load target `%s'\n",
+					   name);
+		} else if (tryload == LOAD_MUST_SUCCEED)
+			exit_error(PARAMETER_PROBLEM,
+				   "Couldn't load target `%s':%s\n",
+				   name, dlerror());
+	}
+#else
+	if (ptr && !ptr->loaded) {
+		if (tryload != DONT_LOAD)
+			ptr->loaded = 1;
+		else
+			ptr = NULL;
+	}
+	if(!ptr && (tryload == LOAD_MUST_SUCCEED)) {
+		exit_error(PARAMETER_PROBLEM,
+			   "Couldn't find target `%s'\n", name);
+	}
+#endif
+
+	if (ptr)
+		ptr->used = 1;
+
+	return ptr;
+}
+
+static struct option *
+merge_options(struct option *oldopts, const struct option *newopts,
+	      unsigned int *option_offset)
+{
+	unsigned int num_old, num_new, i;
+	struct option *merge;
+
+	for (num_old = 0; oldopts[num_old].name; num_old++);
+	for (num_new = 0; newopts[num_new].name; num_new++);
+
+	global_option_offset += OPTION_OFFSET;
+	*option_offset = global_option_offset;
+
+	merge = malloc(sizeof(struct option) * (num_new + num_old + 1));
+	memcpy(merge, oldopts, num_old * sizeof(struct option));
+	for (i = 0; i < num_new; i++) {
+		merge[num_old + i] = newopts[i];
+		merge[num_old + i].val += *option_offset;
+	}
+	memset(merge + num_old + num_new, 0, sizeof(struct option));
+
+	return merge;
+}
+
+void
+register_match(struct iptables_match *me)
+{
+	struct iptables_match **i;
+
+	if (strcmp(me->version, program_version) != 0) {
+		fprintf(stderr, "%s: match `%s' v%s (I'm v%s).\n",
+			program_name, me->name, me->version, program_version);
+		exit(1);
+	}
+
+	if (find_match(me->name, DONT_LOAD)) {
+		fprintf(stderr, "%s: match `%s' already registered.\n",
+			program_name, me->name);
+		exit(1);
+	}
+
+	if (me->size != IPT_ALIGN(me->size)) {
+		fprintf(stderr, "%s: match `%s' has invalid size %u.\n",
+			program_name, me->name, me->size);
+		exit(1);
+	}
+
+	/* Append to list. */
+	for (i = &iptables_matches; *i; i = &(*i)->next);
+	me->next = NULL;
+	*i = me;
+
+	me->m = NULL;
+	me->mflags = 0;
+}
+
+void
+register_target(struct iptables_target *me)
+{
+	if (strcmp(me->version, program_version) != 0) {
+		fprintf(stderr, "%s: target `%s' v%s (I'm v%s).\n",
+			program_name, me->name, me->version, program_version);
+		exit(1);
+	}
+
+	if (find_target(me->name, DONT_LOAD)) {
+		fprintf(stderr, "%s: target `%s' already registered.\n",
+			program_name, me->name);
+		exit(1);
+	}
+
+	if (me->size != IPT_ALIGN(me->size)) {
+		fprintf(stderr, "%s: target `%s' has invalid size %u.\n",
+			program_name, me->name, me->size);
+		exit(1);
+	}
+
+	/* Prepend to list. */
+	me->next = iptables_targets;
+	iptables_targets = me;
+	me->t = NULL;
+	me->tflags = 0;
+}
+
+static void
+print_num(u_int64_t number, unsigned int format)
+{
+	if (format & FMT_KILOMEGAGIGA) {
+		if (number > 99999) {
+			number = (number + 500) / 1000;
+			if (number > 9999) {
+				number = (number + 500) / 1000;
+				if (number > 9999) {
+					number = (number + 500) / 1000;
+					if (number > 9999) {
+						number = (number + 500) / 1000;
+						printf(FMT("%4lluT ","%lluT "), number);
+					}
+					else printf(FMT("%4lluG ","%lluG "), number);
+				}
+				else printf(FMT("%4lluM ","%lluM "), number);
+			} else
+				printf(FMT("%4lluK ","%lluK "), number);
+		} else
+			printf(FMT("%5llu ","%llu "), number);
+	} else
+		printf(FMT("%8llu ","%llu "), number);
+}
+
+
+static void
+print_header(unsigned int format, const char *chain, iptc_handle_t *handle)
+{
+	struct ipt_counters counters;
+	const char *pol = iptc_get_policy(chain, &counters, handle);
+	printf("Chain %s", chain);
+	if (pol) {
+		printf(" (policy %s", pol);
+		if (!(format & FMT_NOCOUNTS)) {
+			fputc(' ', stdout);
+			print_num(counters.pcnt, (format|FMT_NOTABLE));
+			fputs("packets, ", stdout);
+			print_num(counters.bcnt, (format|FMT_NOTABLE));
+			fputs("bytes", stdout);
+		}
+		printf(")\n");
+	} else {
+		unsigned int refs;
+		if (!iptc_get_references(&refs, chain, handle))
+			printf(" (ERROR obtaining refs)\n");
+		else
+			printf(" (%u references)\n", refs);
+	}
+
+	if (format & FMT_LINENUMBERS)
+		printf(FMT("%-4s ", "%s "), "num");
+	if (!(format & FMT_NOCOUNTS)) {
+		if (format & FMT_KILOMEGAGIGA) {
+			printf(FMT("%5s ","%s "), "pkts");
+			printf(FMT("%5s ","%s "), "bytes");
+		} else {
+			printf(FMT("%8s ","%s "), "pkts");
+			printf(FMT("%10s ","%s "), "bytes");
+		}
+	}
+	if (!(format & FMT_NOTARGET))
+		printf(FMT("%-9s ","%s "), "target");
+	fputs(" prot ", stdout);
+	if (format & FMT_OPTIONS)
+		fputs("opt", stdout);
+	if (format & FMT_VIA) {
+		printf(FMT(" %-6s ","%s "), "in");
+		printf(FMT("%-6s ","%s "), "out");
+	}
+	printf(FMT(" %-19s ","%s "), "source");
+	printf(FMT(" %-19s "," %s "), "destination");
+	printf("\n");
+}
+
+
+static int
+print_match(const struct ipt_entry_match *m,
+	    const struct ipt_ip *ip,
+	    int numeric)
+{
+	struct iptables_match *match = find_match(m->u.user.name, TRY_LOAD);
+
+	if (match) {
+		if (match->print)
+			match->print(ip, m, numeric);
+		else
+			printf("%s ", match->name);
+	} else {
+		if (m->u.user.name[0])
+			printf("UNKNOWN match `%s' ", m->u.user.name);
+	}
+	/* Don't stop iterating. */
+	return 0;
+}
+
+/* e is called `fw' here for hysterical raisins */
+static void
+print_firewall(const struct ipt_entry *fw,
+	       const char *targname,
+	       unsigned int num,
+	       unsigned int format,
+	       const iptc_handle_t handle)
+{
+	struct iptables_target *target = NULL;
+	const struct ipt_entry_target *t;
+	u_int8_t flags;
+	char buf[BUFSIZ];
+
+	if (!iptc_is_chain(targname, handle))
+		target = find_target(targname, TRY_LOAD);
+	else
+		target = find_target(IPT_STANDARD_TARGET, LOAD_MUST_SUCCEED);
+
+	t = ipt_get_target((struct ipt_entry *)fw);
+	flags = fw->ip.flags;
+
+	if (format & FMT_LINENUMBERS)
+		printf(FMT("%-4u ", "%u "), num+1);
+
+	if (!(format & FMT_NOCOUNTS)) {
+		print_num(fw->counters.pcnt, format);
+		print_num(fw->counters.bcnt, format);
+	}
+
+	if (!(format & FMT_NOTARGET))
+		printf(FMT("%-9s ", "%s "), targname);
+
+	fputc(fw->ip.invflags & IPT_INV_PROTO ? '!' : ' ', stdout);
+	{
+		char *pname = proto_to_name(fw->ip.proto, format&FMT_NUMERIC);
+		if (pname)
+			printf(FMT("%-5s", "%s "), pname);
+		else
+			printf(FMT("%-5hu", "%hu "), fw->ip.proto);
+	}
+
+	if (format & FMT_OPTIONS) {
+		if (format & FMT_NOTABLE)
+			fputs("opt ", stdout);
+		fputc(fw->ip.invflags & IPT_INV_FRAG ? '!' : '-', stdout);
+		fputc(flags & IPT_F_FRAG ? 'f' : '-', stdout);
+		fputc(' ', stdout);
+	}
+
+	if (format & FMT_VIA) {
+		char iface[IFNAMSIZ+2];
+
+		if (fw->ip.invflags & IPT_INV_VIA_IN) {
+			iface[0] = '!';
+			iface[1] = '\0';
+		}
+		else iface[0] = '\0';
+
+		if (fw->ip.iniface[0] != '\0') {
+			strcat(iface, fw->ip.iniface);
+		}
+		else if (format & FMT_NUMERIC) strcat(iface, "*");
+		else strcat(iface, "any");
+		printf(FMT(" %-6s ","in %s "), iface);
+
+		if (fw->ip.invflags & IPT_INV_VIA_OUT) {
+			iface[0] = '!';
+			iface[1] = '\0';
+		}
+		else iface[0] = '\0';
+
+		if (fw->ip.outiface[0] != '\0') {
+			strcat(iface, fw->ip.outiface);
+		}
+		else if (format & FMT_NUMERIC) strcat(iface, "*");
+		else strcat(iface, "any");
+		printf(FMT("%-6s ","out %s "), iface);
+	}
+
+	fputc(fw->ip.invflags & IPT_INV_SRCIP ? '!' : ' ', stdout);
+	if (fw->ip.smsk.s_addr == 0L && !(format & FMT_NUMERIC))
+		printf(FMT("%-19s ","%s "), "anywhere");
+	else {
+		if (format & FMT_NUMERIC)
+			sprintf(buf, "%s", addr_to_dotted(&(fw->ip.src)));
+		else
+			sprintf(buf, "%s", addr_to_anyname(&(fw->ip.src)));
+		strcat(buf, mask_to_dotted(&(fw->ip.smsk)));
+		printf(FMT("%-19s ","%s "), buf);
+	}
+
+	fputc(fw->ip.invflags & IPT_INV_DSTIP ? '!' : ' ', stdout);
+	if (fw->ip.dmsk.s_addr == 0L && !(format & FMT_NUMERIC))
+		printf(FMT("%-19s","-> %s"), "anywhere");
+	else {
+		if (format & FMT_NUMERIC)
+			sprintf(buf, "%s", addr_to_dotted(&(fw->ip.dst)));
+		else
+			sprintf(buf, "%s", addr_to_anyname(&(fw->ip.dst)));
+		strcat(buf, mask_to_dotted(&(fw->ip.dmsk)));
+		printf(FMT("%-19s","-> %s"), buf);
+	}
+
+	if (format & FMT_NOTABLE)
+		fputs("  ", stdout);
+
+	IPT_MATCH_ITERATE(fw, print_match, &fw->ip, format & FMT_NUMERIC);
+
+	if (target) {
+		if (target->print)
+			/* Print the target information. */
+			target->print(&fw->ip, t, format & FMT_NUMERIC);
+	} else if (t->u.target_size != sizeof(*t))
+		printf("[%u bytes of unknown target data] ",
+		       t->u.target_size - sizeof(*t));
+
+	if (!(format & FMT_NONEWLINE))
+		fputc('\n', stdout);
+}
+
+static void
+print_firewall_line(const struct ipt_entry *fw,
+		    const iptc_handle_t h)
+{
+	struct ipt_entry_target *t;
+
+	t = ipt_get_target((struct ipt_entry *)fw);
+	print_firewall(fw, t->u.user.name, 0, FMT_PRINT_RULE, h);
+}
+
+static int
+append_entry(const ipt_chainlabel chain,
+	     struct ipt_entry *fw,
+	     unsigned int nsaddrs,
+	     const struct in_addr saddrs[],
+	     unsigned int ndaddrs,
+	     const struct in_addr daddrs[],
+	     int verbose,
+	     iptc_handle_t *handle)
+{
+	unsigned int i, j;
+	int ret = 1;
+
+	for (i = 0; i < nsaddrs; i++) {
+		fw->ip.src.s_addr = saddrs[i].s_addr;
+		for (j = 0; j < ndaddrs; j++) {
+			fw->ip.dst.s_addr = daddrs[j].s_addr;
+			if (verbose)
+				print_firewall_line(fw, *handle);
+			ret &= iptc_append_entry(chain, fw, handle);
+		}
+	}
+
+	return ret;
+}
+
+static int
+replace_entry(const ipt_chainlabel chain,
+	      struct ipt_entry *fw,
+	      unsigned int rulenum,
+	      const struct in_addr *saddr,
+	      const struct in_addr *daddr,
+	      int verbose,
+	      iptc_handle_t *handle)
+{
+	fw->ip.src.s_addr = saddr->s_addr;
+	fw->ip.dst.s_addr = daddr->s_addr;
+
+	if (verbose)
+		print_firewall_line(fw, *handle);
+	return iptc_replace_entry(chain, fw, rulenum, handle);
+}
+
+static int
+insert_entry(const ipt_chainlabel chain,
+	     struct ipt_entry *fw,
+	     unsigned int rulenum,
+	     unsigned int nsaddrs,
+	     const struct in_addr saddrs[],
+	     unsigned int ndaddrs,
+	     const struct in_addr daddrs[],
+	     int verbose,
+	     iptc_handle_t *handle)
+{
+	unsigned int i, j;
+	int ret = 1;
+
+	for (i = 0; i < nsaddrs; i++) {
+		fw->ip.src.s_addr = saddrs[i].s_addr;
+		for (j = 0; j < ndaddrs; j++) {
+			fw->ip.dst.s_addr = daddrs[j].s_addr;
+			if (verbose)
+				print_firewall_line(fw, *handle);
+			ret &= iptc_insert_entry(chain, fw, rulenum, handle);
+		}
+	}
+
+	return ret;
+}
+
+static unsigned char *
+make_delete_mask(struct ipt_entry *fw)
+{
+	/* Establish mask for comparison */
+	unsigned int size;
+	struct iptables_match *m;
+	unsigned char *mask, *mptr;
+
+	size = sizeof(struct ipt_entry);
+	for (m = iptables_matches; m; m = m->next) {
+		if (!m->used)
+			continue;
+
+		size += IPT_ALIGN(sizeof(struct ipt_entry_match)) + m->size;
+	}
+
+	mask = fw_calloc(1, size
+			 + IPT_ALIGN(sizeof(struct ipt_entry_target))
+			 + iptables_targets->size);
+
+	memset(mask, 0xFF, sizeof(struct ipt_entry));
+	mptr = mask + sizeof(struct ipt_entry);
+
+	for (m = iptables_matches; m; m = m->next) {
+		if (!m->used)
+			continue;
+
+		memset(mptr, 0xFF,
+		       IPT_ALIGN(sizeof(struct ipt_entry_match))
+		       + m->userspacesize);
+		mptr += IPT_ALIGN(sizeof(struct ipt_entry_match)) + m->size;
+	}
+
+	memset(mptr, 0xFF,
+	       IPT_ALIGN(sizeof(struct ipt_entry_target))
+	       + iptables_targets->userspacesize);
+
+	return mask;
+}
+
+static int
+delete_entry(const ipt_chainlabel chain,
+	     struct ipt_entry *fw,
+	     unsigned int nsaddrs,
+	     const struct in_addr saddrs[],
+	     unsigned int ndaddrs,
+	     const struct in_addr daddrs[],
+	     int verbose,
+	     iptc_handle_t *handle)
+{
+	unsigned int i, j;
+	int ret = 1;
+	unsigned char *mask;
+
+	mask = make_delete_mask(fw);
+	for (i = 0; i < nsaddrs; i++) {
+		fw->ip.src.s_addr = saddrs[i].s_addr;
+		for (j = 0; j < ndaddrs; j++) {
+			fw->ip.dst.s_addr = daddrs[j].s_addr;
+			if (verbose)
+				print_firewall_line(fw, *handle);
+			ret &= iptc_delete_entry(chain, fw, mask, handle);
+		}
+	}
+	return ret;
+}
+
+int
+for_each_chain(int (*fn)(const ipt_chainlabel, int, iptc_handle_t *),
+	       int verbose, int builtinstoo, iptc_handle_t *handle)
+{
+        int ret = 1;
+	const char *chain;
+	char *chains;
+	unsigned int i, chaincount = 0;
+
+	chain = iptc_first_chain(handle);
+	while (chain) {
+		chaincount++;
+		chain = iptc_next_chain(handle);
+        }
+
+	chains = fw_malloc(sizeof(ipt_chainlabel) * chaincount);
+	i = 0;
+	chain = iptc_first_chain(handle);
+	while (chain) {
+		strcpy(chains + i*sizeof(ipt_chainlabel), chain);
+		i++;
+		chain = iptc_next_chain(handle);
+        }
+
+	for (i = 0; i < chaincount; i++) {
+		if (!builtinstoo
+		    && iptc_builtin(chains + i*sizeof(ipt_chainlabel),
+				    *handle))
+			continue;
+	        ret &= fn(chains + i*sizeof(ipt_chainlabel), verbose, handle);
+	}
+
+	free(chains);
+        return ret;
+}
+
+int
+flush_entries(const ipt_chainlabel chain, int verbose,
+	      iptc_handle_t *handle)
+{
+	if (!chain)
+		return for_each_chain(flush_entries, verbose, 1, handle);
+
+	if (verbose)
+		fprintf(stdout, "Flushing chain `%s'\n", chain);
+	return iptc_flush_entries(chain, handle);
+}
+
+static int
+zero_entries(const ipt_chainlabel chain, int verbose,
+	     iptc_handle_t *handle)
+{
+	if (!chain)
+		return for_each_chain(zero_entries, verbose, 1, handle);
+
+	if (verbose)
+		fprintf(stdout, "Zeroing chain `%s'\n", chain);
+	return iptc_zero_entries(chain, handle);
+}
+
+int
+delete_chain(const ipt_chainlabel chain, int verbose,
+	     iptc_handle_t *handle)
+{
+	if (!chain)
+		return for_each_chain(delete_chain, verbose, 0, handle);
+
+	if (verbose)
+	        fprintf(stdout, "Deleting chain `%s'\n", chain);
+	return iptc_delete_chain(chain, handle);
+}
+
+static int
+list_entries(const ipt_chainlabel chain, int verbose, int numeric,
+	     int expanded, int linenumbers, iptc_handle_t *handle)
+{
+	int found = 0;
+	unsigned int format;
+	const char *this;
+
+	format = FMT_OPTIONS;
+	if (!verbose)
+		format |= FMT_NOCOUNTS;
+	else
+		format |= FMT_VIA;
+
+	if (numeric)
+		format |= FMT_NUMERIC;
+
+	if (!expanded)
+		format |= FMT_KILOMEGAGIGA;
+
+	if (linenumbers)
+		format |= FMT_LINENUMBERS;
+
+	for (this = iptc_first_chain(handle);
+	     this;
+	     this = iptc_next_chain(handle)) {
+		const struct ipt_entry *i;
+		unsigned int num;
+
+		if (chain && strcmp(chain, this) != 0)
+			continue;
+
+		if (found) printf("\n");
+
+		print_header(format, this, handle);
+		i = iptc_first_rule(this, handle);
+
+		num = 0;
+		while (i) {
+			print_firewall(i,
+				       iptc_get_target(i, handle),
+				       num++,
+				       format,
+				       *handle);
+			i = iptc_next_rule(i, handle);
+		}
+		found = 1;
+	}
+
+	errno = ENOENT;
+	return found;
+}
+
+static char *get_modprobe(void)
+{
+	int procfile;
+	char *ret;
+
+	procfile = open(PROC_SYS_MODPROBE, O_RDONLY);
+	if (procfile < 0)
+		return NULL;
+
+	ret = malloc(1024);
+	if (ret) {
+		switch (read(procfile, ret, 1024)) {
+		case -1: goto fail;
+		case 1024: goto fail; /* Partial read.  Wierd */
+		}
+		if (ret[strlen(ret)-1]=='\n') 
+			ret[strlen(ret)-1]=0;
+		close(procfile);
+		return ret;
+	}
+ fail:
+	free(ret);
+	close(procfile);
+	return NULL;
+}
+
+int iptables_insmod(const char *modname, const char *modprobe)
+{
+	char *buf = NULL;
+	char *argv[3];
+
+	/* If they don't explicitly set it, read out of kernel */
+	if (!modprobe) {
+		buf = get_modprobe();
+		if (!buf)
+			return -1;
+		modprobe = buf;
+	}
+
+	switch (fork()) {
+	case 0:
+		argv[0] = (char *)modprobe;
+		argv[1] = (char *)modname;
+		argv[2] = NULL;
+		execv(argv[0], argv);
+
+		/* not usually reached */
+		exit(0);
+	case -1:
+		return -1;
+
+	default: /* parent */
+		wait(NULL);
+	}
+
+	free(buf);
+	return 0;
+}
+
+static struct ipt_entry *
+generate_entry(const struct ipt_entry *fw,
+	       struct iptables_match *matches,
+	       struct ipt_entry_target *target)
+{
+	unsigned int size;
+	struct iptables_match *m;
+	struct ipt_entry *e;
+
+	size = sizeof(struct ipt_entry);
+	for (m = matches; m; m = m->next) {
+		if (!m->used)
+			continue;
+
+		size += m->m->u.match_size;
+	}
+
+	e = fw_malloc(size + target->u.target_size);
+	*e = *fw;
+	e->target_offset = size;
+	e->next_offset = size + target->u.target_size;
+
+	size = 0;
+	for (m = matches; m; m = m->next) {
+		if (!m->used)
+			continue;
+
+		memcpy(e->elems + size, m->m, m->m->u.match_size);
+		size += m->m->u.match_size;
+	}
+	memcpy(e->elems + size, target, target->u.target_size);
+
+	return e;
+}
+
+int do_command(int argc, char *argv[], char **table, iptc_handle_t *handle)
+{
+	struct ipt_entry fw, *e = NULL;
+	int invert = 0;
+	unsigned int nsaddrs = 0, ndaddrs = 0;
+	struct in_addr *saddrs = NULL, *daddrs = NULL;
+
+	int c, verbose = 0;
+	const char *chain = NULL;
+	const char *shostnetworkmask = NULL, *dhostnetworkmask = NULL;
+	const char *policy = NULL, *newname = NULL;
+	unsigned int rulenum = 0, options = 0, command = 0;
+	const char *pcnt = NULL, *bcnt = NULL;
+	int ret = 1;
+	struct iptables_match *m;
+	struct iptables_target *target = NULL;
+	struct iptables_target *t;
+	const char *jumpto = "";
+	char *protocol = NULL;
+	const char *modprobe = NULL;
+	int proto_used = 0;
+
+	memset(&fw, 0, sizeof(fw));
+
+	opts = original_opts;
+	global_option_offset = 0;
+
+	/* re-set optind to 0 in case do_command gets called
+	 * a second time */
+	optind = 0;
+
+	/* clear mflags in case do_command gets called a second time
+	 * (we clear the global list of all matches for security)*/
+	for (m = iptables_matches; m; m = m->next) {
+		m->mflags = 0;
+		m->used = 0;
+	}
+
+	for (t = iptables_targets; t; t = t->next) {
+		t->tflags = 0;
+		t->used = 0;
+	}
+
+	/* Suppress error messages: we may add new options if we
+           demand-load a protocol. */
+	opterr = 0;
+
+	while ((c = getopt_long(argc, argv,
+	   "-A:D:R:I:L::M:F::Z::N:X::E:P:Vh::o:p:s:d:j:i:fbvnt:m:xc:",
+					   opts, NULL)) != -1) {
+		switch (c) {
+			/*
+			 * Command selection
+			 */
+		case 'A':
+			add_command(&command, CMD_APPEND, CMD_NONE,
+				    invert);
+			chain = optarg;
+			break;
+
+		case 'D':
+			add_command(&command, CMD_DELETE, CMD_NONE,
+				    invert);
+			chain = optarg;
+			if (optind < argc && argv[optind][0] != '-'
+			    && argv[optind][0] != '!') {
+				rulenum = parse_rulenumber(argv[optind++]);
+				command = CMD_DELETE_NUM;
+			}
+			break;
+
+		case 'R':
+			add_command(&command, CMD_REPLACE, CMD_NONE,
+				    invert);
+			chain = optarg;
+			if (optind < argc && argv[optind][0] != '-'
+			    && argv[optind][0] != '!')
+				rulenum = parse_rulenumber(argv[optind++]);
+			else
+				exit_error(PARAMETER_PROBLEM,
+					   "-%c requires a rule number",
+					   cmd2char(CMD_REPLACE));
+			break;
+
+		case 'I':
+			add_command(&command, CMD_INSERT, CMD_NONE,
+				    invert);
+			chain = optarg;
+			if (optind < argc && argv[optind][0] != '-'
+			    && argv[optind][0] != '!')
+				rulenum = parse_rulenumber(argv[optind++]);
+			else rulenum = 1;
+			break;
+
+		case 'L':
+			add_command(&command, CMD_LIST, CMD_ZERO,
+				    invert);
+			if (optarg) chain = optarg;
+			else if (optind < argc && argv[optind][0] != '-'
+				 && argv[optind][0] != '!')
+				chain = argv[optind++];
+			break;
+
+		case 'F':
+			add_command(&command, CMD_FLUSH, CMD_NONE,
+				    invert);
+			if (optarg) chain = optarg;
+			else if (optind < argc && argv[optind][0] != '-'
+				 && argv[optind][0] != '!')
+				chain = argv[optind++];
+			break;
+
+		case 'Z':
+			add_command(&command, CMD_ZERO, CMD_LIST,
+				    invert);
+			if (optarg) chain = optarg;
+			else if (optind < argc && argv[optind][0] != '-'
+				&& argv[optind][0] != '!')
+				chain = argv[optind++];
+			break;
+
+		case 'N':
+			if (optarg && *optarg == '-')
+				exit_error(PARAMETER_PROBLEM,
+					   "chain name not allowed to start "
+					   "with `-'\n");
+			if (find_target(optarg, TRY_LOAD))
+				exit_error(PARAMETER_PROBLEM,
+					   "chain name may not clash "
+					   "with target name\n");
+			add_command(&command, CMD_NEW_CHAIN, CMD_NONE,
+				    invert);
+			chain = optarg;
+			break;
+
+		case 'X':
+			add_command(&command, CMD_DELETE_CHAIN, CMD_NONE,
+				    invert);
+			if (optarg) chain = optarg;
+			else if (optind < argc && argv[optind][0] != '-'
+				 && argv[optind][0] != '!')
+				chain = argv[optind++];
+			break;
+
+		case 'E':
+			add_command(&command, CMD_RENAME_CHAIN, CMD_NONE,
+				    invert);
+			chain = optarg;
+			if (optind < argc && argv[optind][0] != '-'
+			    && argv[optind][0] != '!')
+				newname = argv[optind++];
+			else
+				exit_error(PARAMETER_PROBLEM,
+				           "-%c requires old-chain-name and "
+					   "new-chain-name",
+					    cmd2char(CMD_RENAME_CHAIN));
+			break;
+
+		case 'P':
+			add_command(&command, CMD_SET_POLICY, CMD_NONE,
+				    invert);
+			chain = optarg;
+			if (optind < argc && argv[optind][0] != '-'
+			    && argv[optind][0] != '!')
+				policy = argv[optind++];
+			else
+				exit_error(PARAMETER_PROBLEM,
+					   "-%c requires a chain and a policy",
+					   cmd2char(CMD_SET_POLICY));
+			break;
+
+		case 'h':
+			if (!optarg)
+				optarg = argv[optind];
+
+			/* iptables -p icmp -h */
+			if (!iptables_matches && protocol)
+				find_match(protocol, TRY_LOAD);
+
+			exit_printhelp();
+
+			/*
+			 * Option selection
+			 */
+		case 'p':
+			check_inverse(optarg, &invert, &optind, argc);
+			set_option(&options, OPT_PROTOCOL, &fw.ip.invflags,
+				   invert);
+
+			/* Canonicalize into lower case */
+			for (protocol = argv[optind-1]; *protocol; protocol++)
+				*protocol = tolower(*protocol);
+
+			protocol = argv[optind-1];
+			fw.ip.proto = parse_protocol(protocol);
+
+			if (fw.ip.proto == 0
+			    && (fw.ip.invflags & IPT_INV_PROTO))
+				exit_error(PARAMETER_PROBLEM,
+					   "rule would never match protocol");
+			fw.nfcache |= NFC_IP_PROTO;
+			break;
+
+		case 's':
+			check_inverse(optarg, &invert, &optind, argc);
+			set_option(&options, OPT_SOURCE, &fw.ip.invflags,
+				   invert);
+			shostnetworkmask = argv[optind-1];
+			fw.nfcache |= NFC_IP_SRC;
+			break;
+
+		case 'd':
+			check_inverse(optarg, &invert, &optind, argc);
+			set_option(&options, OPT_DESTINATION, &fw.ip.invflags,
+				   invert);
+			dhostnetworkmask = argv[optind-1];
+			fw.nfcache |= NFC_IP_DST;
+			break;
+
+		case 'j':
+			set_option(&options, OPT_JUMP, &fw.ip.invflags,
+				   invert);
+			jumpto = parse_target(optarg);
+			/* TRY_LOAD (may be chain name) */
+			target = find_target(jumpto, TRY_LOAD);
+
+			if (target) {
+				size_t size;
+
+				size = IPT_ALIGN(sizeof(struct ipt_entry_target))
+					+ target->size;
+
+				target->t = fw_calloc(1, size);
+				target->t->u.target_size = size;
+				strcpy(target->t->u.user.name, jumpto);
+				target->init(target->t, &fw.nfcache);
+				opts = merge_options(opts, target->extra_opts, &target->option_offset);
+			}
+			break;
+
+
+		case 'i':
+			check_inverse(optarg, &invert, &optind, argc);
+			set_option(&options, OPT_VIANAMEIN, &fw.ip.invflags,
+				   invert);
+			parse_interface(argv[optind-1],
+					fw.ip.iniface,
+					fw.ip.iniface_mask);
+			fw.nfcache |= NFC_IP_IF_IN;
+			break;
+
+		case 'o':
+			check_inverse(optarg, &invert, &optind, argc);
+			set_option(&options, OPT_VIANAMEOUT, &fw.ip.invflags,
+				   invert);
+			parse_interface(argv[optind-1],
+					fw.ip.outiface,
+					fw.ip.outiface_mask);
+			fw.nfcache |= NFC_IP_IF_OUT;
+			break;
+
+		case 'f':
+			set_option(&options, OPT_FRAGMENT, &fw.ip.invflags,
+				   invert);
+			fw.ip.flags |= IPT_F_FRAG;
+			fw.nfcache |= NFC_IP_FRAG;
+			break;
+
+		case 'v':
+			if (!verbose)
+				set_option(&options, OPT_VERBOSE,
+					   &fw.ip.invflags, invert);
+			verbose++;
+			break;
+
+		case 'm': {
+			size_t size;
+
+			if (invert)
+				exit_error(PARAMETER_PROBLEM,
+					   "unexpected ! flag before --match");
+
+			m = find_match(optarg, LOAD_MUST_SUCCEED);
+			size = IPT_ALIGN(sizeof(struct ipt_entry_match))
+					 + m->size;
+			m->m = fw_calloc(1, size);
+			m->m->u.match_size = size;
+			strcpy(m->m->u.user.name, m->name);
+			m->init(m->m, &fw.nfcache);
+			opts = merge_options(opts, m->extra_opts, &m->option_offset);
+		}
+		break;
+
+		case 'n':
+			set_option(&options, OPT_NUMERIC, &fw.ip.invflags,
+				   invert);
+			break;
+
+		case 't':
+			if (invert)
+				exit_error(PARAMETER_PROBLEM,
+					   "unexpected ! flag before --table");
+			*table = argv[optind-1];
+			break;
+
+		case 'x':
+			set_option(&options, OPT_EXPANDED, &fw.ip.invflags,
+				   invert);
+			break;
+
+		case 'V':
+			if (invert)
+				printf("Not %s ;-)\n", program_version);
+			else
+				printf("%s v%s\n",
+				       program_name, program_version);
+			exit(0);
+
+		case '0':
+			set_option(&options, OPT_LINENUMBERS, &fw.ip.invflags,
+				   invert);
+			break;
+
+		case 'M':
+			modprobe = optarg;
+			break;
+
+		case 'c':
+
+			set_option(&options, OPT_COUNTERS, &fw.ip.invflags,
+				   invert);
+			pcnt = optarg;
+			if (optind < argc && argv[optind][0] != '-'
+			    && argv[optind][0] != '!')
+				bcnt = argv[optind++];
+			else
+				exit_error(PARAMETER_PROBLEM,
+					"-%c requires packet and byte counter",
+					opt2char(OPT_COUNTERS));
+
+			if (sscanf(pcnt, "%llu", &fw.counters.pcnt) != 1)
+				exit_error(PARAMETER_PROBLEM,
+					"-%c packet counter not numeric",
+					opt2char(OPT_COUNTERS));
+
+			if (sscanf(bcnt, "%llu", &fw.counters.bcnt) != 1)
+				exit_error(PARAMETER_PROBLEM,
+					"-%c byte counter not numeric",
+					opt2char(OPT_COUNTERS));
+			
+			break;
+
+
+		case 1: /* non option */
+			if (optarg[0] == '!' && optarg[1] == '\0') {
+				if (invert)
+					exit_error(PARAMETER_PROBLEM,
+						   "multiple consecutive ! not"
+						   " allowed");
+				invert = TRUE;
+				optarg[0] = '\0';
+				continue;
+			}
+			printf("Bad argument `%s'\n", optarg);
+			exit_tryhelp(2);
+
+		default:
+			/* FIXME: This scheme doesn't allow two of the same
+			   matches --RR */
+			if (!target
+			    || !(target->parse(c - target->option_offset,
+					       argv, invert,
+					       &target->tflags,
+					       &fw, &target->t))) {
+				for (m = iptables_matches; m; m = m->next) {
+					if (!m->used)
+						continue;
+
+					if (m->parse(c - m->option_offset,
+						     argv, invert,
+						     &m->mflags,
+						     &fw,
+						     &fw.nfcache,
+						     &m->m))
+						break;
+				}
+
+				/* If you listen carefully, you can
+				   actually hear this code suck. */
+
+				/* some explanations (after four different bugs
+				 * in 3 different releases): If we encountere a
+				 * parameter, that has not been parsed yet,
+				 * it's not an option of an explicitly loaded
+				 * match or a target.  However, we support
+				 * implicit loading of the protocol match
+				 * extension.  '-p tcp' means 'l4 proto 6' and
+				 * at the same time 'load tcp protocol match on
+				 * demand if we specify --dport'.
+				 *
+				 * To make this work, we need to make sure:
+				 * - the parameter has not been parsed by
+				 *   a match (m above)
+				 * - a protocol has been specified
+				 * - the protocol extension has not been
+				 *   loaded yet, or is loaded and unused
+				 *   [think of iptables-restore!]
+				 * - the protocol extension can be successively
+				 *   loaded
+				 */
+				if (m == NULL
+				    && protocol
+				    && (!find_proto(protocol, DONT_LOAD,
+						   options&OPT_NUMERIC) 
+					|| (find_proto(protocol, DONT_LOAD,
+							options&OPT_NUMERIC)
+					    && (proto_used == 0))
+				       )
+				    && (m = find_proto(protocol, TRY_LOAD,
+						       options&OPT_NUMERIC))) {
+					/* Try loading protocol */
+					size_t size;
+					
+					proto_used = 1;
+
+					size = IPT_ALIGN(sizeof(struct ipt_entry_match))
+							 + m->size;
+
+					m->m = fw_calloc(1, size);
+					m->m->u.match_size = size;
+					strcpy(m->m->u.user.name, m->name);
+					m->init(m->m, &fw.nfcache);
+
+					opts = merge_options(opts,
+					    m->extra_opts, &m->option_offset);
+
+					optind--;
+					continue;
+				}
+				if (!m)
+					exit_error(PARAMETER_PROBLEM,
+						   "Unknown arg `%s'",
+						   argv[optind-1]);
+			}
+		}
+		invert = FALSE;
+	}
+
+	for (m = iptables_matches; m; m = m->next) {
+		if (!m->used)
+			continue;
+
+		m->final_check(m->mflags);
+	}
+
+	if (target)
+		target->final_check(target->tflags);
+
+	/* Fix me: must put inverse options checking here --MN */
+
+	if (optind < argc)
+		exit_error(PARAMETER_PROBLEM,
+			   "unknown arguments found on commandline");
+	if (!command)
+		exit_error(PARAMETER_PROBLEM, "no command specified");
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,
+			   "nothing appropriate following !");
+
+	if (command & (CMD_REPLACE | CMD_INSERT | CMD_DELETE | CMD_APPEND)) {
+		if (!(options & OPT_DESTINATION))
+			dhostnetworkmask = "0.0.0.0/0";
+		if (!(options & OPT_SOURCE))
+			shostnetworkmask = "0.0.0.0/0";
+	}
+
+	if (shostnetworkmask)
+		parse_hostnetworkmask(shostnetworkmask, &saddrs,
+				      &(fw.ip.smsk), &nsaddrs);
+
+	if (dhostnetworkmask)
+		parse_hostnetworkmask(dhostnetworkmask, &daddrs,
+				      &(fw.ip.dmsk), &ndaddrs);
+
+	if ((nsaddrs > 1 || ndaddrs > 1) &&
+	    (fw.ip.invflags & (IPT_INV_SRCIP | IPT_INV_DSTIP)))
+		exit_error(PARAMETER_PROBLEM, "! not allowed with multiple"
+			   " source or destination IP addresses");
+
+	if (command == CMD_REPLACE && (nsaddrs != 1 || ndaddrs != 1))
+		exit_error(PARAMETER_PROBLEM, "Replacement rule does not "
+			   "specify a unique address");
+
+	generic_opt_check(command, options);
+
+	if (chain && strlen(chain) > IPT_FUNCTION_MAXNAMELEN)
+		exit_error(PARAMETER_PROBLEM,
+			   "chain name `%s' too long (must be under %i chars)",
+			   chain, IPT_FUNCTION_MAXNAMELEN);
+
+	/* only allocate handle if we weren't called with a handle */
+	if (!*handle)
+		*handle = iptc_init(*table);
+
+	if (!*handle) {
+		/* try to insmod the module if iptc_init failed */
+		iptables_insmod("ip_tables", modprobe);
+		*handle = iptc_init(*table);
+	}
+
+	if (!*handle)
+		exit_error(VERSION_PROBLEM,
+			   "can't initialize iptables table `%s': %s",
+			   *table, iptc_strerror(errno));
+
+	if (command == CMD_APPEND
+	    || command == CMD_DELETE
+	    || command == CMD_INSERT
+	    || command == CMD_REPLACE) {
+		if (strcmp(chain, "PREROUTING") == 0
+		    || strcmp(chain, "INPUT") == 0) {
+			/* -o not valid with incoming packets. */
+			if (options & OPT_VIANAMEOUT)
+				exit_error(PARAMETER_PROBLEM,
+					   "Can't use -%c with %s\n",
+					   opt2char(OPT_VIANAMEOUT),
+					   chain);
+		}
+
+		if (strcmp(chain, "POSTROUTING") == 0
+		    || strcmp(chain, "OUTPUT") == 0) {
+			/* -i not valid with outgoing packets */
+			if (options & OPT_VIANAMEIN)
+				exit_error(PARAMETER_PROBLEM,
+					   "Can't use -%c with %s\n",
+					   opt2char(OPT_VIANAMEIN),
+					   chain);
+		}
+
+		if (target && iptc_is_chain(jumpto, *handle)) {
+			printf("Warning: using chain %s, not extension\n",
+			       jumpto);
+
+			target = NULL;
+		}
+
+		/* If they didn't specify a target, or it's a chain
+		   name, use standard. */
+		if (!target
+		    && (strlen(jumpto) == 0
+			|| iptc_is_chain(jumpto, *handle))) {
+			size_t size;
+
+			target = find_target(IPT_STANDARD_TARGET,
+					     LOAD_MUST_SUCCEED);
+
+			size = sizeof(struct ipt_entry_target)
+				+ target->size;
+			target->t = fw_calloc(1, size);
+			target->t->u.target_size = size;
+			strcpy(target->t->u.user.name, jumpto);
+			target->init(target->t, &fw.nfcache);
+		}
+
+		if (!target) {
+			/* it is no chain, and we can't load a plugin.
+			 * We cannot know if the plugin is corrupt, non
+			 * existant OR if the user just misspelled a
+			 * chain. */
+			find_target(jumpto, LOAD_MUST_SUCCEED);
+		} else {
+			e = generate_entry(&fw, iptables_matches, target->t);
+		}
+	}
+
+	switch (command) {
+	case CMD_APPEND:
+		ret = append_entry(chain, e,
+				   nsaddrs, saddrs, ndaddrs, daddrs,
+				   options&OPT_VERBOSE,
+				   handle);
+		break;
+	case CMD_DELETE:
+		ret = delete_entry(chain, e,
+				   nsaddrs, saddrs, ndaddrs, daddrs,
+				   options&OPT_VERBOSE,
+				   handle);
+		break;
+	case CMD_DELETE_NUM:
+		ret = iptc_delete_num_entry(chain, rulenum - 1, handle);
+		break;
+	case CMD_REPLACE:
+		ret = replace_entry(chain, e, rulenum - 1,
+				    saddrs, daddrs, options&OPT_VERBOSE,
+				    handle);
+		break;
+	case CMD_INSERT:
+		ret = insert_entry(chain, e, rulenum - 1,
+				   nsaddrs, saddrs, ndaddrs, daddrs,
+				   options&OPT_VERBOSE,
+				   handle);
+		break;
+	case CMD_LIST:
+		ret = list_entries(chain,
+				   options&OPT_VERBOSE,
+				   options&OPT_NUMERIC,
+				   options&OPT_EXPANDED,
+				   options&OPT_LINENUMBERS,
+				   handle);
+		break;
+	case CMD_FLUSH:
+		ret = flush_entries(chain, options&OPT_VERBOSE, handle);
+		break;
+	case CMD_ZERO:
+		ret = zero_entries(chain, options&OPT_VERBOSE, handle);
+		break;
+	case CMD_LIST|CMD_ZERO:
+		ret = list_entries(chain,
+				   options&OPT_VERBOSE,
+				   options&OPT_NUMERIC,
+				   options&OPT_EXPANDED,
+				   options&OPT_LINENUMBERS,
+				   handle);
+		if (ret)
+			ret = zero_entries(chain,
+					   options&OPT_VERBOSE, handle);
+		break;
+	case CMD_NEW_CHAIN:
+		ret = iptc_create_chain(chain, handle);
+		break;
+	case CMD_DELETE_CHAIN:
+		ret = delete_chain(chain, options&OPT_VERBOSE, handle);
+		break;
+	case CMD_RENAME_CHAIN:
+		ret = iptc_rename_chain(chain, newname,	handle);
+		break;
+	case CMD_SET_POLICY:
+		ret = iptc_set_policy(chain, policy, NULL, handle);
+		break;
+	default:
+		/* We should never reach this... */
+		exit_tryhelp(2);
+	}
+
+	if (verbose > 1)
+		dump_entries(*handle);
+
+	return ret;
+}
diff -urN iptables-1.2.8/.#iptables.c.1.55 iptables-1.2.9/.#iptables.c.1.55
--- iptables-1.2.8/.#iptables.c.1.55	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/.#iptables.c.1.55	2003-04-04 23:46:05.000000000 +0200
@@ -0,0 +1,2303 @@
+/* Code to take an iptables-style command line and do it. */
+
+/*
+ * Author: Paul.Russell@rustcorp.com.au and mneuling@radlogic.com.au
+ *
+ * (C) 2000-2002 by the netfilter coreteam <coreteam@netfilter.org>:
+ * 		    Paul 'Rusty' Russell <rusty@rustcorp.com.au>
+ * 		    Marc Boucher <marc+nf@mbsi.ca>
+ * 		    James Morris <jmorris@intercode.com.au>
+ * 		    Harald Welte <laforge@gnumonks.org>
+ * 		    Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <getopt.h>
+#include <string.h>
+#include <netdb.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <ctype.h>
+#include <stdarg.h>
+#include <limits.h>
+#include <unistd.h>
+#include <iptables.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef IPT_LIB_DIR
+#define IPT_LIB_DIR "/usr/local/lib/iptables"
+#endif
+
+#ifndef PROC_SYS_MODPROBE
+#define PROC_SYS_MODPROBE "/proc/sys/kernel/modprobe"
+#endif
+
+#define FMT_NUMERIC	0x0001
+#define FMT_NOCOUNTS	0x0002
+#define FMT_KILOMEGAGIGA 0x0004
+#define FMT_OPTIONS	0x0008
+#define FMT_NOTABLE	0x0010
+#define FMT_NOTARGET	0x0020
+#define FMT_VIA		0x0040
+#define FMT_NONEWLINE	0x0080
+#define FMT_LINENUMBERS 0x0100
+
+#define FMT_PRINT_RULE (FMT_NOCOUNTS | FMT_OPTIONS | FMT_VIA \
+			| FMT_NUMERIC | FMT_NOTABLE)
+#define FMT(tab,notab) ((format) & FMT_NOTABLE ? (notab) : (tab))
+
+
+#define CMD_NONE		0x0000U
+#define CMD_INSERT		0x0001U
+#define CMD_DELETE		0x0002U
+#define CMD_DELETE_NUM		0x0004U
+#define CMD_REPLACE		0x0008U
+#define CMD_APPEND		0x0010U
+#define CMD_LIST		0x0020U
+#define CMD_FLUSH		0x0040U
+#define CMD_ZERO		0x0080U
+#define CMD_NEW_CHAIN		0x0100U
+#define CMD_DELETE_CHAIN	0x0200U
+#define CMD_SET_POLICY		0x0400U
+#define CMD_CHECK		0x0800U
+#define CMD_RENAME_CHAIN	0x1000U
+#define NUMBER_OF_CMD	13
+static const char cmdflags[] = { 'I', 'D', 'D', 'R', 'A', 'L', 'F', 'Z',
+				 'N', 'X', 'P', 'E' };
+
+#define OPTION_OFFSET 256
+
+#define OPT_NONE	0x00000U
+#define OPT_NUMERIC	0x00001U
+#define OPT_SOURCE	0x00002U
+#define OPT_DESTINATION	0x00004U
+#define OPT_PROTOCOL	0x00008U
+#define OPT_JUMP	0x00010U
+#define OPT_VERBOSE	0x00020U
+#define OPT_EXPANDED	0x00040U
+#define OPT_VIANAMEIN	0x00080U
+#define OPT_VIANAMEOUT	0x00100U
+#define OPT_FRAGMENT    0x00200U
+#define OPT_LINENUMBERS 0x00400U
+#define OPT_COUNTERS	0x00800U
+#define NUMBER_OF_OPT	12
+static const char optflags[NUMBER_OF_OPT]
+= { 'n', 's', 'd', 'p', 'j', 'v', 'x', 'i', 'o', 'f', '3', 'c'};
+
+static struct option original_opts[] = {
+	{ "append", 1, 0, 'A' },
+	{ "delete", 1, 0,  'D' },
+	{ "insert", 1, 0,  'I' },
+	{ "replace", 1, 0,  'R' },
+	{ "list", 2, 0,  'L' },
+	{ "flush", 2, 0,  'F' },
+	{ "zero", 2, 0,  'Z' },
+	{ "new-chain", 1, 0,  'N' },
+	{ "delete-chain", 2, 0,  'X' },
+	{ "rename-chain", 1, 0,  'E' },
+	{ "policy", 1, 0,  'P' },
+	{ "source", 1, 0, 's' },
+	{ "destination", 1, 0,  'd' },
+	{ "src", 1, 0,  's' }, /* synonym */
+	{ "dst", 1, 0,  'd' }, /* synonym */
+	{ "protocol", 1, 0,  'p' },
+	{ "in-interface", 1, 0, 'i' },
+	{ "jump", 1, 0, 'j' },
+	{ "table", 1, 0, 't' },
+	{ "match", 1, 0, 'm' },
+	{ "numeric", 0, 0, 'n' },
+	{ "out-interface", 1, 0, 'o' },
+	{ "verbose", 0, 0, 'v' },
+	{ "exact", 0, 0, 'x' },
+	{ "fragments", 0, 0, 'f' },
+	{ "version", 0, 0, 'V' },
+	{ "help", 2, 0, 'h' },
+	{ "line-numbers", 0, 0, '0' },
+	{ "modprobe", 1, 0, 'M' },
+	{ "set-counters", 1, 0, 'c' },
+	{ 0 }
+};
+
+/* we need this for iptables-restore.  iptables-restore.c sets line to the
+ * current line of the input file, in order  to give a more precise error
+ * message.  iptables itself doesn't need this, so it is initialized to the
+ * magic number of -1 */
+int line = -1;
+
+#ifndef __OPTIMIZE__
+struct ipt_entry_target *
+ipt_get_target(struct ipt_entry *e)
+{
+	return (void *)e + e->target_offset;
+}
+#endif
+
+static struct option *opts = original_opts;
+static unsigned int global_option_offset = 0;
+
+/* Table of legal combinations of commands and options.  If any of the
+ * given commands make an option legal, that option is legal (applies to
+ * CMD_LIST and CMD_ZERO only).
+ * Key:
+ *  +  compulsory
+ *  x  illegal
+ *     optional
+ */
+
+static char commands_v_options[NUMBER_OF_CMD][NUMBER_OF_OPT] =
+/* Well, it's better than "Re: Linux vs FreeBSD" */
+{
+	/*     -n  -s  -d  -p  -j  -v  -x  -i  -o  -f  --line */
+/*INSERT*/    {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
+/*DELETE*/    {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
+/*DELETE_NUM*/{'x','x','x','x','x',' ','x','x','x','x','x'},
+/*REPLACE*/   {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
+/*APPEND*/    {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
+/*LIST*/      {' ','x','x','x','x',' ',' ','x','x','x',' '},
+/*FLUSH*/     {'x','x','x','x','x',' ','x','x','x','x','x'},
+/*ZERO*/      {'x','x','x','x','x',' ','x','x','x','x','x'},
+/*NEW_CHAIN*/ {'x','x','x','x','x',' ','x','x','x','x','x'},
+/*DEL_CHAIN*/ {'x','x','x','x','x',' ','x','x','x','x','x'},
+/*SET_POLICY*/{'x','x','x','x','x',' ','x','x','x','x','x'},
+/*CHECK*/     {'x','+','+','+','x',' ','x',' ',' ',' ','x'},
+/*RENAME*/    {'x','x','x','x','x',' ','x','x','x','x','x'}
+};
+
+static int inverse_for_options[NUMBER_OF_OPT] =
+{
+/* -n */ 0,
+/* -s */ IPT_INV_SRCIP,
+/* -d */ IPT_INV_DSTIP,
+/* -p */ IPT_INV_PROTO,
+/* -j */ 0,
+/* -v */ 0,
+/* -x */ 0,
+/* -i */ IPT_INV_VIA_IN,
+/* -o */ IPT_INV_VIA_OUT,
+/* -f */ IPT_INV_FRAG,
+/*--line*/ 0
+};
+
+const char *program_version;
+const char *program_name;
+
+/* Keeping track of external matches and targets: linked lists.  */
+struct iptables_match *iptables_matches = NULL;
+struct iptables_target *iptables_targets = NULL;
+
+/* Extra debugging from libiptc */
+extern void dump_entries(const iptc_handle_t handle);
+
+/* A few hardcoded protocols for 'all' and in case the user has no
+   /etc/protocols */
+struct pprot {
+	char *name;
+	u_int8_t num;
+};
+
+/* Primitive headers... */
+/* defined in netinet/in.h */
+#if 0
+#ifndef IPPROTO_ESP
+#define IPPROTO_ESP 50
+#endif
+#ifndef IPPROTO_AH
+#define IPPROTO_AH 51
+#endif
+#endif
+
+static const struct pprot chain_protos[] = {
+	{ "tcp", IPPROTO_TCP },
+	{ "udp", IPPROTO_UDP },
+	{ "icmp", IPPROTO_ICMP },
+	{ "esp", IPPROTO_ESP },
+	{ "ah", IPPROTO_AH },
+	{ "all", 0 },
+};
+
+static char *
+proto_to_name(u_int8_t proto, int nolookup)
+{
+	unsigned int i;
+
+	if (proto && !nolookup) {
+		struct protoent *pent = getprotobynumber(proto);
+		if (pent)
+			return pent->p_name;
+	}
+
+	for (i = 0; i < sizeof(chain_protos)/sizeof(struct pprot); i++)
+		if (chain_protos[i].num == proto)
+			return chain_protos[i].name;
+
+	return NULL;
+}
+
+struct in_addr *
+dotted_to_addr(const char *dotted)
+{
+	static struct in_addr addr;
+	unsigned char *addrp;
+	char *p, *q;
+	unsigned int onebyte;
+	int i;
+	char buf[20];
+
+	/* copy dotted string, because we need to modify it */
+	strncpy(buf, dotted, sizeof(buf) - 1);
+	addrp = (unsigned char *) &(addr.s_addr);
+
+	p = buf;
+	for (i = 0; i < 3; i++) {
+		if ((q = strchr(p, '.')) == NULL)
+			return (struct in_addr *) NULL;
+
+		*q = '\0';
+		if (string_to_number(p, 0, 255, &onebyte) == -1)
+			return (struct in_addr *) NULL;
+
+		addrp[i] = (unsigned char) onebyte;
+		p = q + 1;
+	}
+
+	/* we've checked 3 bytes, now we check the last one */
+	if (string_to_number(p, 0, 255, &onebyte) == -1)
+		return (struct in_addr *) NULL;
+
+	addrp[3] = (unsigned char) onebyte;
+
+	return &addr;
+}
+
+static struct in_addr *
+network_to_addr(const char *name)
+{
+	struct netent *net;
+	static struct in_addr addr;
+
+	if ((net = getnetbyname(name)) != NULL) {
+		if (net->n_addrtype != AF_INET)
+			return (struct in_addr *) NULL;
+		addr.s_addr = htonl((unsigned long) net->n_net);
+		return &addr;
+	}
+
+	return (struct in_addr *) NULL;
+}
+
+static void
+inaddrcpy(struct in_addr *dst, struct in_addr *src)
+{
+	/* memcpy(dst, src, sizeof(struct in_addr)); */
+	dst->s_addr = src->s_addr;
+}
+
+void
+exit_error(enum exittype status, char *msg, ...)
+{
+	va_list args;
+
+	va_start(args, msg);
+	fprintf(stderr, "%s v%s: ", program_name, program_version);
+	vfprintf(stderr, msg, args);
+	va_end(args);
+	fprintf(stderr, "\n");
+	if (status == PARAMETER_PROBLEM)
+		exit_tryhelp(status);
+	if (status == VERSION_PROBLEM)
+		fprintf(stderr,
+			"Perhaps iptables or your kernel needs to be upgraded.\n");
+	exit(status);
+}
+
+void
+exit_tryhelp(int status)
+{
+<<<<<<< iptables.c
+	if (line != -1)
+		fprintf(stderr, "Error occurred at line: %d\n", line);
+=======
+	if (line != -1)
+		fprintf(stderr, "Error occured at line: %d\n", line);
+>>>>>>> 1.55
+	fprintf(stderr, "Try `%s -h' or '%s --help' for more information.\n",
+			program_name, program_name );
+	exit(status);
+}
+
+void
+exit_printhelp(void)
+{
+	struct iptables_match *m = NULL;
+	struct iptables_target *t = NULL;
+
+	printf("%s v%s\n\n"
+"Usage: %s -[AD] chain rule-specification [options]\n"
+"       %s -[RI] chain rulenum rule-specification [options]\n"
+"       %s -D chain rulenum [options]\n"
+"       %s -[LFZ] [chain] [options]\n"
+"       %s -[NX] chain\n"
+"       %s -E old-chain-name new-chain-name\n"
+"       %s -P chain target [options]\n"
+"       %s -h (print this help information)\n\n",
+	       program_name, program_version, program_name, program_name,
+	       program_name, program_name, program_name, program_name,
+	       program_name, program_name);
+
+	printf(
+"Commands:\n"
+"Either long or short options are allowed.\n"
+"  --append  -A chain		Append to chain\n"
+"  --delete  -D chain		Delete matching rule from chain\n"
+"  --delete  -D chain rulenum\n"
+"				Delete rule rulenum (1 = first) from chain\n"
+"  --insert  -I chain [rulenum]\n"
+"				Insert in chain as rulenum (default 1=first)\n"
+"  --replace -R chain rulenum\n"
+"				Replace rule rulenum (1 = first) in chain\n"
+"  --list    -L [chain]		List the rules in a chain or all chains\n"
+"  --flush   -F [chain]		Delete all rules in  chain or all chains\n"
+"  --zero    -Z [chain]		Zero counters in chain or all chains\n"
+"  --new     -N chain		Create a new user-defined chain\n"
+"  --delete-chain\n"
+"            -X [chain]		Delete a user-defined chain\n"
+"  --policy  -P chain target\n"
+"				Change policy on chain to target\n"
+"  --rename-chain\n"
+"            -E old-chain new-chain\n"
+"				Change chain name, (moving any references)\n"
+
+"Options:\n"
+"  --proto	-p [!] proto	protocol: by number or name, eg. `tcp'\n"
+"  --source	-s [!] address[/mask]\n"
+"				source specification\n"
+"  --destination -d [!] address[/mask]\n"
+"				destination specification\n"
+"  --in-interface -i [!] input name[+]\n"
+"				network interface name ([+] for wildcard)\n"
+"  --jump	-j target\n"
+"				target for rule (may load target extension)\n"
+"  --match	-m match\n"
+"				extended match (may load extension)\n"
+"  --numeric	-n		numeric output of addresses and ports\n"
+"  --out-interface -o [!] output name[+]\n"
+"				network interface name ([+] for wildcard)\n"
+"  --table	-t table	table to manipulate (default: `filter')\n"
+"  --verbose	-v		verbose mode\n"
+"  --line-numbers		print line numbers when listing\n"
+"  --exact	-x		expand numbers (display exact values)\n"
+"[!] --fragment	-f		match second or further fragments only\n"
+"  --modprobe=<command>		try to insert modules using this command\n"
+"  --set-counters PKTS BYTES	set the counter during insert/append\n"
+"[!] --version	-V		print package version.\n");
+
+	/* Print out any special helps. A user might like to be able
+	   to add a --help to the commandline, and see expected
+	   results. So we call help for all matches & targets */
+	for (t=iptables_targets;t;t=t->next) {
+		printf("\n");
+		t->help();
+	}
+	for (m=iptables_matches;m;m=m->next) {
+		printf("\n");
+		m->help();
+	}
+	exit(0);
+}
+
+static void
+generic_opt_check(int command, int options)
+{
+	int i, j, legal = 0;
+
+	/* Check that commands are valid with options.  Complicated by the
+	 * fact that if an option is legal with *any* command given, it is
+	 * legal overall (ie. -z and -l).
+	 */
+	for (i = 0; i < NUMBER_OF_OPT; i++) {
+		legal = 0; /* -1 => illegal, 1 => legal, 0 => undecided. */
+
+		for (j = 0; j < NUMBER_OF_CMD; j++) {
+			if (!(command & (1<<j)))
+				continue;
+
+			if (!(options & (1<<i))) {
+				if (commands_v_options[j][i] == '+')
+					exit_error(PARAMETER_PROBLEM,
+						   "You need to supply the `-%c' "
+						   "option for this command\n",
+						   optflags[i]);
+			} else {
+				if (commands_v_options[j][i] != 'x')
+					legal = 1;
+				else if (legal == 0)
+					legal = -1;
+			}
+		}
+		if (legal == -1)
+			exit_error(PARAMETER_PROBLEM,
+				   "Illegal option `-%c' with this command\n",
+				   optflags[i]);
+	}
+}
+
+static char
+opt2char(int option)
+{
+	const char *ptr;
+	for (ptr = optflags; option > 1; option >>= 1, ptr++);
+
+	return *ptr;
+}
+
+static char
+cmd2char(int option)
+{
+	const char *ptr;
+	for (ptr = cmdflags; option > 1; option >>= 1, ptr++);
+
+	return *ptr;
+}
+
+static void
+add_command(int *cmd, const int newcmd, const int othercmds, int invert)
+{
+	if (invert)
+		exit_error(PARAMETER_PROBLEM, "unexpected ! flag");
+	if (*cmd & (~othercmds))
+		exit_error(PARAMETER_PROBLEM, "Can't use -%c with -%c\n",
+			   cmd2char(newcmd), cmd2char(*cmd & (~othercmds)));
+	*cmd |= newcmd;
+}
+
+int
+check_inverse(const char option[], int *invert, int *optind, int argc)
+{
+	if (option && strcmp(option, "!") == 0) {
+		if (*invert)
+			exit_error(PARAMETER_PROBLEM,
+				   "Multiple `!' flags not allowed");
+		*invert = TRUE;
+		if (optind) {
+			*optind = *optind+1;
+			if (argc && *optind > argc)
+				exit_error(PARAMETER_PROBLEM,
+					   "no argument following `!'");
+		}
+
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static void *
+fw_calloc(size_t count, size_t size)
+{
+	void *p;
+
+	if ((p = calloc(count, size)) == NULL) {
+		perror("iptables: calloc failed");
+		exit(1);
+	}
+	return p;
+}
+
+static void *
+fw_malloc(size_t size)
+{
+	void *p;
+
+	if ((p = malloc(size)) == NULL) {
+		perror("iptables: malloc failed");
+		exit(1);
+	}
+	return p;
+}
+
+static struct in_addr *
+host_to_addr(const char *name, unsigned int *naddr)
+{
+	struct hostent *host;
+	struct in_addr *addr;
+	unsigned int i;
+
+	*naddr = 0;
+	if ((host = gethostbyname(name)) != NULL) {
+		if (host->h_addrtype != AF_INET ||
+		    host->h_length != sizeof(struct in_addr))
+			return (struct in_addr *) NULL;
+
+		while (host->h_addr_list[*naddr] != (char *) NULL)
+			(*naddr)++;
+		addr = fw_calloc(*naddr, sizeof(struct in_addr));
+		for (i = 0; i < *naddr; i++)
+			inaddrcpy(&(addr[i]),
+				  (struct in_addr *) host->h_addr_list[i]);
+		return addr;
+	}
+
+	return (struct in_addr *) NULL;
+}
+
+static char *
+addr_to_host(const struct in_addr *addr)
+{
+	struct hostent *host;
+
+	if ((host = gethostbyaddr((char *) addr,
+				  sizeof(struct in_addr), AF_INET)) != NULL)
+		return (char *) host->h_name;
+
+	return (char *) NULL;
+}
+
+/*
+ *	All functions starting with "parse" should succeed, otherwise
+ *	the program fails.
+ *	Most routines return pointers to static data that may change
+ *	between calls to the same or other routines with a few exceptions:
+ *	"host_to_addr", "parse_hostnetwork", and "parse_hostnetworkmask"
+ *	return global static data.
+*/
+
+static struct in_addr *
+parse_hostnetwork(const char *name, unsigned int *naddrs)
+{
+	struct in_addr *addrp, *addrptmp;
+
+	if ((addrptmp = dotted_to_addr(name)) != NULL ||
+	    (addrptmp = network_to_addr(name)) != NULL) {
+		addrp = fw_malloc(sizeof(struct in_addr));
+		inaddrcpy(addrp, addrptmp);
+		*naddrs = 1;
+		return addrp;
+	}
+	if ((addrp = host_to_addr(name, naddrs)) != NULL)
+		return addrp;
+
+	exit_error(PARAMETER_PROBLEM, "host/network `%s' not found", name);
+}
+
+static struct in_addr *
+parse_mask(char *mask)
+{
+	static struct in_addr maskaddr;
+	struct in_addr *addrp;
+	unsigned int bits;
+
+	if (mask == NULL) {
+		/* no mask at all defaults to 32 bits */
+		maskaddr.s_addr = 0xFFFFFFFF;
+		return &maskaddr;
+	}
+	if ((addrp = dotted_to_addr(mask)) != NULL)
+		/* dotted_to_addr already returns a network byte order addr */
+		return addrp;
+	if (string_to_number(mask, 0, 32, &bits) == -1)
+		exit_error(PARAMETER_PROBLEM,
+			   "invalid mask `%s' specified", mask);
+	if (bits != 0) {
+		maskaddr.s_addr = htonl(0xFFFFFFFF << (32 - bits));
+		return &maskaddr;
+	}
+
+	maskaddr.s_addr = 0L;
+	return &maskaddr;
+}
+
+void
+parse_hostnetworkmask(const char *name, struct in_addr **addrpp,
+		      struct in_addr *maskp, unsigned int *naddrs)
+{
+	struct in_addr *addrp;
+	char buf[256];
+	char *p;
+	int i, j, k, n;
+
+	strncpy(buf, name, sizeof(buf) - 1);
+	if ((p = strrchr(buf, '/')) != NULL) {
+		*p = '\0';
+		addrp = parse_mask(p + 1);
+	} else
+		addrp = parse_mask(NULL);
+	inaddrcpy(maskp, addrp);
+
+	/* if a null mask is given, the name is ignored, like in "any/0" */
+	if (maskp->s_addr == 0L)
+		strcpy(buf, "0.0.0.0");
+
+	addrp = *addrpp = parse_hostnetwork(buf, naddrs);
+	n = *naddrs;
+	for (i = 0, j = 0; i < n; i++) {
+		addrp[j++].s_addr &= maskp->s_addr;
+		for (k = 0; k < j - 1; k++) {
+			if (addrp[k].s_addr == addrp[j - 1].s_addr) {
+				(*naddrs)--;
+				j--;
+				break;
+			}
+		}
+	}
+}
+
+struct iptables_match *
+find_match(const char *name, enum ipt_tryload tryload)
+{
+	struct iptables_match *ptr;
+
+	for (ptr = iptables_matches; ptr; ptr = ptr->next) {
+		if (strcmp(name, ptr->name) == 0)
+			break;
+	}
+
+#ifndef NO_SHARED_LIBS
+	if (!ptr && tryload != DONT_LOAD) {
+		char path[sizeof(IPT_LIB_DIR) + sizeof("/libipt_.so")
+			 + strlen(name)];
+		sprintf(path, IPT_LIB_DIR "/libipt_%s.so", name);
+		if (dlopen(path, RTLD_NOW)) {
+			/* Found library.  If it didn't register itself,
+			   maybe they specified target as match. */
+			ptr = find_match(name, DONT_LOAD);
+
+			if (!ptr)
+				exit_error(PARAMETER_PROBLEM,
+					   "Couldn't load match `%s'\n",
+					   name);
+		} else if (tryload == LOAD_MUST_SUCCEED)
+			exit_error(PARAMETER_PROBLEM,
+				   "Couldn't load match `%s':%s\n",
+				   name, dlerror());
+	}
+#else
+	if (ptr && !ptr->loaded) {
+		if (tryload != DONT_LOAD)
+			ptr->loaded = 1;
+		else
+			ptr = NULL;
+	}
+	if(!ptr && (tryload == LOAD_MUST_SUCCEED)) {
+		exit_error(PARAMETER_PROBLEM,
+			   "Couldn't find match `%s'\n", name);
+	}
+#endif
+
+	if (ptr)
+		ptr->used = 1;
+
+	return ptr;
+}
+
+/* Christophe Burki wants `-p 6' to imply `-m tcp'.  */
+static struct iptables_match *
+find_proto(const char *pname, enum ipt_tryload tryload, int nolookup)
+{
+	unsigned int proto;
+
+	if (string_to_number(pname, 0, 255, &proto) != -1) {
+		char *protoname = proto_to_name(proto, nolookup);
+
+		if (protoname)
+			return find_match(protoname, tryload);
+	} else
+		return find_match(pname, tryload);
+
+	return NULL;
+}
+
+u_int16_t
+parse_protocol(const char *s)
+{
+	unsigned int proto;
+
+	if (string_to_number(s, 0, 255, &proto) == -1) {
+		struct protoent *pent;
+
+		if ((pent = getprotobyname(s)))
+			proto = pent->p_proto;
+		else {
+			unsigned int i;
+			for (i = 0;
+			     i < sizeof(chain_protos)/sizeof(struct pprot);
+			     i++) {
+				if (strcmp(s, chain_protos[i].name) == 0) {
+					proto = chain_protos[i].num;
+					break;
+				}
+			}
+			if (i == sizeof(chain_protos)/sizeof(struct pprot))
+				exit_error(PARAMETER_PROBLEM,
+					   "unknown protocol `%s' specified",
+					   s);
+		}
+	}
+
+	return (u_int16_t)proto;
+}
+
+static void
+parse_interface(const char *arg, char *vianame, unsigned char *mask)
+{
+	int vialen = strlen(arg);
+	unsigned int i;
+
+	memset(mask, 0, IFNAMSIZ);
+	memset(vianame, 0, IFNAMSIZ);
+
+	if (vialen + 1 > IFNAMSIZ)
+		exit_error(PARAMETER_PROBLEM,
+			   "interface name `%s' must be shorter than IFNAMSIZ"
+			   " (%i)", arg, IFNAMSIZ-1);
+
+	strcpy(vianame, arg);
+	if (vialen == 0)
+		memset(mask, 0, IFNAMSIZ);
+	else if (vianame[vialen - 1] == '+') {
+		memset(mask, 0xFF, vialen - 1);
+		memset(mask + vialen - 1, 0, IFNAMSIZ - vialen + 1);
+		/* Don't remove `+' here! -HW */
+	} else {
+		/* Include nul-terminator in match */
+		memset(mask, 0xFF, vialen + 1);
+		memset(mask + vialen + 1, 0, IFNAMSIZ - vialen - 1);
+		for (i = 0; vianame[i]; i++) {
+			if (!isalnum(vianame[i]) 
+			    && vianame[i] != '_' 
+			    && vianame[i] != '.') {
+				printf("Warning: wierd character in interface"
+				       " `%s' (No aliases, :, ! or *).\n",
+				       vianame);
+				break;
+			}
+		}
+	}
+}
+
+/* Can't be zero. */
+static int
+parse_rulenumber(const char *rule)
+{
+	unsigned int rulenum;
+
+	if (string_to_number(rule, 1, INT_MAX, &rulenum) == -1)
+		exit_error(PARAMETER_PROBLEM,
+			   "Invalid rule number `%s'", rule);
+
+	return rulenum;
+}
+
+static const char *
+parse_target(const char *targetname)
+{
+	const char *ptr;
+
+	if (strlen(targetname) < 1)
+		exit_error(PARAMETER_PROBLEM,
+			   "Invalid target name (too short)");
+
+	if (strlen(targetname)+1 > sizeof(ipt_chainlabel))
+		exit_error(PARAMETER_PROBLEM,
+			   "Invalid target name `%s' (%i chars max)",
+			   targetname, sizeof(ipt_chainlabel)-1);
+
+	for (ptr = targetname; *ptr; ptr++)
+		if (isspace(*ptr))
+			exit_error(PARAMETER_PROBLEM,
+				   "Invalid target name `%s'", targetname);
+	return targetname;
+}
+
+static char *
+addr_to_network(const struct in_addr *addr)
+{
+	struct netent *net;
+
+	if ((net = getnetbyaddr((long) ntohl(addr->s_addr), AF_INET)) != NULL)
+		return (char *) net->n_name;
+
+	return (char *) NULL;
+}
+
+char *
+addr_to_dotted(const struct in_addr *addrp)
+{
+	static char buf[20];
+	const unsigned char *bytep;
+
+	bytep = (const unsigned char *) &(addrp->s_addr);
+	sprintf(buf, "%d.%d.%d.%d", bytep[0], bytep[1], bytep[2], bytep[3]);
+	return buf;
+}
+
+char *
+addr_to_anyname(const struct in_addr *addr)
+{
+	char *name;
+
+	if ((name = addr_to_host(addr)) != NULL ||
+	    (name = addr_to_network(addr)) != NULL)
+		return name;
+
+	return addr_to_dotted(addr);
+}
+
+char *
+mask_to_dotted(const struct in_addr *mask)
+{
+	int i;
+	static char buf[20];
+	u_int32_t maskaddr, bits;
+
+	maskaddr = ntohl(mask->s_addr);
+
+	if (maskaddr == 0xFFFFFFFFL)
+		/* we don't want to see "/32" */
+		return "";
+
+	i = 32;
+	bits = 0xFFFFFFFEL;
+	while (--i >= 0 && maskaddr != bits)
+		bits <<= 1;
+	if (i >= 0)
+		sprintf(buf, "/%d", i);
+	else
+		/* mask was not a decent combination of 1's and 0's */
+		sprintf(buf, "/%s", addr_to_dotted(mask));
+
+	return buf;
+}
+
+int
+string_to_number(const char *s, unsigned int min, unsigned int max,
+		 unsigned int *ret)
+{
+	long number;
+	char *end;
+
+	/* Handle hex, octal, etc. */
+	errno = 0;
+	number = strtol(s, &end, 0);
+	if (*end == '\0' && end != s) {
+		/* we parsed a number, let's see if we want this */
+		if (errno != ERANGE && min <= number && number <= max) {
+			*ret = number;
+			return 0;
+		}
+	}
+	return -1;
+}
+
+static void
+set_option(unsigned int *options, unsigned int option, u_int8_t *invflg,
+	   int invert)
+{
+	if (*options & option)
+		exit_error(PARAMETER_PROBLEM, "multiple -%c flags not allowed",
+			   opt2char(option));
+	*options |= option;
+
+	if (invert) {
+		unsigned int i;
+		for (i = 0; 1 << i != option; i++);
+
+		if (!inverse_for_options[i])
+			exit_error(PARAMETER_PROBLEM,
+				   "cannot have ! before -%c",
+				   opt2char(option));
+		*invflg |= inverse_for_options[i];
+	}
+}
+
+struct iptables_target *
+find_target(const char *name, enum ipt_tryload tryload)
+{
+	struct iptables_target *ptr;
+
+	/* Standard target? */
+	if (strcmp(name, "") == 0
+	    || strcmp(name, IPTC_LABEL_ACCEPT) == 0
+	    || strcmp(name, IPTC_LABEL_DROP) == 0
+	    || strcmp(name, IPTC_LABEL_QUEUE) == 0
+	    || strcmp(name, IPTC_LABEL_RETURN) == 0)
+		name = "standard";
+
+	for (ptr = iptables_targets; ptr; ptr = ptr->next) {
+		if (strcmp(name, ptr->name) == 0)
+			break;
+	}
+
+#ifndef NO_SHARED_LIBS
+	if (!ptr && tryload != DONT_LOAD) {
+		char path[sizeof(IPT_LIB_DIR) + sizeof("/libipt_.so")
+			 + strlen(name)];
+		sprintf(path, IPT_LIB_DIR "/libipt_%s.so", name);
+		if (dlopen(path, RTLD_NOW)) {
+			/* Found library.  If it didn't register itself,
+			   maybe they specified match as a target. */
+			ptr = find_target(name, DONT_LOAD);
+			if (!ptr)
+				exit_error(PARAMETER_PROBLEM,
+					   "Couldn't load target `%s'\n",
+					   name);
+		} else if (tryload == LOAD_MUST_SUCCEED)
+			exit_error(PARAMETER_PROBLEM,
+				   "Couldn't load target `%s':%s\n",
+				   name, dlerror());
+	}
+#else
+	if (ptr && !ptr->loaded) {
+		if (tryload != DONT_LOAD)
+			ptr->loaded = 1;
+		else
+			ptr = NULL;
+	}
+	if(!ptr && (tryload == LOAD_MUST_SUCCEED)) {
+		exit_error(PARAMETER_PROBLEM,
+			   "Couldn't find target `%s'\n", name);
+	}
+#endif
+
+	if (ptr)
+		ptr->used = 1;
+
+	return ptr;
+}
+
+static struct option *
+merge_options(struct option *oldopts, const struct option *newopts,
+	      unsigned int *option_offset)
+{
+	unsigned int num_old, num_new, i;
+	struct option *merge;
+
+	for (num_old = 0; oldopts[num_old].name; num_old++);
+	for (num_new = 0; newopts[num_new].name; num_new++);
+
+	global_option_offset += OPTION_OFFSET;
+	*option_offset = global_option_offset;
+
+	merge = malloc(sizeof(struct option) * (num_new + num_old + 1));
+	memcpy(merge, oldopts, num_old * sizeof(struct option));
+	for (i = 0; i < num_new; i++) {
+		merge[num_old + i] = newopts[i];
+		merge[num_old + i].val += *option_offset;
+	}
+	memset(merge + num_old + num_new, 0, sizeof(struct option));
+
+	return merge;
+}
+
+void
+register_match(struct iptables_match *me)
+{
+	struct iptables_match **i;
+
+	if (strcmp(me->version, program_version) != 0) {
+		fprintf(stderr, "%s: match `%s' v%s (I'm v%s).\n",
+			program_name, me->name, me->version, program_version);
+		exit(1);
+	}
+
+	if (find_match(me->name, DONT_LOAD)) {
+		fprintf(stderr, "%s: match `%s' already registered.\n",
+			program_name, me->name);
+		exit(1);
+	}
+
+	if (me->size != IPT_ALIGN(me->size)) {
+		fprintf(stderr, "%s: match `%s' has invalid size %u.\n",
+			program_name, me->name, me->size);
+		exit(1);
+	}
+
+	/* Append to list. */
+	for (i = &iptables_matches; *i; i = &(*i)->next);
+	me->next = NULL;
+	*i = me;
+
+	me->m = NULL;
+	me->mflags = 0;
+}
+
+void
+register_target(struct iptables_target *me)
+{
+	if (strcmp(me->version, program_version) != 0) {
+		fprintf(stderr, "%s: target `%s' v%s (I'm v%s).\n",
+			program_name, me->name, me->version, program_version);
+		exit(1);
+	}
+
+	if (find_target(me->name, DONT_LOAD)) {
+		fprintf(stderr, "%s: target `%s' already registered.\n",
+			program_name, me->name);
+		exit(1);
+	}
+
+	if (me->size != IPT_ALIGN(me->size)) {
+		fprintf(stderr, "%s: target `%s' has invalid size %u.\n",
+			program_name, me->name, me->size);
+		exit(1);
+	}
+
+	/* Prepend to list. */
+	me->next = iptables_targets;
+	iptables_targets = me;
+	me->t = NULL;
+	me->tflags = 0;
+}
+
+static void
+print_num(u_int64_t number, unsigned int format)
+{
+	if (format & FMT_KILOMEGAGIGA) {
+		if (number > 99999) {
+			number = (number + 500) / 1000;
+			if (number > 9999) {
+				number = (number + 500) / 1000;
+				if (number > 9999) {
+					number = (number + 500) / 1000;
+					if (number > 9999) {
+						number = (number + 500) / 1000;
+						printf(FMT("%4lluT ","%lluT "), number);
+					}
+					else printf(FMT("%4lluG ","%lluG "), number);
+				}
+				else printf(FMT("%4lluM ","%lluM "), number);
+			} else
+				printf(FMT("%4lluK ","%lluK "), number);
+		} else
+			printf(FMT("%5llu ","%llu "), number);
+	} else
+		printf(FMT("%8llu ","%llu "), number);
+}
+
+
+static void
+print_header(unsigned int format, const char *chain, iptc_handle_t *handle)
+{
+	struct ipt_counters counters;
+	const char *pol = iptc_get_policy(chain, &counters, handle);
+	printf("Chain %s", chain);
+	if (pol) {
+		printf(" (policy %s", pol);
+		if (!(format & FMT_NOCOUNTS)) {
+			fputc(' ', stdout);
+			print_num(counters.pcnt, (format|FMT_NOTABLE));
+			fputs("packets, ", stdout);
+			print_num(counters.bcnt, (format|FMT_NOTABLE));
+			fputs("bytes", stdout);
+		}
+		printf(")\n");
+	} else {
+		unsigned int refs;
+		if (!iptc_get_references(&refs, chain, handle))
+			printf(" (ERROR obtaining refs)\n");
+		else
+			printf(" (%u references)\n", refs);
+	}
+
+	if (format & FMT_LINENUMBERS)
+		printf(FMT("%-4s ", "%s "), "num");
+	if (!(format & FMT_NOCOUNTS)) {
+		if (format & FMT_KILOMEGAGIGA) {
+			printf(FMT("%5s ","%s "), "pkts");
+			printf(FMT("%5s ","%s "), "bytes");
+		} else {
+			printf(FMT("%8s ","%s "), "pkts");
+			printf(FMT("%10s ","%s "), "bytes");
+		}
+	}
+	if (!(format & FMT_NOTARGET))
+		printf(FMT("%-9s ","%s "), "target");
+	fputs(" prot ", stdout);
+	if (format & FMT_OPTIONS)
+		fputs("opt", stdout);
+	if (format & FMT_VIA) {
+		printf(FMT(" %-6s ","%s "), "in");
+		printf(FMT("%-6s ","%s "), "out");
+	}
+	printf(FMT(" %-19s ","%s "), "source");
+	printf(FMT(" %-19s "," %s "), "destination");
+	printf("\n");
+}
+
+
+static int
+print_match(const struct ipt_entry_match *m,
+	    const struct ipt_ip *ip,
+	    int numeric)
+{
+	struct iptables_match *match = find_match(m->u.user.name, TRY_LOAD);
+
+	if (match) {
+		if (match->print)
+			match->print(ip, m, numeric);
+		else
+			printf("%s ", match->name);
+	} else {
+		if (m->u.user.name[0])
+			printf("UNKNOWN match `%s' ", m->u.user.name);
+	}
+	/* Don't stop iterating. */
+	return 0;
+}
+
+/* e is called `fw' here for hysterical raisins */
+static void
+print_firewall(const struct ipt_entry *fw,
+	       const char *targname,
+	       unsigned int num,
+	       unsigned int format,
+	       const iptc_handle_t handle)
+{
+	struct iptables_target *target = NULL;
+	const struct ipt_entry_target *t;
+	u_int8_t flags;
+	char buf[BUFSIZ];
+
+	if (!iptc_is_chain(targname, handle))
+		target = find_target(targname, TRY_LOAD);
+	else
+		target = find_target(IPT_STANDARD_TARGET, LOAD_MUST_SUCCEED);
+
+	t = ipt_get_target((struct ipt_entry *)fw);
+	flags = fw->ip.flags;
+
+	if (format & FMT_LINENUMBERS)
+		printf(FMT("%-4u ", "%u "), num+1);
+
+	if (!(format & FMT_NOCOUNTS)) {
+		print_num(fw->counters.pcnt, format);
+		print_num(fw->counters.bcnt, format);
+	}
+
+	if (!(format & FMT_NOTARGET))
+		printf(FMT("%-9s ", "%s "), targname);
+
+	fputc(fw->ip.invflags & IPT_INV_PROTO ? '!' : ' ', stdout);
+	{
+		char *pname = proto_to_name(fw->ip.proto, format&FMT_NUMERIC);
+		if (pname)
+			printf(FMT("%-5s", "%s "), pname);
+		else
+			printf(FMT("%-5hu", "%hu "), fw->ip.proto);
+	}
+
+	if (format & FMT_OPTIONS) {
+		if (format & FMT_NOTABLE)
+			fputs("opt ", stdout);
+		fputc(fw->ip.invflags & IPT_INV_FRAG ? '!' : '-', stdout);
+		fputc(flags & IPT_F_FRAG ? 'f' : '-', stdout);
+		fputc(' ', stdout);
+	}
+
+	if (format & FMT_VIA) {
+		char iface[IFNAMSIZ+2];
+
+		if (fw->ip.invflags & IPT_INV_VIA_IN) {
+			iface[0] = '!';
+			iface[1] = '\0';
+		}
+		else iface[0] = '\0';
+
+		if (fw->ip.iniface[0] != '\0') {
+			strcat(iface, fw->ip.iniface);
+		}
+		else if (format & FMT_NUMERIC) strcat(iface, "*");
+		else strcat(iface, "any");
+		printf(FMT(" %-6s ","in %s "), iface);
+
+		if (fw->ip.invflags & IPT_INV_VIA_OUT) {
+			iface[0] = '!';
+			iface[1] = '\0';
+		}
+		else iface[0] = '\0';
+
+		if (fw->ip.outiface[0] != '\0') {
+			strcat(iface, fw->ip.outiface);
+		}
+		else if (format & FMT_NUMERIC) strcat(iface, "*");
+		else strcat(iface, "any");
+		printf(FMT("%-6s ","out %s "), iface);
+	}
+
+	fputc(fw->ip.invflags & IPT_INV_SRCIP ? '!' : ' ', stdout);
+	if (fw->ip.smsk.s_addr == 0L && !(format & FMT_NUMERIC))
+		printf(FMT("%-19s ","%s "), "anywhere");
+	else {
+		if (format & FMT_NUMERIC)
+			sprintf(buf, "%s", addr_to_dotted(&(fw->ip.src)));
+		else
+			sprintf(buf, "%s", addr_to_anyname(&(fw->ip.src)));
+		strcat(buf, mask_to_dotted(&(fw->ip.smsk)));
+		printf(FMT("%-19s ","%s "), buf);
+	}
+
+	fputc(fw->ip.invflags & IPT_INV_DSTIP ? '!' : ' ', stdout);
+	if (fw->ip.dmsk.s_addr == 0L && !(format & FMT_NUMERIC))
+		printf(FMT("%-19s","-> %s"), "anywhere");
+	else {
+		if (format & FMT_NUMERIC)
+			sprintf(buf, "%s", addr_to_dotted(&(fw->ip.dst)));
+		else
+			sprintf(buf, "%s", addr_to_anyname(&(fw->ip.dst)));
+		strcat(buf, mask_to_dotted(&(fw->ip.dmsk)));
+		printf(FMT("%-19s","-> %s"), buf);
+	}
+
+	if (format & FMT_NOTABLE)
+		fputs("  ", stdout);
+
+	IPT_MATCH_ITERATE(fw, print_match, &fw->ip, format & FMT_NUMERIC);
+
+	if (target) {
+		if (target->print)
+			/* Print the target information. */
+			target->print(&fw->ip, t, format & FMT_NUMERIC);
+	} else if (t->u.target_size != sizeof(*t))
+		printf("[%u bytes of unknown target data] ",
+		       t->u.target_size - sizeof(*t));
+
+	if (!(format & FMT_NONEWLINE))
+		fputc('\n', stdout);
+}
+
+static void
+print_firewall_line(const struct ipt_entry *fw,
+		    const iptc_handle_t h)
+{
+	struct ipt_entry_target *t;
+
+	t = ipt_get_target((struct ipt_entry *)fw);
+	print_firewall(fw, t->u.user.name, 0, FMT_PRINT_RULE, h);
+}
+
+static int
+append_entry(const ipt_chainlabel chain,
+	     struct ipt_entry *fw,
+	     unsigned int nsaddrs,
+	     const struct in_addr saddrs[],
+	     unsigned int ndaddrs,
+	     const struct in_addr daddrs[],
+	     int verbose,
+	     iptc_handle_t *handle)
+{
+	unsigned int i, j;
+	int ret = 1;
+
+	for (i = 0; i < nsaddrs; i++) {
+		fw->ip.src.s_addr = saddrs[i].s_addr;
+		for (j = 0; j < ndaddrs; j++) {
+			fw->ip.dst.s_addr = daddrs[j].s_addr;
+			if (verbose)
+				print_firewall_line(fw, *handle);
+			ret &= iptc_append_entry(chain, fw, handle);
+		}
+	}
+
+	return ret;
+}
+
+static int
+replace_entry(const ipt_chainlabel chain,
+	      struct ipt_entry *fw,
+	      unsigned int rulenum,
+	      const struct in_addr *saddr,
+	      const struct in_addr *daddr,
+	      int verbose,
+	      iptc_handle_t *handle)
+{
+	fw->ip.src.s_addr = saddr->s_addr;
+	fw->ip.dst.s_addr = daddr->s_addr;
+
+	if (verbose)
+		print_firewall_line(fw, *handle);
+	return iptc_replace_entry(chain, fw, rulenum, handle);
+}
+
+static int
+insert_entry(const ipt_chainlabel chain,
+	     struct ipt_entry *fw,
+	     unsigned int rulenum,
+	     unsigned int nsaddrs,
+	     const struct in_addr saddrs[],
+	     unsigned int ndaddrs,
+	     const struct in_addr daddrs[],
+	     int verbose,
+	     iptc_handle_t *handle)
+{
+	unsigned int i, j;
+	int ret = 1;
+
+	for (i = 0; i < nsaddrs; i++) {
+		fw->ip.src.s_addr = saddrs[i].s_addr;
+		for (j = 0; j < ndaddrs; j++) {
+			fw->ip.dst.s_addr = daddrs[j].s_addr;
+			if (verbose)
+				print_firewall_line(fw, *handle);
+			ret &= iptc_insert_entry(chain, fw, rulenum, handle);
+		}
+	}
+
+	return ret;
+}
+
+static unsigned char *
+make_delete_mask(struct ipt_entry *fw)
+{
+	/* Establish mask for comparison */
+	unsigned int size;
+	struct iptables_match *m;
+	unsigned char *mask, *mptr;
+
+	size = sizeof(struct ipt_entry);
+	for (m = iptables_matches; m; m = m->next) {
+		if (!m->used)
+			continue;
+
+		size += IPT_ALIGN(sizeof(struct ipt_entry_match)) + m->size;
+	}
+
+	mask = fw_calloc(1, size
+			 + IPT_ALIGN(sizeof(struct ipt_entry_target))
+			 + iptables_targets->size);
+
+	memset(mask, 0xFF, sizeof(struct ipt_entry));
+	mptr = mask + sizeof(struct ipt_entry);
+
+	for (m = iptables_matches; m; m = m->next) {
+		if (!m->used)
+			continue;
+
+		memset(mptr, 0xFF,
+		       IPT_ALIGN(sizeof(struct ipt_entry_match))
+		       + m->userspacesize);
+		mptr += IPT_ALIGN(sizeof(struct ipt_entry_match)) + m->size;
+	}
+
+	memset(mptr, 0xFF,
+	       IPT_ALIGN(sizeof(struct ipt_entry_target))
+	       + iptables_targets->userspacesize);
+
+	return mask;
+}
+
+static int
+delete_entry(const ipt_chainlabel chain,
+	     struct ipt_entry *fw,
+	     unsigned int nsaddrs,
+	     const struct in_addr saddrs[],
+	     unsigned int ndaddrs,
+	     const struct in_addr daddrs[],
+	     int verbose,
+	     iptc_handle_t *handle)
+{
+	unsigned int i, j;
+	int ret = 1;
+	unsigned char *mask;
+
+	mask = make_delete_mask(fw);
+	for (i = 0; i < nsaddrs; i++) {
+		fw->ip.src.s_addr = saddrs[i].s_addr;
+		for (j = 0; j < ndaddrs; j++) {
+			fw->ip.dst.s_addr = daddrs[j].s_addr;
+			if (verbose)
+				print_firewall_line(fw, *handle);
+			ret &= iptc_delete_entry(chain, fw, mask, handle);
+		}
+	}
+	return ret;
+}
+
+int
+for_each_chain(int (*fn)(const ipt_chainlabel, int, iptc_handle_t *),
+	       int verbose, int builtinstoo, iptc_handle_t *handle)
+{
+        int ret = 1;
+	const char *chain;
+	char *chains;
+	unsigned int i, chaincount = 0;
+
+	chain = iptc_first_chain(handle);
+	while (chain) {
+		chaincount++;
+		chain = iptc_next_chain(handle);
+        }
+
+	chains = fw_malloc(sizeof(ipt_chainlabel) * chaincount);
+	i = 0;
+	chain = iptc_first_chain(handle);
+	while (chain) {
+		strcpy(chains + i*sizeof(ipt_chainlabel), chain);
+		i++;
+		chain = iptc_next_chain(handle);
+        }
+
+	for (i = 0; i < chaincount; i++) {
+		if (!builtinstoo
+		    && iptc_builtin(chains + i*sizeof(ipt_chainlabel),
+				    *handle))
+			continue;
+	        ret &= fn(chains + i*sizeof(ipt_chainlabel), verbose, handle);
+	}
+
+	free(chains);
+        return ret;
+}
+
+int
+flush_entries(const ipt_chainlabel chain, int verbose,
+	      iptc_handle_t *handle)
+{
+	if (!chain)
+		return for_each_chain(flush_entries, verbose, 1, handle);
+
+	if (verbose)
+		fprintf(stdout, "Flushing chain `%s'\n", chain);
+	return iptc_flush_entries(chain, handle);
+}
+
+static int
+zero_entries(const ipt_chainlabel chain, int verbose,
+	     iptc_handle_t *handle)
+{
+	if (!chain)
+		return for_each_chain(zero_entries, verbose, 1, handle);
+
+	if (verbose)
+		fprintf(stdout, "Zeroing chain `%s'\n", chain);
+	return iptc_zero_entries(chain, handle);
+}
+
+int
+delete_chain(const ipt_chainlabel chain, int verbose,
+	     iptc_handle_t *handle)
+{
+	if (!chain)
+		return for_each_chain(delete_chain, verbose, 0, handle);
+
+	if (verbose)
+	        fprintf(stdout, "Deleting chain `%s'\n", chain);
+	return iptc_delete_chain(chain, handle);
+}
+
+static int
+list_entries(const ipt_chainlabel chain, int verbose, int numeric,
+	     int expanded, int linenumbers, iptc_handle_t *handle)
+{
+	int found = 0;
+	unsigned int format;
+	const char *this;
+
+	format = FMT_OPTIONS;
+	if (!verbose)
+		format |= FMT_NOCOUNTS;
+	else
+		format |= FMT_VIA;
+
+	if (numeric)
+		format |= FMT_NUMERIC;
+
+	if (!expanded)
+		format |= FMT_KILOMEGAGIGA;
+
+	if (linenumbers)
+		format |= FMT_LINENUMBERS;
+
+	for (this = iptc_first_chain(handle);
+	     this;
+	     this = iptc_next_chain(handle)) {
+		const struct ipt_entry *i;
+		unsigned int num;
+
+		if (chain && strcmp(chain, this) != 0)
+			continue;
+
+		if (found) printf("\n");
+
+		print_header(format, this, handle);
+		i = iptc_first_rule(this, handle);
+
+		num = 0;
+		while (i) {
+			print_firewall(i,
+				       iptc_get_target(i, handle),
+				       num++,
+				       format,
+				       *handle);
+			i = iptc_next_rule(i, handle);
+		}
+		found = 1;
+	}
+
+	errno = ENOENT;
+	return found;
+}
+
+static char *get_modprobe(void)
+{
+	int procfile;
+	char *ret;
+
+	procfile = open(PROC_SYS_MODPROBE, O_RDONLY);
+	if (procfile < 0)
+		return NULL;
+
+	ret = malloc(1024);
+	if (ret) {
+		switch (read(procfile, ret, 1024)) {
+		case -1: goto fail;
+		case 1024: goto fail; /* Partial read.  Wierd */
+		}
+		if (ret[strlen(ret)-1]=='\n') 
+			ret[strlen(ret)-1]=0;
+		close(procfile);
+		return ret;
+	}
+ fail:
+	free(ret);
+	close(procfile);
+	return NULL;
+}
+
+int iptables_insmod(const char *modname, const char *modprobe)
+{
+	char *buf = NULL;
+	char *argv[3];
+
+	/* If they don't explicitly set it, read out of kernel */
+	if (!modprobe) {
+		buf = get_modprobe();
+		if (!buf)
+			return -1;
+		modprobe = buf;
+	}
+
+	switch (fork()) {
+	case 0:
+		argv[0] = (char *)modprobe;
+		argv[1] = (char *)modname;
+		argv[2] = NULL;
+		execv(argv[0], argv);
+
+		/* not usually reached */
+		exit(0);
+	case -1:
+		return -1;
+
+	default: /* parent */
+		wait(NULL);
+	}
+
+	free(buf);
+	return 0;
+}
+
+static struct ipt_entry *
+generate_entry(const struct ipt_entry *fw,
+	       struct iptables_match *matches,
+	       struct ipt_entry_target *target)
+{
+	unsigned int size;
+	struct iptables_match *m;
+	struct ipt_entry *e;
+
+	size = sizeof(struct ipt_entry);
+	for (m = matches; m; m = m->next) {
+		if (!m->used)
+			continue;
+
+		size += m->m->u.match_size;
+	}
+
+	e = fw_malloc(size + target->u.target_size);
+	*e = *fw;
+	e->target_offset = size;
+	e->next_offset = size + target->u.target_size;
+
+	size = 0;
+	for (m = matches; m; m = m->next) {
+		if (!m->used)
+			continue;
+
+		memcpy(e->elems + size, m->m, m->m->u.match_size);
+		size += m->m->u.match_size;
+	}
+	memcpy(e->elems + size, target, target->u.target_size);
+
+	return e;
+}
+
+int do_command(int argc, char *argv[], char **table, iptc_handle_t *handle)
+{
+	struct ipt_entry fw, *e = NULL;
+	int invert = 0;
+	unsigned int nsaddrs = 0, ndaddrs = 0;
+	struct in_addr *saddrs = NULL, *daddrs = NULL;
+
+	int c, verbose = 0;
+	const char *chain = NULL;
+	const char *shostnetworkmask = NULL, *dhostnetworkmask = NULL;
+	const char *policy = NULL, *newname = NULL;
+	unsigned int rulenum = 0, options = 0, command = 0;
+	const char *pcnt = NULL, *bcnt = NULL;
+	int ret = 1;
+	struct iptables_match *m;
+	struct iptables_target *target = NULL;
+	struct iptables_target *t;
+	const char *jumpto = "";
+	char *protocol = NULL;
+	const char *modprobe = NULL;
+	int proto_used = 0;
+
+	memset(&fw, 0, sizeof(fw));
+
+	opts = original_opts;
+	global_option_offset = 0;
+
+	/* re-set optind to 0 in case do_command gets called
+	 * a second time */
+	optind = 0;
+
+	/* clear mflags in case do_command gets called a second time
+	 * (we clear the global list of all matches for security)*/
+	for (m = iptables_matches; m; m = m->next) {
+		m->mflags = 0;
+		m->used = 0;
+	}
+
+	for (t = iptables_targets; t; t = t->next) {
+		t->tflags = 0;
+		t->used = 0;
+	}
+
+	/* Suppress error messages: we may add new options if we
+           demand-load a protocol. */
+	opterr = 0;
+
+	while ((c = getopt_long(argc, argv,
+	   "-A:D:R:I:L::M:F::Z::N:X::E:P:Vh::o:p:s:d:j:i:fbvnt:m:xc:",
+					   opts, NULL)) != -1) {
+		switch (c) {
+			/*
+			 * Command selection
+			 */
+		case 'A':
+			add_command(&command, CMD_APPEND, CMD_NONE,
+				    invert);
+			chain = optarg;
+			break;
+
+		case 'D':
+			add_command(&command, CMD_DELETE, CMD_NONE,
+				    invert);
+			chain = optarg;
+			if (optind < argc && argv[optind][0] != '-'
+			    && argv[optind][0] != '!') {
+				rulenum = parse_rulenumber(argv[optind++]);
+				command = CMD_DELETE_NUM;
+			}
+			break;
+
+		case 'R':
+			add_command(&command, CMD_REPLACE, CMD_NONE,
+				    invert);
+			chain = optarg;
+			if (optind < argc && argv[optind][0] != '-'
+			    && argv[optind][0] != '!')
+				rulenum = parse_rulenumber(argv[optind++]);
+			else
+				exit_error(PARAMETER_PROBLEM,
+					   "-%c requires a rule number",
+					   cmd2char(CMD_REPLACE));
+			break;
+
+		case 'I':
+			add_command(&command, CMD_INSERT, CMD_NONE,
+				    invert);
+			chain = optarg;
+			if (optind < argc && argv[optind][0] != '-'
+			    && argv[optind][0] != '!')
+				rulenum = parse_rulenumber(argv[optind++]);
+			else rulenum = 1;
+			break;
+
+		case 'L':
+			add_command(&command, CMD_LIST, CMD_ZERO,
+				    invert);
+			if (optarg) chain = optarg;
+			else if (optind < argc && argv[optind][0] != '-'
+				 && argv[optind][0] != '!')
+				chain = argv[optind++];
+			break;
+
+		case 'F':
+			add_command(&command, CMD_FLUSH, CMD_NONE,
+				    invert);
+			if (optarg) chain = optarg;
+			else if (optind < argc && argv[optind][0] != '-'
+				 && argv[optind][0] != '!')
+				chain = argv[optind++];
+			break;
+
+		case 'Z':
+			add_command(&command, CMD_ZERO, CMD_LIST,
+				    invert);
+			if (optarg) chain = optarg;
+			else if (optind < argc && argv[optind][0] != '-'
+				&& argv[optind][0] != '!')
+				chain = argv[optind++];
+			break;
+
+		case 'N':
+			if (optarg && *optarg == '-')
+				exit_error(PARAMETER_PROBLEM,
+					   "chain name not allowed to start "
+					   "with `-'\n");
+			if (find_target(optarg, TRY_LOAD))
+				exit_error(PARAMETER_PROBLEM,
+					   "chain name may not clash "
+					   "with target name\n");
+			add_command(&command, CMD_NEW_CHAIN, CMD_NONE,
+				    invert);
+			chain = optarg;
+			break;
+
+		case 'X':
+			add_command(&command, CMD_DELETE_CHAIN, CMD_NONE,
+				    invert);
+			if (optarg) chain = optarg;
+			else if (optind < argc && argv[optind][0] != '-'
+				 && argv[optind][0] != '!')
+				chain = argv[optind++];
+			break;
+
+		case 'E':
+			add_command(&command, CMD_RENAME_CHAIN, CMD_NONE,
+				    invert);
+			chain = optarg;
+			if (optind < argc && argv[optind][0] != '-'
+			    && argv[optind][0] != '!')
+				newname = argv[optind++];
+			else
+				exit_error(PARAMETER_PROBLEM,
+				           "-%c requires old-chain-name and "
+					   "new-chain-name",
+					    cmd2char(CMD_RENAME_CHAIN));
+			break;
+
+		case 'P':
+			add_command(&command, CMD_SET_POLICY, CMD_NONE,
+				    invert);
+			chain = optarg;
+			if (optind < argc && argv[optind][0] != '-'
+			    && argv[optind][0] != '!')
+				policy = argv[optind++];
+			else
+				exit_error(PARAMETER_PROBLEM,
+					   "-%c requires a chain and a policy",
+					   cmd2char(CMD_SET_POLICY));
+			break;
+
+		case 'h':
+			if (!optarg)
+				optarg = argv[optind];
+
+			/* iptables -p icmp -h */
+			if (!iptables_matches && protocol)
+				find_match(protocol, TRY_LOAD);
+
+			exit_printhelp();
+
+			/*
+			 * Option selection
+			 */
+		case 'p':
+			check_inverse(optarg, &invert, &optind, argc);
+			set_option(&options, OPT_PROTOCOL, &fw.ip.invflags,
+				   invert);
+
+			/* Canonicalize into lower case */
+			for (protocol = argv[optind-1]; *protocol; protocol++)
+				*protocol = tolower(*protocol);
+
+			protocol = argv[optind-1];
+			fw.ip.proto = parse_protocol(protocol);
+
+			if (fw.ip.proto == 0
+			    && (fw.ip.invflags & IPT_INV_PROTO))
+				exit_error(PARAMETER_PROBLEM,
+					   "rule would never match protocol");
+			fw.nfcache |= NFC_IP_PROTO;
+			break;
+
+		case 's':
+			check_inverse(optarg, &invert, &optind, argc);
+			set_option(&options, OPT_SOURCE, &fw.ip.invflags,
+				   invert);
+			shostnetworkmask = argv[optind-1];
+			fw.nfcache |= NFC_IP_SRC;
+			break;
+
+		case 'd':
+			check_inverse(optarg, &invert, &optind, argc);
+			set_option(&options, OPT_DESTINATION, &fw.ip.invflags,
+				   invert);
+			dhostnetworkmask = argv[optind-1];
+			fw.nfcache |= NFC_IP_DST;
+			break;
+
+		case 'j':
+			set_option(&options, OPT_JUMP, &fw.ip.invflags,
+				   invert);
+			jumpto = parse_target(optarg);
+			/* TRY_LOAD (may be chain name) */
+			target = find_target(jumpto, TRY_LOAD);
+
+			if (target) {
+				size_t size;
+
+				size = IPT_ALIGN(sizeof(struct ipt_entry_target))
+					+ target->size;
+
+				target->t = fw_calloc(1, size);
+				target->t->u.target_size = size;
+				strcpy(target->t->u.user.name, jumpto);
+				target->init(target->t, &fw.nfcache);
+				opts = merge_options(opts, target->extra_opts, &target->option_offset);
+			}
+			break;
+
+
+		case 'i':
+			check_inverse(optarg, &invert, &optind, argc);
+			set_option(&options, OPT_VIANAMEIN, &fw.ip.invflags,
+				   invert);
+			parse_interface(argv[optind-1],
+					fw.ip.iniface,
+					fw.ip.iniface_mask);
+			fw.nfcache |= NFC_IP_IF_IN;
+			break;
+
+		case 'o':
+			check_inverse(optarg, &invert, &optind, argc);
+			set_option(&options, OPT_VIANAMEOUT, &fw.ip.invflags,
+				   invert);
+			parse_interface(argv[optind-1],
+					fw.ip.outiface,
+					fw.ip.outiface_mask);
+			fw.nfcache |= NFC_IP_IF_OUT;
+			break;
+
+		case 'f':
+			set_option(&options, OPT_FRAGMENT, &fw.ip.invflags,
+				   invert);
+			fw.ip.flags |= IPT_F_FRAG;
+			fw.nfcache |= NFC_IP_FRAG;
+			break;
+
+		case 'v':
+			if (!verbose)
+				set_option(&options, OPT_VERBOSE,
+					   &fw.ip.invflags, invert);
+			verbose++;
+			break;
+
+		case 'm': {
+			size_t size;
+
+			if (invert)
+				exit_error(PARAMETER_PROBLEM,
+					   "unexpected ! flag before --match");
+
+			m = find_match(optarg, LOAD_MUST_SUCCEED);
+			size = IPT_ALIGN(sizeof(struct ipt_entry_match))
+					 + m->size;
+			m->m = fw_calloc(1, size);
+			m->m->u.match_size = size;
+			strcpy(m->m->u.user.name, m->name);
+			m->init(m->m, &fw.nfcache);
+			opts = merge_options(opts, m->extra_opts, &m->option_offset);
+		}
+		break;
+
+		case 'n':
+			set_option(&options, OPT_NUMERIC, &fw.ip.invflags,
+				   invert);
+			break;
+
+		case 't':
+			if (invert)
+				exit_error(PARAMETER_PROBLEM,
+					   "unexpected ! flag before --table");
+			*table = argv[optind-1];
+			break;
+
+		case 'x':
+			set_option(&options, OPT_EXPANDED, &fw.ip.invflags,
+				   invert);
+			break;
+
+		case 'V':
+			if (invert)
+				printf("Not %s ;-)\n", program_version);
+			else
+				printf("%s v%s\n",
+				       program_name, program_version);
+			exit(0);
+
+		case '0':
+			set_option(&options, OPT_LINENUMBERS, &fw.ip.invflags,
+				   invert);
+			break;
+
+		case 'M':
+			modprobe = optarg;
+			break;
+
+		case 'c':
+
+			set_option(&options, OPT_COUNTERS, &fw.ip.invflags,
+				   invert);
+			pcnt = optarg;
+			if (optind < argc && argv[optind][0] != '-'
+			    && argv[optind][0] != '!')
+				bcnt = argv[optind++];
+			else
+				exit_error(PARAMETER_PROBLEM,
+					"-%c requires packet and byte counter",
+					opt2char(OPT_COUNTERS));
+
+			if (sscanf(pcnt, "%llu", &fw.counters.pcnt) != 1)
+				exit_error(PARAMETER_PROBLEM,
+					"-%c packet counter not numeric",
+					opt2char(OPT_COUNTERS));
+
+			if (sscanf(bcnt, "%llu", &fw.counters.bcnt) != 1)
+				exit_error(PARAMETER_PROBLEM,
+					"-%c byte counter not numeric",
+					opt2char(OPT_COUNTERS));
+			
+			break;
+
+
+		case 1: /* non option */
+			if (optarg[0] == '!' && optarg[1] == '\0') {
+				if (invert)
+					exit_error(PARAMETER_PROBLEM,
+						   "multiple consecutive ! not"
+						   " allowed");
+				invert = TRUE;
+				optarg[0] = '\0';
+				continue;
+			}
+			printf("Bad argument `%s'\n", optarg);
+			exit_tryhelp(2);
+
+		default:
+			/* FIXME: This scheme doesn't allow two of the same
+			   matches --RR */
+			if (!target
+			    || !(target->parse(c - target->option_offset,
+					       argv, invert,
+					       &target->tflags,
+					       &fw, &target->t))) {
+				for (m = iptables_matches; m; m = m->next) {
+					if (!m->used)
+						continue;
+
+					if (m->parse(c - m->option_offset,
+						     argv, invert,
+						     &m->mflags,
+						     &fw,
+						     &fw.nfcache,
+						     &m->m))
+						break;
+				}
+
+				/* If you listen carefully, you can
+				   actually hear this code suck. */
+
+				/* some explanations (after four different bugs
+				 * in 3 different releases): If we encountere a
+				 * parameter, that has not been parsed yet,
+				 * it's not an option of an explicitly loaded
+				 * match or a target.  However, we support
+				 * implicit loading of the protocol match
+				 * extension.  '-p tcp' means 'l4 proto 6' and
+				 * at the same time 'load tcp protocol match on
+				 * demand if we specify --dport'.
+				 *
+				 * To make this work, we need to make sure:
+				 * - the parameter has not been parsed by
+				 *   a match (m above)
+				 * - a protocol has been specified
+				 * - the protocol extension has not been
+				 *   loaded yet, or is loaded and unused
+				 *   [think of iptables-restore!]
+				 * - the protocol extension can be successively
+				 *   loaded
+				 */
+				if (m == NULL
+				    && protocol
+				    && (!find_proto(protocol, DONT_LOAD,
+						   options&OPT_NUMERIC) 
+					|| (find_proto(protocol, DONT_LOAD,
+							options&OPT_NUMERIC)
+					    && (proto_used == 0))
+				       )
+				    && (m = find_proto(protocol, TRY_LOAD,
+						       options&OPT_NUMERIC))) {
+					/* Try loading protocol */
+					size_t size;
+					
+					proto_used = 1;
+
+					size = IPT_ALIGN(sizeof(struct ipt_entry_match))
+							 + m->size;
+
+					m->m = fw_calloc(1, size);
+					m->m->u.match_size = size;
+					strcpy(m->m->u.user.name, m->name);
+					m->init(m->m, &fw.nfcache);
+
+					opts = merge_options(opts,
+					    m->extra_opts, &m->option_offset);
+
+					optind--;
+					continue;
+				}
+				if (!m)
+					exit_error(PARAMETER_PROBLEM,
+						   "Unknown arg `%s'",
+						   argv[optind-1]);
+			}
+		}
+		invert = FALSE;
+	}
+
+	for (m = iptables_matches; m; m = m->next) {
+		if (!m->used)
+			continue;
+
+		m->final_check(m->mflags);
+	}
+
+	if (target)
+		target->final_check(target->tflags);
+
+	/* Fix me: must put inverse options checking here --MN */
+
+	if (optind < argc)
+		exit_error(PARAMETER_PROBLEM,
+			   "unknown arguments found on commandline");
+	if (!command)
+		exit_error(PARAMETER_PROBLEM, "no command specified");
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,
+			   "nothing appropriate following !");
+
+	if (command & (CMD_REPLACE | CMD_INSERT | CMD_DELETE | CMD_APPEND)) {
+		if (!(options & OPT_DESTINATION))
+			dhostnetworkmask = "0.0.0.0/0";
+		if (!(options & OPT_SOURCE))
+			shostnetworkmask = "0.0.0.0/0";
+	}
+
+	if (shostnetworkmask)
+		parse_hostnetworkmask(shostnetworkmask, &saddrs,
+				      &(fw.ip.smsk), &nsaddrs);
+
+	if (dhostnetworkmask)
+		parse_hostnetworkmask(dhostnetworkmask, &daddrs,
+				      &(fw.ip.dmsk), &ndaddrs);
+
+	if ((nsaddrs > 1 || ndaddrs > 1) &&
+	    (fw.ip.invflags & (IPT_INV_SRCIP | IPT_INV_DSTIP)))
+		exit_error(PARAMETER_PROBLEM, "! not allowed with multiple"
+			   " source or destination IP addresses");
+
+	if (command == CMD_REPLACE && (nsaddrs != 1 || ndaddrs != 1))
+		exit_error(PARAMETER_PROBLEM, "Replacement rule does not "
+			   "specify a unique address");
+
+	generic_opt_check(command, options);
+
+	if (chain && strlen(chain) > IPT_FUNCTION_MAXNAMELEN)
+		exit_error(PARAMETER_PROBLEM,
+			   "chain name `%s' too long (must be under %i chars)",
+			   chain, IPT_FUNCTION_MAXNAMELEN);
+
+	/* only allocate handle if we weren't called with a handle */
+	if (!*handle)
+		*handle = iptc_init(*table);
+
+	if (!*handle) {
+		/* try to insmod the module if iptc_init failed */
+		iptables_insmod("ip_tables", modprobe);
+		*handle = iptc_init(*table);
+	}
+
+	if (!*handle)
+		exit_error(VERSION_PROBLEM,
+			   "can't initialize iptables table `%s': %s",
+			   *table, iptc_strerror(errno));
+
+	if (command == CMD_APPEND
+	    || command == CMD_DELETE
+	    || command == CMD_INSERT
+	    || command == CMD_REPLACE) {
+		if (strcmp(chain, "PREROUTING") == 0
+		    || strcmp(chain, "INPUT") == 0) {
+			/* -o not valid with incoming packets. */
+			if (options & OPT_VIANAMEOUT)
+				exit_error(PARAMETER_PROBLEM,
+					   "Can't use -%c with %s\n",
+					   opt2char(OPT_VIANAMEOUT),
+					   chain);
+		}
+
+		if (strcmp(chain, "POSTROUTING") == 0
+		    || strcmp(chain, "OUTPUT") == 0) {
+			/* -i not valid with outgoing packets */
+			if (options & OPT_VIANAMEIN)
+				exit_error(PARAMETER_PROBLEM,
+					   "Can't use -%c with %s\n",
+					   opt2char(OPT_VIANAMEIN),
+					   chain);
+		}
+
+		if (target && iptc_is_chain(jumpto, *handle)) {
+			printf("Warning: using chain %s, not extension\n",
+			       jumpto);
+
+			target = NULL;
+		}
+
+		/* If they didn't specify a target, or it's a chain
+		   name, use standard. */
+		if (!target
+		    && (strlen(jumpto) == 0
+			|| iptc_is_chain(jumpto, *handle))) {
+			size_t size;
+
+			target = find_target(IPT_STANDARD_TARGET,
+					     LOAD_MUST_SUCCEED);
+
+			size = sizeof(struct ipt_entry_target)
+				+ target->size;
+			target->t = fw_calloc(1, size);
+			target->t->u.target_size = size;
+			strcpy(target->t->u.user.name, jumpto);
+			target->init(target->t, &fw.nfcache);
+		}
+
+		if (!target) {
+			/* it is no chain, and we can't load a plugin.
+			 * We cannot know if the plugin is corrupt, non
+			 * existant OR if the user just misspelled a
+			 * chain. */
+			find_target(jumpto, LOAD_MUST_SUCCEED);
+		} else {
+			e = generate_entry(&fw, iptables_matches, target->t);
+		}
+	}
+
+	switch (command) {
+	case CMD_APPEND:
+		ret = append_entry(chain, e,
+				   nsaddrs, saddrs, ndaddrs, daddrs,
+				   options&OPT_VERBOSE,
+				   handle);
+		break;
+	case CMD_DELETE:
+		ret = delete_entry(chain, e,
+				   nsaddrs, saddrs, ndaddrs, daddrs,
+				   options&OPT_VERBOSE,
+				   handle);
+		break;
+	case CMD_DELETE_NUM:
+		ret = iptc_delete_num_entry(chain, rulenum - 1, handle);
+		break;
+	case CMD_REPLACE:
+		ret = replace_entry(chain, e, rulenum - 1,
+				    saddrs, daddrs, options&OPT_VERBOSE,
+				    handle);
+		break;
+	case CMD_INSERT:
+		ret = insert_entry(chain, e, rulenum - 1,
+				   nsaddrs, saddrs, ndaddrs, daddrs,
+				   options&OPT_VERBOSE,
+				   handle);
+		break;
+	case CMD_LIST:
+		ret = list_entries(chain,
+				   options&OPT_VERBOSE,
+				   options&OPT_NUMERIC,
+				   options&OPT_EXPANDED,
+				   options&OPT_LINENUMBERS,
+				   handle);
+		break;
+	case CMD_FLUSH:
+		ret = flush_entries(chain, options&OPT_VERBOSE, handle);
+		break;
+	case CMD_ZERO:
+		ret = zero_entries(chain, options&OPT_VERBOSE, handle);
+		break;
+	case CMD_LIST|CMD_ZERO:
+		ret = list_entries(chain,
+				   options&OPT_VERBOSE,
+				   options&OPT_NUMERIC,
+				   options&OPT_EXPANDED,
+				   options&OPT_LINENUMBERS,
+				   handle);
+		if (ret)
+			ret = zero_entries(chain,
+					   options&OPT_VERBOSE, handle);
+		break;
+	case CMD_NEW_CHAIN:
+		ret = iptc_create_chain(chain, handle);
+		break;
+	case CMD_DELETE_CHAIN:
+		ret = delete_chain(chain, options&OPT_VERBOSE, handle);
+		break;
+	case CMD_RENAME_CHAIN:
+		ret = iptc_rename_chain(chain, newname,	handle);
+		break;
+	case CMD_SET_POLICY:
+		ret = iptc_set_policy(chain, policy, NULL, handle);
+		break;
+	default:
+		/* We should never reach this... */
+		exit_tryhelp(2);
+	}
+
+	if (verbose > 1)
+		dump_entries(*handle);
+
+	return ret;
+}
diff -urN iptables-1.2.8/INCOMPATIBILITIES iptables-1.2.9/INCOMPATIBILITIES
--- iptables-1.2.8/INCOMPATIBILITIES	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/INCOMPATIBILITIES	2003-05-24 13:44:18.000000000 +0200
@@ -0,0 +1,6 @@
+INCOMPATIBILITIES:
+
+- The REJECT target has an '--reject-with admin-prohib' option which used
+  with kernels that do not support it, will result in a plain DROP instead
+  of REJECT.  Use with caution.
+  Kernels that do support it:
diff -urN iptables-1.2.8/KNOWN_BUGS iptables-1.2.9/KNOWN_BUGS
--- iptables-1.2.8/KNOWN_BUGS	2002-07-23 15:44:41.000000000 +0200
+++ iptables-1.2.9/KNOWN_BUGS	1970-01-01 01:00:00.000000000 +0100
@@ -1,14 +0,0 @@
-Known bugs:
-
-1) NAT in the OUTPUT chain only works since kernel 2.4.18.  However,
-   there is a patch for previous kernels in patch-o-matic, called the
-   'local-nat.patch'.  This patch adds a CONFIG_NF_IP_NAT_LOCAL kernel config
-   option.
-
-2) tcpdump traffic is corrupted by OUTPUT NAT.
-
-3) Connection tracking doesn't wait very long for reply FIN, meaning
-   that half-closed pipes can time out early (seen frequently with squid).
-
-4) When you use ip6tables packet mangling on IPv6 packets, the packet will
-   not be re-routed in case e.g. you insert a routing header.
diff -urN iptables-1.2.8/Makefile iptables-1.2.9/Makefile
--- iptables-1.2.8/Makefile	2003-04-13 17:28:11.000000000 +0200
+++ iptables-1.2.9/Makefile	2003-11-02 18:00:08.000000000 +0100
@@ -14,8 +14,8 @@
 ifndef KERNEL_DIR
 KERNEL_DIR=/usr/src/linux
 endif
-IPTABLES_VERSION:=1.2.8
-OLD_IPTABLES_VERSION:=1.2.7a
+IPTABLES_VERSION:=1.2.9
+OLD_IPTABLES_VERSION:=1.2.8
 
 PREFIX:=/usr/local
 LIBDIR:=$(PREFIX)/lib
diff -urN iptables-1.2.8/extensions/.#libipt_ECN.c.1.7 iptables-1.2.9/extensions/.#libipt_ECN.c.1.7
--- iptables-1.2.8/extensions/.#libipt_ECN.c.1.7	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/.#libipt_ECN.c.1.7	2002-06-27 23:42:52.000000000 +0200
@@ -0,0 +1,180 @@
+/* Shared library add-on to iptables for ECN, $Version$
+ *
+ * (C) 2002 by Harald Welte <laforge@gnumonks.org>
+ *
+ * This program is distributed under the terms of GNU GPL v2, 1991
+ *
+ * libipt_ECN.c borrowed heavily from libipt_DSCP.c
+ *
+ * $Id: libipt_ECN.c,v 1.7 2002/05/29 15:11:36 laforge Exp $
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_ECN.h>
+
+static void init(struct ipt_entry_target *t, unsigned int *nfcache) 
+{
+}
+
+static void help(void) 
+{
+	printf(
+"ECN target v%s options\n"
+"  --ecn-tcp-remove		Remove all ECN bits from TCP header\n"
+"ECN target v%s EXPERIMENTAL options (use with extreme care!)\n"
+"  --ecn-ip-ect			Set the IPv4 ECT codepoint (0 to 3)\n"
+"  --ecn-tcp-cwr		Set the IPv4 CWR bit (0 or 1)\n"
+"  --ecn-tcp-ece		Set the IPv4 CWR bit (0 or 1)\n",
+		IPTABLES_VERSION, IPTABLES_VERSION
+);
+}
+
+static struct option opts[] = {
+	{ "ecn-tcp-remove", 0, 0, 'F' },
+	{ "ecn-tcp-cwr", 1, 0, 'G' },
+	{ "ecn-tcp-ece", 1, 0, 'H' },
+	{ "ecn-ip-ect", 1, 0, '9' },
+	{ 0 }
+};
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	unsigned int result;
+	struct ipt_ECN_info *einfo
+		= (struct ipt_ECN_info *)(*target)->data;
+
+	switch (c) {
+	case 'F':
+		if (*flags)
+			exit_error(PARAMETER_PROBLEM,
+			        "ECN target: Only use --ecn-tcp-remove ONCE!");
+		einfo->operation = IPT_ECN_OP_SET_ECE | IPT_ECN_OP_SET_CWR;
+		einfo->proto.tcp.ece = 0;
+		einfo->proto.tcp.cwr = 0;
+		*flags = 1;
+		break;
+	case 'G':
+		if (*flags & IPT_ECN_OP_SET_CWR)
+			exit_error(PARAMETER_PROBLEM,
+				"ECN target: Only use --ecn-tcp-cwr ONCE!");
+		if (string_to_number(optarg, 0, 1, &result))
+			exit_error(PARAMETER_PROBLEM,
+				   "ECN target: Value out of range");
+		einfo->operation |= IPT_ECN_OP_SET_CWR;
+		einfo->proto.tcp.cwr = result;
+		*flags |= IPT_ECN_OP_SET_CWR;
+		break;
+	case 'H':
+		if (*flags & IPT_ECN_OP_SET_ECE)
+			exit_error(PARAMETER_PROBLEM,
+				"ECN target: Only use --ecn-tcp-ece ONCE!");
+		if (string_to_number(optarg, 0, 1, &result))
+			exit_error(PARAMETER_PROBLEM,
+				   "ECN target: Value out of range");
+		einfo->operation |= IPT_ECN_OP_SET_ECE;
+		einfo->proto.tcp.ece = result;
+		*flags |= IPT_ECN_OP_SET_ECE;
+		break;
+	case '9':
+		if (*flags & IPT_ECN_OP_SET_IP)
+			exit_error(PARAMETER_PROBLEM,
+				"ECN target: Only use --ecn-ip-ect ONCE!");
+		if (string_to_number(optarg, 0, 3, &result))
+			exit_error(PARAMETER_PROBLEM,
+				   "ECN target: Value out of range");
+		einfo->operation |= IPT_ECN_OP_SET_IP;
+		einfo->ip_ect = (result << IPT_ECN_SHIFT);
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+		           "ECN target: Parameter --ecn-remove is required");
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	const struct ipt_ECN_info *einfo =
+		(const struct ipt_ECN_info *)target->data;
+
+	printf("ECN ");
+
+	if (einfo->operation == (IPT_ECN_OP_SET_ECE|IPT_ECN_OP_SET_CWR)
+	    && einfo->proto.tcp.ece == 0
+	    && einfo->proto.tcp.cwr == 0)
+		printf("TCP remove ");
+	else {
+		if (einfo->operation & IPT_ECN_OP_SET_ECE)
+			printf("ECE=%u ", einfo->proto.tcp.ece);
+
+		if (einfo->operation & IPT_ECN_OP_SET_CWR)
+			printf("CWR=%u ", einfo->proto.tcp.cwr);
+
+		if (einfo->operation & IPT_ECN_OP_SET_IP)
+			printf("ECT codepoint=%u ", einfo->ip_ect);
+	}
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	const struct ipt_ECN_info *einfo =
+		(const struct ipt_ECN_info *)target->data;
+
+	if (einfo->operation == (IPT_ECN_OP_SET_ECE|IPT_ECN_OP_SET_CWR)
+	    && einfo->proto.tcp.ece == 0
+	    && einfo->proto.tcp.cwr == 0)
+		printf("--ecn-tcp-remove ");
+	else {
+
+		if (einfo->operation & IPT_ECN_OP_SET_ECE)
+			printf("--ecn-tcp-ece %d ", einfo->proto.tcp.ece);
+
+		if (einfo->operation & IPT_ECN_OP_SET_CWR)
+			printf("--ecn-tcp-cwr %d ", einfo->proto.tcp.cwr);
+
+		if (einfo->operation & IPT_ECN_OP_SET_IP)
+			printf("--ecn-ip-ect %d ", einfo->ip_ect);
+	}
+}
+
+static
+struct iptables_target ecn
+= { NULL,
+    "ECN",
+    IPTABLES_VERSION,
+    IPT_ALIGN(sizeof(struct ipt_ECN_info)),
+    IPT_ALIGN(sizeof(struct ipt_ECN_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_target(&ecn);
+}
diff -urN iptables-1.2.8/extensions/.#libipt_recent.c.1.6 iptables-1.2.9/extensions/.#libipt_recent.c.1.6
--- iptables-1.2.8/extensions/.#libipt_recent.c.1.6	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/.#libipt_recent.c.1.6	2003-03-02 17:16:45.000000000 +0100
@@ -0,0 +1,229 @@
+/* Shared library add-on to iptables to add recent matching support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_recent.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"recent v%s options:\n"
+"[!] --set                       Add source address to list, always matches.\n"
+"[!] --rcheck                    Match if source address in list.\n"
+"[!] --update                    Match if source address in list, also update last-seen time.\n"
+"[!] --remove                    Match if source address in list, also removes that address from list.\n"
+"    --seconds seconds           For check and update commands above.\n"
+"                                Specifies that the match will only occur if source address last seen within\n"
+"                                the last 'seconds' seconds.\n"
+"    --hitcount hits             For check and update commands above.\n"
+"                                Specifies that the match will only occur if source address seen hits times.\n"
+"                                May be used in conjunction with the seconds option.\n"
+"    --rttl                      For check and update commands above.\n"
+"                                Specifies that the match will only occur if the source address and the TTL\n"
+"                                match between this packet and the one which was set.\n"
+"                                Useful if you have problems with people spoofing their source address in order\n"
+"                                to DoS you via this module.\n"
+"    --name name                 Name of the recent list to be used.  DEFAULT used if none given.\n"
+"    --rsource                   Save the source address of each packet in the recent list table (default).\n"
+"    --rdest                     Save the destination address of each packet in the recent list table.\n"
+,
+IPTABLES_VERSION);
+
+}
+  
+static struct option opts[] = {
+	{ "set", 0, 0, 201 }, 
+	{ "rcheck", 0, 0, 202 }, 
+	{ "update", 0, 0, 203 },
+	{ "seconds", 1, 0, 204 }, 
+	{ "hitcount", 1, 0, 205 },
+	{ "remove",0, 0, 206 },
+	{ "rttl",0, 0, 207 },
+	{ "name", 1, 0, 208 },
+	{ "rsource", 0, 0, 209 },
+	{ "rdest", 0, 0, 210 },
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *match, unsigned int *nfcache)
+{
+	struct ipt_recent_info *info = (struct ipt_recent_info *)(match)->data;
+
+	*nfcache |= NFC_UNKNOWN;
+
+	strncpy(info->name, "DEFAULT", 200);
+	info->side = IPT_RECENT_SOURCE;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_recent_info *info = (struct ipt_recent_info *)(*match)->data;
+	switch (c) {
+		case 201:
+			if (*flags) 
+				exit_error(PARAMETER_PROBLEM,
+					"recent: only one of `--set', `--check' "
+					"`--update' or `--remove' may be set");
+			check_inverse(optarg, &invert, &optind, 0);
+			info->check_set |= IPT_RECENT_SET;
+			if (invert) 
+				info->invert = 1;
+			*flags = 1;
+			break;
+			
+		case 202:
+			if (*flags) 
+				exit_error(PARAMETER_PROBLEM,
+					"recent: only one of `--set', `--check' "
+					"`--update' or `--remove' may be set");
+			check_inverse(optarg, &invert, &optind, 0);
+			info->check_set |= IPT_RECENT_CHECK;
+			if (invert)
+				info->invert = 1;
+			*flags = 1;
+			break;
+
+		case 203:
+			if (*flags)
+				exit_error(PARAMETER_PROBLEM,
+					"recent: only one of `--set', `--check' "
+					"`--update' or `--remove' may be set");
+			check_inverse(optarg, &invert, &optind, 0);
+			info->check_set |= IPT_RECENT_UPDATE;
+			if (invert)
+				info->invert = 1;
+			*flags = 1;
+			break;
+
+		case 206:
+			if (*flags)
+				exit_error(PARAMETER_PROBLEM,
+					"recent: only one of `--set', `--check' "
+					"`--update' or `--remove' may be set");
+			check_inverse(optarg, &invert, &optind, 0);
+			info->check_set |= IPT_RECENT_REMOVE;
+			if (invert)
+				info->invert = 1;
+			*flags = 1;
+			break;
+
+		case 204:
+			info->seconds = atoi(optarg);
+			break;
+
+		case 205:
+			info->hit_count = atoi(optarg);
+			break;
+
+		case 207:
+			info->check_set |= IPT_RECENT_TTL;
+			break;
+
+		case 208:
+			strncpy(info->name, optarg, 200);
+			break;
+
+		case 209:
+			info->side = IPT_RECENT_SOURCE;
+			break;
+
+		case 210:
+			info->side = IPT_RECENT_DEST;
+			break;
+
+		default:
+			return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; must have specified a specific option. */
+static void
+final_check(unsigned int flags)
+{
+
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+			"recent: you must specify one of `--set', `--check' "
+			"`--update' or `--remove'");
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_recent_info *info = (struct ipt_recent_info *)match->data;
+
+	if (info->invert) fputc('!', stdout);
+
+	printf("recent: ");
+	if(info->check_set & IPT_RECENT_SET) printf("SET ");
+	if(info->check_set & IPT_RECENT_CHECK) printf("CHECK ");
+	if(info->check_set & IPT_RECENT_UPDATE) printf("UPDATE ");
+	if(info->check_set & IPT_RECENT_REMOVE) printf("REMOVE ");
+	if(info->seconds) printf("seconds: %d ", info->seconds);
+	if(info->hit_count) printf("hit_count: %d ", info->hit_count);
+	if(info->check_set & IPT_RECENT_TTL) printf("TTL-Match ");
+	if(info->name) printf("name: %s ", info->name);
+	if(info->side == IPT_RECENT_SOURCE) printf("side: source ");
+	if(info->side == IPT_RECENT_DEST) printf("side: dest");
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_recent_info *info = (struct ipt_recent_info *)match;
+
+	if (info->invert) fputc('!', stdout);
+
+	printf("recent: ");
+	if(info->check_set & IPT_RECENT_SET) printf("SET ");
+	if(info->check_set & IPT_RECENT_CHECK) printf("CHECK ");
+	if(info->check_set & IPT_RECENT_UPDATE) printf("UPDATE ");
+	if(info->check_set & IPT_RECENT_REMOVE) printf("REMOVE ");
+	if(info->seconds) printf("seconds: %d ",info->seconds);
+	if(info->hit_count) printf("hit_count: %d ",info->hit_count);
+	if(info->check_set & IPT_RECENT_TTL) printf("TTL-Match ");
+	if(info->name) printf("name: %s ",info->name);
+	if(info->side == IPT_RECENT_SOURCE) printf("side: source ");
+	if(info->side == IPT_RECENT_DEST) printf("side: dest");
+}
+
+static
+struct iptables_match recent
+= { NULL,
+    "recent",
+    IPTABLES_VERSION,
+    IPT_ALIGN(sizeof(struct ipt_recent_info)),
+    IPT_ALIGN(sizeof(struct ipt_recent_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_match(&recent);
+}
diff -urN iptables-1.2.8/extensions/.CLASSIFY-test iptables-1.2.9/extensions/.CLASSIFY-test
--- iptables-1.2.8/extensions/.CLASSIFY-test	2003-04-13 12:28:50.000000000 +0200
+++ iptables-1.2.9/extensions/.CLASSIFY-test	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-#!/bin/sh
-[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_CLASSIFY.c ] && echo CLASSIFY
-
diff -urN iptables-1.2.8/extensions/.CONNMARK-test iptables-1.2.9/extensions/.CONNMARK-test
--- iptables-1.2.8/extensions/.CONNMARK-test	2002-02-25 12:26:01.000000000 +0100
+++ iptables-1.2.9/extensions/.CONNMARK-test	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#! /bin/sh
-[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_CONNMARK.c ] && echo CONNMARK
diff -urN iptables-1.2.8/extensions/.IPMARK-test iptables-1.2.9/extensions/.IPMARK-test
--- iptables-1.2.8/extensions/.IPMARK-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/.IPMARK-test	2003-05-31 19:31:31.000000000 +0200
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if IPMARK patch is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_IPMARK.h ] && echo IPMARK
diff -urN iptables-1.2.8/extensions/.NETLINK-test iptables-1.2.9/extensions/.NETLINK-test
--- iptables-1.2.8/extensions/.NETLINK-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/.NETLINK-test	2001-02-15 09:05:09.000000000 +0100
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_NETLINK.c ] && echo NETLINK
diff -urN iptables-1.2.8/extensions/.NETLINK.test iptables-1.2.9/extensions/.NETLINK.test
--- iptables-1.2.8/extensions/.NETLINK.test	2001-02-15 09:05:09.000000000 +0100
+++ iptables-1.2.9/extensions/.NETLINK.test	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#! /bin/sh
-[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_NETLINK.c ] && echo NETLINK
diff -urN iptables-1.2.8/extensions/.NETMAP-test iptables-1.2.9/extensions/.NETMAP-test
--- iptables-1.2.8/extensions/.NETMAP-test	2001-05-03 03:15:09.000000000 +0200
+++ iptables-1.2.9/extensions/.NETMAP-test	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#! /bin/sh
-[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_NETMAP.c ] && echo NETMAP
diff -urN iptables-1.2.8/extensions/.ROUTE-test6 iptables-1.2.9/extensions/.ROUTE-test6
--- iptables-1.2.8/extensions/.ROUTE-test6	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/.ROUTE-test6	2003-09-05 14:20:40.000000000 +0200
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv6/ip6t_ROUTE.h ] && echo ROUTE
diff -urN iptables-1.2.8/extensions/.TCPLAG-test iptables-1.2.9/extensions/.TCPLAG-test
--- iptables-1.2.8/extensions/.TCPLAG-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/.TCPLAG-test	2003-08-24 10:07:09.000000000 +0200
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_TCPLAG.c ] && echo TCPLAG
diff -urN iptables-1.2.8/extensions/.XOR-test iptables-1.2.9/extensions/.XOR-test
--- iptables-1.2.8/extensions/.XOR-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/.XOR-test	2003-05-31 19:11:49.000000000 +0200
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_XOR.c ] && echo XOR
diff -urN iptables-1.2.8/extensions/.addrtype-test iptables-1.2.9/extensions/.addrtype-test
--- iptables-1.2.8/extensions/.addrtype-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/.addrtype-test	2003-05-07 18:51:40.000000000 +0200
@@ -0,0 +1,5 @@
+#!/bin/bash
+
+if test -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_addrtype.h; then
+	echo "addrtype"
+fi
diff -urN iptables-1.2.8/extensions/.connbytes-test iptables-1.2.9/extensions/.connbytes-test
--- iptables-1.2.8/extensions/.connbytes-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/.connbytes-test	2003-06-19 14:23:37.000000000 +0200
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_connbytes.c ] && echo connbytes
diff -urN iptables-1.2.8/extensions/.connmark-test iptables-1.2.9/extensions/.connmark-test
--- iptables-1.2.8/extensions/.connmark-test	2002-02-25 12:26:01.000000000 +0100
+++ iptables-1.2.9/extensions/.connmark-test	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#! /bin/sh
-[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_connmark.c ] && echo connmark
diff -urN iptables-1.2.8/extensions/.nth-test6 iptables-1.2.9/extensions/.nth-test6
--- iptables-1.2.8/extensions/.nth-test6	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/.nth-test6	2003-05-03 15:55:06.000000000 +0200
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if nth is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv6/ip6t_nth.h ] && echo nth
diff -urN iptables-1.2.8/extensions/.osf-test iptables-1.2.9/extensions/.osf-test
--- iptables-1.2.8/extensions/.osf-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/.osf-test	2003-09-12 23:22:18.000000000 +0200
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if osf is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_osf.h ] && echo osf
diff -urN iptables-1.2.8/extensions/.random-test6 iptables-1.2.9/extensions/.random-test6
--- iptables-1.2.8/extensions/.random-test6	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/.random-test6	2003-05-03 15:46:18.000000000 +0200
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if random is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv6/ip6t_random.h ] && echo random
diff -urN iptables-1.2.8/extensions/.realm-test iptables-1.2.9/extensions/.realm-test
--- iptables-1.2.8/extensions/.realm-test	2001-07-30 15:30:14.000000000 +0200
+++ iptables-1.2.9/extensions/.realm-test	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-#!/bin/sh
-# True if nth is applied.
-[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_realm.h ] && echo realm
diff -urN iptables-1.2.8/extensions/Makefile iptables-1.2.9/extensions/Makefile
--- iptables-1.2.8/extensions/Makefile	2003-03-05 12:39:31.000000000 +0100
+++ iptables-1.2.9/extensions/Makefile	2003-10-16 09:34:36.000000000 +0200
@@ -5,8 +5,8 @@
 # header files are present in the include/linux directory of this iptables
 # package (HW)
 #
-PF_EXT_SLIB:=ah conntrack dscp ecn esp helper icmp iplimit length limit mac mark multiport owner physdev pkttype rpc standard state tcp tcpmss tos ttl udp unclean DNAT DSCP ECN LOG MARK MASQUERADE MIRROR REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TTL ULOG
-PF6_EXT_SLIB:=eui64 hl icmpv6 length limit mac mark multiport owner standard tcp udp HL LOG MARK
+PF_EXT_SLIB:=ah connlimit connmark conntrack dscp ecn esp helper icmp iprange length limit mac mark multiport owner physdev pkttype realm rpc standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE TTL ULOG
+PF6_EXT_SLIB:=eui64 hl icmpv6 length limit mac mark multiport owner standard tcp udp HL LOG MARK TRACE
 
 # Optionals
 PF_EXT_SLIB_OPTS:=$(foreach T,$(wildcard extensions/.*-test),$(shell KERNEL_DIR=$(KERNEL_DIR) $(T)))
diff -urN iptables-1.2.8/extensions/libip6t_LOG.c iptables-1.2.9/extensions/libip6t_LOG.c
--- iptables-1.2.8/extensions/libip6t_LOG.c	2002-09-07 16:31:01.000000000 +0200
+++ iptables-1.2.9/extensions/libip6t_LOG.c	2003-08-23 13:09:22.000000000 +0200
@@ -26,12 +26,12 @@
 }
 
 static struct option opts[] = {
-	{ "log-level", 1, 0, '!' },
-	{ "log-prefix", 1, 0, '#' },
-	{ "log-tcp-sequence", 0, 0, '1' },
-	{ "log-tcp-options", 0, 0, '2' },
-	{ "log-ip-options", 0, 0, '3' },
-	{ 0 }
+	{ .name = "log-level",        .has_arg = 1, .flag = 0, .val = '!' },
+	{ .name = "log-prefix",       .has_arg = 1, .flag = 0, .val = '#' },
+	{ .name = "log-tcp-sequence", .has_arg = 0, .flag = 0, .val = '1' },
+	{ .name = "log-tcp-options",  .has_arg = 0, .flag = 0, .val = '2' },
+	{ .name = "log-ip-options",   .has_arg = 0, .flag = 0, .val = '3' },
+	{ .name = 0 }
 };
 
 /* Initialize the target. */
@@ -52,15 +52,15 @@
 };
 
 static struct ip6t_log_names ip6t_log_names[]
-= { { "alert", LOG_ALERT },
-    { "crit", LOG_CRIT },
-    { "debug", LOG_DEBUG },
-    { "emerg", LOG_EMERG },
-    { "error", LOG_ERR },		/* DEPRECATED */
-    { "info", LOG_INFO },
-    { "notice", LOG_NOTICE },
-    { "panic", LOG_EMERG },		/* DEPRECATED */
-    { "warning", LOG_WARNING }
+= { { .name = "alert",   .level = LOG_ALERT },
+    { .name = "crit",    .level = LOG_CRIT },
+    { .name = "debug",   .level = LOG_DEBUG },
+    { .name = "emerg",   .level = LOG_EMERG },
+    { .name = "error",   .level = LOG_ERR },		/* DEPRECATED */
+    { .name = "info",    .level = LOG_INFO },
+    { .name = "notice",  .level = LOG_NOTICE },
+    { .name = "panic",   .level = LOG_EMERG },		/* DEPRECATED */
+    { .name = "warning", .level = LOG_WARNING }
 };
 
 static u_int8_t
@@ -225,21 +225,12 @@
 {
 	const struct ip6t_log_info *loginfo
 		= (const struct ip6t_log_info *)target->data;
-	unsigned int i = 0;
 
 	if (strcmp(loginfo->prefix, "") != 0)
 		printf("--log-prefix \"%s\" ", loginfo->prefix);
 
-	if (loginfo->level != LOG_DEFAULT_LEVEL) {
-		for (i = 0;
-		     i < sizeof(ip6t_log_names) / sizeof(struct ip6t_log_names);
-		     i++) {
-			if (loginfo->level == ip6t_log_names[i].level) {
-				printf("--log-level %s ", ip6t_log_names[i].name);
-				break;
-			}
-        }
-    }
+	if (loginfo->level != LOG_DEFAULT_LEVEL)
+		printf("--log-level %d ", loginfo->level);
 
 	if (loginfo->logflags & IP6T_LOG_TCPSEQ)
 		printf("--log-tcp-sequence ");
@@ -251,18 +242,18 @@
 
 static
 struct ip6tables_target log
-= { NULL,
-    "LOG",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_log_info)),
-    IP6T_ALIGN(sizeof(struct ip6t_log_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+= {
+    .name          = "LOG",
+    .version       = IPTABLES_VERSION,
+    .size          = IP6T_ALIGN(sizeof(struct ip6t_log_info)),
+    .userspacesize = IP6T_ALIGN(sizeof(struct ip6t_log_info)),
+    .help          = &help,
+    .init          = &init,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
 };
 
 void _init(void)
diff -urN iptables-1.2.8/extensions/libip6t_MARK.c iptables-1.2.9/extensions/libip6t_MARK.c
--- iptables-1.2.8/extensions/libip6t_MARK.c	2002-05-29 15:08:15.000000000 +0200
+++ iptables-1.2.9/extensions/libip6t_MARK.c	2003-09-05 14:48:08.000000000 +0200
@@ -8,11 +8,6 @@
 #include <linux/netfilter_ipv6/ip6_tables.h>
 #include <linux/netfilter_ipv6/ip6t_MARK.h>
 
-struct markinfo {
-	struct ip6t_entry_target t;
-	struct ip6t_mark_target_info mark;
-};
-
 /* Function which prints out usage message. */
 static void
 help(void)
@@ -25,8 +20,8 @@
 }
 
 static struct option opts[] = {
-	{ "set-mark", 1, 0, '1' },
-	{ 0 }
+	{ .name = "set-mark", .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = 0 }
 };
 
 /* Initialize the target. */
@@ -72,12 +67,6 @@
 		           "MARK target: Parameter --set-mark is required");
 }
 
-static void
-print_mark(unsigned long mark, int numeric)
-{
-	printf("0x%lx ", mark);
-}
-
 /* Prints out the targinfo. */
 static void
 print(const struct ip6t_ip6 *ip,
@@ -86,8 +75,8 @@
 {
 	const struct ip6t_mark_target_info *markinfo =
 		(const struct ip6t_mark_target_info *)target->data;
-	printf("MARK set ");
-	print_mark(markinfo->mark, numeric);
+
+	printf("MARK set 0x%lx ", markinfo->mark);
 }
 
 /* Saves the union ipt_targinfo in parsable form to stdout. */
@@ -101,19 +90,18 @@
 }
 
 static
-struct ip6tables_target mark
-= { NULL,
-    "MARK",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_mark_target_info)),
-    IP6T_ALIGN(sizeof(struct ip6t_mark_target_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct ip6tables_target mark = {
+	.name          = "MARK",
+	.version       = IPTABLES_VERSION,
+	.size          = IP6T_ALIGN(sizeof(struct ip6t_mark_target_info)),
+	.userspacesize = IP6T_ALIGN(sizeof(struct ip6t_mark_target_info)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
 };
 
 void _init(void)
diff -urN iptables-1.2.8/extensions/libip6t_ROUTE.c iptables-1.2.9/extensions/libip6t_ROUTE.c
--- iptables-1.2.8/extensions/libip6t_ROUTE.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libip6t_ROUTE.c	2003-09-05 14:20:40.000000000 +0200
@@ -0,0 +1,209 @@
+/* Shared library add-on to iptables to add ROUTE v6 target support.
+ * Author : Cedric de Launois, <delaunois@info.ucl.ac.be>
+ * v 1.0 2003/06/24
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv6/ip6t_ROUTE.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"ROUTE target v%s options:\n"
+"    --oif   \tifname \t\tRoute the packet through `ifname' network interface\n"
+"    --gw    \tip     \t\tRoute the packet via this gateway\n"
+"    --continue\t     \t\tRoute the packet and continue traversing the rules.\n"
+"\n",
+"1.0");
+}
+
+static struct option opts[] = {
+	{ "oif", 1, 0, '1' },
+	{ "iif", 1, 0, '2' },
+	{ "gw", 1, 0, '3' },
+	{ "continue", 0, 0, '4' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ip6t_entry_target *t, unsigned int *nfcache)
+{
+	struct ip6t_route_target_info *route_info = 
+		(struct ip6t_route_target_info*)t->data;
+
+	route_info->oif[0] = '\0';
+	route_info->iif[0] = '\0';
+	route_info->gw[0] = 0;
+	route_info->gw[1] = 0;
+	route_info->gw[2] = 0;
+	route_info->gw[3] = 0;
+	route_info->flags = 0;
+}
+
+
+#define IP6T_ROUTE_OPT_OIF      0x01
+#define IP6T_ROUTE_OPT_IIF      0x02
+#define IP6T_ROUTE_OPT_GW       0x04
+#define IP6T_ROUTE_OPT_CONTINUE 0x08
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      struct ip6t_entry_target **target)
+{
+	struct ip6t_route_target_info *route_info = 
+		(struct ip6t_route_target_info*)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags & IP6T_ROUTE_OPT_OIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --oif twice");
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --oif");
+
+		if (strlen(optarg) > sizeof(route_info->oif) - 1)
+			exit_error(PARAMETER_PROBLEM,
+				   "Maximum interface name length %u",
+				   sizeof(route_info->oif) - 1);
+
+		strcpy(route_info->oif, optarg);
+		*flags |= IP6T_ROUTE_OPT_OIF;
+		break;
+
+	case '2':
+		exit_error(PARAMETER_PROBLEM,
+			   "--iif option not implemented");
+		break;
+
+	case '3':
+		if (*flags & IP6T_ROUTE_OPT_GW)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --gw twice");
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --gw");
+
+		if (!inet_pton(AF_INET6, optarg, (struct in6_addr*)&route_info->gw)) {
+			exit_error(PARAMETER_PROBLEM,
+				   "Invalid IPv6 address %s",
+				   optarg);
+		}
+
+		*flags |= IP6T_ROUTE_OPT_GW;
+		break;
+
+	case '4':
+		if (*flags & IP6T_ROUTE_OPT_CONTINUE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue twice");
+
+		route_info->flags |= IP6T_ROUTE_CONTINUE;
+		*flags |= IP6T_ROUTE_OPT_CONTINUE;
+
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+		           "ROUTE target: oif or gw option required");
+}
+
+
+/* Prints out the targinfo. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_target *target,
+      int numeric)
+{
+	const struct ip6t_route_target_info *route_info
+		= (const struct ip6t_route_target_info *)target->data;
+
+	printf("ROUTE ");
+
+	if (route_info->oif[0])
+		printf("oif:%s ", route_info->oif);
+
+	if (route_info->gw[0] 
+	    || route_info->gw[1] 
+	    || route_info->gw[2] 
+	    || route_info->gw[3]) {
+		char address[INET6_ADDRSTRLEN];
+		printf("gw:%s ", inet_ntop(AF_INET6, route_info->gw, address, INET6_ADDRSTRLEN));
+	}
+
+	if (route_info->flags & IP6T_ROUTE_CONTINUE)
+		printf("continue");
+
+}
+
+
+static void save(const struct ip6t_ip6 *ip, 
+		 const struct ip6t_entry_target *target)
+{
+	const struct ip6t_route_target_info *route_info
+		= (const struct ip6t_route_target_info *)target->data;
+
+	if (route_info->oif[0])
+		printf("--oif %s ", route_info->oif);
+
+	if (route_info->gw[0] 
+	    || route_info->gw[1] 
+	    || route_info->gw[2] 
+	    || route_info->gw[3]) {
+		char address[INET6_ADDRSTRLEN];
+		printf("--gw %s ", inet_ntop(AF_INET6, route_info->gw, address, INET6_ADDRSTRLEN));
+	}
+
+	if (route_info->flags & IP6T_ROUTE_CONTINUE)
+		printf("--continue ");
+}
+
+
+static
+struct ip6tables_target route
+= { NULL,
+    "ROUTE",
+    IPTABLES_VERSION,
+    IP6T_ALIGN(sizeof(struct ip6t_route_target_info)),
+    IP6T_ALIGN(sizeof(struct ip6t_route_target_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_target6(&route);
+}
diff -urN iptables-1.2.8/extensions/libip6t_TRACE.c iptables-1.2.9/extensions/libip6t_TRACE.c
--- iptables-1.2.8/extensions/libip6t_TRACE.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libip6t_TRACE.c	2003-05-21 12:31:08.000000000 +0200
@@ -0,0 +1,63 @@
+/* Shared library add-on to iptables to add TRACE target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TRACE target v%s takes no options\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ip6t_entry_target *t, unsigned int *nfcache)
+{
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      struct ip6t_entry_target **target)
+{
+	return 0;
+}
+
+static void
+final_check(unsigned int flags)
+{
+}
+
+static
+struct ip6tables_target trace
+= {	.next = NULL,
+	.name = "TRACE",
+	.version = IPTABLES_VERSION,
+	.size = IP6T_ALIGN(0),
+	.userspacesize = IP6T_ALIGN(0),
+	.help = &help,
+	.init = &init,
+	.parse = &parse,
+	.final_check = &final_check,
+	.print = NULL, /* print */
+	.save = NULL, /* save */
+	.extra_opts = opts
+};
+
+void _init(void)
+{
+	register_target6(&trace);
+}
diff -urN iptables-1.2.8/extensions/libip6t_ah.c iptables-1.2.9/extensions/libip6t_ah.c
--- iptables-1.2.8/extensions/libip6t_ah.c	2002-05-29 15:08:15.000000000 +0200
+++ iptables-1.2.9/extensions/libip6t_ah.c	2003-08-23 20:38:48.000000000 +0200
@@ -21,10 +21,10 @@
 }
 
 static struct option opts[] = {
-	{ "ahspi", 1, 0, '1' },
-	{ "ahlen", 1, 0, '2' },
-	{ "ahres", 0, 0, '3' },
-	{0}
+	{ .name = "ahspi", .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = "ahlen", .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = "ahres", .has_arg = 0, .flag = 0, .val = '3' },
+	{ .name = 0 }
 };
 
 static u_int32_t
@@ -33,21 +33,21 @@
 	unsigned long int spi;
 	char* ep;
 
-	spi =  strtoul(spistr,&ep,0) ;
+	spi = strtoul(spistr, &ep, 0);
 
-	if ( spistr == ep ) {
+	if ( spistr == ep )
 		exit_error(PARAMETER_PROBLEM,
 			   "AH no valid digits in %s `%s'", typestr, spistr);
-	}
-	if ( spi == ULONG_MAX  && errno == ERANGE ) {
+
+	if ( spi == ULONG_MAX  && errno == ERANGE )
 		exit_error(PARAMETER_PROBLEM,
 			   "%s `%s' specified too big: would overflow",
 			   typestr, spistr);
-	}	
-	if ( *spistr != '\0'  && *ep != '\0' ) {
+
+	if ( *spistr != '\0'  && *ep != '\0' )
 		exit_error(PARAMETER_PROBLEM,
 			   "AH error parsing %s `%s'", typestr, spistr);
-	}
+
 	return (u_int32_t) spi;
 }
 
@@ -59,13 +59,13 @@
 
 	buffer = strdup(spistring);
 	if ((cp = strchr(buffer, ':')) == NULL)
-		spis[0] = spis[1] = parse_ah_spi(buffer,"spi");
+		spis[0] = spis[1] = parse_ah_spi(buffer, "spi");
 	else {
 		*cp = '\0';
 		cp++;
 
-		spis[0] = buffer[0] ? parse_ah_spi(buffer,"spi") : 0;
-		spis[1] = cp[0] ? parse_ah_spi(cp,"spi") : 0xFFFFFFFF;
+		spis[0] = buffer[0] ? parse_ah_spi(buffer, "spi") : 0;
+		spis[1] = cp[0] ? parse_ah_spi(cp, "spi") : 0xFFFFFFFF;
 	}
 	free(buffer);
 }
@@ -139,17 +139,10 @@
 	const char *inv = invert ? "!" : "";
 
 	if (min != 0 || max != 0xFFFFFFFF || invert) {
-		printf("%s", name);
-		if (min == max) {
-			printf(":%s", inv);
-			printf("%u", min);
-		} else {
-			printf("s:%s", inv);
-			printf("%u",min);
-			printf(":");
-			printf("%u",max);
-		}
-		printf(" ");
+		if (min == max)
+			printf("%s:%s%u ", name, inv, min);
+		else
+			printf("%ss:%s%u:%u ", name, inv, min, max);
 	}
 }
 
@@ -158,12 +151,8 @@
 {
 	const char *inv = invert ? "!" : "";
 
-	if (len != 0 || invert) {
-		printf("%s", name);
-		printf(":%s", inv);
-		printf("%u", len);
-		printf(" ");
-	}
+	if (len != 0 || invert)
+		printf("%s:%s%u ", name, inv, len);
 }
 
 /* Prints out the union ip6t_matchinfo. */
@@ -178,7 +167,10 @@
 		    ah->invflags & IP6T_AH_INV_SPI);
 	print_len("length", ah->hdrlen, 
 		    ah->invflags & IP6T_AH_INV_LEN);
-	if (ah->hdrres) printf("reserved ");
+
+	if (ah->hdrres)
+		printf("reserved ");
+
 	if (ah->invflags & ~IP6T_AH_INV_MASK)
 		printf("Unknown invflags: 0x%X ",
 		       ah->invflags & ~IP6T_AH_INV_MASK);
@@ -209,26 +201,23 @@
 			ahinfo->hdrlen);
 	}
 
-	if (ahinfo->hdrres != 0 ) {
+	if (ahinfo->hdrres != 0 )
 		printf("--ahres ");
-	}
-
 }
 
 static
-struct ip6tables_match ah
-= { NULL,
-    "ah",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_ah)),
-    IP6T_ALIGN(sizeof(struct ip6t_ah)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct ip6tables_match ah = {
+	.name          = "ah",
+	.version       = IPTABLES_VERSION,
+	.size          = IP6T_ALIGN(sizeof(struct ip6t_ah)),
+	.userspacesize = IP6T_ALIGN(sizeof(struct ip6t_ah)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
 };
 
 void
diff -urN iptables-1.2.8/extensions/libip6t_condition.c iptables-1.2.9/extensions/libip6t_condition.c
--- iptables-1.2.8/extensions/libip6t_condition.c	2003-03-26 15:42:35.000000000 +0100
+++ iptables-1.2.9/extensions/libip6t_condition.c	2003-04-28 02:04:34.000000000 +0200
@@ -1,3 +1,4 @@
+/* Shared library add-on to ip6tables for condition match */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -39,13 +40,13 @@
 	struct condition6_info *info =
 	    (struct condition6_info *) (*match)->data;
 
-	check_inverse(optarg, &invert, &optind, 0);
-
 	if (c == 'X') {
 		if (*flags)
 			exit_error(PARAMETER_PROBLEM,
 				   "Can't specify multiple conditions");
 
+		check_inverse(optarg, &invert, &optind, 0);
+
 		if (strlen(argv[optind - 1]) < CONDITION6_NAME_LEN)
 			strcpy(info->name, argv[optind - 1]);
 		else
@@ -88,7 +89,7 @@
 	const struct condition6_info *info =
 	    (const struct condition6_info *) match->data;
 
-	printf("--condition %s%s ", (info->invert) ? "! " : "", info->name);
+	printf("--condition %s\"%s\" ", (info->invert) ? "! " : "", info->name);
 }
 
 
diff -urN iptables-1.2.8/extensions/libip6t_dst.c iptables-1.2.9/extensions/libip6t_dst.c
--- iptables-1.2.8/extensions/libip6t_dst.c	2002-06-14 09:38:16.000000000 +0200
+++ iptables-1.2.9/extensions/libip6t_dst.c	2003-09-04 23:54:40.000000000 +0200
@@ -6,44 +6,37 @@
 #include <getopt.h>
 #include <errno.h>
 #include <ip6tables.h>
-/*#include <linux/in6.h>*/
 #include <linux/netfilter_ipv6/ip6t_opts.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <arpa/inet.h>
-                                        
-#define DEBUG		0
-#define HOPBYHOP	0
-#define UNAME		(HOPBYHOP ? "HBH" : "DST")
-#define LNAME		(HOPBYHOP ? "hbh" : "dst")
+
+#ifdef HOPBYHOP
+#define UNAME "HBH"
+#define LNAME "hbh"
+#else
+#define UNAME "DST"
+#define LNAME "dst"
+#endif
 
 /* Function which prints out usage message. */
 static void
 help(void)
 {
 	printf(
-"%s v%s options:\n"
-" --%s-len [!] length           total length of this header\n"
-" --%s-opts TYPE[:LEN][,TYPE[:LEN]...] \n"
+UNAME " v%s options:\n"
+" --" LNAME "-len [!] length           total length of this header\n"
+" --" LNAME "-opts TYPE[:LEN][,TYPE[:LEN]...] \n"
 "                               Options and its length (list, max: %d)\n", 
-UNAME , IPTABLES_VERSION, LNAME, LNAME, IP6T_OPTS_OPTSNR);
+IPTABLES_VERSION, IP6T_OPTS_OPTSNR);
 }
 
-#if HOPBYHOP
 static struct option opts[] = {
-	{ "hbh-len", 1, 0, '1' },
-	{ "hbh-opts", 1, 0, '2' },
-	{ "hbh-not-strict", 1, 0, '3' },
-	{0}
+	{ .name = LNAME "-len",        .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = LNAME "-opts",       .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = LNAME "-not-strict", .has_arg = 1, .flag = 0, .val = '3' },
+	{ .name = 0 }
 };
-#else
-static struct option opts[] = {
-	{ "dst-len", 1, 0, '1' },
-	{ "dst-opts", 1, 0, '2' },
-	{ "dst-not-strict", 1, 0, '3' },
-	{0}
-};
-#endif
 
 static u_int32_t
 parse_opts_num(const char *idstr, const char *typestr)
@@ -51,20 +44,20 @@
 	unsigned long int id;
 	char* ep;
 
-	id =  strtoul(idstr,&ep,0) ;
+	id = strtoul(idstr, &ep, 0);
 
 	if ( idstr == ep ) {
 		exit_error(PARAMETER_PROBLEM,
-			   "%s no valid digits in %s `%s'", UNAME, typestr, idstr);
+			   UNAME " no valid digits in %s `%s'", typestr, idstr);
 	}
 	if ( id == ULONG_MAX  && errno == ERANGE ) {
 		exit_error(PARAMETER_PROBLEM,
 			   "%s `%s' specified too big: would overflow",
 			   typestr, idstr);
-	}	
+	}
 	if ( *idstr != '\0'  && *ep != '\0' ) {
 		exit_error(PARAMETER_PROBLEM,
-			   "%s error parsing %s `%s'", UNAME, typestr, idstr);
+			   UNAME " error parsing %s `%s'", typestr, idstr);
 	}
 	return (u_int32_t) id;
 }
@@ -76,39 +69,47 @@
         unsigned int i;
 	
 	buffer = strdup(optsstr);
-        if (!buffer) exit_error(OTHER_PROBLEM, "strdup failed");
+        if (!buffer)
+		exit_error(OTHER_PROBLEM, "strdup failed");
 			
-        for (cp=buffer, i=0; cp && i<IP6T_OPTS_OPTSNR; cp=next,i++)
+        for (cp = buffer, i = 0; cp && i < IP6T_OPTS_OPTSNR; cp = next, i++)
         {
-                next=strchr(cp, ',');
-                if (next) *next++='\0';
+                next = strchr(cp, ',');
+
+                if (next)
+			*next++='\0';
+
                 range = strchr(cp, ':');
+
                 if (range) {
                         if (i == IP6T_OPTS_OPTSNR-1)
                                 exit_error(PARAMETER_PROBLEM,
                                            "too many ports specified");
                         *range++ = '\0';
                 }
+
                 opts[i] = (u_int16_t)((parse_opts_num(cp,"opt") & 0x000000FF)<<8); 
                 if (range) {
 			if (opts[i] == 0)
-        			exit_error(PARAMETER_PROBLEM, "PAD0 hasn't got length");
+        			exit_error(PARAMETER_PROBLEM,
+					"PAD0 hasn't got length");
                         opts[i] |= (u_int16_t)(parse_opts_num(range,"length") &
 					0x000000FF);
-                } else {
+                } else
                         opts[i] |= (0x00FF);
-		}
 
-#if DEBUG
+#ifdef DEBUG
 		printf("opts str: %s %s\n", cp, range);
 		printf("opts opt: %04X\n", opts[i]);
 #endif
 	}
-        if (cp) exit_error(PARAMETER_PROBLEM, "too many addresses specified");
+
+        if (cp)
+		exit_error(PARAMETER_PROBLEM, "too many addresses specified");
 
 	free(buffer);
 
-#if DEBUG
+#ifdef DEBUG
 	printf("addr nr: %d\n", i);
 #endif
 
@@ -141,7 +142,7 @@
 	case '1':
 		if (*flags & IP6T_OPTS_LEN)
 			exit_error(PARAMETER_PROBLEM,
-				   "Only one `--%s-len' allowed", LNAME);
+				   "Only one `--" LNAME "-len' allowed");
 		check_inverse(optarg, &invert, &optind, 0);
 		optinfo->hdrlen = parse_opts_num(argv[optind-1], "length");
 		if (invert)
@@ -152,11 +153,11 @@
 	case '2':
 		if (*flags & IP6T_OPTS_OPTS)
 			exit_error(PARAMETER_PROBLEM,
-				   "Only one `--%s-opts' allowed", LNAME);
+				   "Only one `--" LNAME "-opts' allowed");
                 check_inverse(optarg, &invert, &optind, 0);
                 if (invert)
                         exit_error(PARAMETER_PROBLEM,
-				" '!' not allowed with `--%s-opts'", LNAME);
+				" '!' not allowed with `--" LNAME "-opts'");
 		optinfo->optsnr = parse_options(argv[optind-1], optinfo->opts);
 		optinfo->flags |= IP6T_OPTS_OPTS;
 		*flags |= IP6T_OPTS_OPTS;
@@ -164,10 +165,11 @@
 	case '3':
 		if (*flags & IP6T_OPTS_NSTRICT)
 			exit_error(PARAMETER_PROBLEM,
-				   "Only one `--%s-not-strict' allowed", LNAME);
+				   "Only one `--" LNAME "-not-strict' allowed");
 		if ( !(*flags & IP6T_OPTS_OPTS) )
 			exit_error(PARAMETER_PROBLEM,
-				   "`--%s-opts ...' required before `--%s-not-strict'", LNAME, LNAME);
+				   "`--" LNAME "-opts ...' required before `--"
+				   LNAME "-not-strict'");
 		optinfo->flags |= IP6T_OPTS_NSTRICT;
 		*flags |= IP6T_OPTS_NSTRICT;
 		break;
@@ -189,12 +191,13 @@
 {
 	unsigned int i;
 
-	for(i=0; i<optsnr; i++){
-		printf("%d", (optsp[i] & 0xFF00)>>8);
-		if ((optsp[i] & 0x00FF) != 0x00FF){
+	for(i = 0; i < optsnr; i++) {
+		printf("%d", (optsp[i] & 0xFF00) >> 8);
+
+		if ((optsp[i] & 0x00FF) != 0x00FF)
 			printf(":%d", (optsp[i] & 0x00FF));
-		} 
-		printf("%c", (i!=optsnr-1)?',':' ');
+
+		printf("%c", (i != optsnr - 1) ? ',' : ' ');
 	}
 }
 
@@ -205,16 +208,20 @@
 {
 	const struct ip6t_opts *optinfo = (struct ip6t_opts *)match->data;
 
-	printf("%s ", LNAME);
-	if (optinfo->flags & IP6T_OPTS_LEN) {
-		printf("length");
-		printf(":%s", optinfo->invflags & IP6T_OPTS_INV_LEN ? "!" : "");
-		printf("%u", optinfo->hdrlen);
-		printf(" ");
-	}
-	if (optinfo->flags & IP6T_OPTS_OPTS) printf("opts ");
+	printf(LNAME " ");
+	if (optinfo->flags & IP6T_OPTS_LEN)
+		printf("length:%s%u ",
+			optinfo->invflags & IP6T_OPTS_INV_LEN ? "!" : "",
+			optinfo->hdrlen);
+
+	if (optinfo->flags & IP6T_OPTS_OPTS)
+		printf("opts ");
+
 	print_options(optinfo->optsnr, (u_int16_t *)optinfo->opts);
-	if (optinfo->flags & IP6T_OPTS_NSTRICT) printf("not-strict ");
+
+	if (optinfo->flags & IP6T_OPTS_NSTRICT)
+		printf("not-strict ");
+
 	if (optinfo->invflags & ~IP6T_OPTS_INV_MASK)
 		printf("Unknown invflags: 0x%X ",
 		       optinfo->invflags & ~IP6T_OPTS_INV_MASK);
@@ -226,35 +233,33 @@
 	const struct ip6t_opts *optinfo = (struct ip6t_opts *)match->data;
 
 	if (optinfo->flags & IP6T_OPTS_LEN) {
-		printf("--%s-len %s%u ", LNAME, 
+		printf("--" LNAME "-len %s%u ", 
 			(optinfo->invflags & IP6T_OPTS_INV_LEN) ? "! " : "", 
 			optinfo->hdrlen);
 	}
 
-	if (optinfo->flags & IP6T_OPTS_OPTS) printf("--%s-opts ", LNAME);
+	if (optinfo->flags & IP6T_OPTS_OPTS)
+		printf("--" LNAME "-opts ");
+
 	print_options(optinfo->optsnr, (u_int16_t *)optinfo->opts);
-	if (optinfo->flags & IP6T_OPTS_NSTRICT) printf("--%s-not-strict ", LNAME);
 
+	if (optinfo->flags & IP6T_OPTS_NSTRICT)
+		printf("--" LNAME "-not-strict ");
 }
 
 static
-struct ip6tables_match optstruct
-= { NULL,
-#if HOPBYHOP
-    "hbh",
-#else
-    "dst",
-#endif
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_opts)),
-    IP6T_ALIGN(sizeof(struct ip6t_opts)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct ip6tables_match optstruct = {
+	.name          = LNAME,
+	.version       = IPTABLES_VERSION,
+	.size          = IP6T_ALIGN(sizeof(struct ip6t_opts)),
+	.userspacesize = IP6T_ALIGN(sizeof(struct ip6t_opts)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
 };
 
 void
diff -urN iptables-1.2.8/extensions/libip6t_esp.c iptables-1.2.9/extensions/libip6t_esp.c
--- iptables-1.2.8/extensions/libip6t_esp.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.2.9/extensions/libip6t_esp.c	2003-08-23 20:38:25.000000000 +0200
@@ -19,8 +19,8 @@
 }
 
 static struct option opts[] = {
-	{ "espspi", 1, 0, '1' },
-	{0}
+	{ .name = "espspi", .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = 0 }
 };
 
 static u_int32_t
@@ -29,7 +29,7 @@
 	unsigned long int spi;
 	char* ep;
 
-	spi =  strtoul(spistr,&ep,0) ;
+	spi = strtoul(spistr, &ep, 0);
 
 	if ( spistr == ep ) {
 		exit_error(PARAMETER_PROBLEM,
@@ -117,17 +117,10 @@
 	const char *inv = invert ? "!" : "";
 
 	if (min != 0 || max != 0xFFFFFFFF || invert) {
-		printf("%s", name);
-		if (min == max) {
-			printf(":%s", inv);
-			printf("%u", min);
-		} else {
-			printf("s:%s", inv);
-			printf("%u",min);
-			printf(":");
-			printf("%u",max);
-		}
-		printf(" ");
+		if (min == max)
+			printf("%s:%s%u ", name, inv, min);
+		else
+			printf("%ss:%s%u:%u ", name, inv, min, max);
 	}
 }
 
@@ -168,19 +161,18 @@
 }
 
 static
-struct ip6tables_match esp
-= { NULL,
-    "esp",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_esp)),
-    IP6T_ALIGN(sizeof(struct ip6t_esp)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct ip6tables_match esp = {
+	.name          = "esp",
+	.version       = IPTABLES_VERSION,
+	.size          = IP6T_ALIGN(sizeof(struct ip6t_esp)),
+	.userspacesize = IP6T_ALIGN(sizeof(struct ip6t_esp)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
 };
 
 void
diff -urN iptables-1.2.8/extensions/libip6t_frag.c iptables-1.2.9/extensions/libip6t_frag.c
--- iptables-1.2.8/extensions/libip6t_frag.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.2.9/extensions/libip6t_frag.c	2003-09-05 14:47:07.000000000 +0200
@@ -24,13 +24,13 @@
 }
 
 static struct option opts[] = {
-	{ "fragid", 1, 0, '1' },
-	{ "fraglen", 1, 0, '2' },
-	{ "fragres", 0, 0, '3' },
-	{ "fragfirst", 0, 0, '4' },
-	{ "fragmore", 0, 0, '5' },
-	{ "fraglast", 0, 0, '6' },
-	{0}
+	{ .name = "fragid",    .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = "fraglen",   .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = "fragres",   .has_arg = 0, .flag = 0, .val = '3' },
+	{ .name = "fragfirst", .has_arg = 0, .flag = 0, .val = '4' },
+	{ .name = "fragmore",  .has_arg = 0, .flag = 0, .val = '5' },
+	{ .name = "fraglast",  .has_arg = 0, .flag = 0, .val = '6' },
+	{ .name = 0 }
 };
 
 static u_int32_t
@@ -39,7 +39,7 @@
 	unsigned long int id;
 	char* ep;
 
-	id =  strtoul(idstr,&ep,0) ;
+	id = strtoul(idstr, &ep, 0);
 
 	if ( idstr == ep ) {
 		exit_error(PARAMETER_PROBLEM,
@@ -171,16 +171,10 @@
 
 	if (min != 0 || max != 0xFFFFFFFF || invert) {
 		printf("%s", name);
-		if (min == max) {
-			printf(":%s", inv);
-			printf("%u", min);
-		} else {
-			printf("s:%s", inv);
-			printf("%u",min);
-			printf(":");
-			printf("%u",max);
-		}
-		printf(" ");
+		if (min == max)
+			printf(":%s%u ", inv, min);
+		else
+			printf("s:%s%u:%u ", inv, min, max);
 	}
 }
 
@@ -194,16 +188,25 @@
 	printf("frag ");
 	print_ids("id", frag->ids[0], frag->ids[1],
 		    frag->invflags & IP6T_FRAG_INV_IDS);
+
 	if (frag->flags & IP6T_FRAG_LEN) {
-		printf("length");
-		printf(":%s", frag->invflags & IP6T_FRAG_INV_LEN ? "!" : "");
-		printf("%u", frag->hdrlen);
-		printf(" ");
-	}
-	if (frag->flags & IP6T_FRAG_RES) printf("reserved ");
-	if (frag->flags & IP6T_FRAG_FST) printf("first ");
-	if (frag->flags & IP6T_FRAG_MF) printf("more ");
-	if (frag->flags & IP6T_FRAG_NMF) printf("last ");
+		printf("length:%s%u ",
+			frag->invflags & IP6T_FRAG_INV_LEN ? "!" : "",
+			frag->hdrlen);
+	}
+
+	if (frag->flags & IP6T_FRAG_RES)
+		printf("reserved ");
+
+	if (frag->flags & IP6T_FRAG_FST)
+		printf("first ");
+
+	if (frag->flags & IP6T_FRAG_MF)
+		printf("more ");
+
+	if (frag->flags & IP6T_FRAG_NMF)
+		printf("last ");
+
 	if (frag->invflags & ~IP6T_FRAG_INV_MASK)
 		printf("Unknown invflags: 0x%X ",
 		       frag->invflags & ~IP6T_FRAG_INV_MASK);
@@ -234,27 +237,32 @@
 			fraginfo->hdrlen);
 	}
 
-	if (fraginfo->flags & IP6T_FRAG_RES) printf("--fragres ");
-	if (fraginfo->flags & IP6T_FRAG_FST) printf("--fragfirst ");
-	if (fraginfo->flags & IP6T_FRAG_MF) printf("--fragmore ");
-	if (fraginfo->flags & IP6T_FRAG_NMF) printf("--fraglast ");
+	if (fraginfo->flags & IP6T_FRAG_RES)
+		printf("--fragres ");
+
+	if (fraginfo->flags & IP6T_FRAG_FST)
+		printf("--fragfirst ");
+
+	if (fraginfo->flags & IP6T_FRAG_MF)
+		printf("--fragmore ");
 
+	if (fraginfo->flags & IP6T_FRAG_NMF)
+		printf("--fraglast ");
 }
 
 static
-struct ip6tables_match frag
-= { NULL,
-    "frag",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_frag)),
-    IP6T_ALIGN(sizeof(struct ip6t_frag)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct ip6tables_match frag = {
+	.name          = "frag",
+	.version       = IPTABLES_VERSION,
+	.size          = IP6T_ALIGN(sizeof(struct ip6t_frag)),
+	.userspacesize = IP6T_ALIGN(sizeof(struct ip6t_frag)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
 };
 
 void
diff -urN iptables-1.2.8/extensions/libip6t_fuzzy.c iptables-1.2.9/extensions/libip6t_fuzzy.c
--- iptables-1.2.8/extensions/libip6t_fuzzy.c	2003-04-11 12:30:36.000000000 +0200
+++ iptables-1.2.9/extensions/libip6t_fuzzy.c	2003-08-23 20:39:18.000000000 +0200
@@ -7,6 +7,9 @@
 
 2002-08-07 Hime Aguiar e Oliveira Jr. <hime@engineer.com> : Initial version.
 2003-04-08 Maciej Soltysiak <solt@dns.toxicfilms.tv> : IPv6 Port
+2003-06-09 Hime Aguiar e Oliveira Jr. <hime@engineer.com> : Bug corrections in
+the save function , thanks to information given by Jean-Francois Patenaude.
+
 */
 
 #include <stdio.h>
@@ -31,9 +34,9 @@
 };
 
 static struct option opts[] = {
-	{ "lower-limit", 1 , 0 , '1' } ,
-	{ "upper-limit", 1 , 0 , '2' } ,
-	{ 0 }
+	{ .name = "lower-limit", .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = "upper-limit", .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = 0 }
 };
 
 /* Initialize data structures */
@@ -61,8 +64,8 @@
       unsigned int *nfcache,
       struct ip6t_entry_match **match)
 {
-
-struct ip6t_fuzzy_info *fuzzyinfo = (struct ip6t_fuzzy_info *)(*match)->data;
+	struct ip6t_fuzzy_info *fuzzyinfo =
+		(struct ip6t_fuzzy_info *)(*match)->data;
 
 	u_int32_t num;
 
@@ -96,7 +99,7 @@
 	if (string_to_number(optarg,1,MAXFUZZYRATE,&num) == -1 || num < 1)
 		exit_error(PARAMETER_PROBLEM,"BAD --upper-limit");
 
-		fuzzyinfo->maximum_rate = num ;
+		fuzzyinfo->maximum_rate = num;
 
 		*flags |= IP6T_FUZZY_OPT_MAXIMUM;
 
@@ -120,8 +123,8 @@
 	const struct ip6t_fuzzy_info *fuzzyinfo
 		= (const struct ip6t_fuzzy_info *)match->data;
 
-	printf(" fuzzy: lower limit = %u pps - upper limit = %u pps ",fuzzyinfo->minimum_rate,fuzzyinfo->maximum_rate);
-
+	printf(" fuzzy: lower limit = %u pps - upper limit = %u pps ",
+		fuzzyinfo->minimum_rate, fuzzyinfo->maximum_rate);
 }
 
 /* Saves the union ip6t_targinfo in parsable form to stdout. */
@@ -131,24 +134,22 @@
 	const struct ip6t_fuzzy_info *fuzzyinfo
 		= (const struct ip6t_fuzzy_info *)match->data;
 
-	printf("--upper-limit %u ",fuzzyinfo->minimum_rate);
-	printf("--lower-limit %u ",fuzzyinfo->maximum_rate);
-
+	printf("--lower-limit %u --upper-limit %u ",
+		fuzzyinfo->minimum_rate, fuzzyinfo->maximum_rate);
 }
 
-struct ip6tables_match fuzzy_match
-= { NULL,
-    "fuzzy",
-    IPTABLES_VERSION,
-    IP6T_ALIGN(sizeof(struct ip6t_fuzzy_info)),
-    IP6T_ALIGN(sizeof(struct ip6t_fuzzy_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+struct ip6tables_match fuzzy_match = {
+	.name          = "fuzzy",
+	.version       = IPTABLES_VERSION,
+	.size          = IP6T_ALIGN(sizeof(struct ip6t_fuzzy_info)),
+	.userspacesize = IP6T_ALIGN(sizeof(struct ip6t_fuzzy_info)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
 };
 
 void _init(void)
diff -urN iptables-1.2.8/extensions/libip6t_hl.c iptables-1.2.9/extensions/libip6t_hl.c
--- iptables-1.2.8/extensions/libip6t_hl.c	2003-01-08 10:14:20.000000000 +0100
+++ iptables-1.2.9/extensions/libip6t_hl.c	2003-05-14 07:21:48.000000000 +0200
@@ -3,6 +3,7 @@
  * Maciej Soltysiak <solt@dns.toxicfilms.tv>
  * Based on HW's ttl match
  * This program is released under the terms of GNU GPL
+ * Cleanups by Stephane Ouellette <ouellettes@videotron.ca>
  */
 
 #include <stdio.h>
@@ -18,7 +19,7 @@
 {
 	printf(
 "HL match v%s options:\n"
-"  --hl-eq value	Match hop limit value\n"
+"  --hl-eq [!] value	Match hop limit value\n"
 "  --hl-lt value	Match HL < value\n"
 "  --hl-gt value	Match HL > value\n"
 , IPTABLES_VERSION);
@@ -81,7 +82,6 @@
 			break;
 		default:
 			return 0;
-
 	}
 
 	return 1;
@@ -92,82 +92,61 @@
 	if (!flags) 
 		exit_error(PARAMETER_PROBLEM,
 			"HL match: You must specify one of "
-			"`--hl-eq', `--hl-lt', `--hl-gt");
+			"`--hl-eq', `--hl-lt', `--hl-gt'");
 }
 
 static void print(const struct ip6t_ip6 *ip, 
 		const struct ip6t_entry_match *match,
 		int numeric)
 {
+	static const char *op[] = {
+		[IP6T_HL_EQ] = "==",
+		[IP6T_HL_NE] = "!=",
+		[IP6T_HL_LT] = "<",
+		[IP6T_HL_GT] = ">" };
+
 	const struct ip6t_hl_info *info = 
 		(struct ip6t_hl_info *) match->data;
 
-	printf("HL match ");
-	switch (info->mode) {
-		case IP6T_HL_EQ:
-			printf("HL == ");
-			break;
-		case IP6T_HL_NE:
-			printf("HL != ");
-			break;
-		case IP6T_HL_LT:
-			printf("HL < ");
-			break;
-		case IP6T_HL_GT:
-			printf("HL > ");
-			break;
-	}
-	printf("%u ", info->hop_limit);
+	printf("HL match HL %s %u ", op[info->mode], info->hop_limit);
 }
 
 static void save(const struct ip6t_ip6 *ip, 
 		const struct ip6t_entry_match *match)
 {
+	static const char *op[] = {
+		[IP6T_HL_EQ] = "eq",
+		[IP6T_HL_NE] = "eq !",
+		[IP6T_HL_LT] = "lt",
+		[IP6T_HL_GT] = "gt" };
+
 	const struct ip6t_hl_info *info =
 		(struct ip6t_hl_info *) match->data;
 
-	switch (info->mode) {
-		case IP6T_HL_EQ:
-			printf("--hl-eq ");
-			break;
-		case IP6T_HL_NE:
-			printf("! --hl-eq ");
-			break;
-		case IP6T_HL_LT:
-			printf("--hl-lt ");
-			break;
-		case IP6T_HL_GT:
-			printf("--hl-gt ");
-			break;
-		default:
-			/* error */
-			break;
-	}
-	printf("%u ", info->hop_limit);
+	printf("--hl-%s %u ", op[info->mode], info->hop_limit);
 }
 
 static struct option opts[] = {
-	{ "hl", 1, 0, '2' },
-	{ "hl-eq", 1, 0, '2'},
-	{ "hl-lt", 1, 0, '3'},
-	{ "hl-gt", 1, 0, '4'},
+	{ .name = "hl",    .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = "hl-eq", .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = "hl-lt", .has_arg = 1, .flag = 0, .val = '3' },
+	{ .name = "hl-gt", .has_arg = 1, .flag = 0, .val = '4' },
 	{ 0 }
 };
 
 static
 struct ip6tables_match hl = {
-	NULL,
-	"hl",
-	IPTABLES_VERSION,
-	IP6T_ALIGN(sizeof(struct ip6t_hl_info)),
-	IP6T_ALIGN(sizeof(struct ip6t_hl_info)),
-	&help,
-	&init,
-	&parse,
-	&final_check,
-	&print,
-	&save,
-	opts
+	.name          = "hl",
+	.version       = IPTABLES_VERSION,
+	.size          = IP6T_ALIGN(sizeof(struct ip6t_hl_info)),
+	.userspacesize = IP6T_ALIGN(sizeof(struct ip6t_hl_info)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
 };
 
 
diff -urN iptables-1.2.8/extensions/libip6t_mac.c iptables-1.2.9/extensions/libip6t_mac.c
--- iptables-1.2.8/extensions/libip6t_mac.c	2003-01-06 14:04:53.000000000 +0100
+++ iptables-1.2.9/extensions/libip6t_mac.c	2003-06-15 00:39:35.000000000 +0200
@@ -86,11 +86,11 @@
 	return 1;
 }
 
-static void print_mac(unsigned char macaddress[ETH_ALEN], int invert)
+static void print_mac(unsigned char macaddress[ETH_ALEN])
 {
 	unsigned int i;
 
-	printf("%s%02X", invert ? "! " : "", macaddress[0]);
+	printf("%02X", macaddress[0]);
 	for (i = 1; i < ETH_ALEN; i++)
 		printf(":%02X", macaddress[i]);
 	printf(" ");
@@ -111,16 +111,21 @@
       int numeric)
 {
 	printf("MAC ");
-	print_mac(((struct ip6t_mac_info *)match->data)->srcaddr,
-		  ((struct ip6t_mac_info *)match->data)->invert);
+
+	if (((struct ip6t_mac_info *)match->data)->invert)
+		printf("! ");
+
+	print_mac(((struct ip6t_mac_info *)match->data)->srcaddr);
 }
 
 /* Saves the union ip6t_matchinfo in parsable form to stdout. */
 static void save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
 {
+	if (((struct ip6t_mac_info *)match->data)->invert)
+		printf("! ");
+
 	printf("--mac-source ");
-	print_mac(((struct ip6t_mac_info *)match->data)->srcaddr,
-		  ((struct ip6t_mac_info *)match->data)->invert);
+	print_mac(((struct ip6t_mac_info *)match->data)->srcaddr);
 }
 
 static
diff -urN iptables-1.2.8/extensions/libip6t_multiport.c iptables-1.2.9/extensions/libip6t_multiport.c
--- iptables-1.2.8/extensions/libip6t_multiport.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.2.9/extensions/libip6t_multiport.c	2003-07-14 09:43:07.000000000 +0200
@@ -237,7 +237,7 @@
 
 	for (i=0; i < multiinfo->count; i++) {
 		printf("%s", i ? "," : "");
-		print_port(multiinfo->ports[i], ip->proto, 0);
+		print_port(multiinfo->ports[i], ip->proto, 1);
 	}
 	printf(" ");
 }
diff -urN iptables-1.2.8/extensions/libip6t_nth.c iptables-1.2.9/extensions/libip6t_nth.c
--- iptables-1.2.8/extensions/libip6t_nth.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libip6t_nth.c	2003-05-03 15:55:06.000000000 +0200
@@ -0,0 +1,238 @@
+/* 
+   Shared library add-on to iptables to add match support for every Nth packet
+   
+   This file is distributed under the terms of the GNU General Public
+   License (GPL). Copies of the GPL can be obtained from:
+   ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+   2001-07-17 Fabrice MARIE <fabrice@netfilter.org> : initial development.
+   2001-09-20 Richard Wagner (rwagner@cloudnet.com)
+        * added support for multiple counters
+        * added support for matching on individual packets
+          in the counter cycle
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv6/ip6t_nth.h>
+
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"nth v%s options:\n"
+"   --every     Nth              Match every Nth packet\n"
+"  [--counter]  num              Use counter 0-%u (default:0)\n"
+"  [--start]    num              Initialize the counter at the number 'num'\n"
+"                                instead of 0. Must be between 0 and Nth-1\n"
+"  [--packet]   num              Match on 'num' packet. Must be between 0\n"
+"                                and Nth-1.\n\n"
+"                                If --packet is used for a counter than\n"
+"                                there must be Nth number of --packet\n"
+"                                rules, covering all values between 0 and\n"
+"                                Nth-1 inclusively.\n",
+IPTABLES_VERSION, IP6T_NTH_NUM_COUNTERS-1);
+}
+
+static struct option opts[] = {
+	{ "every", 1, 0, '1' },
+	{ "start", 1, 0, '2' },
+        { "counter", 1, 0, '3' },
+        { "packet", 1, 0, '4' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ip6t_entry_match *m, unsigned int *nfcache)
+{
+	*nfcache |= NFC_UNKNOWN;
+}
+
+#define IP6T_NTH_OPT_EVERY	0x01
+#define IP6T_NTH_OPT_NOT_EVERY	0x02
+#define IP6T_NTH_OPT_START	0x04
+#define IP6T_NTH_OPT_COUNTER     0x08
+#define IP6T_NTH_OPT_PACKET      0x10
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct ip6t_nth_info *nthinfo = (struct ip6t_nth_info *)(*match)->data;
+	unsigned int num;
+
+	switch (c) {
+	case '1':
+		/* check for common mistakes... */
+		if ((!invert) && (*flags & IP6T_NTH_OPT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --every twice");
+		if (invert && (*flags & IP6T_NTH_OPT_NOT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --every twice");
+		if ((!invert) && (*flags & IP6T_NTH_OPT_NOT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --every with ! --every");
+		if (invert && (*flags & IP6T_NTH_OPT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --every with --every");
+
+		/* Remember, this function will interpret a leading 0 to be 
+		   Octal, a leading 0x to be hexdecimal... */
+                if (string_to_number(optarg, 2, 100, &num) == -1 || num < 2)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --every `%s', must be between 2 and 100", optarg);
+
+		/* assign the values */
+		nthinfo->every = num-1;
+		nthinfo->startat = 0;
+                nthinfo->packet = 0xFF;
+                if(!(*flags & IP6T_NTH_OPT_EVERY))
+                {
+                        nthinfo->counter = 0;
+                }
+		if (invert)
+		{
+			*flags |= IP6T_NTH_OPT_NOT_EVERY;
+			nthinfo->not = 1;
+		}
+		else
+		{
+			*flags |= IP6T_NTH_OPT_EVERY;
+			nthinfo->not = 0;
+		}
+		break;
+	case '2':
+		/* check for common mistakes... */
+		if (!((*flags & IP6T_NTH_OPT_EVERY) ||
+		      (*flags & IP6T_NTH_OPT_NOT_EVERY)))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --start before --every");
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify with ! --start");
+		if (*flags & IP6T_NTH_OPT_START)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --start twice");
+		if (string_to_number(optarg, 0, nthinfo->every, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --start `%s', must between 0 and %u", optarg, nthinfo->every);
+		*flags |= IP6T_NTH_OPT_START;
+		nthinfo->startat = num;
+		break;
+        case '3':
+                /* check for common mistakes... */
+                if (invert)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify with ! --counter");
+                if (*flags & IP6T_NTH_OPT_COUNTER)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --counter twice");
+                if (string_to_number(optarg, 0, IP6T_NTH_NUM_COUNTERS-1, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --counter `%s', must between 0 and %u", optarg, IP6T_NTH_NUM_COUNTERS-1);
+                /* assign the values */
+                *flags |= IP6T_NTH_OPT_COUNTER;
+                nthinfo->counter = num;
+                break;
+        case '4':
+                /* check for common mistakes... */
+                if (!((*flags & IP6T_NTH_OPT_EVERY) ||
+                      (*flags & IP6T_NTH_OPT_NOT_EVERY)))
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --packet before --every");
+                if ((*flags & IP6T_NTH_OPT_NOT_EVERY))
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --packet with ! --every");
+                if (invert)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify with ! --packet");
+                if (*flags & IP6T_NTH_OPT_PACKET)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --packet twice");
+                if (string_to_number(optarg, 0, nthinfo->every, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --packet `%s', must between 0 and %u", optarg, nthinfo->every);
+                *flags |= IP6T_NTH_OPT_PACKET;
+                nthinfo->packet = num;
+                break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	const struct ip6t_nth_info *nthinfo
+		= (const struct ip6t_nth_info *)match->data;
+
+	if (nthinfo->not == 1)
+		printf(" !");
+	printf("every %uth ", (nthinfo->every +1));
+	if (nthinfo->counter != 0) 
+		printf("counter #%u ", (nthinfo->counter));
+        if (nthinfo->packet != 0xFF)
+                printf("packet #%u ", nthinfo->packet);
+	if (nthinfo->startat != 0)
+		printf("start at %u ", nthinfo->startat);
+}
+
+/* Saves the union ip6t_targinfo in parsable form to stdout. */
+static void
+save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+	const struct ip6t_nth_info *nthinfo
+		= (const struct ip6t_nth_info *)match->data;
+
+	if (nthinfo->not == 1)
+		printf("! ");
+	printf("--every %u ", (nthinfo->every +1));
+	printf("--counter %u ", (nthinfo->counter));
+	if (nthinfo->startat != 0)
+		printf("--start %u ", nthinfo->startat );
+        if (nthinfo->packet != 0xFF)
+                printf("--packet %u ", nthinfo->packet );
+}
+
+struct ip6tables_match nth
+= { NULL,
+    "nth",
+    IPTABLES_VERSION,
+    IP6T_ALIGN(sizeof(struct ip6t_nth_info)),
+    IP6T_ALIGN(sizeof(struct ip6t_nth_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_match6(&nth);
+}
diff -urN iptables-1.2.8/extensions/libip6t_owner.c iptables-1.2.9/extensions/libip6t_owner.c
--- iptables-1.2.8/extensions/libip6t_owner.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.2.9/extensions/libip6t_owner.c	2003-06-30 18:16:54.000000000 +0200
@@ -14,14 +14,26 @@
 static void
 help(void)
 {
+#ifdef IP6T_OWNER_COMM
 	printf(
 "OWNER match v%s options:\n"
 "[!] --uid-owner userid     Match local uid\n"
 "[!] --gid-owner groupid    Match local gid\n"
 "[!] --pid-owner processid  Match local pid\n"
 "[!] --sid-owner sessionid  Match local sid\n"
+"[!] --cmd-owner name       Match local command name\n"
 "\n",
 IPTABLES_VERSION);
+#else
+	printf(
+"OWNER match v%s options:\n"
+"[!] --uid-owner userid     Match local uid\n"
+"[!] --gid-owner groupid    Match local gid\n"
+"[!] --pid-owner processid  Match local pid\n"
+"[!] --sid-owner sessionid  Match local sid\n"
+"\n",
+IPTABLES_VERSION);
+#endif /* IP6T_OWNER_COMM */
 }
 
 static struct option opts[] = {
@@ -29,6 +41,9 @@
 	{ "gid-owner", 1, 0, '2' },
 	{ "pid-owner", 1, 0, '3' },
 	{ "sid-owner", 1, 0, '4' },
+#ifdef IP6T_OWNER_COMM
+	{ "cmd-owner", 1, 0, '5' },
+#endif
 	{0}
 };
 
@@ -107,6 +122,21 @@
 		*flags = 1;
 		break;
 
+#ifdef IP6T_OWNER_COMM
+	case '5':
+		check_inverse(optarg, &invert, &optind, 0);
+		if(strlen(optarg) > sizeof(ownerinfo->comm))
+			exit_error(PARAMETER_PROBLEM, "OWNER CMD `%s' too long, max %d characters", optarg, sizeof(ownerinfo->comm));
+		
+		strncpy(ownerinfo->comm, optarg, sizeof(ownerinfo->comm));
+
+		if (invert)
+			ownerinfo->invert |= IP6T_OWNER_COMM;
+		ownerinfo->match |= IP6T_OWNER_COMM;
+		*flags = 1;
+		break;
+#endif
+		
 	default:
 		return 0;
 	}
@@ -121,7 +151,7 @@
 		printf(label);
 
 		if (info->invert & flag)
-			fputc('!', stdout);
+			printf("! ");
 
 		switch(info->match & flag) {
 		case IP6T_OWNER_UID:
@@ -154,6 +184,11 @@
 		case IP6T_OWNER_SID:
 			printf("%u ", info->sid);
 			break;
+#ifdef IP6T_OWNER_COMM
+		case IP6T_OWNER_COMM:
+			printf("%.*s ", (int)sizeof(info->comm), info->comm);
+			break;
+#endif
 		default:
 			break;
 		}
@@ -181,6 +216,9 @@
 	print_item(info, IP6T_OWNER_GID, numeric, "OWNER GID match ");
 	print_item(info, IP6T_OWNER_PID, numeric, "OWNER PID match ");
 	print_item(info, IP6T_OWNER_SID, numeric, "OWNER SID match ");
+#ifdef IP6T_OWNER_COMM
+	print_item(info, IP6T_OWNER_COMM, numeric, "OWNER CMD match ");
+#endif
 }
 
 /* Saves the union ip6t_matchinfo in parsable form to stdout. */
@@ -193,6 +231,9 @@
 	print_item(info, IP6T_OWNER_GID, 0, "--gid-owner ");
 	print_item(info, IP6T_OWNER_PID, 0, "--pid-owner ");
 	print_item(info, IP6T_OWNER_SID, 0, "--sid-owner ");
+#ifdef IP6T_OWNER_COMM
+	print_item(info, IP6T_OWNER_COMM, 0, "--cmd-owner ");
+#endif
 }
 
 static
diff -urN iptables-1.2.8/extensions/libip6t_random.c iptables-1.2.9/extensions/libip6t_random.c
--- iptables-1.2.8/extensions/libip6t_random.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libip6t_random.c	2003-05-03 15:46:18.000000000 +0200
@@ -0,0 +1,152 @@
+/* 
+   Shared library add-on to iptables to add match support for random match.
+   
+   This file is distributed under the terms of the GNU General Public
+   License (GPL). Copies of the GPL can be obtained from:
+   ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+   2001-10-14 Fabrice MARIE <fabrice@netfilter.org> : initial development.
+   2003-04-30 Maciej Soltysiak <solt@dns.toxicfilms.tv> : IPv6 port.
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv6/ip6t_random.h>
+
+/**
+ * The kernel random routing returns numbers between 0 and 255.
+ * To ease the task of the user in choosing the probability
+ * of matching, we want him to be able to use percentages.
+ * Therefore we have to accept numbers in percentage here,
+ * turn them into number between 0 and 255 for the kernel module,
+ * and turn them back to percentages when we print/save
+ * the rule.
+ */
+
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"random v%s options:\n"
+"  [--average]     percent      The probability in percentage of the match\n"
+"                               If ommited, a probability of 50%% percent is set.\n"
+"                               Percentage must be within : 1 <= percent <= 99.\n\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "average", 1, 0, '1' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ip6t_entry_match *m, unsigned int *nfcache)
+{
+	struct ip6t_rand_info *randinfo = (struct ip6t_rand_info *)(m)->data;
+	*nfcache |= NFC_UNKNOWN;
+
+	/* We assign the average to be 50 which is our default value */
+	/* 50 * 2.55 = 128 */
+	randinfo->average = 128;
+}
+
+#define IP6T_RAND_OPT_AVERAGE	0x01
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct ip6t_rand_info *randinfo = (struct ip6t_rand_info *)(*match)->data;
+	unsigned int num;
+
+	switch (c) {
+	case '1':
+		/* check for common mistakes... */
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --average");
+		if (*flags & IP6T_RAND_OPT_AVERAGE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --average twice");
+
+		/* Remember, this function will interpret a leading 0 to be 
+		   Octal, a leading 0x to be hexdecimal... */
+                if (string_to_number(optarg, 1, 99, &num) == -1 || num < 1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --average `%s', must be between 1 and 99", optarg);
+
+		/* assign the values */
+		randinfo->average = (int)(num * 2.55);
+		*flags |= IP6T_RAND_OPT_AVERAGE;
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	const struct ip6t_rand_info *randinfo
+		= (const struct ip6t_rand_info *)match->data;
+	div_t result = div((randinfo->average*100), 255);
+	if (result.rem > 127)  /* round up... */
+		++result.quot;
+
+	printf(" random %u%% ", result.quot);
+}
+
+/* Saves the union ip6t_targinfo in parsable form to stdout. */
+static void
+save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+	const struct ip6t_rand_info *randinfo
+		= (const struct ip6t_rand_info *)match->data;
+	div_t result = div((randinfo->average *100), 255);
+	if (result.rem > 127)  /* round up... */
+		++result.quot;
+
+	printf("--average %u ", result.quot);
+}
+
+struct ip6tables_match rand_match
+= { NULL,
+    "random",
+    IPTABLES_VERSION,
+    IP6T_ALIGN(sizeof(struct ip6t_rand_info)),
+    IP6T_ALIGN(sizeof(struct ip6t_rand_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_match6(&rand_match);
+}
diff -urN iptables-1.2.8/extensions/libip6t_udp.c iptables-1.2.9/extensions/libip6t_udp.c
--- iptables-1.2.8/extensions/libip6t_udp.c	2002-07-26 18:27:57.000000000 +0200
+++ iptables-1.2.9/extensions/libip6t_udp.c	2003-10-06 13:36:51.000000000 +0200
@@ -205,7 +205,7 @@
 	const struct ip6t_udp *udpinfo = (struct ip6t_udp *)match->data;
 
 	if (udpinfo->spts[0] != 0
-	    && udpinfo->spts[1] != 0xFFFF) {
+	    || udpinfo->spts[1] != 0xFFFF) {
 		if (udpinfo->invflags & IP6T_UDP_INV_SRCPT)
 			printf("! ");
 		if (udpinfo->spts[0]
@@ -219,7 +219,7 @@
 	}
 
 	if (udpinfo->dpts[0] != 0
-	    && udpinfo->dpts[1] != 0xFFFF) {
+	    || udpinfo->dpts[1] != 0xFFFF) {
 		if (udpinfo->invflags & IP6T_UDP_INV_DSTPT)
 			printf("! ");
 		if (udpinfo->dpts[0]
diff -urN iptables-1.2.8/extensions/libipt_IPMARK.c iptables-1.2.9/extensions/libipt_IPMARK.c
--- iptables-1.2.8/extensions/libipt_IPMARK.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_IPMARK.c	2003-06-30 18:16:54.000000000 +0200
@@ -0,0 +1,170 @@
+/* Shared library add-on to iptables to add IPMARK target support.
+ * (C) 2003 by Grzegorz Janoszka <Grzegorz.Janoszka@pro.onet.pl>
+ *
+ * based on original MARK target
+ * 
+ * This program is distributed under the terms of GNU GPL
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_IPMARK.h>
+
+#define IPT_ADDR_USED        1
+#define IPT_AND_MASK_USED    2
+#define IPT_OR_MASK_USED     4
+
+struct ipmarkinfo {
+	struct ipt_entry_target t;
+	struct ipt_ipmark_target_info ipmark;
+};
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"IPMARK target v%s options:\n"
+"  --addr src/dst         use source or destination ip address\n"
+"  --and-mask value       logical AND ip address with this value becomes MARK\n"
+"  --or-mask value        logical OR ip address with this value becomes MARK\n"
+"\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "addr", 1, 0, '1' },
+	{ "and-mask", 1, 0, '2' },
+	{ "or-mask", 1, 0, '3' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+	struct ipt_ipmark_target_info *ipmarkinfo =
+		(struct ipt_ipmark_target_info *)t->data;
+
+	ipmarkinfo->andmask=0xffffffff;
+	ipmarkinfo->ormask=0;
+
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	struct ipt_ipmark_target_info *ipmarkinfo
+		= (struct ipt_ipmark_target_info *)(*target)->data;
+
+	switch (c) {
+		char *end;
+	case '1':
+		if(!strcmp(optarg, "src")) ipmarkinfo->addr=IPT_IPMARK_SRC;
+		  else if(!strcmp(optarg, "dst")) ipmarkinfo->addr=IPT_IPMARK_DST;
+		    else exit_error(PARAMETER_PROBLEM, "Bad addr value `%s' - should be `src' or `dst'", optarg);
+		if (*flags & IPT_ADDR_USED)
+			exit_error(PARAMETER_PROBLEM,
+			           "IPMARK target: Can't specify --addr twice");
+		*flags |= IPT_ADDR_USED;
+		break;
+	
+	case '2':
+		ipmarkinfo->andmask = strtoul(optarg, &end, 0);
+		if (*end != '\0' || end == optarg)
+			exit_error(PARAMETER_PROBLEM, "Bad and-mask value `%s'", optarg);
+		if (*flags & IPT_AND_MASK_USED)
+			exit_error(PARAMETER_PROBLEM,
+			           "IPMARK target: Can't specify --and-mask twice");
+		*flags |= IPT_AND_MASK_USED;
+		break;
+	case '3':
+		ipmarkinfo->ormask = strtoul(optarg, &end, 0);
+		if (*end != '\0' || end == optarg)
+			exit_error(PARAMETER_PROBLEM, "Bad or-mask value `%s'", optarg);
+		if (*flags & IPT_OR_MASK_USED)
+			exit_error(PARAMETER_PROBLEM,
+			           "IPMARK target: Can't specify --or-mask twice");
+		*flags |= IPT_OR_MASK_USED;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+	if (!(flags & IPT_ADDR_USED))
+		exit_error(PARAMETER_PROBLEM,
+		           "IPMARK target: Parameter --addr is required");
+	if (!(flags & (IPT_AND_MASK_USED | IPT_OR_MASK_USED)))
+		exit_error(PARAMETER_PROBLEM,
+		           "IPMARK target: Parameter --and-mask or --or-mask is required");
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	const struct ipt_ipmark_target_info *ipmarkinfo =
+		(const struct ipt_ipmark_target_info *)target->data;
+
+	if(ipmarkinfo->addr == IPT_IPMARK_SRC)
+	  printf("IPMARK src");
+	else
+	  printf("IPMARK dst");
+	printf(" ip and 0x%lx or 0x%lx", ipmarkinfo->andmask, ipmarkinfo->ormask);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	const struct ipt_ipmark_target_info *ipmarkinfo =
+		(const struct ipt_ipmark_target_info *)target->data;
+
+	if(ipmarkinfo->addr == IPT_IPMARK_SRC)
+	  printf("--addr=src ");
+	else
+	  printf("--addr=dst ");
+	if(ipmarkinfo->andmask != 0xffffffff)
+	  printf("--and-mask 0x%lx ", ipmarkinfo->andmask);
+	if(ipmarkinfo->ormask != 0)
+	  printf("--or-mask 0x%lx ", ipmarkinfo->ormask);
+}
+
+static
+struct iptables_target ipmark
+= { NULL,
+    "IPMARK",
+    IPTABLES_VERSION,
+    IPT_ALIGN(sizeof(struct ipt_ipmark_target_info)),
+    IPT_ALIGN(sizeof(struct ipt_ipmark_target_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_target(&ipmark);
+}
diff -urN iptables-1.2.8/extensions/libipt_LOG.c iptables-1.2.9/extensions/libipt_LOG.c
--- iptables-1.2.8/extensions/libipt_LOG.c	2002-09-07 16:31:01.000000000 +0200
+++ iptables-1.2.9/extensions/libipt_LOG.c	2003-08-23 13:09:22.000000000 +0200
@@ -26,12 +26,12 @@
 }
 
 static struct option opts[] = {
-	{ "log-level", 1, 0, '!' },
-	{ "log-prefix", 1, 0, '#' },
-	{ "log-tcp-sequence", 0, 0, '1' },
-	{ "log-tcp-options", 0, 0, '2' },
-	{ "log-ip-options", 0, 0, '3' },
-	{ 0 }
+	{ .name = "log-level",        .has_arg = 1, .flag = 0, .val = '!' },
+	{ .name = "log-prefix",       .has_arg = 1, .flag = 0, .val = '#' },
+	{ .name = "log-tcp-sequence", .has_arg = 0, .flag = 0, .val = '1' },
+	{ .name = "log-tcp-options",  .has_arg = 0, .flag = 0, .val = '2' },
+	{ .name = "log-ip-options",   .has_arg = 0, .flag = 0, .val = '3' },
+	{ .name = 0 }
 };
 
 /* Initialize the target. */
@@ -52,15 +52,15 @@
 };
 
 static struct ipt_log_names ipt_log_names[]
-= { { "alert", LOG_ALERT },
-    { "crit", LOG_CRIT },
-    { "debug", LOG_DEBUG },
-    { "emerg", LOG_EMERG },
-    { "error", LOG_ERR },		/* DEPRECATED */
-    { "info", LOG_INFO },
-    { "notice", LOG_NOTICE },
-    { "panic", LOG_EMERG },		/* DEPRECATED */
-    { "warning", LOG_WARNING }
+= { { .name = "alert",   .level = LOG_ALERT },
+    { .name = "crit",    .level = LOG_CRIT },
+    { .name = "debug",   .level = LOG_DEBUG },
+    { .name = "emerg",   .level = LOG_EMERG },
+    { .name = "error",   .level = LOG_ERR },		/* DEPRECATED */
+    { .name = "info",    .level = LOG_INFO },
+    { .name = "notice",  .level = LOG_NOTICE },
+    { .name = "panic",   .level = LOG_EMERG },		/* DEPRECATED */
+    { .name = "warning", .level = LOG_WARNING }
 };
 
 static u_int8_t
@@ -225,21 +225,12 @@
 {
 	const struct ipt_log_info *loginfo
 		= (const struct ipt_log_info *)target->data;
-	unsigned int i = 0;
 
 	if (strcmp(loginfo->prefix, "") != 0)
 		printf("--log-prefix \"%s\" ", loginfo->prefix);
 
-	if (loginfo->level != LOG_DEFAULT_LEVEL) {
-		for (i = 0;
-		     i < sizeof(ipt_log_names) / sizeof(struct ipt_log_names);
-		     i++) {
-			if (loginfo->level == ipt_log_names[i].level) {
-				printf("--log-level %s ", ipt_log_names[i].name);
-				break;
-			}
-        }
-    }
+	if (loginfo->level != LOG_DEFAULT_LEVEL)
+		printf("--log-level %d ", loginfo->level);
 
 	if (loginfo->logflags & IPT_LOG_TCPSEQ)
 		printf("--log-tcp-sequence ");
@@ -251,18 +242,18 @@
 
 static
 struct iptables_target log
-= { NULL,
-    "LOG",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_log_info)),
-    IPT_ALIGN(sizeof(struct ipt_log_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+= {
+    .name          = "LOG",
+    .version       = IPTABLES_VERSION,
+    .size          = IPT_ALIGN(sizeof(struct ipt_log_info)),
+    .userspacesize = IPT_ALIGN(sizeof(struct ipt_log_info)),
+    .help          = &help,
+    .init          = &init,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
 };
 
 void _init(void)
diff -urN iptables-1.2.8/extensions/libipt_MASQUERADE.c iptables-1.2.9/extensions/libipt_MASQUERADE.c
--- iptables-1.2.8/extensions/libipt_MASQUERADE.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.2.9/extensions/libipt_MASQUERADE.c	2003-11-01 19:32:28.000000000 +0100
@@ -47,7 +47,7 @@
 	mr->range[0].flags |= IP_NAT_RANGE_PROTO_SPECIFIED;
 
 	port = atoi(arg);
-	if (port == 0 || port > 65535)
+	if (port <= 0 || port > 65535)
 		exit_error(PARAMETER_PROBLEM, "Port `%s' not valid\n", arg);
 
 	dash = strchr(arg, '-');
diff -urN iptables-1.2.8/extensions/libipt_NOTRACK.c iptables-1.2.9/extensions/libipt_NOTRACK.c
--- iptables-1.2.8/extensions/libipt_NOTRACK.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_NOTRACK.c	2003-05-21 12:31:08.000000000 +0200
@@ -0,0 +1,63 @@
+/* Shared library add-on to iptables to add NOTRACK target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"NOTRACK target v%s takes no options\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	return 0;
+}
+
+static void
+final_check(unsigned int flags)
+{
+}
+
+static
+struct iptables_target notrack 
+= {	.next = NULL,
+	.name = "NOTRACK",
+	.version = IPTABLES_VERSION,
+	.size = IPT_ALIGN(0),
+	.userspacesize = IPT_ALIGN(0),
+	.help = &help,
+	.init = &init,
+	.parse = &parse,
+	.final_check = &final_check,
+	.print = NULL, /* print */
+	.save = NULL, /* save */
+	.extra_opts = opts
+};
+
+void _init(void)
+{
+	register_target(&notrack);
+}
diff -urN iptables-1.2.8/extensions/libipt_REJECT.c iptables-1.2.9/extensions/libipt_REJECT.c
--- iptables-1.2.8/extensions/libipt_REJECT.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.2.9/extensions/libipt_REJECT.c	2003-05-25 09:37:54.000000000 +0200
@@ -9,6 +9,16 @@
 #include <iptables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/netfilter_ipv4/ipt_REJECT.h>
+#include <linux/version.h>
+
+/* If we are compiling against a kernel that does not support
+ * IPT_ICMP_ADMIN_PROHIBITED, we are emulating it.
+ * The result will be a plain DROP of the packet instead of
+ * reject. -- Maciej Soltysiak <solt@dns.toxicfilms.tv>
+ */
+#ifndef IPT_ICMP_ADMIN_PROHIBITED
+#define IPT_ICMP_ADMIN_PROHIBITED	IPT_TCP_RESET + 1
+#endif
 
 struct reject_names {
 	const char *name;
@@ -35,7 +45,9 @@
 	{"icmp-host-prohibited", "host-prohib",
 	 IPT_ICMP_HOST_PROHIBITED, "ICMP host prohibited"},
 	{"tcp-reset", "tcp-reset",
-	 IPT_TCP_RESET, "TCP RST packet"}
+	 IPT_TCP_RESET, "TCP RST packet"},
+	{"icmp-admin-prohibited", "admin-prohib",
+	 IPT_ICMP_ADMIN_PROHIBITED, "ICMP administratively prohibited (*)"}
 };
 
 static void
@@ -64,6 +76,8 @@
 "                                a reply packet according to type:\n");
 
 	print_reject_types();
+
+	printf("(*) See man page or read the INCOMPATIBILITES file for compatibility issues.\n");
 }
 
 static struct option opts[] = {
diff -urN iptables-1.2.8/extensions/libipt_ROUTE.c iptables-1.2.9/extensions/libipt_ROUTE.c
--- iptables-1.2.8/extensions/libipt_ROUTE.c	2003-01-08 10:51:34.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_ROUTE.c	2003-08-02 16:48:32.000000000 +0200
@@ -1,5 +1,6 @@
 /* Shared library add-on to iptables to add ROUTE target support.
- * Author : Cdric de Launois, <delaunois@info.ucl.ac.be>
+ * Author : Cedric de Launois, <delaunois@info.ucl.ac.be>
+ * v 1.8 2003/06/24
  */
 
 #include <stdio.h>
@@ -20,17 +21,20 @@
 {
 	printf(
 "ROUTE target v%s options:\n"
-"  --oif   \tifname \t\tSend the packet out using `ifname' network interface\n"
-"  --iif   \tifname \t\tChange the packet's incoming interface to `ifname'\n"
-"  --gw    \tip     \t\tRoute the packet via this gateway\n"
+"    --oif   \tifname \t\tRoute the packet through `ifname' network interface\n"
+"    --iif   \tifname \t\tChange the packet's incoming interface to `ifname'\n"
+"    --gw    \tip     \t\tRoute the packet via this gateway\n"
+"    --continue\t     \t\tRoute the packet and continue traversing the\n"
+"            \t       \t\trules. Not valid with --iif.\n"
 "\n",
-IPTABLES_VERSION);
+"1.8");
 }
 
 static struct option opts[] = {
 	{ "oif", 1, 0, '1' },
 	{ "iif", 1, 0, '2' },
 	{ "gw", 1, 0, '3' },
+	{ "continue", 0, 0, '4' },
 	{ 0 }
 };
 
@@ -44,11 +48,14 @@
 	route_info->oif[0] = '\0';
 	route_info->iif[0] = '\0';
 	route_info->gw = 0;
+	route_info->flags = 0;
 }
 
 
-#define IPT_ROUTE_OPT_IF       0x01
-#define IPT_ROUTE_OPT_GW       0x02
+#define IPT_ROUTE_OPT_OIF      0x01
+#define IPT_ROUTE_OPT_IIF      0x02
+#define IPT_ROUTE_OPT_GW       0x04
+#define IPT_ROUTE_OPT_CONTINUE 0x08
 
 /* Function which parses command options; returns true if it
    ate an option */
@@ -62,9 +69,13 @@
 
 	switch (c) {
 	case '1':
-		if (*flags & IPT_ROUTE_OPT_IF)
+		if (*flags & IPT_ROUTE_OPT_OIF)
 			exit_error(PARAMETER_PROBLEM,
-				   "Can't specify --oif twice or --oif with --iif");
+				   "Can't specify --oif twice");
+
+		if (*flags & IPT_ROUTE_OPT_IIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't use --oif and --iif together");
 
 		if (check_inverse(optarg, &invert, NULL, 0))
 			exit_error(PARAMETER_PROBLEM,
@@ -76,13 +87,17 @@
 				   sizeof(route_info->oif) - 1);
 
 		strcpy(route_info->oif, optarg);
-		*flags |= IPT_ROUTE_OPT_IF;
+		*flags |= IPT_ROUTE_OPT_OIF;
 		break;
 
 	case '2':
-		if (*flags & IPT_ROUTE_OPT_IF)
+		if (*flags & IPT_ROUTE_OPT_IIF)
 			exit_error(PARAMETER_PROBLEM,
-				   "Can't specify --iif twice or --iif with --oif");
+				   "Can't specify --iif twice");
+
+		if (*flags & IPT_ROUTE_OPT_OIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't use --iif and --oif together");
 
 		if (check_inverse(optarg, &invert, NULL, 0))
 			exit_error(PARAMETER_PROBLEM,
@@ -94,7 +109,7 @@
 				   sizeof(route_info->iif) - 1);
 
 		strcpy(route_info->iif, optarg);
-		*flags |= IPT_ROUTE_OPT_IF;
+		*flags |= IPT_ROUTE_OPT_IIF;
 		break;
 
 	case '3':
@@ -102,6 +117,10 @@
 			exit_error(PARAMETER_PROBLEM,
 				   "Can't specify --gw twice");
 
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --gw");
+
 		if (!inet_aton(optarg, (struct in_addr*)&route_info->gw)) {
 			exit_error(PARAMETER_PROBLEM,
 				   "Invalid IP address %s",
@@ -111,6 +130,16 @@
 		*flags |= IPT_ROUTE_OPT_GW;
 		break;
 
+	case '4':
+		if (*flags & IPT_ROUTE_OPT_CONTINUE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue twice");
+
+		route_info->flags |= IPT_ROUTE_CONTINUE;
+		*flags |= IPT_ROUTE_OPT_CONTINUE;
+
+		break;
+
 	default:
 		return 0;
 	}
@@ -124,7 +153,11 @@
 {
 	if (!flags)
 		exit_error(PARAMETER_PROBLEM,
-		           "ROUTE target: one parameter is required");
+		           "ROUTE target: oif, iif or gw option required");
+
+	if ((flags & IPT_ROUTE_OPT_CONTINUE) && (flags & IPT_ROUTE_OPT_IIF))
+		exit_error(PARAMETER_PROBLEM,
+			   "ROUTE target: can't continue traversing the rules with iif option");
 }
 
 
@@ -140,15 +173,19 @@
 	printf("ROUTE ");
 
 	if (route_info->oif[0])
-		printf("oif %s ", route_info->oif);
+		printf("oif:%s ", route_info->oif);
 
 	if (route_info->iif[0])
-		printf("iif %s ", route_info->iif);
+		printf("iif:%s ", route_info->iif);
 
 	if (route_info->gw) {
 		struct in_addr ip = { route_info->gw };
-		printf("gw %s ", inet_ntoa(ip));
+		printf("gw:%s ", inet_ntoa(ip));
 	}
+
+	if (route_info->flags & IPT_ROUTE_CONTINUE)
+		printf("continue");
+
 }
 
 
@@ -168,6 +205,9 @@
 		struct in_addr ip = { route_info->gw };
 		printf("--gw %s ", inet_ntoa(ip));
 	}
+
+	if (route_info->flags & IPT_ROUTE_CONTINUE)
+		printf("--continue ");
 }
 
 
diff -urN iptables-1.2.8/extensions/libipt_TCPLAG.c iptables-1.2.9/extensions/libipt_TCPLAG.c
--- iptables-1.2.8/extensions/libipt_TCPLAG.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_TCPLAG.c	2003-08-24 10:06:41.000000000 +0200
@@ -0,0 +1,228 @@
+/* libipt_TCPLAG.c -- module for iptables to interface with TCPLAG target
+ * Copyright (C) 2002 Telford Tendys <telford@triode.net.au>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Shared library add-on to iptables for TCPLAG target control
+ *
+ * This allows installation and removal of the TCPLAG target
+ * Note that there is a lot more commentary in this file than
+ * the average libipt target (i.e. more than none) but these
+ * are just my deductions based on examination of the source
+ * and 
+ */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_TCPLAG.h>
+
+/*
+ * This merely dumps out text for the user
+ * (saves keeping the manpage up to date)
+ */
+static void help( void )
+{
+	printf( "TCPLAG options:\n"
+			" --log-level=n    Set the syslog level to n (integer 0 to 7)\n\n"
+			" --log-prefix=xx  Prefix log messages with xx\n" );
+}
+
+/*
+ * See "man getopt_long" for an explanation of this structure
+ *
+ * If one of our options DOES happen to come up then we get
+ * a callback into parse(), our vals must not overlap with any
+ * normal iptables short options (I think) because there is only
+ * one actual options handler and it can't tell whose options it
+ * is really looking at unless they are all distinct.
+ *
+ * These are exactly the same as the LOG target options
+ * and have the same purpose.
+ */
+static const struct option opts[] =
+{
+	{ "log-level",     1, 0, '!' },
+	{ "log-prefix",    1, 0, '#' },
+	{ 0 }
+};
+
+/*
+ * This gives us a chance to install some initial values in
+ * our own private data structure (which is at t->data).
+ * Probably we could fiddle with t->tflags too but there is
+ * no great advantage in doing so.
+ * 
+ * TODO: Find documentation for the above flags which
+ *       can be ored into nfcache...
+ *
+ * NFC_IP6_DST_PT
+ * NFC_IP6_PROTO_UNKNOWN
+ * NFC_IP6_SRC_PT
+ * NFC_IP6_TCPFLAGS
+ * NFC_IP_DST_PT
+ * NFC_IP_SRC_PT
+ * NFC_IP_TOS
+ * NFC_UNKNOWN             -- This one seems safest
+ */
+static void init( struct ipt_entry_target *t, unsigned int *nfcache )
+{
+	struct ipt_tcplag *el = (struct ipt_tcplag *)t->data;
+	memset( el, 0, sizeof( struct ipt_tcplag ));
+	el->level = 4; /* Default to warning level */
+	strcpy( el->prefix, "TCPLAG:" ); /* Give a reasonable default prefix */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/*
+ * It doesn't take much thought to see how little thought has gone into
+ * this particular API. However, to add to that I'd just like to say that
+ * it can be made to work and small miracles are still miracles.
+ *
+ * The input parameters are as follows:
+ * 
+ *  c      --  the 'val' from opts[] above, could possibly be something
+ *             we cannot recognise in which case return(0).
+ *             If we do recognise it then return(1).
+ *
+ *  argv   --  in case we want to take parameters from the command line,
+ *             not sure how to safely ensure that the parameter that
+ *             we want to take will really exist, presumably getopt_long()
+ *             will have already checked such things (what about optional
+ *             parameters huh?).
+ *
+ *  invert --  if the option parameter had '!' in front of it, usually this
+ *             would inversion of the matching sense but I don't think it
+ *             is useful in the case of targets.
+ *
+ *  flags  --  always (*target)->tflags for those who feel it is better
+ *             to access this field indirectly <shrug> starts of
+ *             zero for a fresh target, gets fed into final_check().
+ *
+ *  entry  --  apparently useless
+ *
+ *  target --  the record that holds data about this target,
+ *             most importantly, our private data is (*target)->data
+ *             (this has already been malloced for us).
+ */
+static int parse( int c, char **argv, int invert, unsigned int *flags,
+				  const struct ipt_entry *entry, struct ipt_entry_target **target )
+{
+	struct ipt_tcplag *el = (struct ipt_tcplag *)( *target )->data;
+/*
+ * Yeah, we could complain about options being issued twice but
+ * is it really worth the trouble? Will it make the world a better place?
+ */
+	switch( c )
+	{
+/*
+ * I really can't be bothered with the syslog naming convention,
+ * it isn't terribly useful anyhow.
+ */
+		case '!':
+			el->level = strtol( optarg, 0, 10 );
+			return( 1 );
+/*
+ * 15 chars should be plenty
+ */
+		case '#':
+			strncpy( el->prefix, optarg, 15 );
+			el->prefix[ 14 ] = 0; /* Force termination */
+			return( 1 );
+	}
+	return( 0 );
+}
+
+/*
+ * This gets given the (*target)->tflags value from
+ * the parse() above and it gets called after all the
+ * parsing of options is completed. Thus if one option
+ * requires another option you can test the flags and
+ * decide whether everything is in order.
+ *
+ * If there is a problem then do something like:
+ *		exit_error( PARAMETER_PROBLEM, "foobar parameters detected in TCPLAG target");
+ *
+ * In this case, no errors are possible
+ */
+static void final_check( unsigned int flags ) { }
+/*
+ * This print is for the purpose of user-readable display
+ * such as what "iptables -L" would give. The notes in
+ * iptables.h say that target could possibly be a null pointer
+ * but coding of the various libipt_XX.c modules suggests
+ * that it is safe to presume target is correctly initialised.
+ */
+static void print(const struct ipt_ip *ip, const struct ipt_entry_target *target, int numeric)
+{
+	const struct ipt_tcplag *el = (const struct ipt_tcplag *)target->data;
+	printf("TCPLAG <%d>", el->level );
+	if( el->prefix[ 0 ])
+	{
+		printf( "%s", el->prefix );
+	}
+}
+
+/*
+ * As above but command-line style printout
+ * (machine-readable for restoring table)
+ */
+static void save( const struct ipt_ip *ip, const struct ipt_entry_target *target )
+{
+	const struct ipt_tcplag *el = (const struct ipt_tcplag *)target->data;
+	printf("TCPLAG --log-level=%d", el->level );
+	if( el->prefix[ 0 ])
+	{
+/*
+ * FIXME: Should have smarter quoting
+ */
+		printf( " --log-prefix='%s'", el->prefix );
+	}
+}
+
+/*
+ * The version must match the iptables version exactly
+ * which is a big pain, could use `iptables -V` in makefile
+ * but we can't guarantee compatibility with all iptables
+ * so we are stuck with only supporting one particular version.
+ */
+static struct iptables_target targ =
+{
+next:	          0,
+name:             "TCPLAG",
+version:          "1.2.3",
+size:             IPT_ALIGN( sizeof( struct ipt_tcplag )),
+userspacesize:    IPT_ALIGN( sizeof( struct ipt_tcplag )),
+help:             &help,
+init:             &init,
+parse:            &parse,
+final_check:      &final_check,
+print:            &print,
+save:             &save,
+extra_opts:       opts
+};
+
+/*
+ * Always nervous trusting _init() but oh well that is the standard
+ * so have to go ahead and use it. This registers your target into
+ * the list of available targets so that your options become available.
+ */
+void _init( void ) { register_target( &targ ); }
diff -urN iptables-1.2.8/extensions/libipt_TRACE.c iptables-1.2.9/extensions/libipt_TRACE.c
--- iptables-1.2.8/extensions/libipt_TRACE.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_TRACE.c	2003-05-21 12:31:08.000000000 +0200
@@ -0,0 +1,63 @@
+/* Shared library add-on to iptables to add TRACE target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TRACE target v%s takes no options\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	return 0;
+}
+
+static void
+final_check(unsigned int flags)
+{
+}
+
+static
+struct iptables_target trace
+= {	.next = NULL,
+	.name = "TRACE",
+	.version = IPTABLES_VERSION,
+	.size = IPT_ALIGN(0),
+	.userspacesize = IPT_ALIGN(0),
+	.help = &help,
+	.init = &init,
+	.parse = &parse,
+	.final_check = &final_check,
+	.print = NULL, /* print */
+	.save = NULL, /* save */
+	.extra_opts = opts
+};
+
+void _init(void)
+{
+	register_target(&trace);
+}
diff -urN iptables-1.2.8/extensions/libipt_XOR.c iptables-1.2.9/extensions/libipt_XOR.c
--- iptables-1.2.8/extensions/libipt_XOR.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_XOR.c	2003-05-31 19:11:49.000000000 +0200
@@ -0,0 +1,112 @@
+/* Shared library add-on to iptables for the XOR target
+ * (C) 2000 by Tim Vandermeersch <Tim.Vandermeersch@pandora.be>
+ * Based on libipt_TTL.c
+ *
+ * Version 1.0
+ *
+ * This program is distributed under the terms of GNU GPL
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_XOR.h>
+
+#define	IPT_KEY_SET		1
+#define IPT_BLOCKSIZE_SET	2
+
+static void init(struct ipt_entry_target *t, unsigned int *nfcache) 
+{
+}
+
+static void help(void) 
+{
+	printf(
+		"XOR target v%s options\n"
+		"  --key string	          Set key to \"string\"\n"
+		"  --block-size		  Set block size\n",
+		IPTABLES_VERSION);
+}
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+		const struct ipt_entry *entry, 
+		struct ipt_entry_target **target)
+{
+	struct ipt_XOR_info *info = (struct ipt_XOR_info *) (*target)->data;
+	
+	if (!optarg)
+		exit_error(PARAMETER_PROBLEM, "XOR: too few arguments");
+	
+	if (check_inverse(optarg, &invert, NULL, 0))
+		exit_error(PARAMETER_PROBLEM, "XOR: unexpected '!'");
+
+	switch (c) {	
+		case '1':
+			strncpy(info->key, optarg, 30);
+			*flags |= IPT_KEY_SET;
+			break;
+		case '2':
+			info->block_size = atoi(optarg);
+			*flags |= IPT_BLOCKSIZE_SET;
+			break;
+		default:
+			return 0;
+	}
+	
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	if (!(flags & IPT_KEY_SET))
+		exit_error(PARAMETER_PROBLEM, "XOR: You must specify a key");
+	if (!(flags & IPT_BLOCKSIZE_SET))
+		exit_error(PARAMETER_PROBLEM, "XOR: You must specify a block-size");
+}
+
+static void save (const struct ipt_ip *ip,
+		const struct ipt_entry_target *target)
+{
+	const struct ipt_XOR_info *info = (struct ipt_XOR_info *) target->data;
+
+	printf("--key %s ", info->key);
+	printf("--block-size %u ", info->block_size);
+}
+
+static void print (const struct ipt_ip *ip,
+	const struct ipt_entry_target *target, int numeric)
+{
+	const struct ipt_XOR_info *info = (struct ipt_XOR_info *) target->data;
+
+	printf("key: %s ", info->key);
+	printf("block-size: %u ", info->block_size);
+}
+
+static struct option opts[] = {
+	{ "key", 1, 0, '1' },
+	{ "block-size", 1, 0, '2' },
+	{ 0 }
+};
+
+static struct iptables_target XOR = { NULL, 
+	"XOR",
+	IPTABLES_VERSION,
+	IPT_ALIGN(sizeof(struct ipt_XOR_info)),
+	IPT_ALIGN(sizeof(struct ipt_XOR_info)),
+	&help,
+	&init,
+	&parse,
+	&final_check,
+	&print,
+	&save,
+	opts 
+};
+
+void _init(void)
+{
+	register_target(&XOR);
+}
diff -urN iptables-1.2.8/extensions/libipt_addrtype.c iptables-1.2.9/extensions/libipt_addrtype.c
--- iptables-1.2.8/extensions/libipt_addrtype.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_addrtype.c	2003-05-07 18:51:40.000000000 +0200
@@ -0,0 +1,214 @@
+/* Shared library add-on to iptables to add addrtype matching support 
+ * 
+ * This program is released under the terms of GNU GPL */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <iptables.h>
+
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_addrtype.h>
+
+/* from linux/rtnetlink.h, must match order of enumeration */
+static char *rtn_names[] = {
+	"UNSPEC",
+	"UNICAST",
+	"LOCAL",
+	"BROADCAST",
+	"ANYCAST",
+	"MULTICAST",
+	"BLACKHOLE",
+	"UNREACHABLE",
+	"PROHIBIT",
+	"THROW",
+	"NAT",
+	"XRESOLVE",
+	NULL
+};
+
+static void help_types(void)
+{
+	int i;
+
+	for (i = 0; rtn_names[i]; i++)
+		printf("                                %s\n", rtn_names[i]);
+}
+
+static void help(void) 
+{
+	printf(
+"Address type match v%s options:\n"
+" [!] --src-type type[,...]      Match source address type\n"
+" [!] --dst-type type[,...]      Match destination address type\n"
+"\n"
+"Valid types:           \n"
+, IPTABLES_VERSION);
+	help_types();
+}
+
+static void init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	/* caching not yet implemented */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static int
+parse_type(const char *name, size_t strlen, u_int16_t *mask)
+{
+	int i;
+
+	for (i = 0; rtn_names[i]; i++)
+		if (strncasecmp(name, rtn_names[i], strlen) == 0) {
+			/* build up bitmask for kernel module */
+			*mask |= (1 << i);
+			return 1;
+		}
+
+	return 0;
+}
+
+static void parse_types(const char *arg, u_int16_t *mask)
+{
+	const char *comma;
+
+	while ((comma = strchr(arg, ',')) != NULL) {
+		if (comma == arg || !parse_type(arg, comma-arg, mask))
+			exit_error(PARAMETER_PROBLEM,
+			           "addrtype: bad type `%s'", arg);
+		arg = comma + 1;
+	}
+
+	if (strlen(arg) == 0 || !parse_type(arg, strlen(arg), mask))
+		exit_error(PARAMETER_PROBLEM, "addrtype: bad type `%s'", arg);
+}
+	
+#define IPT_ADDRTYPE_OPT_SRCTYPE	0x1
+#define IPT_ADDRTYPE_OPT_DSTTYPE	0x2
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+		const struct ipt_entry *entry, unsigned int *nfcache,
+		struct ipt_entry_match **match)
+{
+	struct ipt_addrtype_info *info =
+		(struct ipt_addrtype_info *) (*match)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags&IPT_ADDRTYPE_OPT_SRCTYPE)
+			exit_error(PARAMETER_PROBLEM,
+			           "addrtype: can't specify src-type twice");
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_types(argv[optind-1], &info->source);
+		if (invert)
+			info->invert_source = 1;
+		*flags |= IPT_ADDRTYPE_OPT_SRCTYPE;
+		break;
+	case '2':
+		if (*flags&IPT_ADDRTYPE_OPT_DSTTYPE)
+			exit_error(PARAMETER_PROBLEM,
+			           "addrtype: can't specify dst-type twice");
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_types(argv[optind-1], &info->dest);
+		if (invert)
+			info->invert_dest = 1;
+		*flags |= IPT_ADDRTYPE_OPT_DSTTYPE;
+		break;
+	default:
+		return 0;
+	}
+	
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	if (!(flags & (IPT_ADDRTYPE_OPT_SRCTYPE|IPT_ADDRTYPE_OPT_DSTTYPE)))
+		exit_error(PARAMETER_PROBLEM,
+			   "addrtype: you must specify --src-type or --dst-type");
+}
+
+static void print_types(u_int16_t mask)
+{
+	const char *sep = "";
+	int i;
+
+	for (i = 0; rtn_names[i]; i++)
+		if (mask & (1 << i)) {
+			printf("%s%s", sep, rtn_names[i]);
+			sep = ",";
+		}
+
+	printf(" ");
+}
+
+static void print(const struct ipt_ip *ip, 
+		const struct ipt_entry_match *match,
+		int numeric)
+{
+	const struct ipt_addrtype_info *info = 
+		(struct ipt_addrtype_info *) match->data;
+
+	printf("ADDRTYPE match ");
+	if (info->source) {
+		printf("src-type ");
+		if (info->invert_source)
+			printf("!");
+		print_types(info->source);
+	}
+	if (info->dest) {
+		printf("dst-type ");
+		if (info->invert_dest)
+			printf("!");
+		print_types(info->dest);
+	}
+}
+
+static void save(const struct ipt_ip *ip, 
+		const struct ipt_entry_match *match)
+{
+	const struct ipt_addrtype_info *info =
+		(struct ipt_addrtype_info *) match->data;
+
+	if (info->source) {
+		printf("--src-type ");
+		if (info->invert_source)
+			printf("! ");
+		print_types(info->source);
+	}
+	if (info->dest) {
+		printf("--dst-type ");
+		if (info->invert_dest)
+			printf("! ");
+		print_types(info->dest);
+	}
+}
+
+static struct option opts[] = {
+	{ "src-type", 1, 0, '1' },
+	{ "dst-type", 1, 0, '2' },
+	{ 0 }
+};
+
+static
+struct iptables_match addrtype = {
+	NULL,
+	"addrtype",
+	IPTABLES_VERSION,
+	IPT_ALIGN(sizeof(struct ipt_addrtype_info)),
+	IPT_ALIGN(sizeof(struct ipt_addrtype_info)),
+	&help,
+	&init,
+	&parse,
+	&final_check,
+	&print,
+	&save,
+	opts
+};
+
+
+void _init(void) 
+{
+	register_match(&addrtype);
+}
diff -urN iptables-1.2.8/extensions/libipt_condition.c iptables-1.2.9/extensions/libipt_condition.c
--- iptables-1.2.8/extensions/libipt_condition.c	2003-03-26 15:42:35.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_condition.c	2003-04-28 02:04:34.000000000 +0200
@@ -1,3 +1,4 @@
+/* Shared library add-on to iptables for condition match */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -39,13 +40,13 @@
 	struct condition_info *info =
 	    (struct condition_info *) (*match)->data;
 
-	check_inverse(optarg, &invert, &optind, 0);
-
 	if (c == 'X') {
 		if (*flags)
 			exit_error(PARAMETER_PROBLEM,
 				   "Can't specify multiple conditions");
 
+		check_inverse(optarg, &invert, &optind, 0);
+
 		if (strlen(argv[optind - 1]) < CONDITION_NAME_LEN)
 			strcpy(info->name, argv[optind - 1]);
 		else
@@ -88,7 +89,7 @@
 	const struct condition_info *info =
 	    (const struct condition_info *) match->data;
 
-	printf("--condition %s%s ", (info->invert) ? "! " : "", info->name);
+	printf("--condition %s\"%s\" ", (info->invert) ? "! " : "", info->name);
 }
 
 
diff -urN iptables-1.2.8/extensions/libipt_connbytes.c iptables-1.2.9/extensions/libipt_connbytes.c
--- iptables-1.2.8/extensions/libipt_connbytes.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_connbytes.c	2003-06-19 14:23:37.000000000 +0200
@@ -0,0 +1,134 @@
+/* Shared library add-on to iptables to add byte tracking support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ipt_connbytes.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"connbytes v%s options:\n"
+" [!] --connbytes from:[to]\n"
+"				Transfered byte range to match\n"
+"\n", IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "connbytes", 1, 0, '1' },
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	/* Can't cache this */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static void
+parse_range(const char *arg, struct ipt_connbytes_info *si)
+{
+	char *colon,*p;
+
+	si->from = strtol(arg,&colon,10);
+	if (*colon != ':') 
+		exit_error(PARAMETER_PROBLEM, "Bad range `%s'", arg);
+	si->to = strtol(colon+1,&p,10);
+	if (p == colon+1) {
+		/* second number omited */
+		si->to = 0xffffffff;
+	}
+	if (si->from > si->to)
+		exit_error(PARAMETER_PROBLEM, "%lu should be less than %lu", si->from,si->to);
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_connbytes_info *sinfo = (struct ipt_connbytes_info *)(*match)->data;
+	int i;
+
+	switch (c) {
+	case '1':
+		if (check_inverse(optarg, &invert, optind, 0))
+			optind++;
+
+		parse_range(argv[optind-1], sinfo);
+		if (invert) {
+			i = sinfo->from;
+			sinfo->from = sinfo->to;
+			sinfo->to = i;
+		}
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM, "You must specify `--connbytes'");
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_connbytes_info *sinfo = (struct ipt_connbytes_info *)match->data;
+
+	if (sinfo->from > sinfo->to) 
+		printf("connbytes ! %lu:%lu",sinfo->to,sinfo->from);
+	else
+		printf("connbytes %lu:%lu",sinfo->from,sinfo->to);
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_connbytes_info *sinfo = (struct ipt_connbytes_info *)match->data;
+
+	if (sinfo->from > sinfo->to) 
+		printf("! --connbytes %lu:%lu",sinfo->to,sinfo->from);
+	else
+		printf("--connbytes %lu:%lu",sinfo->from,sinfo->to);
+}
+
+static
+struct iptables_match state
+= { NULL,
+    "connbytes",
+    IPTABLES_VERSION,
+    IPT_ALIGN(sizeof(struct ipt_connbytes_info)),
+    IPT_ALIGN(sizeof(struct ipt_connbytes_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_match(&state);
+}
diff -urN iptables-1.2.8/extensions/libipt_connlimit.c iptables-1.2.9/extensions/libipt_connlimit.c
--- iptables-1.2.8/extensions/libipt_connlimit.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_connlimit.c	2003-04-30 18:54:48.000000000 +0200
@@ -0,0 +1,132 @@
+/* Shared library add-on to iptables to add connection limit support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ipt_connlimit.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"connlimit v%s options:\n"
+"[!] --connlimit-above n		match if the number of existing tcp connections is (not) above n\n"
+" --connlimit-mask n		group hosts using mask\n"
+"\n", IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "connlimit-above", 1, 0, '1' },
+	{ "connlimit-mask",  1, 0, '2' },
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	/* Can't cache this */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_connlimit_info *info = (struct ipt_connlimit_info*)(*match)->data;
+
+	if (0 == (*flags & 2)) {
+		/* set default mask unless we've already seen a mask option */
+		info->mask = htonl(0xFFFFFFFF);
+	}
+
+	switch (c) {
+	case '1':
+		check_inverse(optarg, &invert, &optind, 0);
+		info->limit = atoi(argv[optind-1]);
+		info->inverse = invert;
+		*flags |= 1;
+		break;
+
+	case '2':
+		info->mask = htonl(0xFFFFFFFF << (32 - atoi(argv[optind-1])));
+		*flags |= 2;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check */
+static void final_check(unsigned int flags)
+{
+	if (!flags & 1)
+		exit_error(PARAMETER_PROBLEM, "You must specify `--connlimit-above'");
+}
+
+static int
+count_bits(u_int32_t mask)
+{
+	int i, bits;
+
+	for (bits = 0, i = 31; i >= 0; i--) {
+		if (mask & htonl((u_int32_t)1 << i)) {
+			bits++;
+			continue;
+		}
+		break;
+	}
+	return bits;
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_connlimit_info *info = (struct ipt_connlimit_info*)match->data;
+
+	printf("#conn/%d %s %d ", count_bits(info->mask),
+	       info->inverse ? "<" : ">", info->limit);
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_connlimit_info *info = (struct ipt_connlimit_info*)match->data;
+
+	printf("%s--connlimit-above %d ",info->inverse ? "! " : "",info->limit);
+	printf("--connlimit-mask %d ",count_bits(info->mask));
+}
+
+static struct iptables_match connlimit = {
+	name:		"connlimit",
+	version:	IPTABLES_VERSION,
+	size:		IPT_ALIGN(sizeof(struct ipt_connlimit_info)),
+	userspacesize:	offsetof(struct ipt_connlimit_info,data),
+	help:		help,
+	init:		init,
+	parse:		parse,
+	final_check:	final_check,
+	print:		print,
+	save: 		save,
+	extra_opts:	opts
+};
+
+void _init(void)
+{
+	register_match(&connlimit);
+}
diff -urN iptables-1.2.8/extensions/libipt_conntrack.c iptables-1.2.9/extensions/libipt_conntrack.c
--- iptables-1.2.8/extensions/libipt_conntrack.c	2003-03-04 15:50:50.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_conntrack.c	2003-10-07 20:54:30.000000000 +0200
@@ -13,13 +13,17 @@
 #include <linux/netfilter_ipv4/ip_conntrack_tuple.h>
 #include <linux/netfilter_ipv4/ipt_conntrack.h>
 
+#ifndef IPT_CONNTRACK_STATE_UNTRACKED
+#define IPT_CONNTRACK_STATE_UNTRACKED (1 << (IP_CT_NUMBER + 3))
+#endif
+
 /* Function which prints out usage message. */
 static void
 help(void)
 {
 	printf(
 "conntrack match v%s options:\n"
-" [!] --ctstate [INVALID|ESTABLISHED|NEW|RELATED|SNAT|DNAT][,...]\n"
+" [!] --ctstate [INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED|SNAT|DNAT][,...]\n"
 "				State(s) to match\n"
 " [!] --ctproto	proto		Protocol to match; by number or name, eg. `tcp'\n"
 "     --ctorigsrc  [!] address[/mask]\n"
@@ -30,7 +34,7 @@
 "				Reply source specification\n"
 "     --ctrepldst  [!] address[/mask]\n"
 "				Reply destination specification\n"
-" [!] --ctstatus [NONE|EXPECTED|SEEN_REPLY|ASSURED][,...]\n"
+" [!] --ctstatus [NONE|EXPECTED|SEEN_REPLY|ASSURED|CONFIRMED][,...]\n"
 "				Status(es) to match\n"
 " [!] --ctexpire time[:time]	Match remaining lifetime in seconds against\n"
 "				value or range of values (inclusive)\n"
@@ -70,6 +74,8 @@
 		sinfo->statemask |= IPT_CONNTRACK_STATE_BIT(IP_CT_ESTABLISHED);
 	else if (strncasecmp(state, "RELATED", strlen) == 0)
 		sinfo->statemask |= IPT_CONNTRACK_STATE_BIT(IP_CT_RELATED);
+	else if (strncasecmp(state, "UNTRACKED", strlen) == 0)
+		sinfo->statemask |= IPT_CONNTRACK_STATE_UNTRACKED;
 	else if (strncasecmp(state, "SNAT", strlen) == 0)
 		sinfo->statemask |= IPT_CONNTRACK_STATE_SNAT;
 	else if (strncasecmp(state, "DNAT", strlen) == 0)
@@ -105,6 +111,10 @@
 		sinfo->statusmask |= IPS_SEEN_REPLY;
 	else if (strncasecmp(status, "ASSURED", strlen) == 0)
 		sinfo->statusmask |= IPS_ASSURED;
+#ifdef IPS_CONFIRMED
+	else if (strncasecmp(status, "CONFIRMED", strlen) == 0)
+		sinfo->stausmask |= IPS_CONFIRMED;
+#endif
 	else
 		return 0;
 	return 1;
@@ -345,6 +355,10 @@
 		printf("%sESTABLISHED", sep);
 		sep = ",";
 	}
+	if (statemask & IPT_CONNTRACK_STATE_UNTRACKED) {
+		printf("%sUNTRACKED", sep);
+		sep = ",";
+	}
 	if (statemask & IPT_CONNTRACK_STATE_SNAT) {
 		printf("%sSNAT", sep);
 		sep = ",";
@@ -373,6 +387,12 @@
 		printf("%sASSURED", sep);
 		sep = ",";
 	}
+#ifdef IPS_CONFIRMED
+	if (statusmask & IPS_CONFIRMED) {
+		printf("%sCONFIRMED", sep);
+		sep =",";
+	}
+#endif
 	if (statusmask == 0) {
 		printf("%sNONE", sep);
 		sep = ",";
diff -urN iptables-1.2.8/extensions/libipt_fuzzy.c iptables-1.2.9/extensions/libipt_fuzzy.c
--- iptables-1.2.8/extensions/libipt_fuzzy.c	2002-08-26 18:10:30.000000000 +0200
+++ iptables-1.2.9/extensions/libipt_fuzzy.c	2003-06-15 00:39:35.000000000 +0200
@@ -6,6 +6,8 @@
    ftp://prep.ai.mit.edu/pub/gnu/GPL
 
 2002-08-07 Hime Aguiar e Oliveira Jr. <hime@engineer.com> : Initial version.
+2003-06-09 Hime Aguiar e Oliveira Jr. <hime@engineer.com> : Bug corrections in
+the save function , thanks to information given by Jean-Francois Patenaude .
 
 */
 
@@ -131,8 +133,8 @@
 	const struct ipt_fuzzy_info *fuzzyinfo
 		= (const struct ipt_fuzzy_info *)match->data;
 
-	printf("--upper-limit %u ",fuzzyinfo->minimum_rate);
-	printf("--lower-limit %u ",fuzzyinfo->maximum_rate);
+	printf("--lower-limit %u ",fuzzyinfo->minimum_rate);
+	printf("--upper-limit %u ",fuzzyinfo->maximum_rate);
 
 }
 
diff -urN iptables-1.2.8/extensions/libipt_iplimit.c iptables-1.2.9/extensions/libipt_iplimit.c
--- iptables-1.2.8/extensions/libipt_iplimit.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.2.9/extensions/libipt_iplimit.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,132 +0,0 @@
-/* Shared library add-on to iptables to add state tracking support. */
-#include <stdio.h>
-#include <netdb.h>
-#include <string.h>
-#include <stdlib.h>
-#include <stddef.h>
-#include <getopt.h>
-#include <iptables.h>
-#include <linux/netfilter_ipv4/ip_conntrack.h>
-#include <linux/netfilter_ipv4/ipt_iplimit.h>
-
-/* Function which prints out usage message. */
-static void
-help(void)
-{
-	printf(
-"iplimit v%s options:\n"
-"[!] --iplimit-above n		match if the number of existing tcp connections is (not) above n\n"
-" --iplimit-mask n		group hosts using mask\n"
-"\n", IPTABLES_VERSION);
-}
-
-static struct option opts[] = {
-	{ "iplimit-above", 1, 0, '1' },
-	{ "iplimit-mask",  1, 0, '2' },
-	{0}
-};
-
-/* Initialize the match. */
-static void
-init(struct ipt_entry_match *m, unsigned int *nfcache)
-{
-	/* Can't cache this */
-	*nfcache |= NFC_UNKNOWN;
-}
-
-/* Function which parses command options; returns true if it
-   ate an option */
-static int
-parse(int c, char **argv, int invert, unsigned int *flags,
-      const struct ipt_entry *entry,
-      unsigned int *nfcache,
-      struct ipt_entry_match **match)
-{
-	struct ipt_iplimit_info *info = (struct ipt_iplimit_info*)(*match)->data;
-
-	if (0 == (*flags & 2)) {
-		/* set default mask unless we've already seen a mask option */
-		info->mask = htonl(0xFFFFFFFF);
-	}
-
-	switch (c) {
-	case '1':
-		check_inverse(optarg, &invert, &optind, 0);
-		info->limit = atoi(argv[optind-1]);
-		info->inverse = invert;
-		*flags |= 1;
-		break;
-
-	case '2':
-		info->mask = htonl(0xFFFFFFFF << (32 - atoi(argv[optind-1])));
-		*flags |= 2;
-		break;
-
-	default:
-		return 0;
-	}
-
-	return 1;
-}
-
-/* Final check */
-static void final_check(unsigned int flags)
-{
-	if (!flags & 1)
-		exit_error(PARAMETER_PROBLEM, "You must specify `--iplimit-above'");
-}
-
-static int
-count_bits(u_int32_t mask)
-{
-	int i, bits;
-
-	for (bits = 0, i = 31; i >= 0; i--) {
-		if (mask & htonl((u_int32_t)1 << i)) {
-			bits++;
-			continue;
-		}
-		break;
-	}
-	return bits;
-}
-
-/* Prints out the matchinfo. */
-static void
-print(const struct ipt_ip *ip,
-      const struct ipt_entry_match *match,
-      int numeric)
-{
-	struct ipt_iplimit_info *info = (struct ipt_iplimit_info*)match->data;
-
-	printf("#conn/%d %s %d ", count_bits(info->mask),
-	       info->inverse ? "<" : ">", info->limit);
-}
-
-/* Saves the matchinfo in parsable form to stdout. */
-static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
-{
-	struct ipt_iplimit_info *info = (struct ipt_iplimit_info*)match->data;
-
-	printf("%s--iplimit-above %d ",info->inverse ? "! " : "",info->limit);
-	printf("--iplimit-mask %d ",count_bits(info->mask));
-}
-
-static struct iptables_match iplimit = {
-	name:		"iplimit",
-	version:	IPTABLES_VERSION,
-	size:		IPT_ALIGN(sizeof(struct ipt_iplimit_info)),
-	userspacesize:	offsetof(struct ipt_iplimit_info,data),
-	help:		help,
-	init:		init,
-	parse:		parse,
-	final_check:	final_check,
-	print:		print,
-	save: 		save,
-	extra_opts:	opts
-};
-
-void _init(void)
-{
-	register_match(&iplimit);
-}
diff -urN iptables-1.2.8/extensions/libipt_iprange.c iptables-1.2.9/extensions/libipt_iprange.c
--- iptables-1.2.8/extensions/libipt_iprange.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_iprange.c	2003-04-23 15:27:09.000000000 +0200
@@ -0,0 +1,195 @@
+/* Shared library add-on to iptables to add IP range matching support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_iprange.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"iprange match v%s options:\n"
+"[!] --src-range ip-ip        Match source IP in the specified range\n"
+"[!] --dst-range ip-ip        Match destination IP in the specified range\n"
+"\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "src-range", 1, 0, '1' },
+	{ "dst-range", 1, 0, '2' },
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	/* Can't cache this. */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static void
+parse_iprange(char *arg, struct ipt_iprange *range)
+{
+	char *dash;
+	struct in_addr *ip;
+
+	dash = strchr(arg, '-');
+	if (dash)
+		*dash = '\0';
+		
+	ip = dotted_to_addr(arg);
+	if (!ip)
+		exit_error(PARAMETER_PROBLEM, "iprange match: Bad IP address `%s'\n", 
+			   arg);
+	range->min_ip = ip->s_addr;
+
+	if (dash) {
+		ip = dotted_to_addr(dash+1);
+		if (!ip)
+			exit_error(PARAMETER_PROBLEM, "iprange match: Bad IP address `%s'\n",
+				   dash+1);
+		range->max_ip = ip->s_addr;
+	} else
+		range->max_ip = range->min_ip;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_iprange_info *info = (struct ipt_iprange_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags & IPRANGE_SRC)
+			exit_error(PARAMETER_PROBLEM,
+				   "iprange match: Only use --src-range ONCE!");
+		*flags |= IPRANGE_SRC;
+
+		info->flags |= IPRANGE_SRC;
+		check_inverse(optarg, &invert, &optind, 0);
+		if (invert) {
+			info->flags |= IPRANGE_SRC_INV;
+			printf("hoho\n");
+		}
+		parse_iprange(optarg, &info->src);		
+
+		break;
+
+	case '2':
+		if (*flags & IPRANGE_DST)
+			exit_error(PARAMETER_PROBLEM,
+				   "iprange match: Only use --dst-range ONCE!");
+		*flags |= IPRANGE_DST;
+
+		info->flags |= IPRANGE_DST;
+		check_inverse(optarg, &invert, &optind, 0);
+		if (invert)
+			info->flags |= IPRANGE_DST_INV;
+
+		parse_iprange(optarg, &info->dst);		
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; must have specified --src-range or --dst-range. */
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+			   "iprange match: You must specify `--src-range' or `--dst-range'");
+}
+
+static void
+print_iprange(const struct ipt_iprange *range)
+{
+	const unsigned char *byte_min, *byte_max;
+
+	byte_min = (const unsigned char *) &(range->min_ip);
+	byte_max = (const unsigned char *) &(range->max_ip);
+	printf("%d.%d.%d.%d-%d.%d.%d.%d ", 
+		byte_min[0], byte_min[1], byte_min[2], byte_min[3],
+		byte_max[0], byte_max[1], byte_max[2], byte_max[3]);
+}
+
+/* Prints out the info. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_iprange_info *info = (struct ipt_iprange_info *)match->data;
+
+	if (info->flags & IPRANGE_SRC) {
+		printf("source IP range ");
+		if (info->flags & IPRANGE_SRC_INV)
+			printf("! ");
+		print_iprange(&info->src);
+	}
+	if (info->flags & IPRANGE_DST) {
+		printf("destination IP range ");
+		if (info->flags & IPRANGE_DST_INV)
+			printf("! ");
+		print_iprange(&info->dst);
+	}
+}
+
+/* Saves the union ipt_info in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_iprange_info *info = (struct ipt_iprange_info *)match->data;
+
+	if (info->flags & IPRANGE_SRC) {
+		if (info->flags & IPRANGE_SRC_INV)
+			printf("! ");
+		printf("--src-range ");
+		print_iprange(&info->src);
+		if (info->flags & IPRANGE_DST)
+			fputc(' ', stdout);
+	}
+	if (info->flags & IPRANGE_DST) {
+		if (info->flags & IPRANGE_DST_INV)
+			printf("! ");
+		printf("--dst-range ");
+		print_iprange(&info->dst);
+	}
+}
+
+static
+struct iptables_match iprange
+= { NULL,
+    "iprange",
+    IPTABLES_VERSION,
+    IPT_ALIGN(sizeof(struct ipt_iprange_info)),
+    IPT_ALIGN(sizeof(struct ipt_iprange_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_match(&iprange);
+}
diff -urN iptables-1.2.8/extensions/libipt_mac.c iptables-1.2.9/extensions/libipt_mac.c
--- iptables-1.2.8/extensions/libipt_mac.c	2002-10-02 15:52:17.000000000 +0200
+++ iptables-1.2.9/extensions/libipt_mac.c	2003-06-15 00:39:35.000000000 +0200
@@ -86,11 +86,11 @@
 	return 1;
 }
 
-static void print_mac(unsigned char macaddress[ETH_ALEN], int invert)
+static void print_mac(unsigned char macaddress[ETH_ALEN])
 {
 	unsigned int i;
 
-	printf("%s%02X", invert ? "! " : "", macaddress[0]);
+	printf("%02X", macaddress[0]);
 	for (i = 1; i < ETH_ALEN; i++)
 		printf(":%02X", macaddress[i]);
 	printf(" ");
@@ -111,16 +111,21 @@
       int numeric)
 {
 	printf("MAC ");
-	print_mac(((struct ipt_mac_info *)match->data)->srcaddr,
-		  ((struct ipt_mac_info *)match->data)->invert);
+
+	if (((struct ipt_mac_info *)match->data)->invert)
+		printf("! ");
+	
+	print_mac(((struct ipt_mac_info *)match->data)->srcaddr);
 }
 
 /* Saves the union ipt_matchinfo in parsable form to stdout. */
 static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
 {
+	if (((struct ipt_mac_info *)match->data)->invert)
+		printf("! ");
+
 	printf("--mac-source ");
-	print_mac(((struct ipt_mac_info *)match->data)->srcaddr,
-		  ((struct ipt_mac_info *)match->data)->invert);
+	print_mac(((struct ipt_mac_info *)match->data)->srcaddr);
 }
 
 static
diff -urN iptables-1.2.8/extensions/libipt_mport.c iptables-1.2.9/extensions/libipt_mport.c
--- iptables-1.2.8/extensions/libipt_mport.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.2.9/extensions/libipt_mport.c	2003-07-14 09:43:07.000000000 +0200
@@ -276,10 +276,10 @@
                     && minfo->ports[i-1] == minfo->ports[i])
                         break;
 		printf("%s", i ? "," : "");
-		print_port(minfo->ports[i], ip->proto, 0);
+		print_port(minfo->ports[i], ip->proto, 1);
                 if (pflags & (1<<i)) {
                         printf(":");
-                        print_port(minfo->ports[++i], ip->proto, 0);
+                        print_port(minfo->ports[++i], ip->proto, 1);
                 }
 	}
 	printf(" ");
diff -urN iptables-1.2.8/extensions/libipt_multiport.c iptables-1.2.9/extensions/libipt_multiport.c
--- iptables-1.2.8/extensions/libipt_multiport.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.2.9/extensions/libipt_multiport.c	2003-07-14 09:43:07.000000000 +0200
@@ -237,7 +237,7 @@
 
 	for (i=0; i < multiinfo->count; i++) {
 		printf("%s", i ? "," : "");
-		print_port(multiinfo->ports[i], ip->proto, 0);
+		print_port(multiinfo->ports[i], ip->proto, 1);
 	}
 	printf(" ");
 }
diff -urN iptables-1.2.8/extensions/libipt_osf.c iptables-1.2.9/extensions/libipt_osf.c
--- iptables-1.2.8/extensions/libipt_osf.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_osf.c	2003-09-29 12:49:15.000000000 +0200
@@ -0,0 +1,130 @@
+/*
+ * libipt_osf.c
+ *
+ * Copyright (c) 2003 Evgeniy Polyakov <johnpol@2ka.mipt.ru>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/*
+ * iptables interface for OS fingerprint matching module.
+ */
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_osf.h>
+
+static void help(void)
+{
+	printf("OS fingerprint match v%s options:\n"
+		"  --genre [!] string          Match a OS genre bypassive fingerprinting.\n",
+		IPTABLES_VERSION);
+}
+
+
+static struct option opts[] = {
+	{ .name = "genre",     .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = 0 }
+};
+
+
+static void init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	*nfcache |= NFC_UNKNOWN;
+}
+
+
+static void parse_string(const unsigned char *s, struct ipt_osf_info *info)
+{
+	if (strlen(s) < MAXGENRELEN) 
+		strcpy(info->genre, s);
+	else 
+		exit_error(PARAMETER_PROBLEM, "Genre string too long `%s' [%d], max=%d", 
+				s, strlen(s), MAXGENRELEN);
+}
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+      			const struct ipt_entry *entry,
+      			unsigned int *nfcache,
+      			struct ipt_entry_match **match)
+{
+	struct ipt_osf_info *info = (struct ipt_osf_info *)(*match)->data;
+	
+	switch(c) 
+	{
+		case '1':
+			if (*flags)
+				exit_error(PARAMETER_PROBLEM, "Can't specify multiple strings");
+			check_inverse(optarg, &invert, &optind, 0);
+			parse_string(argv[optind-1], info);
+			if (invert)
+				info->invert = 1;
+			info->len=strlen((char *)info->genre);
+			*flags = 1;
+			break;
+		default:
+			return 0;
+	}
+
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM, "OS fingerprint match: You must specify `--genre'");
+}
+
+static void print(const struct ipt_ip *ip, const struct ipt_entry_match *match, int numeric)
+{
+	const struct ipt_osf_info *info = (const struct ipt_osf_info*) match->data;
+
+	printf("OS fingerprint match %s%s ", (info->invert) ? "!" : "", info->genre);
+}
+
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	const struct ipt_osf_info *info = (const struct ipt_osf_info*) match->data;
+
+	printf("--genre %s%s ", (info->invert) ? "! ": "", info->genre);
+}
+
+
+static struct iptables_match osf_match = {
+    .name          = "osf",
+    .version       = IPTABLES_VERSION,
+    .size          = IPT_ALIGN(sizeof(struct ipt_osf_info)),
+    .userspacesize = IPT_ALIGN(sizeof(struct ipt_osf_info)),
+    .help          = &help,
+    .init          = &init,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
+};
+
+
+void _init(void)
+{
+	register_match(&osf_match);
+}
diff -urN iptables-1.2.8/extensions/libipt_owner.c iptables-1.2.9/extensions/libipt_owner.c
--- iptables-1.2.8/extensions/libipt_owner.c	2003-01-06 13:40:33.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_owner.c	2003-05-03 20:52:15.000000000 +0200
@@ -148,7 +148,7 @@
 	if(info->match & flag) {
 
 		if (info->invert & flag)
-			fputc('!', stdout);
+			printf("! ");
 
 		printf(label);
 
diff -urN iptables-1.2.8/extensions/libipt_physdev.c iptables-1.2.9/extensions/libipt_physdev.c
--- iptables-1.2.8/extensions/libipt_physdev.c	2003-02-11 21:19:04.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_physdev.c	2003-04-28 02:04:34.000000000 +0200
@@ -17,14 +17,20 @@
 {
 	printf(
 "physdev v%s options:\n"
-" --physdev-in [!] input name[+]	bridge port name ([+] for wildcard)\n"
+" --physdev-in [!] input name[+]		bridge port name ([+] for wildcard)\n"
 " --physdev-out [!] output name[+]	bridge port name ([+] for wildcard)\n"
+" [!] --physdev-is-in			arrived on a bridge device\n"
+" [!] --physdev-is-out			will leave on a bridge device\n"
+" [!] --physdev-is-bridged		it's a bridged packet\n"
 "\n", IPTABLES_VERSION);
 }
 
 static struct option opts[] = {
 	{ "physdev-in", 1, 0, '1' },
 	{ "physdev-out", 1, 0, '2' },
+	{ "physdev-is-in", 0, 0, '3' },
+	{ "physdev-is-out", 0, 0, '4' },
+	{ "physdev-is-bridged", 0, 0, '5' },
 	{0}
 };
 
@@ -83,26 +89,56 @@
 
 	switch (c) {
 	case '1':
-		if (*flags & IPT_PHYSDEV_OP_MATCH_IN)
-			exit_error(PARAMETER_PROBLEM,
-				   "multiple --physdev-in not allowed");
+		if (*flags & IPT_PHYSDEV_OP_IN)
+			goto multiple_use;
 		check_inverse(optarg, &invert, &optind, 0);
 		parse_interface(argv[optind-1], info->physindev, info->in_mask);
 		if (invert)
-			info->invert |= IPT_PHYSDEV_OP_MATCH_IN;
-		*flags |= IPT_PHYSDEV_OP_MATCH_IN;
+			info->invert |= IPT_PHYSDEV_OP_IN;
+		info->bitmask |= IPT_PHYSDEV_OP_IN;
+		*flags |= IPT_PHYSDEV_OP_IN;
 		break;
 
 	case '2':
-		if (*flags & IPT_PHYSDEV_OP_MATCH_OUT)
-			exit_error(PARAMETER_PROBLEM,
-				   "multiple --physdev-out not allowed");
+		if (*flags & IPT_PHYSDEV_OP_OUT)
+			goto multiple_use;
 		check_inverse(optarg, &invert, &optind, 0);
 		parse_interface(argv[optind-1], info->physoutdev,
 				info->out_mask);
 		if (invert)
-			info->invert |= IPT_PHYSDEV_OP_MATCH_OUT;
-		*flags |= IPT_PHYSDEV_OP_MATCH_OUT;
+			info->invert |= IPT_PHYSDEV_OP_OUT;
+		info->bitmask |= IPT_PHYSDEV_OP_OUT;
+		*flags |= IPT_PHYSDEV_OP_OUT;
+		break;
+
+	case '3':
+		if (*flags & IPT_PHYSDEV_OP_ISIN)
+			goto multiple_use;
+		check_inverse(optarg, &invert, &optind, 0);
+		info->bitmask |= IPT_PHYSDEV_OP_ISIN;
+		if (invert)
+			info->invert |= IPT_PHYSDEV_OP_ISIN;
+		*flags |= IPT_PHYSDEV_OP_ISIN;
+		break;
+
+	case '4':
+		if (*flags & IPT_PHYSDEV_OP_ISOUT)
+			goto multiple_use;
+		check_inverse(optarg, &invert, &optind, 0);
+		info->bitmask |= IPT_PHYSDEV_OP_ISOUT;
+		if (invert)
+			info->invert |= IPT_PHYSDEV_OP_ISOUT;
+		*flags |= IPT_PHYSDEV_OP_ISOUT;
+		break;
+
+	case '5':
+		if (*flags & IPT_PHYSDEV_OP_BRIDGED)
+			goto multiple_use;
+		check_inverse(optarg, &invert, &optind, 0);
+		if (invert)
+			info->invert |= IPT_PHYSDEV_OP_BRIDGED;
+		*flags |= IPT_PHYSDEV_OP_BRIDGED;
+		info->bitmask |= IPT_PHYSDEV_OP_BRIDGED;
 		break;
 
 	default:
@@ -110,26 +146,16 @@
 	}
 
 	return 1;
-}
+multiple_use:
+	exit_error(PARAMETER_PROBLEM,
+	   "multiple use of the same physdev option is not allowed");
 
-static void final_check(unsigned int flags)
-{
 }
 
-static void print_iface(u_int8_t invert, char *dev, char *prefix)
+static void final_check(unsigned int flags)
 {
-	char iface[IFNAMSIZ+2];
-
-	if (invert) {
-		iface[0] = '!';
-		iface[1] = '\0';
-	} else
-		iface[0] = '\0';
-
-	if (dev[0] != '\0') {
-		strcat(iface, dev);
-		printf("%s%s", prefix, iface);
-	}
+	if (flags == 0)
+		exit_error(PARAMETER_PROBLEM, "PHYSDEV: no physdev option specified");
 }
 
 static void
@@ -141,10 +167,22 @@
 		(struct ipt_physdev_info*)match->data;
 
 	printf("PHYSDEV match");
-	print_iface(info->invert & IPT_PHYSDEV_OP_MATCH_IN, info->physindev,
-		    " physindev=");
-	print_iface(info->invert & IPT_PHYSDEV_OP_MATCH_OUT, info->physoutdev,
-		    " physoutdev=");
+	if (info->bitmask & IPT_PHYSDEV_OP_ISIN)
+		printf("%s --physdev-is-in",
+		       info->invert & IPT_PHYSDEV_OP_ISIN ? " !":"");
+	if (info->bitmask & IPT_PHYSDEV_OP_IN)
+		printf("%s --physdev-in %s",
+		(info->invert & IPT_PHYSDEV_OP_IN) ? " !":"", info->physindev);
+
+	if (info->bitmask & IPT_PHYSDEV_OP_ISOUT)
+		printf("%s --physdev-is-out",
+		       info->invert & IPT_PHYSDEV_OP_ISOUT ? " !":"");
+	if (info->bitmask & IPT_PHYSDEV_OP_OUT)
+		printf("%s --physdev-out %s",
+		(info->invert & IPT_PHYSDEV_OP_OUT) ? " !":"", info->physoutdev);
+	if (info->bitmask & IPT_PHYSDEV_OP_BRIDGED)
+		printf("%s --physdev-is-bridged",
+		       info->invert & IPT_PHYSDEV_OP_BRIDGED ? " !":"");
 	printf(" ");
 }
 
@@ -153,10 +191,22 @@
 	struct ipt_physdev_info *info =
 		(struct ipt_physdev_info*)match->data;
 
-	print_iface(info->invert & IPT_PHYSDEV_OP_MATCH_IN, info->physindev,
-		    "--physdev-in ");
-	print_iface(info->invert & IPT_PHYSDEV_OP_MATCH_OUT, info->physoutdev,
-		    "--physdev-out ");
+	if (info->bitmask & IPT_PHYSDEV_OP_ISIN)
+		printf("%s --physdev-is-in",
+		       info->invert & IPT_PHYSDEV_OP_ISIN ? " !":"");
+	if (info->bitmask & IPT_PHYSDEV_OP_IN)
+		printf("%s --physdev-in %s",
+		(info->invert & IPT_PHYSDEV_OP_IN) ? " !":"", info->physindev);
+
+	if (info->bitmask & IPT_PHYSDEV_OP_ISOUT)
+		printf("%s --physdev-is-out",
+		       info->invert & IPT_PHYSDEV_OP_ISOUT ? " !":"");
+	if (info->bitmask & IPT_PHYSDEV_OP_OUT)
+		printf("%s --physdev-out %s",
+		(info->invert & IPT_PHYSDEV_OP_OUT) ? " !":"", info->physoutdev);
+	if (info->bitmask & IPT_PHYSDEV_OP_BRIDGED)
+		printf("%s --physdev-is-bridged",
+		       info->invert & IPT_PHYSDEV_OP_BRIDGED ? " !":"");
 	printf(" ");
 }
 
diff -urN iptables-1.2.8/extensions/libipt_pool.c.orig iptables-1.2.9/extensions/libipt_pool.c.orig
--- iptables-1.2.8/extensions/libipt_pool.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_pool.c.orig	2002-06-04 09:57:31.000000000 +0200
@@ -0,0 +1,144 @@
+/* Shared library add-on to iptables to add IP address pool matching. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ipt_pool.h>
+
+#include <libippool/ip_pool_support.h>
+
+/* FIXME --RR */
+#include "../ippool/libippool.c"
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"pool v%s options:\n"
+" [!] --srcpool NAME|INDEX\n"
+" [!] --dstpool NAME|INDEX\n"
+"			Pool index (or name from %s) to match\n"
+"\n", IPTABLES_VERSION, IPPOOL_CONF);
+}
+
+static struct option opts[] = {
+	{ "srcpool", 1, 0, '1' },
+	{ "dstpool", 1, 0, '2' },
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *match, unsigned int *nfcache)
+{
+	struct ipt_pool_info *info =
+		(struct ipt_pool_info *)match->data;
+
+	info->src = IP_POOL_NONE;
+	info->dst = IP_POOL_NONE;
+	info->flags = 0;
+	/* Can't cache this - XXX */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Function which parses command options; returns true if it ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_pool_info *info =
+		(struct ipt_pool_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		check_inverse(optarg, &invert, &optind, 0);
+		info->src = ip_pool_get_index(argv[optind-1]);
+		if (invert) info->flags |= IPT_POOL_INV_SRC;
+		*flags = 1;
+		break;
+	case '2':
+		check_inverse(optarg, &invert, &optind, 0);
+		info->dst = ip_pool_get_index(argv[optind-1]);
+		if (invert) info->flags |= IPT_POOL_INV_DST;
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; must have specified --srcpool or --dstpool. */
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM, "You must specify either `--srcpool or --dstpool'");
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	char buf[256];
+	struct ipt_pool_info *info =
+		(struct ipt_pool_info *)match->data;
+
+	if (info->src != IP_POOL_NONE)
+		printf("%ssrcpool %s ",
+			(info->flags & IPT_POOL_INV_SRC) ? "!" : "",
+			ip_pool_get_name(buf, sizeof(buf), info->src, 0));
+	if (info->dst != IP_POOL_NONE)
+		printf("%sdstpool %s ",
+			(info->flags & IPT_POOL_INV_DST) ? "!" : "",
+			ip_pool_get_name(buf, sizeof(buf), info->dst, 0));
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	char buf[256];
+	struct ipt_pool_info *info =
+		(struct ipt_pool_info *)match->data;
+
+	if (info->src != IP_POOL_NONE)
+		printf("%s--srcpool %s",
+			(info->flags & IPT_POOL_INV_SRC) ? "! " : "",
+			ip_pool_get_name(buf, sizeof(buf), info->src, 0));
+	if (info->dst != IP_POOL_NONE)
+		printf("%s--dstpool %s",
+			(info->flags & IPT_POOL_INV_DST) ? "! " : "",
+			ip_pool_get_name(buf, sizeof(buf), info->dst, 0));
+}
+
+static
+struct iptables_match pool
+= { NULL,
+    "pool",
+    IPTABLES_VERSION,
+    IPT_ALIGN(sizeof(struct ipt_pool_info)),
+    IPT_ALIGN(sizeof(struct ipt_pool_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_match(&pool);
+}
diff -urN iptables-1.2.8/extensions/libipt_psd.c iptables-1.2.9/extensions/libipt_psd.c
--- iptables-1.2.8/extensions/libipt_psd.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.2.9/extensions/libipt_psd.c	2003-03-02 17:16:45.000000000 +0100
@@ -11,6 +11,7 @@
   2000-08-18 Dennis Koslowski <koslowski@astaro.de> : first release
   2000-12-01 Dennis Koslowski <koslowski@astaro.de> : UDP scans detection added
   2001-02-04 Jan Rekorajski <baggins@pld.org.pl> : converted from target to match
+  2003-03-02 Harald Welte <laforge@netfilter.org>: fix 'storage' bug
 */
 
 #include <stdio.h>
@@ -82,11 +83,11 @@
 {
 	struct ipt_psd_info *psdinfo = (struct ipt_psd_info *)(*match)->data;
 	unsigned int num;
-	char storage[strlen(optarg) + 2];
+	
+	if (!optarg)
+		exit_error(PARAMETER_PROBLEM, "missing optarg");
 
 	/* string_to_number needs a leading space */
-	storage[0] = ' ';
-	strcpy(&storage[1], optarg);
 
 	switch (c) {
 	/* PSD-weight-threshold */
@@ -95,7 +96,7 @@
 			exit_error(PARAMETER_PROBLEM,
 				   "Can't specify --psd-weight-threshold "
 				   "twice");
-                if (string_to_number(storage, 0, 10000, &num) == -1)
+                if (string_to_number(optarg, 0, 10000, &num) == -1)
                         exit_error(PARAMETER_PROBLEM,
                                    "bad --psd-weight-threshold `%s'", optarg);
 		psdinfo->weight_threshold = num;
@@ -107,7 +108,7 @@
 		if (*flags & IPT_PSD_OPT_DTRESH)
 			exit_error(PARAMETER_PROBLEM,
 				   "Can't specify --psd-delay-threshold twice");
-                if (string_to_number(storage, 0, 10000, &num) == -1)
+                if (string_to_number(optarg, 0, 10000, &num) == -1)
                         exit_error(PARAMETER_PROBLEM,
                                    "bad --psd-delay-threshold `%s'", optarg);
 		psdinfo->delay_threshold = num;
@@ -119,7 +120,7 @@
 		if (*flags & IPT_PSD_OPT_LPWEIGHT)
 			exit_error(PARAMETER_PROBLEM,
 				   "Can't specify --psd-lo-ports-weight twice");
-                if (string_to_number(storage, 0, 10000, &num) == -1)
+                if (string_to_number(optarg, 0, 10000, &num) == -1)
                         exit_error(PARAMETER_PROBLEM,
                                    "bad --psd-lo-ports-weight `%s'", optarg);
 		psdinfo->lo_ports_weight = num;
@@ -131,7 +132,7 @@
 		if (*flags & IPT_PSD_OPT_HPWEIGHT)
 			exit_error(PARAMETER_PROBLEM,
 				   "Can't specify --psd-hi-ports-weight twice");
-                if (string_to_number(storage, 0, 10000, &num) == -1)
+                if (string_to_number(optarg, 0, 10000, &num) == -1)
                         exit_error(PARAMETER_PROBLEM,
                                    "bad --psd-hi-ports-weight `%s'", optarg);
 		psdinfo->hi_ports_weight = num;
@@ -160,10 +161,10 @@
 		= (const struct ipt_psd_info *)match->data;
 
 	printf("psd ");
-	printf("weight-threshold: %u ",psdinfo->weight_threshold);
-	printf("delay-threshold: %u ",psdinfo->delay_threshold);
-	printf("lo-ports-weight: %u ",psdinfo->lo_ports_weight);
-	printf("hi-ports-weight: %u ",psdinfo->hi_ports_weight);
+	printf("weight-threshold: %u ", psdinfo->weight_threshold);
+	printf("delay-threshold: %u ", psdinfo->delay_threshold);
+	printf("lo-ports-weight: %u ", psdinfo->lo_ports_weight);
+	printf("hi-ports-weight: %u ", psdinfo->hi_ports_weight);
 }
 
 /* Saves the union ipt_targinfo in parsable form to stdout. */
@@ -175,8 +176,8 @@
 
 	printf("--psd-weight-threshold %u ", psdinfo->weight_threshold);
 	printf("--psd-delay-threshold %u ", psdinfo->delay_threshold);
-	printf("--psd-lo-ports-weight %u ",psdinfo->lo_ports_weight);
-	printf("--psd-hi-ports-weight %u ",psdinfo->hi_ports_weight);
+	printf("--psd-lo-ports-weight %u ", psdinfo->lo_ports_weight);
+	printf("--psd-hi-ports-weight %u ", psdinfo->hi_ports_weight);
 }
 
 static
diff -urN iptables-1.2.8/extensions/libipt_recent.c iptables-1.2.9/extensions/libipt_recent.c
--- iptables-1.2.8/extensions/libipt_recent.c	2003-03-30 22:26:42.000000000 +0200
+++ iptables-1.2.9/extensions/libipt_recent.c	2003-06-15 00:39:35.000000000 +0200
@@ -8,17 +8,34 @@
 #include <iptables.h>
 #include <linux/netfilter_ipv4/ipt_recent.h>
 
-/* need thos two to not fail compilation with old kernel, new userspace */
+/* Need these in order to not fail when compiling against an older kernel. */
 #ifndef RECENT_NAME
 #define RECENT_NAME	"ipt_recent"
 #endif /* RECENT_NAME */
+
 #ifndef RECENT_VER
 #define RECENT_VER	"unknown"
 #endif /* RECENT_VER */
+
 #ifndef IPT_RECENT_NAME_LEN
-#define	IPT_RECENT_NAME_LEN	200
+#define IPT_RECENT_NAME_LEN	200
 #endif /* IPT_RECENT_NAME_LEN */
 
+/* Options for this module */
+static struct option opts[] = {
+	{ .name = "set",      .has_arg = 0, .flag = 0, .val = 201 }, 
+	{ .name = "rcheck",   .has_arg = 0, .flag = 0, .val = 202 }, 
+	{ .name = "update",   .has_arg = 0, .flag = 0, .val = 203 },
+	{ .name = "seconds",  .has_arg = 1, .flag = 0, .val = 204 }, 
+	{ .name = "hitcount", .has_arg = 1, .flag = 0, .val = 205 },
+	{ .name = "remove",   .has_arg = 0, .flag = 0, .val = 206 },
+	{ .name = "rttl",     .has_arg = 0, .flag = 0, .val = 207 },
+	{ .name = "name",     .has_arg = 1, .flag = 0, .val = 208 },
+	{ .name = "rsource",  .has_arg = 0, .flag = 0, .val = 209 },
+	{ .name = "rdest",    .has_arg = 0, .flag = 0, .val = 210 },
+	{ .name = 0,          .has_arg = 0, .flag = 0, .val = 0   }
+};
+
 /* Function which prints out usage message. */
 static void
 help(void)
@@ -41,28 +58,14 @@
 "                                Useful if you have problems with people spoofing their source address in order\n"
 "                                to DoS you via this module.\n"
 "    --name name                 Name of the recent list to be used.  DEFAULT used if none given.\n"
-"    --rsource                   Save the source address of each packet in the recent list table (default).\n"
-"    --rdest                     Save the destination address of each packet in the recent list table.\n"
+"    --rsource                   Match/Save the source address of each packet in the recent list table (default).\n"
+"    --rdest                     Match/Save the destination address of each packet in the recent list table.\n"
 RECENT_NAME " " RECENT_VER ": Stephen Frost <sfrost@snowman.net>.  http://snowman.net/projects/ipt_recent/\n"
 ,
 IPTABLES_VERSION);
 
 }
   
-static struct option opts[] = {
-	{ "set", 0, 0, 201 }, 
-	{ "rcheck", 0, 0, 202 }, 
-	{ "update", 0, 0, 203 },
-	{ "seconds", 1, 0, 204 }, 
-	{ "hitcount", 1, 0, 205 },
-	{ "remove",0, 0, 206 },
-	{ "rttl",0, 0, 207},
-	{ "name", 1, 0, 208},
-	{ "rsource", 0, 0, 209},
-	{ "rdest", 0, 0, 210},
-	{0}
-};
-
 /* Initialize the match. */
 static void
 init(struct ipt_entry_match *match, unsigned int *nfcache)
@@ -175,7 +178,8 @@
 {
 	struct ipt_recent_info *info = (struct ipt_recent_info *)match->data;
 
-	if (info->invert) fputc('!', stdout);
+	if (info->invert)
+		fputc('!', stdout);
 
 	printf("recent: ");
 	if(info->check_set & IPT_RECENT_SET) printf("SET ");
@@ -194,37 +198,37 @@
 static void
 save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
 {
-	struct ipt_recent_info *info = (struct ipt_recent_info *)match;
+	struct ipt_recent_info *info = (struct ipt_recent_info *)match->data;
 
-	if (info->invert) fputc('!', stdout);
+	if (info->invert)
+		printf("! ");
 
-	printf("recent: ");
 	if(info->check_set & IPT_RECENT_SET) printf("--set ");
 	if(info->check_set & IPT_RECENT_CHECK) printf("--rcheck ");
 	if(info->check_set & IPT_RECENT_UPDATE) printf("--update ");
 	if(info->check_set & IPT_RECENT_REMOVE) printf("--remove ");
 	if(info->seconds) printf("--seconds %d ",info->seconds);
 	if(info->hit_count) printf("--hitcount %d ",info->hit_count);
-	if(info->check_set & IPT_RECENT_TTL) printf("-rttl ");
+	if(info->check_set & IPT_RECENT_TTL) printf("--rttl ");
 	if(info->name) printf("--name %s ",info->name);
 	if(info->side == IPT_RECENT_SOURCE) printf("--rsource ");
 	if(info->side == IPT_RECENT_DEST) printf("--rdest ");
 }
 
-static
-struct iptables_match recent
-= { NULL,
-    "recent",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_recent_info)),
-    IPT_ALIGN(sizeof(struct ipt_recent_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+/* Structure for iptables to use to communicate with module */
+static struct iptables_match recent = { 
+    .next          = NULL,
+    .name          = "recent",
+    .version       = IPTABLES_VERSION,
+    .size          = IPT_ALIGN(sizeof(struct ipt_recent_info)),
+    .userspacesize = IPT_ALIGN(sizeof(struct ipt_recent_info)),
+    .help          = &help,
+    .init          = &init,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
 };
 
 void _init(void)
diff -urN iptables-1.2.8/extensions/libipt_sctp.c iptables-1.2.9/extensions/libipt_sctp.c
--- iptables-1.2.8/extensions/libipt_sctp.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_sctp.c	2003-05-03 20:05:58.000000000 +0200
@@ -0,0 +1,402 @@
+/* Shared library add-on to iptables for SCTP matching
+ *
+ * (C) 2003 by Harald Welte <laforge@gnumonks.org>
+ *
+ * This program is distributed under the terms of GNU GPL v2, 1991
+ *
+ * libipt_ecn.c borrowed heavily from libipt_dscp.c
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <netdb.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_sctp.h>
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_sctp_info *einfo = (struct ipt_sctp_info *)m->data;
+
+	einfo->spts[1] = einfo->dpts[1] = 0xFFFF;
+}
+
+static void help(void) 
+{
+	printf(
+"SCTP match v%s options\n"
+" --sctp-chunks [!] mask comp	match when SCTP chunks & mask == comp\n"
+" --source-port [!] port[:port]\n"
+" --sport ...\n"
+"                               match source port(s)"
+" --destination-port [!] port[:port]\n"
+" --dport ...\n\n",
+	IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ .name = "source-port", .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = "sport", .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = "destination-port", .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = "dport", .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = "sctp-chunks", .has_arg = 1, .flag = 0, .val = '3' },
+	{ .name = 0 }
+};
+
+static int
+service_to_port(const char *name)
+{
+	struct servent *service;
+
+	if ((service = getservbyname(name, "sctp")) != NULL)
+		return ntohs((unsigned short) service->s_port);
+
+	return -1;
+}
+
+static u_int16_t
+parse_sctp_port(const char *port)
+{
+	unsigned int portnum;
+
+	if (string_to_number(port, 0, 65535, &portnum) != -1 ||
+	    (portnum = service_to_port(port)) != -1)
+		return (u_int16_t)portnum;
+
+	exit_error(PARAMETER_PROBLEM,
+		   "invalid TCP port/service `%s' specified", port);
+}
+
+
+static void
+parse_sctp_ports(const char *portstring, u_int16_t *ports)
+{
+	char *buffer;
+	char *cp;
+
+	buffer = strdup(portstring);
+	if ((cp = strchr(buffer, ':')) == NULL)
+		ports[0] = ports[1] = parse_sctp_port(buffer);
+	else {
+		*cp = '\0';
+		cp++;
+
+		ports[0] = buffer[0] ? parse_sctp_port(buffer) : 0;
+		ports[1] = cp[0] ? parse_sctp_port(cp) : 0xFFFF;
+
+		if (ports[0] > ports[1])
+			exit_error(PARAMETER_PROBLEM,
+				   "invalid portrange (min > max)");
+	}
+	free(buffer);
+}
+
+struct sctp_chunk_names {
+	const char *name;
+	unsigned int flag;
+};
+
+/* FIXME: */
+#define ALL_CHUNKS	0xabcdef
+static struct sctp_chunk_names sctp_chunk_names[]
+= { { .name = "DATA", 		.flag = (1 << 0) },
+    { .name = "INIT", 		.flag = (1 << 1) },
+    { .name = "INIT_ACK", 	.flag = (1 << 2) },
+    { .name = "SACK",		.flag = (1 << 3) },
+    { .name = "HEARTBEAT",	.flag = (1 << 4) },
+    { .name = "HEARTBEAT_ACK",	.flag = (1 << 5) },
+    { .name = "ABORT",		.flag = (1 << 6) },
+    { .name = "SHUTDOWN",	.flag = (1 << 7) },
+    { .name = "SHUTDOWN_ACK",	.flag = (1 << 8) },
+    { .name = "ERROR",		.flag = (1 << 9) },
+    { .name = "COOKIE_ECHO",	.flag = (1 << 10) },
+    { .name = "COOKIE_ACK",	.flag = (1 << 11) },
+    { .name = "ECN_ECNE",	.flag = (1 << 12) },
+    { .name = "ECN_CWR",	.flag = (1 << 13) },
+    { .name = "SHUTDOWN_COMPLETE", .flag = (1 << 14) },
+    { .name = "ASCONF",		.flag = (1 << 31) },
+    { .name = "ASCONF_ACK",	.flag = (1 << 30) },
+    { .name = "ALL", 		.flag = ALL_CHUNKS },
+    { .name = "NONE",		.flag = 0 },
+};
+
+
+static unsigned int
+parse_sctp_chunk(const char *flags)
+{
+	unsigned int ret = 0;
+	char *ptr;
+	char *buffer;
+
+	buffer = strdup(flags);
+
+	for (ptr = strtok(buffer, ","); ptr; ptr = strtok(NULL, ",")) {
+		unsigned int i;
+		int found = 0;
+		for (i = 0;
+		     i < sizeof(sctp_chunk_names)/sizeof(struct sctp_chunk_names);
+		     i++) {
+			if (strcasecmp(sctp_chunk_names[i].name, ptr) == 0) {
+				ret |= sctp_chunk_names[i].flag;
+				found = 1;
+				break;
+			}
+		}
+		if (!found)
+			exit_error(PARAMETER_PROBLEM,
+				   "Unknown sctp chunk `%s'", ptr);
+	}
+
+	free(buffer);
+	return ret;
+}
+
+static void
+parse_sctp_chunks(struct ipt_sctp_info *einfo,
+		const char *mask,
+		const char *cmp,
+		int invert)
+{
+	einfo->chunks = parse_sctp_chunk(mask);
+	einfo->chunk_mask = parse_sctp_chunk(cmp);
+
+	if (invert)
+		einfo->invflags |= IPT_SCTP_INV_CHUNKS;
+}
+
+#define SCTP_SRC_PORTS	0x01
+#define SCTP_DST_PORTS	0x02
+#define SCTP_CHUNKS	0x03
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_sctp_info *einfo
+		= (struct ipt_sctp_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags & SCTP_SRC_PORTS)
+			exit_error(PARAMETER_PROBLEM,
+			           "Only one `--source-port' allowed");
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_sctp_ports(argv[optind-1], einfo->spts);
+		if (invert)
+			einfo->invflags |= IPT_SCTP_INV_SRCPT;
+		*flags |= SCTP_SRC_PORTS;
+		*nfcache |= NFC_IP_SRC_PT;
+		break;
+
+	case '2':
+		if (*flags & SCTP_DST_PORTS)
+			exit_error(PARAMETER_PROBLEM,
+				   "Only one `--destination-port' allowed");
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_sctp_ports(argv[optind-1], einfo->dpts);
+		if (invert)
+			einfo->invflags |= IPT_SCTP_INV_DSTPT;
+		*flags |= SCTP_DST_PORTS;
+		*nfcache |= NFC_IP_DST_PT;
+		break;
+
+	case '3':
+		if (*flags & SCTP_CHUNKS)
+			exit_error(PARAMETER_PROBLEM,
+				   "Only one `--sctp-chunks' allowed");
+		check_inverse(optarg, &invert, &optind, 0);
+
+		if (!argv[optind] 
+		    || argv[optind][0] == '-' || argv[optind][0] == '!')
+			exit_error(PARAMETER_PROBLEM,
+				   "--sctp-chunks requires two args");
+
+		parse_sctp_chunks(einfo, argv[optind-1], argv[optind], invert);
+		optind++;
+		*flags |= SCTP_CHUNKS;
+		break;
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+}
+
+static char *
+port_to_service(int port)
+{
+	struct servent *service;
+
+	if ((service = getservbyport(htons(port), "sctp")))
+		return service->s_name;
+
+	return NULL;
+}
+
+static void
+print_port(u_int16_t port, int numeric)
+{
+	char *service;
+
+	if (numeric || (service = port_to_service(port)) == NULL)
+		printf("%u", port);
+	else
+		printf("%s", service);
+}
+
+static void
+print_ports(const char *name, u_int16_t min, u_int16_t max,
+	    int invert, int numeric)
+{
+	const char *inv = invert ? "!" : "";
+
+	if (min != 0 || max != 0xFFFF || invert) {
+		printf("%s", name);
+		if (min == max) {
+			printf(":%s", inv);
+			print_port(min, numeric);
+		} else {
+			printf("s:%s", inv);
+			print_port(min, numeric);
+			printf(":");
+			print_port(max, numeric);
+		}
+		printf(" ");
+	}
+}
+
+static void
+print_chunk(u_int32_t chunks)
+{
+	unsigned int have_flag = 0;
+
+	while (chunks) {
+		unsigned int i;
+
+		for (i = 0; (chunks & sctp_chunk_names[i].flag) == 0; i++);
+
+		if (have_flag)
+			printf(",");
+		printf("%s", sctp_chunk_names[i].name);
+		have_flag = 1;
+
+		chunks &= ~sctp_chunk_names[i].flag;
+	}
+
+	if (!have_flag)
+		printf("NONE");
+}
+
+static void
+print_chunks(u_int32_t mask, u_int32_t cmp, int invert, int numeric)
+{
+	if (mask || invert) {
+		printf("flags:%s", invert ? "!" : "");
+		if (numeric)
+			printf("0x%04X/0x%04X ", mask, cmp);
+		else {
+			print_chunk(mask);
+			printf("/");
+			print_chunk(cmp);
+			printf(" ");
+		}
+	}
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	const struct ipt_sctp_info *einfo =
+		(const struct ipt_sctp_info *)match->data;
+
+	printf("sctp ");
+
+	print_ports("spt", einfo->spts[0], einfo->spts[1],
+		    einfo->invflags & IPT_SCTP_INV_SRCPT,
+		    numeric);
+	print_ports("dpt", einfo->dpts[0], einfo->dpts[1],
+		    einfo->invflags & IPT_SCTP_INV_DSTPT,
+		    numeric);
+
+	print_chunks(einfo->chunks, einfo->chunk_mask,
+		     einfo->invflags & ~IPT_SCTP_INV_MASK,
+		     numeric);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	const struct ipt_sctp_info *einfo =
+		(const struct ipt_sctp_info *)match->data;
+
+	if (einfo->spts[0] != 0
+	    || einfo->spts[1] != 0xFFFF) {
+		if (einfo->invflags & IPT_SCTP_INV_SRCPT)
+			printf("! ");
+		if (einfo->spts[0] != einfo->spts[1])
+			printf("--sport %u:%u ", 
+			       einfo->spts[0], einfo->spts[1]);
+		else
+			printf("--sport %u ", einfo->spts[0]);
+	}
+
+	if (einfo->dpts[0] != 0
+	    || einfo->dpts[1] != 0xFFFF) {
+		if (einfo->invflags & IPT_SCTP_INV_DSTPT)
+			printf("! ");
+		if (einfo->dpts[0] != einfo->dpts[1])
+			printf("--dport %u:%u ",
+			       einfo->dpts[0], einfo->dpts[1]);
+		else
+			printf("--dport %u ", einfo->dpts[0]);
+	}
+
+	if (einfo->chunks
+	    || (einfo->invflags & IPT_SCTP_INV_CHUNKS)) {
+		if (einfo->invflags & IPT_SCTP_INV_CHUNKS)
+			printf("! ");
+		printf("--sctp-chunks ");
+		if (einfo->chunks != ALL_CHUNKS) {
+			print_chunk(einfo->chunks);
+		}
+		printf(" ");
+		print_chunk(einfo->chunk_mask);
+		printf(" ");
+	}
+}
+
+static
+struct iptables_match sctp
+= { .name          = "sctp",
+    .version       = IPTABLES_VERSION,
+    .size          = IPT_ALIGN(sizeof(struct ipt_sctp_info)),
+    .userspacesize = IPT_ALIGN(sizeof(struct ipt_sctp_info)),
+    .help          = &help,
+    .init          = &init,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
+};
+
+void _init(void)
+{
+	register_match(&sctp);
+}
diff -urN iptables-1.2.8/extensions/libipt_state.c iptables-1.2.9/extensions/libipt_state.c
--- iptables-1.2.8/extensions/libipt_state.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.2.9/extensions/libipt_state.c	2003-10-07 20:54:30.000000000 +0200
@@ -8,13 +8,17 @@
 #include <linux/netfilter_ipv4/ip_conntrack.h>
 #include <linux/netfilter_ipv4/ipt_state.h>
 
+#ifndef IPT_STATE_UNTRACKED
+#define IPT_STATE_UNTRACKED (1 << (IP_CT_NUMBER + 1))
+#endif
+
 /* Function which prints out usage message. */
 static void
 help(void)
 {
 	printf(
 "state v%s options:\n"
-" [!] --state [INVALID|ESTABLISHED|NEW|RELATED][,...]\n"
+" [!] --state [INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED][,...]\n"
 "				State(s) to match\n"
 "\n", IPTABLES_VERSION);
 }
@@ -43,6 +47,8 @@
 		sinfo->statemask |= IPT_STATE_BIT(IP_CT_ESTABLISHED);
 	else if (strncasecmp(state, "RELATED", strlen) == 0)
 		sinfo->statemask |= IPT_STATE_BIT(IP_CT_RELATED);
+	else if (strncasecmp(state, "UNTRACKED", strlen) == 0)
+		sinfo->statemask |= IPT_STATE_UNTRACKED;
 	else
 		return 0;
 	return 1;
@@ -117,6 +123,10 @@
 		printf("%sESTABLISHED", sep);
 		sep = ",";
 	}
+	if (statemask & IPT_STATE_UNTRACKED) {
+		printf("%sUNTRACKED", sep);
+		sep = ",";
+	}
 	printf(" ");
 }
 
diff -urN iptables-1.2.8/extensions/libipt_string.c iptables-1.2.9/extensions/libipt_string.c
--- iptables-1.2.8/extensions/libipt_string.c	2003-02-26 18:34:13.000000000 +0100
+++ iptables-1.2.9/extensions/libipt_string.c	2003-05-03 20:52:15.000000000 +0200
@@ -18,23 +18,26 @@
 #include <iptables.h>
 #include <linux/netfilter_ipv4/ipt_string.h>
 
+
 /* Function which prints out usage message. */
 static void
 help(void)
 {
 	printf(
 "STRING match v%s options:\n"
-"--string [!] string             Match a string in a packet\n",
+"--string [!] string          Match a string in a packet\n"
+"--hex-string [!] string      Match a hex string in a packet\n",
 IPTABLES_VERSION);
-
-	fputc('\n', stdout);
 }
 
+
 static struct option opts[] = {
-	{ "string", 1, 0, '1' },
-	{0}
+	{ .name = "string",     .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = "hex-string", .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = 0 }
 };
 
+
 /* Initialize the match. */
 static void
 init(struct ipt_entry_match *m, unsigned int *nfcache)
@@ -42,9 +45,18 @@
 	*nfcache |= NFC_UNKNOWN;
 }
 
+
 static void
 parse_string(const unsigned char *s, struct ipt_string_info *info)
 {	
+	if (strlen(s) <= BM_MAX_NLEN) strcpy(info->string, s);
+	else exit_error(PARAMETER_PROBLEM, "STRING too long `%s'", s);
+}
+
+
+static void
+parse_hex_string(const unsigned char *s, struct ipt_string_info *info)
+{
 	int i=0, slen, sindex=0, schar;
 	short hex_f = 0, literal_f = 0;
 	char hextmp[3];
@@ -90,6 +102,10 @@
 				/* must end with a "|" */
 				exit_error(PARAMETER_PROBLEM, "Invalid hex block");
 			}
+			if (! isxdigit(s[i])) /* check for valid hex char */
+				exit_error(PARAMETER_PROBLEM, "Invalid hex char `%c'", s[i]);
+			if (! isxdigit(s[i+1])) /* check for valid hex char */
+				exit_error(PARAMETER_PROBLEM, "Invalid hex char `%c'", s[i+1]);
 			hextmp[0] = s[i];
 			hextmp[1] = s[i+1];
 			hextmp[2] = '\0';
@@ -109,8 +125,10 @@
 			exit_error(PARAMETER_PROBLEM, "STRING too long `%s'", s);
 		sindex++;
 	}
+	info->len = sindex;
 }
 
+
 /* Function which parses command options; returns true if it
    ate an option */
 static int
@@ -123,11 +141,27 @@
 
 	switch (c) {
 	case '1':
+		if (*flags)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify multiple strings");
+
 		check_inverse(optarg, &invert, &optind, 0);
 		parse_string(argv[optind-1], stringinfo);
 		if (invert)
 			stringinfo->invert = 1;
-                stringinfo->len=strlen((char *)&stringinfo->string);
+		stringinfo->len=strlen((char *)&stringinfo->string);
+		*flags = 1;
+		break;
+
+	case '2':
+		if (*flags)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify multiple strings");
+
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_hex_string(argv[optind-1], stringinfo);  /* sets length */
+		if (invert)
+			stringinfo->invert = 1;
 		*flags = 1;
 		break;
 
@@ -137,14 +171,6 @@
 	return 1;
 }
 
-static void
-print_string(char string[], int invert, int numeric)
-{
-
-	if (invert)
-		fputc('!', stdout);
-	printf("%s ",string);
-}
 
 /* Final check; must have specified --string. */
 static void
@@ -155,42 +181,46 @@
 			   "STRING match: You must specify `--string'");
 }
 
+
 /* Prints out the matchinfo. */
 static void
 print(const struct ipt_ip *ip,
       const struct ipt_entry_match *match,
       int numeric)
 {
-	printf("STRING match ");
-	print_string(((struct ipt_string_info *)match->data)->string,
-		  ((struct ipt_string_info *)match->data)->invert, numeric);
+	const struct ipt_string_info *info =
+	    (const struct ipt_string_info*) match->data;
+
+	printf("STRING match %s%s ", (info->invert) ? "!" : "", info->string);
 }
 
-/* Saves the union ipt_matchinfo in parsable form to stdout. */
+
+/* Saves the union ipt_matchinfo in parseable form to stdout. */
 static void
 save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
 {
-	printf("--string ");
-	print_string(((struct ipt_string_info *)match->data)->string,
-		  ((struct ipt_string_info *)match->data)->invert, 0);
-}
-
-static
-struct iptables_match string
-= { NULL,
-    "string",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_string_info)),
-    IPT_ALIGN(sizeof(struct ipt_string_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+	const struct ipt_string_info *info =
+	    (const struct ipt_string_info*) match->data;
+
+	printf("--string %s%s ", (info->invert) ? "! ": "", info->string);
+}
+
+
+static struct iptables_match string = {
+    .name          = "string",
+    .version       = IPTABLES_VERSION,
+    .size          = IPT_ALIGN(sizeof(struct ipt_string_info)),
+    .userspacesize = IPT_ALIGN(sizeof(struct ipt_string_info)),
+    .help          = &help,
+    .init          = &init,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
 };
 
+
 void _init(void)
 {
 	register_match(&string);
diff -urN iptables-1.2.8/include/libipq/libipq.h iptables-1.2.9/include/libipq/libipq.h
--- iptables-1.2.8/include/libipq/libipq.h	2001-11-24 16:09:19.000000000 +0100
+++ iptables-1.2.9/include/libipq/libipq.h	2003-09-07 12:08:00.000000000 +0200
@@ -35,7 +35,7 @@
 typedef u_int64_t ipq_id_t;
 #else
 #include <linux/netfilter_ipv4/ip_queue.h>
-typedef u_int32_t ipq_id_t;
+typedef unsigned long ipq_id_t;
 #endif
 
 #ifdef DEBUG_LIBIPQ
diff -urN iptables-1.2.8/include/libiptc/libip6tc.h iptables-1.2.9/include/libiptc/libip6tc.h
--- iptables-1.2.8/include/libiptc/libip6tc.h	2002-02-25 10:00:36.000000000 +0100
+++ iptables-1.2.9/include/libiptc/libip6tc.h	2003-05-06 23:08:26.000000000 +0200
@@ -26,6 +26,9 @@
 /* Take a snapshot of the rules. Returns NULL on error. */
 ip6tc_handle_t ip6tc_init(const char *tablename);
 
+/* Cleanup after ip6tc_init(). */
+void ip6tc_free(ip6tc_handle_t *h);
+
 /* Iterator functions to run through the chains.  Returns NULL at end. */
 const char *ip6tc_first_chain(ip6tc_handle_t *handle);
 const char *ip6tc_next_chain(ip6tc_handle_t *handle);
diff -urN iptables-1.2.8/include/libiptc/libiptc.h iptables-1.2.9/include/libiptc/libiptc.h
--- iptables-1.2.8/include/libiptc/libiptc.h	2001-04-19 18:35:39.000000000 +0200
+++ iptables-1.2.9/include/libiptc/libiptc.h	2003-06-18 18:24:02.000000000 +0200
@@ -34,6 +34,9 @@
 /* Take a snapshot of the rules.  Returns NULL on error. */
 iptc_handle_t iptc_init(const char *tablename);
 
+/* Cleanup after iptc_init(). */
+void iptc_free(iptc_handle_t *h);
+
 /* Iterator functions to run through the chains.  Returns NULL at end. */
 const char *iptc_first_chain(iptc_handle_t *handle);
 const char *iptc_next_chain(iptc_handle_t *handle);
diff -urN iptables-1.2.8/include/linux/netfilter_ipv4/ipt_CLASSIFY.h iptables-1.2.9/include/linux/netfilter_ipv4/ipt_CLASSIFY.h
--- iptables-1.2.8/include/linux/netfilter_ipv4/ipt_CLASSIFY.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/include/linux/netfilter_ipv4/ipt_CLASSIFY.h	2003-09-13 07:23:46.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef _IPT_CLASSIFY_H
+#define _IPT_CLASSIFY_H
+
+struct ipt_classify_target_info {
+	u_int32_t priority;
+};
+
+#endif /*_IPT_CLASSIFY_H */
diff -urN iptables-1.2.8/include/linux/netfilter_ipv4/ipt_CONNMARK.h iptables-1.2.9/include/linux/netfilter_ipv4/ipt_CONNMARK.h
--- iptables-1.2.8/include/linux/netfilter_ipv4/ipt_CONNMARK.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/include/linux/netfilter_ipv4/ipt_CONNMARK.h	2003-08-24 00:09:24.000000000 +0200
@@ -0,0 +1,15 @@
+#ifndef _IPT_CONNMARK_H_target
+#define _IPT_CONNMARK_H_target
+
+enum {
+	IPT_CONNMARK_SET = 0,
+	IPT_CONNMARK_SAVE,
+	IPT_CONNMARK_RESTORE
+};
+
+struct ipt_connmark_target_info {
+	unsigned long mark;
+	u_int8_t mode;
+};
+
+#endif /*_IPT_CONNMARK_H_target*/
diff -urN iptables-1.2.8/include/linux/netfilter_ipv4/ipt_connlimit.h iptables-1.2.9/include/linux/netfilter_ipv4/ipt_connlimit.h
--- iptables-1.2.8/include/linux/netfilter_ipv4/ipt_connlimit.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/include/linux/netfilter_ipv4/ipt_connlimit.h	2003-04-30 18:54:48.000000000 +0200
@@ -0,0 +1,12 @@
+#ifndef _IPT_CONNLIMIT_H
+#define _IPT_CONNLIMIT_H
+
+struct ipt_connlimit_data;
+
+struct ipt_connlimit_info {
+	int limit;
+	int inverse;
+	u_int32_t mask;
+	struct ipt_connlimit_data *data;
+};
+#endif /* _IPT_CONNLIMIT_H */
diff -urN iptables-1.2.8/include/linux/netfilter_ipv4/ipt_connmark.h iptables-1.2.9/include/linux/netfilter_ipv4/ipt_connmark.h
--- iptables-1.2.8/include/linux/netfilter_ipv4/ipt_connmark.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/include/linux/netfilter_ipv4/ipt_connmark.h	2003-08-24 00:07:10.000000000 +0200
@@ -0,0 +1,9 @@
+#ifndef _IPT_CONNMARK_H
+#define _IPT_CONNMARK_H
+
+struct ipt_connmark_info {
+	unsigned long mark, mask;
+	u_int8_t invert;
+};
+
+#endif /*_IPT_CONNMARK_H*/
diff -urN iptables-1.2.8/include/linux/netfilter_ipv4/ipt_iplimit.h iptables-1.2.9/include/linux/netfilter_ipv4/ipt_iplimit.h
--- iptables-1.2.8/include/linux/netfilter_ipv4/ipt_iplimit.h	2001-02-28 12:21:54.000000000 +0100
+++ iptables-1.2.9/include/linux/netfilter_ipv4/ipt_iplimit.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-#ifndef _IPT_IPLIMIT_H
-#define _IPT_IPLIMIT_H
-
-struct ipt_iplimit_data;
-
-struct ipt_iplimit_info {
-	int limit;
-	int inverse;
-	u_int32_t mask;
-	struct ipt_iplimit_data *data;
-};
-#endif /* _IPT_IPLIMIT_H */
diff -urN iptables-1.2.8/include/linux/netfilter_ipv4/ipt_iprange.h iptables-1.2.9/include/linux/netfilter_ipv4/ipt_iprange.h
--- iptables-1.2.8/include/linux/netfilter_ipv4/ipt_iprange.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/include/linux/netfilter_ipv4/ipt_iprange.h	2003-08-23 23:40:38.000000000 +0200
@@ -0,0 +1,23 @@
+#ifndef _IPT_IPRANGE_H
+#define _IPT_IPRANGE_H
+
+#define IPRANGE_SRC		0x01	/* Match source IP address */
+#define IPRANGE_DST		0x02	/* Match destination IP address */
+#define IPRANGE_SRC_INV		0x10	/* Negate the condition */
+#define IPRANGE_DST_INV		0x20	/* Negate the condition */
+
+struct ipt_iprange {
+	/* Inclusive: network order. */
+	u_int32_t min_ip, max_ip;
+};
+
+struct ipt_iprange_info
+{
+	struct ipt_iprange src;
+	struct ipt_iprange dst;
+
+	/* Flags from above */
+	u_int8_t flags;
+};
+
+#endif /* _IPT_IPRANGE_H */
diff -urN iptables-1.2.8/include/linux/netfilter_ipv4/ipt_physdev.h iptables-1.2.9/include/linux/netfilter_ipv4/ipt_physdev.h
--- iptables-1.2.8/include/linux/netfilter_ipv4/ipt_physdev.h	2003-02-11 21:19:04.000000000 +0100
+++ iptables-1.2.9/include/linux/netfilter_ipv4/ipt_physdev.h	2003-11-02 17:53:25.000000000 +0100
@@ -5,15 +5,20 @@
 #include <linux/if.h>
 #endif
 
-#define IPT_PHYSDEV_OP_MATCH_IN 0x01
-#define IPT_PHYSDEV_OP_MATCH_OUT 0x02
+#define IPT_PHYSDEV_OP_IN		0x01
+#define IPT_PHYSDEV_OP_OUT		0x02
+#define IPT_PHYSDEV_OP_BRIDGED		0x04
+#define IPT_PHYSDEV_OP_ISIN		0x08
+#define IPT_PHYSDEV_OP_ISOUT		0x10
+#define IPT_PHYSDEV_OP_MASK		(0x20 - 1)
 
 struct ipt_physdev_info {
-	u_int8_t invert;
 	char physindev[IFNAMSIZ];
 	char in_mask[IFNAMSIZ];
 	char physoutdev[IFNAMSIZ];
 	char out_mask[IFNAMSIZ];
+	u_int8_t invert;
+	u_int8_t bitmask;
 };
 
 #endif /*_IPT_PHYSDEV_H*/
diff -urN iptables-1.2.8/include/linux/netfilter_ipv4/ipt_realm.h iptables-1.2.9/include/linux/netfilter_ipv4/ipt_realm.h
--- iptables-1.2.8/include/linux/netfilter_ipv4/ipt_realm.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/include/linux/netfilter_ipv4/ipt_realm.h	2003-08-23 23:59:31.000000000 +0200
@@ -0,0 +1,9 @@
+#ifndef _IPT_REALM_H
+#define _IPT_REALM_H
+
+struct ipt_realm_info {
+	u_int32_t id;
+	u_int32_t mask;
+	u_int8_t invert;
+};
+#endif /*_IPT_REALM_H*/
diff -urN iptables-1.2.8/include/linux/netfilter_ipv4/ipt_sctp.h iptables-1.2.9/include/linux/netfilter_ipv4/ipt_sctp.h
--- iptables-1.2.8/include/linux/netfilter_ipv4/ipt_sctp.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/include/linux/netfilter_ipv4/ipt_sctp.h	2003-05-03 20:05:58.000000000 +0200
@@ -0,0 +1,25 @@
+/* iptables module for matching the SCTP header
+ *
+ * (C) 2003 Harald Welte <laforge@gnumonks.org>
+ *
+ * This software is distributed under GNU GPL v2, 1991
+ *
+ * $Id: ipt_sctp.h,v 1.1 2003/05/03 18:05:58 laforge Exp $
+ */
+#ifndef _IPT_SCTP_H
+#define _IPT_SCTP_H
+
+struct ipt_sctp_info {
+	u_int16_t spts[2];			/* Souce port range */
+	u_int16_t dpts[2];			/* Destination port range */
+	u_int32_t chunks;			/* chunks to be matched */
+	u_int32_t chunk_mask;			/* chunk mask to be matched */
+	u_int8_t invflags;			/* Inverse flags */
+};
+
+#define IPT_SCTP_INV_SRCPT	0x01	/* Invert the sense of source ports */
+#define IPT_SCTP_INV_DSTPT	0x02	/* Invert the sense of dest ports */
+#define IPT_SCTP_INV_CHUNKS	0x03	/* Invert the sense of chunks */
+#define IPT_SCTP_INV_MASK	0x03	/* All possible flags */
+
+#endif /* _IPT_SCTP_H */
diff -urN iptables-1.2.8/ip6tables-restore.c iptables-1.2.9/ip6tables-restore.c
--- iptables-1.2.8/ip6tables-restore.c	2003-03-05 08:46:15.000000000 +0100
+++ iptables-1.2.9/ip6tables-restore.c	2003-05-03 20:52:13.000000000 +0200
@@ -7,7 +7,7 @@
  * 	Rusty Russell <rusty@linuxcare.com.au>
  * This code is distributed under the terms of GNU GPL v2
  *
- * $Id: ip6tables-restore.c,v 1.11 2003/03/05 07:46:15 laforge Exp $
+ * $Id: ip6tables-restore.c,v 1.12 2003/05/02 15:30:11 laforge Exp $
  */
 
 #include <getopt.h>
@@ -102,7 +102,7 @@
 
 int main(int argc, char *argv[])
 {
-	ip6tc_handle_t handle;
+	ip6tc_handle_t handle = NULL;
 	char buffer[10240];
 	int c;
 	char curtable[IP6T_TABLE_MAXNAMELEN + 1];
@@ -183,6 +183,9 @@
 			}
 			strncpy(curtable, table, IP6T_TABLE_MAXNAMELEN);
 
+			if (handle)
+				ip6tc_free(&handle);
+
 			handle = create_handle(table, modprobe);
 			if (noflush == 0) {
 				DEBUGP("Cleaning all chains of table '%s'\n",
diff -urN iptables-1.2.8/ip6tables-save.c iptables-1.2.9/ip6tables-save.c
--- iptables-1.2.8/ip6tables-save.c	2002-08-14 13:40:41.000000000 +0200
+++ iptables-1.2.9/ip6tables-save.c	2003-05-03 20:52:13.000000000 +0200
@@ -305,6 +305,8 @@
 		exit_error(OTHER_PROBLEM, "Binary NYI\n");
 	}
 
+	ip6tc_free(&h);
+
 	return 1;
 }
 
diff -urN iptables-1.2.8/ip6tables.8 iptables-1.2.9/ip6tables.8
--- iptables-1.2.8/ip6tables.8	2002-08-07 11:56:14.000000000 +0200
+++ iptables-1.2.9/ip6tables.8	2003-06-30 18:16:54.000000000 +0200
@@ -27,7 +27,7 @@
 .SH NAME
 ip6tables \- IPv6 packet filter administration
 .SH SYNOPSIS
-.BR "ip6tables [-t table] -[ADC] " "chain rule-specification [options]"
+.BR "ip6tables [-t table] -[AD] " "chain rule-specification [options]"
 .br
 .BR "ip6tables [-t table] -I " "chain [rulenum] rule-specification [options]"
 .br
@@ -93,8 +93,9 @@
 that table if it is not already there.
 
 The tables are as follows:
-.TP
-.B "filter"
+.RS
+.TP .4i
+.BR "filter" :
 This is the default table (if no -t option is passed).  It contains
 the built-in chains
 .B INPUT
@@ -104,7 +105,7 @@
 .B OUTPUT
 (for locally-generated packets).
 .TP
-.B "mangle"
+.BR "mangle" :
 This table is used for specialized packet alteration.  Until kernel
 2.4.17 it had two built-in chains:
 .B PREROUTING
@@ -118,6 +119,7 @@
 (for altering packets being routed through the box), and
 .B POSTROUTING
 (for altering packets as they are about to go out).
+.RE
 .SH OPTIONS
 The options that are recognized by
 .B ip6tables
@@ -157,10 +159,10 @@
 .BR "-L, --list " "[\fIchain\fP]"
 List all rules in the selected chain.  If no chain is selected, all
 chains are listed.  As every other iptables command, it applies to the
-specified table (filter is the default), so NAT rules get listed by
-.br
- iptables -t nat -n -L
-.br
+specified table (filter is the default), so mangle rules get listed by
+.nf
+ ip6tables -t mangle -n -L
+.fi
 Please note that it is often used with the
 .B -n
 option, in order to avoid long reverse DNS lookups.
@@ -169,9 +171,9 @@
 (zero) option as well, in which case the chain(s) will be atomically
 listed and zeroed.  The exact output is affected by the other
 arguments given. The exact rules are suppressed until you use
-.br
+.nf
  ip6tables -L -v
-.br
+.fi
 .TP
 .BR "-F, --flush " "[\fIchain\fP]"
 Flush the selected chain (all the chains in the table if none is given).
@@ -398,14 +400,14 @@
 set.  Flags are: 
 .BR "SYN ACK FIN RST URG PSH ALL NONE" .
 Hence the command
-.br
+.nf
  ip6tables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN
-.br
+.fi
 will only match packets with the SYN flag set, and the ACK, FIN and
 RST flags unset.
 .TP
 .B "[!] --syn"
-Only match TCP packets with the SYN bit set and the ACK and FIN bits
+Only match TCP packets with the SYN bit set and the ACK and RST bits
 cleared.  Such packets are used to request TCP connection initiation;
 for example, blocking such packets coming in an interface will prevent
 incoming TCP connections, but outgoing TCP connections will be
@@ -438,9 +440,9 @@
 .BR "--icmpv6-type " "[!] \fItypename\fP"
 This allows specification of the ICMP type, which can be a numeric
 IPv6-ICMP type, or one of the IPv6-ICMP type names shown by the command
-.br
+.nf
  ip6tables -p ipv6-icmp -h
-.br
+.fi
 .SS mac
 .TP
 .BR "--mac-source " "[!] \fIaddress\fP"
@@ -607,15 +609,17 @@
 returned:
 .TP
 .BI "--reject-with " "type"
-The type given can be 
-.BR icmp6-no-route ,
-.BR no-route ,
-.BR icmp6-adm-prohibited ,
-.BR adm-prohibited ,
-.BR icmp6-addr-unreachable ,
-.BR addr-unreach ,
-.BR icmp6-port-unreachable ,
-.BR port-unreach ,
+The type given can be
+.nf
+.B " icmp6-no-route"
+.B " no-route"
+.B " icmp6-adm-prohibited"
+.B " adm-prohibited"
+.B " icmp6-addr-unreachable"
+.B " addr-unreach"
+.B " icmp6-port-unreachable"
+.B " port-unreach"
+.fi
 which return the appropriate IPv6-ICMP error message (\fBport-unreach\fP is
 the default). Finally, the option
 .B tcp-reset
@@ -751,7 +755,8 @@
 .B OUTPUT
 are only traversed for packets coming into the local host and
 originating from the local host respectively.  Hence every packet only
-passes through one of the three chains; previously a forwarded packet
+passes through one of the three chains (except loopback traffic, which
+involves both INPUT and OUTPUT chains); previously a forwarded packet
 would pass through all three.
 .PP
 The other main difference is that 
@@ -805,12 +810,11 @@
 .PP
 Harald Welte wrote the ULOG target, TTL match+target and libipulog.
 .PP
-The Netfilter Core Team is: Marc Boucher, Jozsef Kadlecsik, James Morris,
-Harald Welte and Rusty Russell.
+The Netfilter Core Team is: Marc Boucher, Martin Josefsson, Jozsef Kadlecsik,
+James Morris, Harald Welte and Rusty Russell.
 .PP
 ip6tables man page created by Andras Kis-Szabo, based on
 iptables man page written by Herve Eychenne <rv@wallfire.org>.
-
 .\" .. and did I mention that we are incredibly cool people?
 .\" .. sexy, too ..
 .\" .. witty, charming, powerful ..
diff -urN iptables-1.2.8/ip6tables.c iptables-1.2.9/ip6tables.c
--- iptables-1.2.8/ip6tables.c	2003-03-05 08:46:15.000000000 +0100
+++ iptables-1.2.9/ip6tables.c	2003-06-30 18:16:54.000000000 +0200
@@ -578,10 +578,13 @@
 static char *
 mask_to_numeric(const struct in6_addr *addrp)
 {
-	static char buf[20];
+	static char buf[50+2];
 	int l = ipv6_prefix_length(addrp);
-	if (l == -1)
-		return addr_to_numeric(addrp);
+	if (l == -1) {
+		strcpy(buf, "/");
+		strcat(buf, addr_to_numeric(addrp));
+		return buf;
+	}
 	sprintf(buf, "/%d", l);
 	return buf;
 }
diff -urN iptables-1.2.8/iptables-restore.c iptables-1.2.9/iptables-restore.c
--- iptables-1.2.8/iptables-restore.c	2003-03-06 12:56:31.000000000 +0100
+++ iptables-1.2.9/iptables-restore.c	2003-05-03 20:52:13.000000000 +0200
@@ -4,7 +4,7 @@
  *
  * This code is distributed under the terms of GNU GPL v2
  *
- * $Id: iptables-restore.c,v 1.25 2003/03/06 11:56:31 laforge Exp $
+ * $Id: iptables-restore.c,v 1.26 2003/05/02 15:30:11 laforge Exp $
  */
 
 #include <getopt.h>
@@ -99,7 +99,7 @@
 
 int main(int argc, char *argv[])
 {
-	iptc_handle_t handle;
+	iptc_handle_t handle = NULL;
 	char buffer[10240];
 	int c;
 	char curtable[IPT_TABLE_MAXNAMELEN + 1];
@@ -180,6 +180,9 @@
 			}
 			strncpy(curtable, table, IPT_TABLE_MAXNAMELEN);
 
+			if (handle)
+				iptc_free(&handle);
+
 			handle = create_handle(table, modprobe);
 			if (noflush == 0) {
 				DEBUGP("Cleaning all chains of table '%s'\n",
diff -urN iptables-1.2.8/iptables-save.c iptables-1.2.9/iptables-save.c
--- iptables-1.2.8/iptables-save.c	2002-08-07 11:07:41.000000000 +0200
+++ iptables-1.2.9/iptables-save.c	2003-05-03 20:52:13.000000000 +0200
@@ -304,6 +304,8 @@
 		exit_error(OTHER_PROBLEM, "Binary NYI\n");
 	}
 
+	iptc_free(&h);
+
 	return 1;
 }
 
diff -urN iptables-1.2.8/iptables.8 iptables-1.2.9/iptables.8
--- iptables-1.2.8/iptables.8	2003-03-03 23:23:22.000000000 +0100
+++ iptables-1.2.9/iptables.8	2003-06-30 18:16:54.000000000 +0200
@@ -25,7 +25,7 @@
 .SH NAME
 iptables \- administration tool for IPv4 packet filtering and NAT
 .SH SYNOPSIS
-.BR "iptables [-t table] -[ADC] " "chain rule-specification [options]"
+.BR "iptables [-t table] -[AD] " "chain rule-specification [options]"
 .br
 .BR "iptables [-t table] -I " "chain [rulenum] rule-specification [options]"
 .br
@@ -91,8 +91,9 @@
 that table if it is not already there.
 
 The tables are as follows:
-.TP
-.B "filter"
+.RS
+.TP .4i
+.BR "filter" :
 This is the default table (if no -t option is passed).  It contains
 the built-in chains
 .B INPUT
@@ -102,7 +103,7 @@
 .B OUTPUT
 (for locally-generated packets).
 .TP
-.B "nat"
+.BR "nat" :
 This table is consulted when a packet that creates a new
 connection is encountered.  It consists of three built-ins:
 .B PREROUTING
@@ -112,7 +113,7 @@
 .B POSTROUTING
 (for altering packets as they are about to go out).
 .TP
-.B "mangle"
+.BR "mangle" :
 This table is used for specialized packet alteration.  Until kernel
 2.4.17 it had two built-in chains:
 .B PREROUTING
@@ -126,6 +127,7 @@
 (for altering packets being routed through the box), and
 .B POSTROUTING
 (for altering packets as they are about to go out).
+.RE
 .SH OPTIONS
 The options that are recognized by
 .B iptables
@@ -166,9 +168,9 @@
 List all rules in the selected chain.  If no chain is selected, all
 chains are listed.  As every other iptables command, it applies to the
 specified table (filter is the default), so NAT rules get listed by
-.br
+.nf
  iptables -t nat -n -L
-.br
+.fi
 Please note that it is often used with the
 .B -n
 option, in order to avoid long reverse DNS lookups.
@@ -177,9 +179,9 @@
 (zero) option as well, in which case the chain(s) will be atomically
 listed and zeroed.  The exact output is affected by the other
 arguments given. The exact rules are suppressed until you use
-.br
+.nf
  iptables -L -v
-.br
+.fi
 .TP
 .BR "-F, --flush " "[\fIchain\fP]"
 Flush the selected chain (all the chains in the table if none is given).
@@ -450,12 +452,13 @@
 .TP
 .BI "--helper " "string"
 Matches packets related to the specified conntrack-helper.
-.TP
+.RS
+.PP
 string can be "ftp" for packets related to a ftp-session on default port.
 For other ports append -portnr to the value, ie. "ftp-2121".
-.br
+.PP
 Same rules apply for other conntrack-helpers.
-.br
+.RE
 .SS icmp
 This extension is loaded if `--protocol icmp' is specified.  It
 provides the following option:
@@ -463,9 +466,9 @@
 .BR "--icmp-type " "[!] \fItypename\fP"
 This allows specification of the ICMP type, which can be a numeric
 ICMP type, or one of the ICMP type names shown by the command
-.br
+.nf
  iptables -p icmp -h
-.br
+.fi
 .SS length
 This module matches the length of a packet against a specific value
 or range of values.
@@ -557,8 +560,7 @@
 supporting this feature)
 .SS physdev
 This module matches on the bridge port input and output devices enslaved
-to a bridge device. This is only useful if the input device or output device
-is a bridge device. This module is a part of the infrastructure that enables
+to a bridge device. This module is a part of the infrastructure that enables
 a transparent bridging IP firewall and is only useful for kernel versions
 above version 2.5.44.
 .TP
@@ -570,7 +572,8 @@
 and
 .B PREROUTING
 chains). If the interface name ends in a "+", then any
-interface which begins with this name will match.
+interface which begins with this name will match. If the packet didn't arrive
+through a bridge device, this packet won't match this option, unless '!' is used.
 .TP
 .B --physdev-out name
 Name of a bridge port via which a packet is going to be sent (for packets
@@ -585,7 +588,19 @@
 .B OUTPUT
 chains one cannot match on the bridge output port, however one can in the
 .B "filter OUTPUT"
-chain.
+chain. If the packet won't leave by a bridge device or it is yet unknown what
+the output device will be, then the packet won't match this option, unless
+'!' is used.
+.TP
+.B --physdev-is-in
+Matches if the packet has entered through a bridge interface.
+.TP
+.B --physdev-is-out
+Matches if the packet will leave through a bridge interface.
+.TP
+.B --physdev-is-bridged
+Matches if the packet is being bridged and therefore is not being routed.
+This is only useful in the FORWARD and POSTROUTING chains.
 .SS pkttype
 This module matches the link-layer packet type.
 .TP
@@ -598,7 +613,9 @@
 Where state is a comma separated list of the connection states to
 match.  Possible states are
 .B INVALID
-meaning that the packet is associated with no known connection,
+meaning that the packet could not be identified for some reason which
+includes running out of memory and ICMP errors which don't correspond to any
+known connection,
 .B ESTABLISHED
 meaning that the packet is associated with a connection which has seen
 packets in both directions,
@@ -638,9 +655,9 @@
 set.  Flags are:
 .BR "SYN ACK FIN RST URG PSH ALL NONE" .
 Hence the command
-.br
+.nf
  iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN
-.br
+.fi
 will only match packets with the SYN flag set, and the ACK, FIN and
 RST flags unset.
 .TP
@@ -718,7 +735,8 @@
 .BR "-p udp" ).
 If no port range is specified, then the destination port will never be
 modified.
-.TP
+.RS
+.PP
 You can add several --to-destination options.  If you specify more
 than one destination address, either via an address range or multiple
 --to-destination options, a simple round-robin (one after another in
@@ -848,12 +866,15 @@
 .TP
 .BI "--reject-with " "type"
 The type given can be
-.BR icmp-net-unreachable ,
-.BR icmp-host-unreachable ,
-.BR icmp-port-unreachable ,
-.BR icmp-proto-unreachable ,
-.BR "icmp-net-prohibited or"
-.BR icmp-host-prohibited ,
+.nf
+.B " icmp-net-unreachable"
+.B " icmp-host-unreachable"
+.B " icmp-port-unreachable"
+.B " icmp-proto-unreachable"
+.B " icmp-net-prohibited"
+.B " icmp-host-prohibited or"
+.B " icmp-admin-prohibited (*)"
+.fi
 which return the appropriate ICMP error message (\fBport-unreachable\fP is
 the default).  The option
 .B tcp-reset
@@ -862,6 +883,8 @@
 .I ident
 (113/tcp) probes which frequently occur when sending mail to broken mail
 hosts (which won't accept your mail otherwise).
+.TP
+(*) Using icmp-admin-prohibited with kernels that do not support it will result in a plain DROP instead of REJECT
 .SS SNAT
 This target is only valid in the
 .B nat
@@ -883,7 +906,8 @@
 mapped to other ports below 512: those between 512 and 1023 inclusive
 will be mapped to ports below 1024, and other ports will be mapped to
 1024 or above. Where possible, no port alteration will occur.
-.TP
+.RS
+.PP
 You can add several --to-source options.  If you specify more
 than one source address, either via an address range or multiple
 --to-source options, a simple round-robin (one after another in
@@ -900,19 +924,25 @@
 problem are that everything works fine from your Linux
 firewall/router, but machines behind it can never exchange large
 packets:
-.br
- 1) Web browsers connect, then hang with no data received.
-.br
- 2) Small mail works fine, but large emails hang.
-.br
- 3) ssh works fine, but scp hangs after initial handshaking.
-.br
+.PD 0
+.RS 0.1i
+.TP 0.3i
+1)
+Web browsers connect, then hang with no data received.
+.TP
+2)
+Small mail works fine, but large emails hang.
+.TP
+3)
+ssh works fine, but scp hangs after initial handshaking.
+.RE
+.PD
 Workaround: activate this option and add a rule to your firewall
 configuration like:
-.br
+.nf
  iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN \\
-.br
              -j TCPMSS --clamp-mss-to-pmtu
+.fi
 .TP
 .BI "--set-mss " "value"
 Explicitly set MSS option to specified value.
@@ -929,9 +959,9 @@
 .TP
 .BI "--set-tos " "tos"
 You can use a numeric TOS values, or use
-.br
+.nf
  iptables -j TOS -h
-.br
+.fi
 to see the list of valid TOS names.
 .SS ULOG
 This target provides userspace logging of matching packets.  When this
@@ -979,7 +1009,8 @@
 .B OUTPUT
 are only traversed for packets coming into the local host and
 originating from the local host respectively.  Hence every packet only
-passes through one of the three chains; previously a forwarded packet
+passes through one of the three chains (except loopback traffic, which
+involves both INPUT and OUTPUT chains); previously a forwarded packet
 would pass through all three.
 .PP
 The other main difference is that
@@ -996,13 +1027,11 @@
 optional extension modules.  This should simplify much of the previous
 confusion over the combination of IP masquerading and packet filtering
 seen previously.  So the following options are handled differently:
-.br
+.nf
  -j MASQ
-.br
  -M -S
-.br
  -M -L
-.br
+.fi
 There are several other changes in iptables.
 .SH SEE ALSO
 .BR iptables-save (8),
@@ -1033,11 +1062,10 @@
 .PP
 Harald Welte wrote the ULOG target, TTL, DSCP, ECN matches and targets.
 .PP
-The Netfilter Core Team is: Marc Boucher, Jozsef Kadlecsik, James Morris,
-Harald Welte and Rusty Russell.
+The Netfilter Core Team is: Marc Boucher, Martin Josefsson, Jozsef Kadlecsik, 
+James Morris, Harald Welte and Rusty Russell.
 .PP
 Man page written by Herve Eychenne <rv@wallfire.org>.
-
 .\" .. and did I mention that we are incredibly cool people?
 .\" .. sexy, too ..
 .\" .. witty, charming, powerful ..
diff -urN iptables-1.2.8/iptables.c iptables-1.2.9/iptables.c
--- iptables-1.2.8/iptables.c	2003-03-31 14:11:55.000000000 +0200
+++ iptables-1.2.9/iptables.c	2003-06-15 00:39:35.000000000 +0200
@@ -337,7 +337,7 @@
 exit_tryhelp(int status)
 {
 	if (line != -1)
-		fprintf(stderr, "Error occured at line: %d\n", line);
+		fprintf(stderr, "Error occurred at line: %d\n", line);
 	fprintf(stderr, "Try `%s -h' or '%s --help' for more information.\n",
 			program_name, program_name );
 	exit(status);
@@ -1254,14 +1254,14 @@
 
 	fputc(fw->ip.invflags & IPT_INV_DSTIP ? '!' : ' ', stdout);
 	if (fw->ip.dmsk.s_addr == 0L && !(format & FMT_NUMERIC))
-		printf(FMT("%-19s","-> %s"), "anywhere");
+		printf(FMT("%-19s ","-> %s"), "anywhere");
 	else {
 		if (format & FMT_NUMERIC)
 			sprintf(buf, "%s", addr_to_dotted(&(fw->ip.dst)));
 		else
 			sprintf(buf, "%s", addr_to_anyname(&(fw->ip.dst)));
 		strcat(buf, mask_to_dotted(&(fw->ip.dmsk)));
-		printf(FMT("%-19s","-> %s"), buf);
+		printf(FMT("%-19s ","-> %s"), buf);
 	}
 
 	if (format & FMT_NOTABLE)
diff -urN iptables-1.2.8/libiptc/libip4tc.c iptables-1.2.9/libiptc/libip4tc.c
--- iptables-1.2.8/libiptc/libip4tc.c	2002-06-12 21:22:29.000000000 +0200
+++ iptables-1.2.9/libiptc/libip4tc.c	2003-10-07 20:54:30.000000000 +0200
@@ -91,6 +91,7 @@
 #define TC_SET_POLICY		iptc_set_policy
 #define TC_GET_RAW_SOCKET	iptc_get_raw_socket
 #define TC_INIT			iptc_init
+#define TC_FREE			iptc_free
 #define TC_COMMIT		iptc_commit
 #define TC_STRERROR		iptc_strerror
 
@@ -435,6 +436,19 @@
 			assert(h->info.hook_entry[NF_IP_POST_ROUTING] == n);
 			user_offset = h->info.hook_entry[NF_IP_POST_ROUTING];
 		}
+	} else if (strcmp(h->info.name, "raw") == 0) {
+		assert(h->info.valid_hooks
+		       == (1 << NF_IP_PRE_ROUTING
+			   | 1 << NF_IP_LOCAL_OUT));
+
+		/* Hooks should be first three */
+		assert(h->info.hook_entry[NF_IP_PRE_ROUTING] == 0);
+
+		n = get_chain_end(h, n);
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP_LOCAL_OUT] == n);
+
+		user_offset = h->info.hook_entry[NF_IP_LOCAL_OUT];
 
 #ifdef NF_IP_DROPPING
 	} else if (strcmp(h->info.name, "drop") == 0) {
diff -urN iptables-1.2.8/libiptc/libip6tc.c iptables-1.2.9/libiptc/libip6tc.c
--- iptables-1.2.8/libiptc/libip6tc.c	2002-02-14 00:13:23.000000000 +0100
+++ iptables-1.2.9/libiptc/libip6tc.c	2003-10-08 00:11:20.000000000 +0200
@@ -86,6 +86,7 @@
 #define TC_SET_POLICY		ip6tc_set_policy
 #define TC_GET_RAW_SOCKET	ip6tc_get_raw_socket
 #define TC_INIT			ip6tc_init
+#define TC_FREE			ip6tc_free
 #define TC_COMMIT		ip6tc_commit
 #define TC_STRERROR		ip6tc_strerror
 
@@ -110,7 +111,7 @@
 #include "libiptc.c"
 
 #define BIT6(a, l) \
- (((a->in6_u.u6_addr32[(l) / 32]) >> ((l) & 31)) & 1)
+ ((ntohl(a->in6_u.u6_addr32[(l) / 32]) >> (31 - ((l) & 31))) & 1)
 
 int
 ipv6_prefix_length(const struct in6_addr *a)
@@ -381,6 +382,19 @@
 			assert(h->info.hook_entry[NF_IP6_POST_ROUTING] == n);
 			user_offset = h->info.hook_entry[NF_IP6_POST_ROUTING];
 		}
+	} else if (strcmp(h->info.name, "raw") == 0) {
+		assert(h->info.valid_hooks
+		       == (1 << NF_IP6_PRE_ROUTING
+			   | 1 << NF_IP6_LOCAL_OUT));
+
+		/* Hooks should be first three */
+		assert(h->info.hook_entry[NF_IP6_PRE_ROUTING] == 0);
+
+		n = get_chain_end(h, n);
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
+
+		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
 	} else {
                 fprintf(stderr, "Unknown table `%s'\n", h->info.name);
 		abort();
diff -urN iptables-1.2.8/libiptc/libip6tc.c.orig iptables-1.2.9/libiptc/libip6tc.c.orig
--- iptables-1.2.8/libiptc/libip6tc.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/libiptc/libip6tc.c.orig	2003-06-24 20:28:36.000000000 +0200
@@ -0,0 +1,449 @@
+/* Library which manipulates firewall rules.  Version 0.1. */
+
+/* Architecture of firewall rules is as follows:
+ *
+ * Chains go INPUT, FORWARD, OUTPUT then user chains.
+ * Each user chain starts with an ERROR node.
+ * Every chain ends with an unconditional jump: a RETURN for user chains,
+ * and a POLICY for built-ins.
+ */
+
+/* (C)1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
+   COPYING for details). */
+
+#include <assert.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <arpa/inet.h>
+
+#ifdef DEBUG_CONNTRACK
+#define inline
+#endif
+
+#if !defined(__GLIBC__) || (__GLIBC__ < 2)
+typedef unsigned int socklen_t;
+#endif
+
+#include "libiptc/libip6tc.h"
+
+#define HOOK_PRE_ROUTING	NF_IP6_PRE_ROUTING
+#define HOOK_LOCAL_IN		NF_IP6_LOCAL_IN
+#define HOOK_FORWARD		NF_IP6_FORWARD
+#define HOOK_LOCAL_OUT		NF_IP6_LOCAL_OUT
+#define HOOK_POST_ROUTING	NF_IP6_POST_ROUTING
+
+#define STRUCT_ENTRY_TARGET	struct ip6t_entry_target
+#define STRUCT_ENTRY		struct ip6t_entry
+#define STRUCT_ENTRY_MATCH	struct ip6t_entry_match
+#define STRUCT_GETINFO		struct ip6t_getinfo
+#define STRUCT_GET_ENTRIES	struct ip6t_get_entries
+#define STRUCT_COUNTERS		struct ip6t_counters
+#define STRUCT_COUNTERS_INFO	struct ip6t_counters_info
+#define STRUCT_STANDARD_TARGET	struct ip6t_standard_target
+#define STRUCT_REPLACE		struct ip6t_replace
+
+#define STRUCT_TC_HANDLE	struct ip6tc_handle
+#define TC_HANDLE_T		ip6tc_handle_t
+
+#define ENTRY_ITERATE		IP6T_ENTRY_ITERATE
+#define TABLE_MAXNAMELEN	IP6T_TABLE_MAXNAMELEN
+#define FUNCTION_MAXNAMELEN	IP6T_FUNCTION_MAXNAMELEN
+
+#define GET_TARGET		ip6t_get_target
+
+#define ERROR_TARGET		IP6T_ERROR_TARGET
+#define NUMHOOKS		NF_IP6_NUMHOOKS
+
+#define IPT_CHAINLABEL		ip6t_chainlabel
+
+#define TC_DUMP_ENTRIES		dump_entries6
+#define TC_IS_CHAIN		ip6tc_is_chain
+#define TC_FIRST_CHAIN		ip6tc_first_chain
+#define TC_NEXT_CHAIN		ip6tc_next_chain
+#define TC_FIRST_RULE		ip6tc_first_rule
+#define TC_NEXT_RULE		ip6tc_next_rule
+#define TC_GET_TARGET		ip6tc_get_target
+#define TC_BUILTIN		ip6tc_builtin
+#define TC_GET_POLICY		ip6tc_get_policy
+#define TC_INSERT_ENTRY		ip6tc_insert_entry
+#define TC_REPLACE_ENTRY	ip6tc_replace_entry
+#define TC_APPEND_ENTRY		ip6tc_append_entry
+#define TC_DELETE_ENTRY		ip6tc_delete_entry
+#define TC_DELETE_NUM_ENTRY	ip6tc_delete_num_entry
+#define TC_CHECK_PACKET		ip6tc_check_packet
+#define TC_FLUSH_ENTRIES	ip6tc_flush_entries
+#define TC_ZERO_ENTRIES		ip6tc_zero_entries
+#define TC_ZERO_COUNTER		ip6tc_zero_counter
+#define TC_READ_COUNTER		ip6tc_read_counter
+#define TC_SET_COUNTER		ip6tc_set_counter
+#define TC_CREATE_CHAIN		ip6tc_create_chain
+#define TC_GET_REFERENCES	ip6tc_get_references
+#define TC_DELETE_CHAIN		ip6tc_delete_chain
+#define TC_RENAME_CHAIN		ip6tc_rename_chain
+#define TC_SET_POLICY		ip6tc_set_policy
+#define TC_GET_RAW_SOCKET	ip6tc_get_raw_socket
+#define TC_INIT			ip6tc_init
+#define TC_FREE			ip6tc_free
+#define TC_COMMIT		ip6tc_commit
+#define TC_STRERROR		ip6tc_strerror
+
+#define TC_AF			AF_INET6
+#define TC_IPPROTO		IPPROTO_IPV6
+
+#define SO_SET_REPLACE		IP6T_SO_SET_REPLACE
+#define SO_SET_ADD_COUNTERS	IP6T_SO_SET_ADD_COUNTERS
+#define SO_GET_INFO		IP6T_SO_GET_INFO
+#define SO_GET_ENTRIES		IP6T_SO_GET_ENTRIES
+#define SO_GET_VERSION		IP6T_SO_GET_VERSION
+
+#define STANDARD_TARGET		IP6T_STANDARD_TARGET
+#define LABEL_RETURN		IP6TC_LABEL_RETURN
+#define LABEL_ACCEPT		IP6TC_LABEL_ACCEPT
+#define LABEL_DROP		IP6TC_LABEL_DROP
+#define LABEL_QUEUE		IP6TC_LABEL_QUEUE
+
+#define ALIGN			IP6T_ALIGN
+#define RETURN			IP6T_RETURN
+
+#include "libiptc.c"
+
+#define BIT6(a, l) \
+ ((ntohl(a->in6_u.u6_addr32[(l) / 32]) >> (31 - ((l) & 31))) & 1)
+
+int
+ipv6_prefix_length(const struct in6_addr *a)
+{
+	int l, i;
+	for (l = 0; l < 128; l++) {
+		if (BIT6(a, l) == 0)
+			break;
+	}
+	for (i = l + 1; i < 128; i++) {
+		if (BIT6(a, i) == 1)
+			return -1;
+	}
+	return l;
+}
+
+static int
+dump_entry(struct ip6t_entry *e, const ip6tc_handle_t handle)
+{
+	size_t i;
+	char buf[40];
+	int len;
+	struct ip6t_entry_target *t;
+	
+	printf("Entry %u (%lu):\n", entry2index(handle, e),
+	       entry2offset(handle, e));
+	puts("SRC IP: ");
+	inet_ntop(AF_INET6, &e->ipv6.src, buf, sizeof buf);
+	puts(buf);
+	putchar('/');
+	len = ipv6_prefix_length(&e->ipv6.smsk);
+	if (len != -1)
+		printf("%d", len);
+	else {
+		inet_ntop(AF_INET6, &e->ipv6.smsk, buf, sizeof buf);
+		puts(buf);
+	}
+	putchar('\n');
+	
+	puts("DST IP: ");
+	inet_ntop(AF_INET6, &e->ipv6.dst, buf, sizeof buf);
+	puts(buf);
+	putchar('/');
+	len = ipv6_prefix_length(&e->ipv6.dmsk);
+	if (len != -1)
+		printf("%d", len);
+	else {
+		inet_ntop(AF_INET6, &e->ipv6.dmsk, buf, sizeof buf);
+		puts(buf);
+	}
+	putchar('\n');
+	
+	printf("Interface: `%s'/", e->ipv6.iniface);
+	for (i = 0; i < IFNAMSIZ; i++)
+		printf("%c", e->ipv6.iniface_mask[i] ? 'X' : '.');
+	printf("to `%s'/", e->ipv6.outiface);
+	for (i = 0; i < IFNAMSIZ; i++)
+		printf("%c", e->ipv6.outiface_mask[i] ? 'X' : '.');
+	printf("\nProtocol: %u\n", e->ipv6.proto);
+	if (e->ipv6.flags & IP6T_F_TOS)
+		printf("TOS: %u\n", e->ipv6.tos);
+	printf("Flags: %02X\n", e->ipv6.flags);
+	printf("Invflags: %02X\n", e->ipv6.invflags);
+	printf("Counters: %llu packets, %llu bytes\n",
+	       e->counters.pcnt, e->counters.bcnt);
+	printf("Cache: %08X ", e->nfcache);
+	if (e->nfcache & NFC_ALTERED) printf("ALTERED ");
+	if (e->nfcache & NFC_UNKNOWN) printf("UNKNOWN ");
+	if (e->nfcache & NFC_IP6_SRC) printf("IP6_SRC ");
+	if (e->nfcache & NFC_IP6_DST) printf("IP6_DST ");
+	if (e->nfcache & NFC_IP6_IF_IN) printf("IP6_IF_IN ");
+	if (e->nfcache & NFC_IP6_IF_OUT) printf("IP6_IF_OUT ");
+	if (e->nfcache & NFC_IP6_TOS) printf("IP6_TOS ");
+	if (e->nfcache & NFC_IP6_PROTO) printf("IP6_PROTO ");
+	if (e->nfcache & NFC_IP6_OPTIONS) printf("IP6_OPTIONS ");
+	if (e->nfcache & NFC_IP6_TCPFLAGS) printf("IP6_TCPFLAGS ");
+	if (e->nfcache & NFC_IP6_SRC_PT) printf("IP6_SRC_PT ");
+	if (e->nfcache & NFC_IP6_DST_PT) printf("IP6_DST_PT ");
+	if (e->nfcache & NFC_IP6_PROTO_UNKNOWN) printf("IP6_PROTO_UNKNOWN ");
+	printf("\n");
+	
+	IP6T_MATCH_ITERATE(e, print_match);
+
+	t = ip6t_get_target(e);
+	printf("Target name: `%s' [%u]\n", t->u.user.name, t->u.target_size);
+	if (strcmp(t->u.user.name, IP6T_STANDARD_TARGET) == 0) {
+		int pos = *(int *)t->data;
+		if (pos < 0)
+			printf("verdict=%s\n",
+			       pos == -NF_ACCEPT-1 ? "NF_ACCEPT"
+			       : pos == -NF_DROP-1 ? "NF_DROP"
+			       : pos == IP6T_RETURN ? "RETURN"
+			       : "UNKNOWN");
+		else
+			printf("verdict=%u\n", pos);
+	} else if (strcmp(t->u.user.name, IP6T_ERROR_TARGET) == 0)
+		printf("error=`%s'\n", t->data);
+
+	printf("\n");
+	return 0;
+}
+
+static int
+is_same(const STRUCT_ENTRY *a, const STRUCT_ENTRY *b,
+	unsigned char *matchmask)
+{
+	unsigned int i;
+	STRUCT_ENTRY_TARGET *ta, *tb;
+	unsigned char *mptr;
+
+	/* Always compare head structures: ignore mask here. */
+	if (memcmp(&a->ipv6.src, &b->ipv6.src, sizeof(struct in6_addr))
+	    || memcmp(&a->ipv6.dst, &b->ipv6.dst, sizeof(struct in6_addr))
+	    || memcmp(&a->ipv6.smsk, &b->ipv6.smsk, sizeof(struct in6_addr))
+	    || memcmp(&a->ipv6.dmsk, &b->ipv6.dmsk, sizeof(struct in6_addr))
+	    || a->ipv6.proto != b->ipv6.proto
+	    || a->ipv6.tos != b->ipv6.tos
+	    || a->ipv6.flags != b->ipv6.flags
+	    || a->ipv6.invflags != b->ipv6.invflags)
+		return 0;
+
+	for (i = 0; i < IFNAMSIZ; i++) {
+		if (a->ipv6.iniface_mask[i] != b->ipv6.iniface_mask[i])
+			return 0;
+		if ((a->ipv6.iniface[i] & a->ipv6.iniface_mask[i])
+		    != (b->ipv6.iniface[i] & b->ipv6.iniface_mask[i]))
+			return 0;
+		if (a->ipv6.outiface_mask[i] != b->ipv6.outiface_mask[i])
+			return 0;
+		if ((a->ipv6.outiface[i] & a->ipv6.outiface_mask[i])
+		    != (b->ipv6.outiface[i] & b->ipv6.outiface_mask[i]))
+			return 0;
+	}
+
+	if (a->nfcache != b->nfcache
+	    || a->target_offset != b->target_offset
+	    || a->next_offset != b->next_offset)
+		return 0;
+
+	mptr = matchmask + sizeof(STRUCT_ENTRY);
+	if (IP6T_MATCH_ITERATE(a, match_different, a->elems, b->elems, &mptr))
+		return 0;
+
+	ta = GET_TARGET((STRUCT_ENTRY *)a);
+	tb = GET_TARGET((STRUCT_ENTRY *)b);
+	if (ta->u.target_size != tb->u.target_size)
+		return 0;
+	if (strcmp(ta->u.user.name, tb->u.user.name) != 0)
+		return 0;
+	mptr += sizeof(*ta);
+
+	if (target_different(ta->data, tb->data,
+			     ta->u.target_size - sizeof(*ta), mptr))
+		return 0;
+
+	return 1;
+}
+
+/* All zeroes == unconditional rule. */
+static inline int
+unconditional(const struct ip6t_ip6 *ipv6)
+{
+	unsigned int i;
+
+	for (i = 0; i < sizeof(*ipv6); i++)
+		if (((char *)ipv6)[i])
+			break;
+
+	return (i == sizeof(*ipv6));
+}
+
+#ifdef IPTC_DEBUG
+/* Do every conceivable sanity check on the handle */
+static void
+do_check(TC_HANDLE_T h, unsigned int line)
+{
+	unsigned int i, n;
+	unsigned int user_offset; /* Offset of first user chain */
+	int was_return;
+
+	assert(h->changed == 0 || h->changed == 1);
+	if (strcmp(h->info.name, "filter") == 0) {
+		assert(h->info.valid_hooks
+		       == (1 << NF_IP6_LOCAL_IN
+			   | 1 << NF_IP6_FORWARD
+			   | 1 << NF_IP6_LOCAL_OUT));
+
+		/* Hooks should be first three */
+		assert(h->info.hook_entry[NF_IP6_LOCAL_IN] == 0);
+
+		n = get_chain_end(h, 0);
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP6_FORWARD] == n);
+
+		n = get_chain_end(h, n);
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
+
+		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
+	} else if (strcmp(h->info.name, "nat") == 0) {
+		assert((h->info.valid_hooks
+			== (1 << NF_IP6_PRE_ROUTING
+			    | 1 << NF_IP6_LOCAL_OUT
+			    | 1 << NF_IP6_POST_ROUTING)) ||
+		       (h->info.valid_hooks
+			== (1 << NF_IP6_PRE_ROUTING
+			    | 1 << NF_IP6_LOCAL_IN
+			    | 1 << NF_IP6_LOCAL_OUT
+			    | 1 << NF_IP6_POST_ROUTING)));
+
+		assert(h->info.hook_entry[NF_IP6_PRE_ROUTING] == 0);
+
+		n = get_chain_end(h, 0);
+
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP6_POST_ROUTING] == n);
+		n = get_chain_end(h, n);
+
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
+		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
+
+		if (h->info.valid_hooks & (1 << NF_IP6_LOCAL_IN)) {
+			n = get_chain_end(h, n);
+			n += get_entry(h, n)->next_offset;
+			assert(h->info.hook_entry[NF_IP6_LOCAL_IN] == n);
+			user_offset = h->info.hook_entry[NF_IP6_LOCAL_IN];
+		}
+
+	} else if (strcmp(h->info.name, "mangle") == 0) {
+		/* This code is getting ugly because linux < 2.4.18-pre6 had
+		 * two mangle hooks, linux >= 2.4.18-pre6 has five mangle hooks
+		 * */
+		assert((h->info.valid_hooks
+			== (1 << NF_IP6_PRE_ROUTING
+			    | 1 << NF_IP6_LOCAL_OUT)) ||
+		       (h->info.valid_hooks
+			== (1 << NF_IP6_PRE_ROUTING
+			    | 1 << NF_IP6_LOCAL_IN
+			    | 1 << NF_IP6_FORWARD
+			    | 1 << NF_IP6_LOCAL_OUT
+			    | 1 << NF_IP6_POST_ROUTING)));
+
+		/* Hooks should be first five */
+		assert(h->info.hook_entry[NF_IP6_PRE_ROUTING] == 0);
+
+		n = get_chain_end(h, 0);
+
+		if (h->info.valid_hooks & (1 << NF_IP6_LOCAL_IN)) {
+			n += get_entry(h, n)->next_offset;
+			assert(h->info.hook_entry[NF_IP6_LOCAL_IN] == n);
+			n = get_chain_end(h, n);
+		}
+
+		if (h->info.valid_hooks & (1 << NF_IP6_FORWARD)) {
+			n += get_entry(h, n)->next_offset;
+			assert(h->info.hook_entry[NF_IP6_FORWARD] == n);
+			n = get_chain_end(h, n);
+		}
+
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
+		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
+
+		if (h->info.valid_hooks & (1 << NF_IP6_POST_ROUTING)) {
+			n = get_chain_end(h, n);
+			n += get_entry(h, n)->next_offset;
+			assert(h->info.hook_entry[NF_IP6_POST_ROUTING] == n);
+			user_offset = h->info.hook_entry[NF_IP6_POST_ROUTING];
+		}
+	} else {
+                fprintf(stderr, "Unknown table `%s'\n", h->info.name);
+		abort();
+	}
+
+	/* User chain == end of last builtin + policy entry */
+	user_offset = get_chain_end(h, user_offset);
+	user_offset += get_entry(h, user_offset)->next_offset;
+
+	/* Overflows should be end of entry chains, and unconditional
+           policy nodes. */
+	for (i = 0; i < NUMHOOKS; i++) {
+		STRUCT_ENTRY *e;
+		STRUCT_STANDARD_TARGET *t;
+
+		if (!(h->info.valid_hooks & (1 << i)))
+			continue;
+		assert(h->info.underflow[i]
+		       == get_chain_end(h, h->info.hook_entry[i]));
+
+		e = get_entry(h, get_chain_end(h, h->info.hook_entry[i]));
+		assert(unconditional(&e->ipv6));
+		assert(e->target_offset == sizeof(*e));
+		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+		printf("target_size=%u, align=%u\n",
+			t->target.u.target_size, ALIGN(sizeof(*t)));
+		assert(t->target.u.target_size == ALIGN(sizeof(*t)));
+		assert(e->next_offset == sizeof(*e) + ALIGN(sizeof(*t)));
+
+		assert(strcmp(t->target.u.user.name, STANDARD_TARGET)==0);
+		assert(t->verdict == -NF_DROP-1 || t->verdict == -NF_ACCEPT-1);
+
+		/* Hooks and underflows must be valid entries */
+		entry2index(h, get_entry(h, h->info.hook_entry[i]));
+		entry2index(h, get_entry(h, h->info.underflow[i]));
+	}
+
+	assert(h->info.size
+	       >= h->info.num_entries * (sizeof(STRUCT_ENTRY)
+					 +sizeof(STRUCT_STANDARD_TARGET)));
+
+	assert(h->entries.size
+	       >= (h->new_number
+		   * (sizeof(STRUCT_ENTRY)
+		      + sizeof(STRUCT_STANDARD_TARGET))));
+	assert(strcmp(h->info.name, h->entries.name) == 0);
+
+	i = 0; n = 0;
+	was_return = 0;
+
+#if 0
+	/* Check all the entries. */
+	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+		      check_entry, &i, &n, user_offset, &was_return, h);
+
+	assert(i == h->new_number);
+	assert(n == h->entries.size);
+
+	/* Final entry must be error node */
+	assert(strcmp(GET_TARGET(index2entry(h, h->new_number-1))
+		      ->u.user.name,
+		      ERROR_TARGET) == 0);
+#endif
+}
+#endif /*IPTC_DEBUG*/
diff -urN iptables-1.2.8/libiptc/libiptc.c iptables-1.2.9/libiptc/libiptc.c
--- iptables-1.2.8/libiptc/libiptc.c	2002-05-29 15:08:16.000000000 +0200
+++ iptables-1.2.9/libiptc/libiptc.c	2003-07-05 22:11:11.000000000 +0200
@@ -1,4 +1,4 @@
-/* Library which manipulates firewall rules.  Version $Revision: 1.35 $ */
+/* Library which manipulates firewall rules.  Version $Revision: 1.41 $ */
 
 /* Architecture of firewall rules is as follows:
  *
@@ -8,8 +8,17 @@
  * and a POLICY for built-ins.
  */
 
-/* (C)1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
-   COPYING for details). */
+/* (C) 1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
+ * COPYING for details). 
+ * (C) 2000-2003 by the Netfilter Core Team <coreteam@netfilter.org>
+ *
+ * 2003-Jun-20: Harald Welte <laforge@netfilter.org>:
+ *	- Reimplementation of chain cache to use offsets instead of entries
+ * 2003-Jun-23: Harald Welte <laforge@netfilter.org>:
+ * 	- performance optimization, sponsored by Astaro AG (http://www.astaro.com/)
+ * 	  don't rebuild the chain cache after every operation, instead fix it
+ * 	  up after a ruleset change.  
+ */
 
 #ifndef IPT_LIB_DIR
 #define IPT_LIB_DIR "/usr/local/lib/iptables"
@@ -59,9 +68,9 @@
 {
 	char name[TABLE_MAXNAMELEN];
 	/* This is the first rule in chain. */
-	STRUCT_ENTRY *start;
+	unsigned int start_off;
 	/* Last rule in chain */
-	STRUCT_ENTRY *end;
+	unsigned int end_off;
 };
 
 STRUCT_TC_HANDLE
@@ -94,13 +103,6 @@
 static void
 set_changed(TC_HANDLE_T h)
 {
-	if (h->cache_chain_heads) {
-		free(h->cache_chain_heads);
-		h->cache_chain_heads = NULL;
-		h->cache_num_chains = 0;
-		h->cache_chain_iteration = NULL;
-		h->cache_rule_end = NULL;
-	}
 	h->changed = 1;
 }
 
@@ -171,15 +173,28 @@
 static inline unsigned long
 entry2offset(const TC_HANDLE_T h, const STRUCT_ENTRY *e)
 {
-	return (char *)e - (char *)h->entries.entrytable;
+	return (void *)e - (void *)h->entries.entrytable;
 }
 
-static unsigned long
+static inline unsigned long
 index2offset(TC_HANDLE_T h, unsigned int index)
 {
 	return entry2offset(h, index2entry(h, index));
 }
 
+static inline STRUCT_ENTRY *
+offset2entry(TC_HANDLE_T h, unsigned int offset)
+{
+	return (STRUCT_ENTRY *) ((void *)h->entries.entrytable+offset);
+}
+
+static inline unsigned int
+offset2index(const TC_HANDLE_T h, unsigned int offset)
+{
+	return entry2index(h, offset2entry(h, offset));
+}
+
+
 static const char *
 get_errorlabel(TC_HANDLE_T h, unsigned int offset)
 {
@@ -234,25 +249,32 @@
 
 	iptc_fn = TC_INIT;
 
-	if (sockfd != -1)
+	if (sockfd != -1) {
 		close(sockfd);
+		sockfd = -1;
+	}
 
+	if (strlen(tablename) >= TABLE_MAXNAMELEN) {
+		errno = EINVAL;
+		return NULL;
+	}
+	
 	sockfd = socket(TC_AF, SOCK_RAW, IPPROTO_RAW);
 	if (sockfd < 0)
 		return NULL;
 
 	s = sizeof(info);
-	if (strlen(tablename) >= TABLE_MAXNAMELEN) {
-		errno = EINVAL;
-		return NULL;
-	}
+
 	strcpy(info.name, tablename);
 	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_INFO, &info, &s) < 0)
 		return NULL;
 
 	if ((h = alloc_handle(info.name, info.size, info.num_entries))
-	    == NULL)
+	    == NULL) {
+		close(sockfd);
+		sockfd = -1;
 		return NULL;
+	}
 
 /* Too hard --RR */
 #if 0
@@ -284,6 +306,8 @@
 
 	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_ENTRIES, &h->entries,
 		       &tmp) < 0) {
+		close(sockfd);
+		sockfd = -1;
 		free(h);
 		return NULL;
 	}
@@ -292,6 +316,17 @@
 	return h;
 }
 
+void
+TC_FREE(TC_HANDLE_T *h)
+{
+	close(sockfd);
+	sockfd = -1;
+	if ((*h)->cache_chain_heads)
+		free((*h)->cache_chain_heads);
+	free(*h);
+	*h = NULL;
+}
+
 static inline int
 print_match(const STRUCT_ENTRY_MATCH *m)
 {
@@ -349,7 +384,8 @@
 	/* Last entry.  End it. */
 	if (entry2offset(h, e) + e->next_offset == h->entries.size) {
 		/* This is the ERROR node at end of the table */
-		h->cache_chain_heads[h->cache_num_chains-1].end = *prev;
+		h->cache_chain_heads[h->cache_num_chains-1].end_off = 
+			entry2offset(h, *prev);
 		return 0;
 	}
 
@@ -357,24 +393,24 @@
 	   target, or a hook entry point */
 	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) == 0) {
 		/* prev was last entry in previous chain */
-		h->cache_chain_heads[h->cache_num_chains-1].end
-			= *prev;
+		h->cache_chain_heads[h->cache_num_chains-1].end_off
+			= entry2offset(h, *prev);
 
 		strcpy(h->cache_chain_heads[h->cache_num_chains].name,
 		       (const char *)GET_TARGET(e)->data);
-		h->cache_chain_heads[h->cache_num_chains].start
-			= (void *)e + e->next_offset;
+		h->cache_chain_heads[h->cache_num_chains].start_off
+			= entry2offset(h, (void *)e + e->next_offset);
 		h->cache_num_chains++;
 	} else if ((builtin = is_hook_entry(e, h)) != 0) {
 		if (h->cache_num_chains > 0)
 			/* prev was last entry in previous chain */
-			h->cache_chain_heads[h->cache_num_chains-1].end
-				= *prev;
+			h->cache_chain_heads[h->cache_num_chains-1].end_off
+				= entry2offset(h, *prev);
 
 		strcpy(h->cache_chain_heads[h->cache_num_chains].name,
 		       h->hooknames[builtin-1]);
-		h->cache_chain_heads[h->cache_num_chains].start
-			= (void *)e;
+		h->cache_chain_heads[h->cache_num_chains].start_off
+			= entry2offset(h, (void *)e);
 		h->cache_num_chains++;
 	}
 
@@ -421,6 +457,81 @@
 	return 1;
 }
 
+static int 
+correct_cache(TC_HANDLE_T h, unsigned int offset, int delta)
+{
+	int i;		/* needs to be signed because deleting first
+			   chain can make it drop to -1 */
+
+	if (!delta)
+		return 1;
+
+	for (i = 0; i < h->cache_num_chains; i++) {
+		struct chain_cache *cc = &h->cache_chain_heads[i];
+
+		if (delta < 0) {
+			/* take care about deleted chains */
+			if (cc->start_off > offset+delta
+			    && cc->end_off < offset) {
+				/* this chain is within the deleted range,
+				 * let's remove it from the cache */
+				void *start;
+				unsigned int size;
+
+				h->cache_num_chains--;
+
+				/* no need for memmove since we are 
+				 * removing the last entry */
+				if (i >= h->cache_num_chains)
+					continue;
+
+				start = &h->cache_chain_heads[i+1];
+				size = (h->cache_num_chains-i)
+					* sizeof(struct chain_cache);
+				memmove(cc, start, size);
+
+				/* iterate over same index again, since
+				 * it is now a different chain */
+				i--;
+				continue;
+			}
+		}
+
+		if (cc->start_off > offset)
+			cc->start_off += delta;
+
+		if (cc->end_off >= offset)
+			cc->end_off += delta;
+	}
+	/* HW_FIXME: sorting might be needed, but just in case a new chain was
+	 * added */
+
+	return 1;
+}
+
+static int
+add_chain_cache(TC_HANDLE_T h, const char *name, unsigned int start_off,
+		unsigned int end_off)
+{
+	struct chain_cache *ccs = realloc(h->cache_chain_heads, 
+					  (h->new_number / 2 + 4 + 1)
+					   * sizeof(struct chain_cache));
+	struct chain_cache *newcc;
+	
+	if (!ccs)
+		return 0;
+
+	h->cache_chain_heads = ccs;
+	newcc = &h->cache_chain_heads[h->cache_num_chains];
+	h->cache_num_chains++;
+
+	strncpy(newcc->name, name, TABLE_MAXNAMELEN-1);
+	newcc->start_off = start_off;
+	newcc->end_off = end_off;
+
+	return 1;
+}
+
 /* Returns cache ptr if found, otherwise NULL. */
 static struct chain_cache *
 find_label(const char *name, TC_HANDLE_T handle)
@@ -523,11 +634,11 @@
 	}
 
 	/* Empty chain: single return/policy rule */
-	if (c->start == c->end)
+	if (c->start_off == c->end_off)
 		return NULL;
 
-	(*handle)->cache_rule_end = c->end;
-	return c->start;
+	(*handle)->cache_rule_end = offset2entry(*handle, c->end_off);
+	return offset2entry(*handle, c->start_off);
 }
 
 /* Returns NULL when rules run out. */
@@ -666,7 +777,7 @@
 	return target_name(*handle, e);
 }
 
-static int
+static inline int
 correct_verdict(STRUCT_ENTRY *e,
 		char *base,
 		unsigned int offset, int delta_offset)
@@ -767,8 +878,16 @@
 	newh->entries.size = (*handle)->entries.size + rules_size;
 	newh->hooknames = (*handle)->hooknames;
 
-	if ((*handle)->cache_chain_heads)
-		free((*handle)->cache_chain_heads);
+	newh->cache_chain_heads = (*handle)->cache_chain_heads;
+	newh->cache_num_builtins = (*handle)->cache_num_builtins;
+	newh->cache_num_chains = (*handle)->cache_num_chains;
+	newh->cache_rule_end = (*handle)->cache_rule_end;
+	newh->cache_chain_iteration = (*handle)->cache_chain_iteration;
+	if (!correct_cache(newh, offset, rules_size)) {
+		free(newh);
+		return 0;
+	}
+
 	free(*handle);
 	*handle = newh;
 
@@ -827,6 +946,10 @@
 	(*handle)->new_number -= num_rules;
 	(*handle)->entries.size -= rules_size;
 
+	/* Fix the chain cache */
+	if (!correct_cache(*handle, offset+rules_size, -(int)rules_size))
+		return 0;
+
 	return set_verdict(offset, -(int)rules_size, handle);
 }
 
@@ -884,7 +1007,7 @@
 
 		c = find_label(t->u.user.name, handle);
 		if (c)
-			return standard_map(e, entry2offset(handle, c->start));
+			return standard_map(e, c->start_off);
 	}
 
 	/* Must be a module?  If not, kernel will reject... */
@@ -924,10 +1047,10 @@
 		return 0;
 	}
 
-	chainindex = entry2index(*handle, c->start);
+	chainindex = offset2index(*handle, c->start_off);
 
 	tmp = index2entry(*handle, chainindex + rulenum);
-	if (!tmp || tmp > c->end) {
+	if (!tmp || tmp > offset2entry(*handle, c->end_off)) {
 		errno = E2BIG;
 		return 0;
 	}
@@ -964,10 +1087,10 @@
 		return 0;
 	}
 
-	chainindex = entry2index(*handle, c->start);
+	chainindex = offset2index(*handle, c->start_off);
 
 	tmp = index2entry(*handle, chainindex + rulenum);
-	if (!tmp || tmp >= c->end) {
+	if (!tmp || tmp >= offset2entry(*handle, c->end_off)) {
 		errno = E2BIG;
 		return 0;
 	}
@@ -1005,13 +1128,11 @@
 	}
 
 	if (!map_target(*handle, (STRUCT_ENTRY *)e,
-			entry2offset(*handle, c->end), &old))
+			c->end_off, &old))
 		return 0;
 
-	ret = insert_rules(1, e->next_offset, e,
-			   entry2offset(*handle, c->end),
-			   entry2index(*handle, c->end),
-			   0, handle);
+	ret = insert_rules(1, e->next_offset, e, c->end_off, 
+			   offset2index(*handle, c->end_off), 0, handle);
 	unmap_target((STRUCT_ENTRY *)e, &old);
 	return ret;
 }
@@ -1085,8 +1206,7 @@
 		return 0;
 	}
 
-	for (offset = entry2offset(*handle, c->start);
-	     offset < entry2offset(*handle, c->end);
+	for (offset = c->start_off; offset < c->end_off;
 	     offset += e->next_offset) {
 		STRUCT_ENTRY_TARGET discard;
 
@@ -1135,9 +1255,9 @@
 		return 0;
 	}
 
-	index = entry2index(*handle, c->start) + rulenum;
+	index = offset2index(*handle, c->start_off) + rulenum;
 
-	if (index >= entry2index(*handle, c->end)) {
+	if (index >= offset2index(*handle, c->end_off)) {
 		errno = E2BIG;
 		return 0;
 	}
@@ -1169,6 +1289,7 @@
 TC_FLUSH_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
 {
 	unsigned int startindex, endindex;
+	STRUCT_ENTRY *startentry, *endentry;
 	struct chain_cache *c;
 	int ret;
 
@@ -1177,12 +1298,14 @@
 		errno = ENOENT;
 		return 0;
 	}
-	startindex = entry2index(*handle, c->start);
-	endindex = entry2index(*handle, c->end);
+	startindex = offset2index(*handle, c->start_off);
+	endindex = offset2index(*handle, c->end_off);
+	startentry = offset2entry(*handle, c->start_off);
+	endentry = offset2entry(*handle, c->end_off);
 
 	ret = delete_rules(endindex - startindex,
-			   (char *)c->end - (char *)c->start,
-			   entry2offset(*handle, c->start), startindex,
+			   (char *)endentry - (char *)startentry,
+			   c->start_off, startindex,
 			   handle);
 	return ret;
 }
@@ -1199,8 +1322,8 @@
 		return 0;
 	}
 
-	i = entry2index(*handle, c->start);
-	end = entry2index(*handle, c->end);
+	i = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
 
 	for (; i <= end; i++) {
 		if ((*handle)->counter_map[i].maptype ==COUNTER_MAP_NORMAL_MAP)
@@ -1228,8 +1351,8 @@
 		return NULL;
 	}
 
-	chainindex = entry2index(*handle, c->start);
-	end = entry2index(*handle, c->end);
+	chainindex = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
 
 	if (chainindex + rulenum > end) {
 		errno = E2BIG;
@@ -1258,8 +1381,8 @@
 		return 0;
 	}
 
-	chainindex = entry2index(*handle, c->start);
-	end = entry2index(*handle, c->end);
+	chainindex = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
 
 	if (chainindex + rulenum > end) {
 		errno = E2BIG;
@@ -1297,8 +1420,8 @@
 		return 0;
 	}
 
-	chainindex = entry2index(*handle, c->start);
-	end = entry2index(*handle, c->end);
+	chainindex = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
 
 	if (chainindex + rulenum > end) {
 		errno = E2BIG;
@@ -1330,6 +1453,7 @@
 		STRUCT_ENTRY ret;
 		STRUCT_STANDARD_TARGET target;
 	} newc;
+	unsigned int destination;
 
 	iptc_fn = TC_CREATE_CHAIN;
 
@@ -1367,11 +1491,21 @@
 		= ALIGN(sizeof(STRUCT_STANDARD_TARGET));
 	newc.target.verdict = RETURN;
 
+	destination = index2offset(*handle, (*handle)->new_number -1);
+
 	/* Add just before terminal entry */
 	ret = insert_rules(2, sizeof(newc), &newc.head,
-			   index2offset(*handle, (*handle)->new_number - 1),
+			   destination,
 			   (*handle)->new_number - 1,
 			   0, handle);
+
+	set_changed(*handle);
+
+	/* add chain cache info for this chain */
+	add_chain_cache(*handle, chain, 
+			destination+newc.head.next_offset, 
+			destination+newc.head.next_offset);
+
 	return ret;
 }
 
@@ -1405,7 +1539,7 @@
 	*ref = 0;
 	ENTRY_ITERATE((*handle)->entries.entrytable,
 		      (*handle)->entries.size,
-		      count_ref, entry2offset(*handle, c->start), ref);
+		      count_ref, c->start_off, ref);
 	return 1;
 }
 
@@ -1417,6 +1551,7 @@
 	unsigned int references;
 	struct chain_cache *c;
 	int ret;
+	STRUCT_ENTRY *start;
 
 	if (!TC_GET_REFERENCES(&references, chain, handle))
 		return 0;
@@ -1438,18 +1573,20 @@
 		return 0;
 	}
 
-	if ((void *)c->start != c->end) {
+	if (c->start_off != c->end_off) {
 		errno = ENOTEMPTY;
 		return 0;
 	}
 
 	/* Need label index: preceeds chain start */
-	labelidx = entry2index(*handle, c->start) - 1;
+	labelidx = offset2index(*handle, c->start_off) - 1;
 	labeloff = index2offset(*handle, labelidx);
 
+	start = offset2entry(*handle, c->start_off);
+
 	ret = delete_rules(2,
 			   get_entry(*handle, labeloff)->next_offset
-			   + c->start->next_offset,
+			   + start->next_offset,
 			   labeloff, labelidx, handle);
 	return ret;
 }
@@ -1488,7 +1625,7 @@
 	}
 
 	/* Need label index: preceeds chain start */
-	labelidx = entry2index(*handle, c->start) - 1;
+	labelidx = offset2index(*handle, c->start_off) - 1;
 	labeloff = index2offset(*handle, labelidx);
 
 	t = (struct ipt_error_target *)
@@ -1496,6 +1633,11 @@
 
 	memset(t->error, 0, sizeof(t->error));
 	strcpy(t->error, newname);
+
+	/* update chain cache */
+	memset(c->name, 0, sizeof(c->name));
+	strcpy(c->name, newname);
+
 	set_changed(*handle);
 
 	return 1;
@@ -1582,11 +1724,13 @@
 	STRUCT_REPLACE *repl;
 	STRUCT_COUNTERS_INFO *newcounters;
 	unsigned int i;
-	size_t counterlen
-		= sizeof(STRUCT_COUNTERS_INFO)
-		+ sizeof(STRUCT_COUNTERS) * (*handle)->new_number;
+	size_t counterlen;
 
 	CHECK(*handle);
+
+	counterlen = sizeof(STRUCT_COUNTERS_INFO)
+			+ sizeof(STRUCT_COUNTERS) * (*handle)->new_number;
+
 #if 0
 	TC_DUMP_ENTRIES(*handle);
 #endif
@@ -1713,10 +1857,7 @@
 	free(newcounters);
 
  finished:
-	if ((*handle)->cache_chain_heads)
-		free((*handle)->cache_chain_heads);
-	free(*handle);
-	*handle = NULL;
+	TC_FREE(handle);
 	return 1;
 }
 
diff -urN iptables-1.2.8/libiptc2/.#libiptc.c.1.40 iptables-1.2.9/libiptc2/.#libiptc.c.1.40
--- iptables-1.2.8/libiptc2/.#libiptc.c.1.40	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/libiptc2/.#libiptc.c.1.40	2003-07-13 17:52:11.000000000 +0200
@@ -0,0 +1,1972 @@
+/* Library which manipulates firewall rules.  Version $Revision: 1.40 $ */
+
+/* Architecture of firewall rules is as follows:
+ *
+ * Chains go INPUT, FORWARD, OUTPUT then user chains.
+ * Each user chain starts with an ERROR node.
+ * Every chain ends with an unconditional jump: a RETURN for user chains,
+ * and a POLICY for built-ins.
+ */
+
+/* (C) 1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
+ * COPYING for details). 
+ * (C) 2000-2003 by the Netfilter Core Team <coreteam@netfilter.org>
+ *
+ * 2003-Jun-20: Harald Welte <laforge@netfilter.org>:
+ *	- Reimplementation of chain cache to use offsets instead of entries
+ * 2003-Jun-23: Harald Welte <laforge@netfilter.org>:
+ * 	- speed optimization, sponsored by Astaro AG (http://www.astaro.com/)
+ * 	  don't rebuild the chain cache after every operation, instead fix it
+ * 	  up after a ruleset change.  
+ * 2003-Jun-30: Harald Welte <laforge@netfilter.org>:
+ * 	- total reimplementation
+ */
+#include "linux_listhelp.h"
+
+#ifndef IPT_LIB_DIR
+#define IPT_LIB_DIR "/usr/local/lib/iptables"
+#endif
+
+static int sockfd = -1;
+static void *iptc_fn = NULL;
+
+static const char *hooknames[]
+= { [HOOK_PRE_ROUTING]  "PREROUTING",
+    [HOOK_LOCAL_IN]     "INPUT",
+    [HOOK_FORWARD]      "FORWARD",
+    [HOOK_LOCAL_OUT]    "OUTPUT",
+    [HOOK_POST_ROUTING] "POSTROUTING",
+#ifdef HOOK_DROPPING
+    [HOOK_DROPPING]	"DROPPING"
+#endif
+};
+
+struct counter_map
+{
+	enum {
+		COUNTER_MAP_NOMAP,
+		COUNTER_MAP_NORMAL_MAP,
+		COUNTER_MAP_ZEROED,
+		COUNTER_MAP_SET
+	} maptype;
+	unsigned int mappos;
+};
+
+/* Convenience structures */
+struct ipt_error_target
+{
+	STRUCT_ENTRY_TARGET t;
+	char error[TABLE_MAXNAMELEN];
+};
+
+struct rule_head
+{
+	struct list_head list;		/* list of rules in chain */
+	
+	struct chain_head *chain;	/* we're part of this chain */
+	struct rule_head *target;	/* target of this rule, in case
+					   it is a jump rule */
+
+
+	unsigned int size;		/* size of rule */
+	STRUCT_ENTRY *entry_blob;	/* pointer to entry in blob */
+	STRUCT_ENTRY entry[0];
+};
+
+struct chain_head
+{
+	struct list_head list;
+
+	char name[TABLE_MAXNAMELEN];
+	unsigned int hooknum;
+	struct list_head rules;
+};
+
+STRUCT_TC_HANDLE
+{
+	/* Have changes been made? */
+	int changed;
+
+	/* linked list of chains in this table */
+	struct list_head chains;
+	
+	/* current position of first_chain() / next_chain() */
+	struct chain_head *chain_iterator_cur;
+
+	/* current position of first_rule() / next_rule() */
+	struct rule_head *rule_iterator_cur;
+
+	struct counter_map *counter_map;
+
+	/* the structure we receive from getsockopt() */
+	STRUCT_GETINFO info;
+
+	/* Array of hook names */
+	const char **hooknames;
+#if 0
+	/* Size in here reflects original state. */
+
+
+	/* Cached position of chain heads (NULL = no cache). */
+	unsigned int cache_num_chains;
+	unsigned int cache_num_builtins;
+	struct chain_cache *cache_chain_heads;
+
+	/* Chain iterator: current chain cache entry. */
+	struct chain_cache *cache_chain_iteration;
+
+	/* Rule iterator: terminal rule */
+	STRUCT_ENTRY *cache_rule_end;
+
+	/* Number in here reflects current state. */
+	unsigned int new_number;
+#endif
+	STRUCT_GET_ENTRIES entries;
+};
+
+static void
+set_changed(TC_HANDLE_T h)
+{
+	h->changed = 1;
+}
+
+#ifdef IPTC_DEBUG
+static void do_check(TC_HANDLE_T h, unsigned int line);
+#define CHECK(h) do { if (!getenv("IPTC_NO_CHECK")) do_check((h), __LINE__); } while(0)
+#else
+#define CHECK(h)
+#endif
+
+static struct rule_head *ruleh_alloc(unsigned int size)
+{
+	struct rule_head *ruleh = malloc(sizeof(*ruleh)+size);
+	if (!ruleh)
+		return NULL;
+	
+	memset(ruleh, 0, sizeof(*ruleh)+size);
+	ruleh->size = size;
+
+	return ruleh;
+}
+
+static void ruleh_free(struct rule_head *ruleh)
+{
+	list_del(&ruleh->list);
+	free(ruleh);
+}
+
+static struct rule_head *ruleh_get_n(struct chain_head *chain, int num)
+{
+	return NULL;
+}
+
+static struct chain_head *chainh_alloc(TC_HANDLE_T h, const char *name)
+{
+	struct chain_head *chainh = malloc(sizeof(*chainh));
+	if (!chainh)
+		return NULL;
+
+	memset(chainh, 0, sizeof(*chainh));
+	strncpy(chainh->name, name, sizeof(&chainh->name));
+	list_append(&chainh->list, &h->chains);
+
+	return chainh;
+}
+
+static void
+chainh_free(struct chain_head *chainh)
+{
+	/* FIXME */
+	struct list_head *cur_item, *item2;
+
+	list_for_each_safe(cur_item, item2, &chainh->rules) {
+		struct rule_head *ruleh = list_entry(cur_item, 
+						     struct rule_head,
+						    list);
+		ruleh_free(ruleh);
+	}
+
+	list_del(&chainh->list);
+}
+
+#if 0
+static inline int
+get_number(const STRUCT_ENTRY *i,
+	   const STRUCT_ENTRY *seek,
+	   unsigned int *pos)
+{
+	if (i == seek)
+		return 1;
+	(*pos)++;
+	return 0;
+}
+#endif
+
+static struct chain_head *
+chainh_find(TC_HANDLE_T h, const IPT_CHAINLABEL name)
+{
+	struct list_head *cur;
+
+	list_for_each(cur, &h->chains) {
+		struct chain_head *ch = list_entry(cur, struct chain_head, 
+						   list);
+		if (!strcmp(name, ch->name))
+			return ch;
+	}
+	return NULL;
+}
+
+static inline unsigned long
+entry2offset(const TC_HANDLE_T h, const STRUCT_ENTRY *e)
+{
+	return (void *)e - (void *)h->entries.entrytable;
+}
+
+#if 0
+static unsigned int
+entry2index(const TC_HANDLE_T h, const STRUCT_ENTRY *seek)
+{
+	unsigned int pos = 0;
+
+	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+			  get_number, seek, &pos) == 0) {
+		fprintf(stderr, "ERROR: offset %i not an entry!\n",
+			(char *)seek - (char *)h->entries.entrytable);
+		abort();
+	}
+	return pos;
+}
+
+static inline int
+get_entry_n(STRUCT_ENTRY *i,
+	    unsigned int number,
+	    unsigned int *pos,
+	    STRUCT_ENTRY **pe)
+{
+	if (*pos == number) {
+		*pe = i;
+		return 1;
+	}
+	(*pos)++;
+	return 0;
+}
+
+static STRUCT_ENTRY *
+index2entry(TC_HANDLE_T h, unsigned int index)
+{
+	unsigned int pos = 0;
+	STRUCT_ENTRY *ret = NULL;
+
+	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+		      get_entry_n, index, &pos, &ret);
+
+	return ret;
+}
+
+static inline STRUCT_ENTRY *
+get_entry(TC_HANDLE_T h, unsigned int offset)
+{
+	return (STRUCT_ENTRY *)((char *)h->entries.entrytable + offset);
+}
+
+
+static inline unsigned long
+index2offset(TC_HANDLE_T h, unsigned int index)
+{
+	return entry2offset(h, index2entry(h, index));
+}
+
+static inline STRUCT_ENTRY *
+offset2entry(TC_HANDLE_T h, unsigned int offset)
+{
+	return (STRUCT_ENTRY *) ((void *)h->entries.entrytable+offset);
+}
+
+static inline unsigned int
+offset2index(const TC_HANDLE_T h, unsigned int offset)
+{
+	return entry2index(h, offset2entry(h, offset));
+}
+
+
+static const char *
+get_errorlabel(TC_HANDLE_T h, unsigned int offset)
+{
+	STRUCT_ENTRY *e;
+
+	e = get_entry(h, offset);
+	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) != 0) {
+		fprintf(stderr, "ERROR: offset %u not an error node!\n",
+			offset);
+		abort();
+	}
+
+	return (const char *)GET_TARGET(e)->data;
+}
+#endif
+
+/* Allocate handle of given size */
+static TC_HANDLE_T
+alloc_handle(const char *tablename, unsigned int size, unsigned int num_rules)
+{
+	size_t len;
+	TC_HANDLE_T h;
+
+	len = sizeof(STRUCT_TC_HANDLE)
+		+ size
+		+ num_rules * sizeof(struct counter_map);
+
+	if ((h = malloc(len)) == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	h->changed = 0;
+
+	h->counter_map = (void *)h
+		+ sizeof(STRUCT_TC_HANDLE)
+		+ size;
+	strcpy(h->info.name, tablename);
+	strcpy(h->entries.name, tablename);
+	INIT_LIST_HEAD(&h->chains);
+
+	return h;
+}
+
+struct rule_head *
+append_entrycopy(STRUCT_ENTRY *e, struct chain_head *chain)
+{
+	struct rule_head *ruleh = ruleh_alloc(e->next_offset);
+	if (!ruleh)
+		return NULL;
+	
+	memcpy(&ruleh->entry, e, e->next_offset);
+	ruleh->chain = chain;
+	ruleh->entry_blob = e;
+	list_append(&ruleh->list, &chain->rules);
+
+	return ruleh;
+}
+
+
+/* have to return 0 on success, bcf ENTRY_ITERATE */
+static inline int 
+parse_entry(STRUCT_ENTRY *e, TC_HANDLE_T h, struct chain_head **curchain)
+{
+	int i;
+	union tgt_u {
+		STRUCT_ENTRY_TARGET ent;
+		STRUCT_STANDARD_TARGET std;
+		struct ipt_error_target err;
+	} *tgt;
+
+	tgt = (union tgt_u *) GET_TARGET(e);
+
+	if (e->target_offset == sizeof(STRUCT_ENTRY)
+	    && (strcmp(tgt->ent.u.user.name, IPT_STANDARD_TARGET) == 0)) {
+		/* jump to somewhere else */
+		append_entrycopy(e, *curchain);
+		/* FIXME: */
+	} else if (e->target_offset == sizeof(STRUCT_ENTRY)
+		   && e->next_offset == sizeof(STRUCT_ENTRY)
+		   			+ ALIGN(sizeof(struct ipt_error_target))
+		   && !strcmp(tgt->ent.u.user.name, ERROR_TARGET)) {
+		/* chain head */
+		*curchain = chainh_find(h, tgt->err.error);
+		if (*curchain) {
+			/* FIXME: error handling */
+			return 1;
+		}
+
+		*curchain = chainh_alloc(h, tgt->err.error);
+		/* FIXME: error handling */
+		append_entrycopy(e, *curchain);
+	} else if (e->target_offset == sizeof(STRUCT_ENTRY)
+		   && e->next_offset == sizeof(STRUCT_ENTRY)
+		   			+ ALIGN(sizeof(STRUCT_STANDARD_TARGET))
+		   && tgt->std.verdict == RETURN) {
+		/* chain end */
+		append_entrycopy(e, *curchain);
+		*curchain = NULL;
+	} else {
+		/* normal rule */
+		append_entrycopy(e, *curchain);
+	}
+
+	/* iterate over hook_entries, needed to connect builtin
+	 * chains with hook numbers */
+	for (i = 0; i < NUMHOOKS; i++) {
+		if (!(h->info.valid_hooks & (1 << i)))
+			continue;
+		if (h->info.hook_entry[i] == entry2offset(h, e)) {
+			/* found hook entry point */
+			if (*curchain)
+				(*curchain)->hooknum = i;
+		}
+		if (h->info.underflow[i] == entry2offset(h, e)) {
+			/* found underflow point */
+		}
+	}
+
+	return 0;
+}
+
+static int parse_ruleset(TC_HANDLE_T h)
+{
+	struct chain_head *curchain;
+	
+	/* iterate over ruleset; create linked list of rule_head/chain_head */
+	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size, 
+		      parse_entry, h, &curchain)) {
+		/* some error happened while iterating */
+		return 0;
+	}
+
+	return 1;
+}
+
+TC_HANDLE_T
+TC_INIT(const char *tablename)
+{
+	TC_HANDLE_T h;
+	STRUCT_GETINFO info;
+	unsigned int i;
+	int tmp;
+	socklen_t s;
+
+	iptc_fn = TC_INIT;
+
+	if (sockfd != -1) {
+		close(sockfd);
+		sockfd = -1;
+	}
+
+	if (strlen(tablename) >= TABLE_MAXNAMELEN) {
+		errno = EINVAL;
+		return NULL;
+	}
+	
+	sockfd = socket(TC_AF, SOCK_RAW, IPPROTO_RAW);
+	if (sockfd < 0)
+		return NULL;
+
+	s = sizeof(info);
+
+	strcpy(info.name, tablename);
+	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_INFO, &info, &s) < 0)
+		return NULL;
+
+	if ((h = alloc_handle(info.name, info.size, info.num_entries))
+	    == NULL) {
+		close(sockfd);
+		sockfd = -1;
+		return NULL;
+	}
+
+/* Too hard --RR */
+#if 0
+	sprintf(pathname, "%s/%s", IPT_LIB_DIR, info.name);
+	dynlib = dlopen(pathname, RTLD_NOW);
+	if (!dynlib) {
+		errno = ENOENT;
+		return NULL;
+	}
+	h->hooknames = dlsym(dynlib, "hooknames");
+	if (!h->hooknames) {
+		errno = ENOENT;
+		return NULL;
+	}
+#else
+	h->hooknames = hooknames;
+#endif
+
+	/* Initialize current state */
+	h->info = info;
+	//h->new_number = h->info.num_entries;
+	for (i = 0; i < h->info.num_entries; i++)
+		h->counter_map[i]
+			= ((struct counter_map){COUNTER_MAP_NORMAL_MAP, i});
+
+	h->entries.size = h->info.size;
+
+	tmp = sizeof(STRUCT_GET_ENTRIES) + h->info.size;
+
+	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_ENTRIES, &h->entries,
+		       &tmp) < 0) {
+		close(sockfd);
+		sockfd = -1;
+		free(h);
+		return NULL;
+	}
+
+	CHECK(h);
+	parse_ruleset(h);
+
+	return h;
+}
+
+void
+TC_FREE(TC_HANDLE_T *h)
+{
+	struct list_head *cur_item, *item2;
+
+	close(sockfd);
+	sockfd = -1;
+
+	/* free all chains */
+	list_for_each_safe(cur_item, item2, (*h)->chains.next) {
+		struct chain_head *chead = list_entry(cur_item,
+						      struct chain_head,
+						      list);
+		chainh_free(chead);
+	}
+
+	/* FIXME: free all other ressources we might be using */
+
+	free(*h);
+	*h = NULL;
+}
+
+static inline int
+print_match(const STRUCT_ENTRY_MATCH *m)
+{
+	printf("Match name: `%s'\n", m->u.user.name);
+	return 0;
+}
+
+static int dump_entry(STRUCT_ENTRY *e, const TC_HANDLE_T handle);
+ 
+#if 0
+void
+TC_DUMP_ENTRIES(const TC_HANDLE_T handle)
+{
+	CHECK(handle);
+
+	printf("libiptc v%s.  %u entries, %u bytes.\n",
+	       IPTABLES_VERSION,
+	       handle->new_number, handle->entries.size);
+	printf("Table `%s'\n", handle->info.name);
+	printf("Hooks: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
+	       handle->info.hook_entry[HOOK_PRE_ROUTING],
+	       handle->info.hook_entry[HOOK_LOCAL_IN],
+	       handle->info.hook_entry[HOOK_FORWARD],
+	       handle->info.hook_entry[HOOK_LOCAL_OUT],
+	       handle->info.hook_entry[HOOK_POST_ROUTING]);
+	printf("Underflows: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
+	       handle->info.underflow[HOOK_PRE_ROUTING],
+	       handle->info.underflow[HOOK_LOCAL_IN],
+	       handle->info.underflow[HOOK_FORWARD],
+	       handle->info.underflow[HOOK_LOCAL_OUT],
+	       handle->info.underflow[HOOK_POST_ROUTING]);
+
+	ENTRY_ITERATE(handle->entries.entrytable, handle->entries.size,
+		      dump_entry, handle);
+}
+
+/* Returns 0 if not hook entry, else hooknumber + 1 */
+static inline unsigned int
+is_hook_entry(STRUCT_ENTRY *e, TC_HANDLE_T h)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUMHOOKS; i++) {
+		if ((h->info.valid_hooks & (1 << i))
+		    && get_entry(h, h->info.hook_entry[i]) == e)
+			return i+1;
+	}
+	return 0;
+}
+
+
+static int alphasort(const void *a, const void *b)
+{
+	return strcmp(((struct chain_cache *)a)->name,
+		      ((struct chain_cache *)b)->name);
+}
+#endif
+
+/* Returns chain head if found, otherwise NULL. */
+static struct chain_head *
+find_label(const char *name, TC_HANDLE_T handle)
+{
+	struct list_head *pos;
+
+	if (list_empty(&handle->chains))
+		return NULL;
+
+	list_for_each(pos, &handle->chains) {
+		struct chain_head *c = list_entry(pos, struct chain_head, list);
+		if (!strcmp(c->name, name))
+			return c;
+	}
+
+	return NULL;
+}
+
+/* Does this chain exist? */
+int TC_IS_CHAIN(const char *chain, const TC_HANDLE_T handle)
+{
+	return find_label(chain, handle) != NULL;
+}
+
+#if 0
+/* Returns the position of the final (ie. unconditional) element. */
+static unsigned int
+get_chain_end(const TC_HANDLE_T handle, unsigned int start)
+{
+	unsigned int last_off, off;
+	STRUCT_ENTRY *e;
+
+	last_off = start;
+	e = get_entry(handle, start);
+
+	/* Terminate when we meet a error label or a hook entry. */
+	for (off = start + e->next_offset;
+	     off < handle->entries.size;
+	     last_off = off, off += e->next_offset) {
+		STRUCT_ENTRY_TARGET *t;
+		unsigned int i;
+
+		e = get_entry(handle, off);
+
+		/* We hit an entry point. */
+		for (i = 0; i < NUMHOOKS; i++) {
+			if ((handle->info.valid_hooks & (1 << i))
+			    && off == handle->info.hook_entry[i])
+				return last_off;
+		}
+
+		/* We hit a user chain label */
+		t = GET_TARGET(e);
+		if (strcmp(t->u.user.name, ERROR_TARGET) == 0)
+			return last_off;
+	}
+	/* SHOULD NEVER HAPPEN */
+	fprintf(stderr, "ERROR: Off end (%u) of chain from %u!\n",
+		handle->entries.size, off);
+	abort();
+}
+#endif
+
+/* Iterator functions to run through the chains. */
+const char *
+TC_FIRST_CHAIN(TC_HANDLE_T *handle)
+{
+	struct chain_head *firsthead = list_entry((*handle)->chains.next,
+						   struct chain_head, list);
+	(*handle)->chain_iterator_cur = firsthead;
+
+	return firsthead->name;
+}
+
+/* Iterator functions to run through the chains.  Returns NULL at end. */
+const char *
+TC_NEXT_CHAIN(TC_HANDLE_T *handle)
+{
+	struct chain_head *next = list_entry(&(*handle)->chain_iterator_cur->list.next, struct chain_head, list);
+	(*handle)->chain_iterator_cur = next;
+
+	if (&next->list == &(*handle)->chains)
+		return NULL;
+
+	return next->name;
+}
+
+/* Get first rule in the given chain: NULL for empty chain. */
+const STRUCT_ENTRY *
+TC_FIRST_RULE(const char *chain, TC_HANDLE_T *handle)
+{
+	struct chain_head *c;
+	struct rule_head *r;
+
+	c = find_label(chain, *handle);
+	if (!c) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	/* Empty chain: single return/policy rule */
+	if (list_empty(&c->rules))
+		return NULL;
+
+	r = list_entry(c->rules.next, struct rule_head, list);
+	(*handle)->rule_iterator_cur = r;
+
+	return r->entry;
+}
+
+/* Returns NULL when rules run out. */
+const STRUCT_ENTRY *
+TC_NEXT_RULE(const STRUCT_ENTRY *prev, TC_HANDLE_T *handle)
+{
+	struct rule_head *r = list_entry((*handle)->rule_iterator_cur->list.next, struct rule_head, list);
+
+	if (&r->list == &r->chain->rules)
+		return NULL;
+
+	/* NOTE: prev is without any influence ! */
+	return r->entry;
+}
+
+#if 0
+/* How many rules in this chain? */
+unsigned int
+TC_NUM_RULES(const char *chain, TC_HANDLE_T *handle)
+{
+	unsigned int off = 0;
+	STRUCT_ENTRY *start, *end;
+
+	CHECK(*handle);
+	if (!find_label(&off, chain, *handle)) {
+		errno = ENOENT;
+		return (unsigned int)-1;
+	}
+
+	start = get_entry(*handle, off);
+	end = get_entry(*handle, get_chain_end(*handle, off));
+
+	return entry2index(*handle, end) - entry2index(*handle, start);
+}
+
+/* Get n'th rule in this chain. */
+const STRUCT_ENTRY *TC_GET_RULE(const char *chain,
+				unsigned int n,
+				TC_HANDLE_T *handle)
+{
+	unsigned int pos = 0, chainindex;
+
+	CHECK(*handle);
+	if (!find_label(&pos, chain, *handle)) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	chainindex = entry2index(*handle, get_entry(*handle, pos));
+
+	return index2entry(*handle, chainindex + n);
+}
+#endif
+
+static const char *
+target_name(TC_HANDLE_T handle, const STRUCT_ENTRY *ce)
+{
+	int spos;
+	unsigned int labelidx;
+	STRUCT_ENTRY *jumpto;
+
+	/* To avoid const warnings */
+	STRUCT_ENTRY *e = (STRUCT_ENTRY *)ce;
+
+	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) != 0)
+		return GET_TARGET(e)->u.user.name;
+
+	/* Standard target: evaluate */
+	spos = *(int *)GET_TARGET(e)->data;
+	if (spos < 0) {
+		if (spos == RETURN)
+			return LABEL_RETURN;
+		else if (spos == -NF_ACCEPT-1)
+			return LABEL_ACCEPT;
+		else if (spos == -NF_DROP-1)
+			return LABEL_DROP;
+		else if (spos == -NF_QUEUE-1)
+			return LABEL_QUEUE;
+
+		fprintf(stderr, "ERROR: off %lu/%u not a valid target (%d)\n",
+			entry2offset(handle, e), handle->entries.size,
+			spos);
+		abort();
+	}
+
+	jumpto = get_entry(handle, spos);
+
+	/* Fall through rule */
+	if (jumpto == (void *)e + e->next_offset)
+		return "";
+
+	/* Must point to head of a chain: ie. after error rule */
+	/* FIXME: this needs to deal with internal jump targets */
+	labelidx = entry2index(handle, jumpto) - 1;
+	return get_errorlabel(handle, index2offset(handle, labelidx));
+}
+
+/* Returns a pointer to the target name of this position. */
+const char *TC_GET_TARGET(const STRUCT_ENTRY *e,
+			  TC_HANDLE_T *handle)
+{
+	return target_name(*handle, e);
+}
+
+/* Is this a built-in chain?  Actually returns hook + 1. */
+int
+TC_BUILTIN(const char *chain, const TC_HANDLE_T handle)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUMHOOKS; i++) {
+		if ((handle->info.valid_hooks & (1 << i))
+		    && handle->hooknames[i]
+		    && strcmp(handle->hooknames[i], chain) == 0)
+			return i+1;
+	}
+	return 0;
+}
+
+/* Get the policy of a given built-in chain */
+const char *
+TC_GET_POLICY(const char *chain,
+	      STRUCT_COUNTERS *counters,
+	      TC_HANDLE_T *handle)
+{
+	unsigned int start;
+	STRUCT_ENTRY *e;
+	int hook;
+
+	hook = TC_BUILTIN(chain, *handle);
+	if (hook != 0)
+		start = (*handle)->info.hook_entry[hook-1];
+	else
+		return NULL;
+
+	e = get_entry(*handle, get_chain_end(*handle, start));
+	*counters = e->counters;
+
+	return target_name(*handle, e);
+}
+
+static int
+correct_verdict(STRUCT_ENTRY *e,
+		char *base,
+		unsigned int offset, int delta_offset)
+{
+	STRUCT_STANDARD_TARGET *t = (void *)GET_TARGET(e);
+	unsigned int curr = (char *)e - base;
+
+	/* Trap: insert of fall-through rule.  Don't change fall-through
+	   verdict to jump-over-next-rule. */
+	if (strcmp(t->target.u.user.name, STANDARD_TARGET) == 0
+	    && t->verdict > (int)offset
+	    && !(curr == offset &&
+		 t->verdict == curr + e->next_offset)) {
+		t->verdict += delta_offset;
+	}
+
+	return 0;
+}
+
+/* Adjusts standard verdict jump positions after an insertion/deletion. */
+static int
+set_verdict(unsigned int offset, int delta_offset, TC_HANDLE_T *handle)
+{
+	ENTRY_ITERATE((*handle)->entries.entrytable,
+		      (*handle)->entries.size,
+		      correct_verdict, (char *)(*handle)->entries.entrytable,
+		      offset, delta_offset);
+
+	set_changed(*handle);
+	return 1;
+}
+
+/* If prepend is set, then we are prepending to a chain: if the
+ * insertion position is an entry point, keep the entry point. */
+static int
+insert_rules(unsigned int num_rules, unsigned int rules_size,
+	     const STRUCT_ENTRY *insert,
+	     unsigned int offset, unsigned int num_rules_offset,
+	     int prepend,
+	     TC_HANDLE_T *handle)
+{
+	TC_HANDLE_T newh;
+	STRUCT_GETINFO newinfo;
+	unsigned int i;
+
+	if (offset >= (*handle)->entries.size) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	newinfo = (*handle)->info;
+
+	/* Fix up entry points. */
+	for (i = 0; i < NUMHOOKS; i++) {
+		/* Entry points to START of chain, so keep same if
+                   inserting on at that point. */
+		if ((*handle)->info.hook_entry[i] > offset)
+			newinfo.hook_entry[i] += rules_size;
+
+		/* Underflow always points to END of chain (policy),
+		   so if something is inserted at same point, it
+		   should be advanced. */
+		if ((*handle)->info.underflow[i] >= offset)
+			newinfo.underflow[i] += rules_size;
+	}
+
+	newh = alloc_handle((*handle)->info.name,
+			    (*handle)->entries.size + rules_size,
+			    (*handle)->new_number + num_rules);
+	if (!newh)
+		return 0;
+	newh->info = newinfo;
+
+	/* Copy pre... */
+	memcpy(newh->entries.entrytable, (*handle)->entries.entrytable,offset);
+	/* ... Insert new ... */
+	memcpy((char *)newh->entries.entrytable + offset, insert, rules_size);
+	/* ... copy post */
+	memcpy((char *)newh->entries.entrytable + offset + rules_size,
+	       (char *)(*handle)->entries.entrytable + offset,
+	       (*handle)->entries.size - offset);
+
+	/* Move counter map. */
+	/* Copy pre... */
+	memcpy(newh->counter_map, (*handle)->counter_map,
+	       sizeof(struct counter_map) * num_rules_offset);
+	/* ... copy post */
+	memcpy(newh->counter_map + num_rules_offset + num_rules,
+	       (*handle)->counter_map + num_rules_offset,
+	       sizeof(struct counter_map) * ((*handle)->new_number
+					     - num_rules_offset));
+	/* Set intermediates to no counter copy */
+	for (i = 0; i < num_rules; i++)
+		newh->counter_map[num_rules_offset+i]
+			= ((struct counter_map){ COUNTER_MAP_SET, 0 });
+
+	newh->new_number = (*handle)->new_number + num_rules;
+	newh->entries.size = (*handle)->entries.size + rules_size;
+	newh->hooknames = (*handle)->hooknames;
+
+	if ((*handle)->cache_chain_heads)
+		free((*handle)->cache_chain_heads);
+	free(*handle);
+	*handle = newh;
+
+	return set_verdict(offset, rules_size, handle);
+}
+
+static int
+delete_rules(unsigned int num_rules, unsigned int rules_size,
+	     unsigned int offset, unsigned int num_rules_offset,
+	     TC_HANDLE_T *handle)
+{
+	unsigned int i;
+
+	if (offset + rules_size > (*handle)->entries.size) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	/* Fix up entry points. */
+	for (i = 0; i < NUMHOOKS; i++) {
+		/* In practice, we never delete up to a hook entry,
+		   since the built-in chains are always first,
+		   so these two are never equal */
+		if ((*handle)->info.hook_entry[i] >= offset + rules_size)
+			(*handle)->info.hook_entry[i] -= rules_size;
+		else if ((*handle)->info.hook_entry[i] > offset) {
+			fprintf(stderr, "ERROR: Deleting entry %u %u %u\n",
+				i, (*handle)->info.hook_entry[i], offset);
+			abort();
+		}
+
+		/* Underflow points to policy (terminal) rule in
+                   built-in, so sequality is valid here (when deleting
+                   the last rule). */
+		if ((*handle)->info.underflow[i] >= offset + rules_size)
+			(*handle)->info.underflow[i] -= rules_size;
+		else if ((*handle)->info.underflow[i] > offset) {
+			fprintf(stderr, "ERROR: Deleting uflow %u %u %u\n",
+				i, (*handle)->info.underflow[i], offset);
+			abort();
+		}
+	}
+
+	/* Move the rules down. */
+	memmove((char *)(*handle)->entries.entrytable + offset,
+		(char *)(*handle)->entries.entrytable + offset + rules_size,
+		(*handle)->entries.size - (offset + rules_size));
+
+	/* Move the counter map down. */
+	memmove(&(*handle)->counter_map[num_rules_offset],
+		&(*handle)->counter_map[num_rules_offset + num_rules],
+		sizeof(struct counter_map)
+		* ((*handle)->new_number - (num_rules + num_rules_offset)));
+
+	/* Fix numbers */
+	(*handle)->new_number -= num_rules;
+	(*handle)->entries.size -= rules_size;
+
+	return set_verdict(offset, -(int)rules_size, handle);
+}
+
+static int
+standard_map(STRUCT_ENTRY *e, int verdict)
+{
+	STRUCT_STANDARD_TARGET *t;
+
+	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+
+	if (t->target.u.target_size
+	    != ALIGN(sizeof(STRUCT_STANDARD_TARGET))) {
+		errno = EINVAL;
+		return 0;
+	}
+	/* memset for memcmp convenience on delete/replace */
+	memset(t->target.u.user.name, 0, FUNCTION_MAXNAMELEN);
+	strcpy(t->target.u.user.name, STANDARD_TARGET);
+	t->verdict = verdict;
+
+	return 1;
+}
+
+static int
+map_target(const TC_HANDLE_T handle,
+	   STRUCT_ENTRY *e,
+	   unsigned int offset,
+	   STRUCT_ENTRY_TARGET *old)
+{
+	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
+
+	/* Save old target (except data, which we don't change, except for
+	   standard case, where we don't care). */
+	*old = *t;
+
+	/* Maybe it's empty (=> fall through) */
+	if (strcmp(t->u.user.name, "") == 0)
+		return standard_map(e, offset + e->next_offset);
+	/* Maybe it's a standard target name... */
+	else if (strcmp(t->u.user.name, LABEL_ACCEPT) == 0)
+		return standard_map(e, -NF_ACCEPT - 1);
+	else if (strcmp(t->u.user.name, LABEL_DROP) == 0)
+		return standard_map(e, -NF_DROP - 1);
+	else if (strcmp(t->u.user.name, LABEL_QUEUE) == 0)
+		return standard_map(e, -NF_QUEUE - 1);
+	else if (strcmp(t->u.user.name, LABEL_RETURN) == 0)
+		return standard_map(e, RETURN);
+	else if (TC_BUILTIN(t->u.user.name, handle)) {
+		/* Can't jump to builtins. */
+		errno = EINVAL;
+		return 0;
+	} else {
+		/* Maybe it's an existing chain name. */
+		struct chain_cache *c;
+
+		c = find_label(t->u.user.name, handle);
+		if (c)
+			return standard_map(e, c->start_off);
+	}
+
+	/* Must be a module?  If not, kernel will reject... */
+	/* memset to all 0 for your memcmp convenience. */
+	memset(t->u.user.name + strlen(t->u.user.name),
+	       0,
+	       FUNCTION_MAXNAMELEN - strlen(t->u.user.name));
+	return 1;
+}
+
+static void
+unmap_target(STRUCT_ENTRY *e, STRUCT_ENTRY_TARGET *old)
+{
+	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
+
+	/* Save old target (except data, which we don't change, except for
+	   standard case, where we don't care). */
+	*t = *old;
+}
+
+/* Insert the entry `fw' in chain `chain' into position `rulenum'. */
+int
+TC_INSERT_ENTRY(const IPT_CHAINLABEL chain,
+		const STRUCT_ENTRY *e,
+		unsigned int rulenum,
+		TC_HANDLE_T *handle)
+{
+	unsigned int chainindex, offset;
+	STRUCT_ENTRY_TARGET old;
+	struct chain_cache *c;
+	STRUCT_ENTRY *tmp;
+	int ret;
+
+	iptc_fn = TC_INSERT_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+
+	tmp = index2entry(*handle, chainindex + rulenum);
+	if (!tmp || tmp > offset2entry(*handle, c->end_off)) {
+		errno = E2BIG;
+		return 0;
+	}
+	offset = index2offset(*handle, chainindex + rulenum);
+
+	/* Mapping target actually alters entry, but that's
+           transparent to the caller. */
+	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
+		return 0;
+
+	ret = insert_rules(1, e->next_offset, e, offset,
+			   chainindex + rulenum, rulenum == 0, handle);
+	unmap_target((STRUCT_ENTRY *)e, &old);
+	return ret;
+}
+
+/* Atomically replace rule `rulenum' in `chain' with `fw'. */
+int
+TC_REPLACE_ENTRY(const IPT_CHAINLABEL chain,
+		 const STRUCT_ENTRY *e,
+		 unsigned int rulenum,
+		 TC_HANDLE_T *handle)
+{
+	unsigned int chainindex, offset;
+	STRUCT_ENTRY_TARGET old;
+	struct chain_cache *c;
+	STRUCT_ENTRY *tmp;
+	int ret;
+
+	iptc_fn = TC_REPLACE_ENTRY;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+
+	tmp = index2entry(*handle, chainindex + rulenum);
+	if (!tmp || tmp >= offset2entry(*handle, c->end_off)) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	offset = index2offset(*handle, chainindex + rulenum);
+	/* Replace = delete and insert. */
+	if (!delete_rules(1, get_entry(*handle, offset)->next_offset,
+			  offset, chainindex + rulenum, handle))
+		return 0;
+
+	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
+		return 0;
+
+	ret = insert_rules(1, e->next_offset, e, offset,
+			   chainindex + rulenum, 1, handle);
+	unmap_target((STRUCT_ENTRY *)e, &old);
+	return ret;
+}
+
+/* Append entry `fw' to chain `chain'.  Equivalent to insert with
+   rulenum = length of chain. */
+int
+TC_APPEND_ENTRY(const IPT_CHAINLABEL chain,
+		const STRUCT_ENTRY *e,
+		TC_HANDLE_T *handle)
+{
+	struct chain_cache *c;
+	STRUCT_ENTRY_TARGET old;
+	int ret;
+
+	iptc_fn = TC_APPEND_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	if (!map_target(*handle, (STRUCT_ENTRY *)e,
+			c->end_off, &old))
+		return 0;
+
+	ret = insert_rules(1, e->next_offset, e, c->end_off, 
+			   offset2index(*handle, c->end_off), 0, handle);
+	unmap_target((STRUCT_ENTRY *)e, &old);
+	return ret;
+}
+
+static inline int
+match_different(const STRUCT_ENTRY_MATCH *a,
+		const unsigned char *a_elems,
+		const unsigned char *b_elems,
+		unsigned char **maskptr)
+{
+	const STRUCT_ENTRY_MATCH *b;
+	unsigned int i;
+
+	/* Offset of b is the same as a. */
+	b = (void *)b_elems + ((unsigned char *)a - a_elems);
+
+	if (a->u.match_size != b->u.match_size)
+		return 1;
+
+	if (strcmp(a->u.user.name, b->u.user.name) != 0)
+		return 1;
+
+	*maskptr += ALIGN(sizeof(*a));
+
+	for (i = 0; i < a->u.match_size - ALIGN(sizeof(*a)); i++)
+		if (((a->data[i] ^ b->data[i]) & (*maskptr)[i]) != 0)
+			return 1;
+	*maskptr += i;
+	return 0;
+}
+
+static inline int
+target_different(const unsigned char *a_targdata,
+		 const unsigned char *b_targdata,
+		 unsigned int tdatasize,
+		 const unsigned char *mask)
+{
+	unsigned int i;
+	for (i = 0; i < tdatasize; i++)
+		if (((a_targdata[i] ^ b_targdata[i]) & mask[i]) != 0)
+			return 1;
+
+	return 0;
+}
+
+static int
+is_same(const STRUCT_ENTRY *a,
+	const STRUCT_ENTRY *b,
+	unsigned char *matchmask);
+
+/* Delete the first rule in `chain' which matches `fw'. */
+int
+TC_DELETE_ENTRY(const IPT_CHAINLABEL chain,
+		const STRUCT_ENTRY *origfw,
+		unsigned char *matchmask,
+		TC_HANDLE_T *handle)
+{
+	unsigned int offset;
+	struct chain_cache *c;
+	STRUCT_ENTRY *e, *fw;
+
+	iptc_fn = TC_DELETE_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	fw = malloc(origfw->next_offset);
+	if (fw == NULL) {
+		errno = ENOMEM;
+		return 0;
+	}
+
+	for (offset = c->start_off; offset < c->end_off;
+	     offset += e->next_offset) {
+		STRUCT_ENTRY_TARGET discard;
+
+		memcpy(fw, origfw, origfw->next_offset);
+
+		/* FIXME: handle this in is_same --RR */
+		if (!map_target(*handle, fw, offset, &discard)) {
+			free(fw);
+			return 0;
+		}
+		e = get_entry(*handle, offset);
+
+#if 0
+		printf("Deleting:\n");
+		dump_entry(newe);
+#endif
+		if (is_same(e, fw, matchmask)) {
+			int ret;
+			ret = delete_rules(1, e->next_offset,
+					   offset, entry2index(*handle, e),
+					   handle);
+			free(fw);
+			return ret;
+		}
+	}
+
+	free(fw);
+	errno = ENOENT;
+	return 0;
+}
+
+/* Delete the rule in position `rulenum' in `chain'. */
+int
+TC_DELETE_NUM_ENTRY(const IPT_CHAINLABEL chain,
+		    unsigned int rulenum,
+		    TC_HANDLE_T *handle)
+{
+	unsigned int index;
+	int ret;
+	STRUCT_ENTRY *e;
+	struct chain_cache *c;
+
+	iptc_fn = TC_DELETE_NUM_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	index = offset2index(*handle, c->start_off) + rulenum;
+
+	if (index >= offset2index(*handle, c->end_off)) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	e = index2entry(*handle, index);
+	if (e == NULL) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	ret = delete_rules(1, e->next_offset, entry2offset(*handle, e),
+			   index, handle);
+	return ret;
+}
+
+/* Check the packet `fw' on chain `chain'.  Returns the verdict, or
+   NULL and sets errno. */
+const char *
+TC_CHECK_PACKET(const IPT_CHAINLABEL chain,
+		STRUCT_ENTRY *entry,
+		TC_HANDLE_T *handle)
+{
+	errno = ENOSYS;
+	return NULL;
+}
+
+/* Flushes the entries in the given chain (ie. empties chain). */
+int
+TC_FLUSH_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	unsigned int startindex, endindex;
+	STRUCT_ENTRY *startentry, *endentry;
+	struct chain_cache *c;
+	int ret;
+
+	iptc_fn = TC_FLUSH_ENTRIES;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+	startindex = offset2index(*handle, c->start_off);
+	endindex = offset2index(*handle, c->end_off);
+	startentry = offset2entry(*handle, c->start_off);
+	endentry = offset2entry(*handle, c->end_off);
+
+	ret = delete_rules(endindex - startindex,
+			   (char *)endentry - (char *)startentry,
+			   c->start_off, startindex,
+			   handle);
+	return ret;
+}
+
+/* Zeroes the counters in a chain. */
+int
+TC_ZERO_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	unsigned int i, end;
+	struct chain_cache *c;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	i = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
+
+	for (; i <= end; i++) {
+		if ((*handle)->counter_map[i].maptype ==COUNTER_MAP_NORMAL_MAP)
+			(*handle)->counter_map[i].maptype = COUNTER_MAP_ZEROED;
+	}
+	set_changed(*handle);
+
+	return 1;
+}
+
+STRUCT_COUNTERS *
+TC_READ_COUNTER(const IPT_CHAINLABEL chain,
+		unsigned int rulenum,
+		TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_cache *c;
+	unsigned int chainindex, end;
+
+	iptc_fn = TC_READ_COUNTER;
+	CHECK(*handle);
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
+
+	if (chainindex + rulenum > end) {
+		errno = E2BIG;
+		return NULL;
+	}
+
+	e = index2entry(*handle, chainindex + rulenum);
+
+	return &e->counters;
+}
+
+int
+TC_ZERO_COUNTER(const IPT_CHAINLABEL chain,
+		unsigned int rulenum,
+		TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_cache *c;
+	unsigned int chainindex, end;
+	
+	iptc_fn = TC_ZERO_COUNTER;
+	CHECK(*handle);
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
+
+	if (chainindex + rulenum > end) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	e = index2entry(*handle, chainindex + rulenum);
+
+	if ((*handle)->counter_map[chainindex + rulenum].maptype
+			== COUNTER_MAP_NORMAL_MAP) {
+		(*handle)->counter_map[chainindex + rulenum].maptype
+			 = COUNTER_MAP_ZEROED;
+	}
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+int 
+TC_SET_COUNTER(const IPT_CHAINLABEL chain,
+	       unsigned int rulenum,
+	       STRUCT_COUNTERS *counters,
+	       TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_cache *c;
+	unsigned int chainindex, end;
+
+	iptc_fn = TC_SET_COUNTER;
+	CHECK(*handle);
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
+
+	if (chainindex + rulenum > end) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	e = index2entry(*handle, chainindex + rulenum);
+
+	(*handle)->counter_map[chainindex + rulenum].maptype
+		= COUNTER_MAP_SET;
+
+	memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+/* Creates a new chain. */
+/* To create a chain, create two rules: error node and unconditional
+ * return. */
+int
+TC_CREATE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	int ret;
+	struct chainstart {
+		STRUCT_ENTRY head;
+		struct ipt_error_target name;
+	} *newc1;
+	struct chainend {
+		STRUCT_ENTRY ret;
+		STRUCT_STANDARD_TARGET target;
+	} *newc2;
+	struct chain_head *chead;
+
+	iptc_fn = TC_CREATE_CHAIN;
+
+	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
+           QUEUE, RETURN. */
+	if (find_label(chain, *handle)
+	    || strcmp(chain, LABEL_DROP) == 0
+	    || strcmp(chain, LABEL_ACCEPT) == 0
+	    || strcmp(chain, LABEL_QUEUE) == 0
+	    || strcmp(chain, LABEL_RETURN) == 0) {
+		errno = EEXIST;
+		return 0;
+	}
+
+	if (strlen(chain)+1 > sizeof(IPT_CHAINLABEL)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	chead = chainh_alloc(*handle, chain);
+	if (!chead) {
+		errno = ENOMEM;
+		return 0;
+	}
+	
+	newc1 = ruleh_alloc(sizeof(*newc1));
+	if (!newc1) {
+		chainh_free(chead);
+		return 0;
+	}
+
+	newc2 = ruleh_alloc(sizeof(*newc2));
+	if (!newc2) {
+		chainh_free(chead);
+		ruleh_free(newc1);
+		return 0;
+	}
+
+	newc1->head.target_offset = sizeof(STRUCT_ENTRY);
+	newc1->head.next_offset
+		= sizeof(STRUCT_ENTRY)
+		+ ALIGN(sizeof(struct ipt_error_target));
+	strcpy(newc1->name.t.u.user.name, ERROR_TARGET);
+	newc1->name.t.u.target_size = ALIGN(sizeof(struct ipt_error_target));
+	strcpy(newc1->name.error, chain);
+
+	newc2->ret.target_offset = sizeof(STRUCT_ENTRY);
+	newc2->ret.next_offset
+		= sizeof(STRUCT_ENTRY)
+		+ ALIGN(sizeof(STRUCT_STANDARD_TARGET));
+	strcpy(newc2->target.target.u.user.name, STANDARD_TARGET);
+	newc->target.target.u.target_size
+		= ALIGN(sizeof(STRUCT_STANDARD_TARGET));
+	newc->target.verdict = RETURN;
+
+	list_prepend(newc1, &chead->rules);
+	list_append(newc2, &chead->rules);
+
+	return 1;
+}
+
+static int
+count_ref(STRUCT_ENTRY *e, unsigned int offset, unsigned int *ref)
+{
+	STRUCT_STANDARD_TARGET *t;
+
+	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) == 0) {
+		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+
+		if (t->verdict == offset)
+			(*ref)++;
+	}
+
+	return 0;
+}
+
+/* Get the number of references to this chain. */
+int
+TC_GET_REFERENCES(unsigned int *ref, const IPT_CHAINLABEL chain,
+		  TC_HANDLE_T *handle)
+{
+	struct chain_cache *c;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	*ref = 0;
+	ENTRY_ITERATE((*handle)->entries.entrytable,
+		      (*handle)->entries.size,
+		      count_ref, c->start_off, ref);
+	return 1;
+}
+
+/* Deletes a chain. */
+int
+TC_DELETE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	unsigned int labelidx, labeloff;
+	unsigned int references;
+	struct chain_cache *c;
+	int ret;
+	STRUCT_ENTRY *start;
+
+	if (!TC_GET_REFERENCES(&references, chain, handle))
+		return 0;
+
+	iptc_fn = TC_DELETE_CHAIN;
+
+	if (TC_BUILTIN(chain, *handle)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	if (references > 0) {
+		errno = EMLINK;
+		return 0;
+	}
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	if (c->start_off != c->end_off) {
+		errno = ENOTEMPTY;
+		return 0;
+	}
+
+	/* Need label index: preceeds chain start */
+	labelidx = offset2index(*handle, c->start_off) - 1;
+	labeloff = index2offset(*handle, labelidx);
+
+	start = offset2entry(*handle, c->start_off);
+
+	ret = delete_rules(2,
+			   get_entry(*handle, labeloff)->next_offset
+			   + start->next_offset,
+			   labeloff, labelidx, handle);
+	return ret;
+}
+
+/* Renames a chain. */
+int TC_RENAME_CHAIN(const IPT_CHAINLABEL oldname,
+		    const IPT_CHAINLABEL newname,
+		    TC_HANDLE_T *handle)
+{
+	unsigned int labeloff, labelidx;
+	struct chain_cache *c;
+	struct ipt_error_target *t;
+
+	iptc_fn = TC_RENAME_CHAIN;
+
+	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
+           QUEUE, RETURN. */
+	if (find_label(newname, *handle)
+	    || strcmp(newname, LABEL_DROP) == 0
+	    || strcmp(newname, LABEL_ACCEPT) == 0
+	    || strcmp(newname, LABEL_QUEUE) == 0
+	    || strcmp(newname, LABEL_RETURN) == 0) {
+		errno = EEXIST;
+		return 0;
+	}
+
+	if (!(c = find_label(oldname, *handle))
+	    || TC_BUILTIN(oldname, *handle)) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	if (strlen(newname)+1 > sizeof(IPT_CHAINLABEL)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	/* Need label index: preceeds chain start */
+	labelidx = offset2index(*handle, c->start_off) - 1;
+	labeloff = index2offset(*handle, labelidx);
+
+	t = (struct ipt_error_target *)
+		GET_TARGET(get_entry(*handle, labeloff));
+
+	memset(t->error, 0, sizeof(t->error));
+	strcpy(t->error, newname);
+	set_changed(*handle);
+
+	return 1;
+}
+
+/* Sets the policy on a built-in chain. */
+int
+TC_SET_POLICY(const IPT_CHAINLABEL chain,
+	      const IPT_CHAINLABEL policy,
+	      STRUCT_COUNTERS *counters,
+	      TC_HANDLE_T *handle)
+{
+	unsigned int hook;
+	unsigned int policyoff, ctrindex;
+	STRUCT_ENTRY *e;
+	STRUCT_STANDARD_TARGET *t;
+
+	iptc_fn = TC_SET_POLICY;
+	/* Figure out which chain. */
+	hook = TC_BUILTIN(chain, *handle);
+	if (hook == 0) {
+		errno = ENOENT;
+		return 0;
+	} else
+		hook--;
+
+	policyoff = get_chain_end(*handle, (*handle)->info.hook_entry[hook]);
+	if (policyoff != (*handle)->info.underflow[hook]) {
+		printf("ERROR: Policy for `%s' offset %u != underflow %u\n",
+		       chain, policyoff, (*handle)->info.underflow[hook]);
+		return 0;
+	}
+
+	e = get_entry(*handle, policyoff);
+	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+
+	if (strcmp(policy, LABEL_ACCEPT) == 0)
+		t->verdict = -NF_ACCEPT - 1;
+	else if (strcmp(policy, LABEL_DROP) == 0)
+		t->verdict = -NF_DROP - 1;
+	else {
+		errno = EINVAL;
+		return 0;
+	}
+
+	ctrindex = entry2index(*handle, e);
+
+	if (counters) {
+		/* set byte and packet counters */
+		memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
+
+		(*handle)->counter_map[ctrindex].maptype
+			= COUNTER_MAP_SET;
+
+	} else {
+		(*handle)->counter_map[ctrindex]
+			= ((struct counter_map){ COUNTER_MAP_NOMAP, 0 });
+	}
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+/* Without this, on gcc 2.7.2.3, we get:
+   libiptc.c: In function `TC_COMMIT':
+   libiptc.c:833: fixed or forbidden register was spilled.
+   This may be due to a compiler bug or to impossible asm
+   statements or clauses.
+*/
+static void
+subtract_counters(STRUCT_COUNTERS *answer,
+		  const STRUCT_COUNTERS *a,
+		  const STRUCT_COUNTERS *b)
+{
+	answer->pcnt = a->pcnt - b->pcnt;
+	answer->bcnt = a->bcnt - b->bcnt;
+}
+
+int
+TC_COMMIT(TC_HANDLE_T *handle)
+{
+	/* Replace, then map back the counters. */
+	STRUCT_REPLACE *repl;
+	STRUCT_COUNTERS_INFO *newcounters;
+	unsigned int i;
+	size_t counterlen;
+
+	CHECK(*handle);
+
+	counterlen = sizeof(STRUCT_COUNTERS_INFO)
+			+ sizeof(STRUCT_COUNTERS) * (*handle)->new_number;
+
+#if 0
+	TC_DUMP_ENTRIES(*handle);
+#endif
+
+	/* Don't commit if nothing changed. */
+	if (!(*handle)->changed)
+		goto finished;
+
+	repl = malloc(sizeof(*repl) + (*handle)->entries.size);
+	if (!repl) {
+		errno = ENOMEM;
+		return 0;
+	}
+
+	/* These are the old counters we will get from kernel */
+	repl->counters = malloc(sizeof(STRUCT_COUNTERS)
+				* (*handle)->info.num_entries);
+	if (!repl->counters) {
+		free(repl);
+		errno = ENOMEM;
+		return 0;
+	}
+
+	/* These are the counters we're going to put back, later. */
+	newcounters = malloc(counterlen);
+	if (!newcounters) {
+		free(repl->counters);
+		free(repl);
+		errno = ENOMEM;
+		return 0;
+	}
+
+	strcpy(repl->name, (*handle)->info.name);
+	repl->num_entries = (*handle)->new_number;
+	repl->size = (*handle)->entries.size;
+	memcpy(repl->hook_entry, (*handle)->info.hook_entry,
+	       sizeof(repl->hook_entry));
+	memcpy(repl->underflow, (*handle)->info.underflow,
+	       sizeof(repl->underflow));
+	repl->num_counters = (*handle)->info.num_entries;
+	repl->valid_hooks = (*handle)->info.valid_hooks;
+	memcpy(repl->entries, (*handle)->entries.entrytable,
+	       (*handle)->entries.size);
+
+	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_REPLACE, repl,
+		       sizeof(*repl) + (*handle)->entries.size) < 0) {
+		free(repl->counters);
+		free(repl);
+		free(newcounters);
+		return 0;
+	}
+
+	/* Put counters back. */
+	strcpy(newcounters->name, (*handle)->info.name);
+	newcounters->num_counters = (*handle)->new_number;
+	for (i = 0; i < (*handle)->new_number; i++) {
+		unsigned int mappos = (*handle)->counter_map[i].mappos;
+		switch ((*handle)->counter_map[i].maptype) {
+		case COUNTER_MAP_NOMAP:
+			newcounters->counters[i]
+				= ((STRUCT_COUNTERS){ 0, 0 });
+			break;
+
+		case COUNTER_MAP_NORMAL_MAP:
+			/* Original read: X.
+			 * Atomic read on replacement: X + Y.
+			 * Currently in kernel: Z.
+			 * Want in kernel: X + Y + Z.
+			 * => Add in X + Y
+			 * => Add in replacement read.
+			 */
+			newcounters->counters[i] = repl->counters[mappos];
+			break;
+
+		case COUNTER_MAP_ZEROED:
+			/* Original read: X.
+			 * Atomic read on replacement: X + Y.
+			 * Currently in kernel: Z.
+			 * Want in kernel: Y + Z.
+			 * => Add in Y.
+			 * => Add in (replacement read - original read).
+			 */
+			subtract_counters(&newcounters->counters[i],
+					  &repl->counters[mappos],
+					  &index2entry(*handle, i)->counters);
+			break;
+
+		case COUNTER_MAP_SET:
+			/* Want to set counter (iptables-restore) */
+
+			memcpy(&newcounters->counters[i],
+			       &index2entry(*handle, i)->counters,
+			       sizeof(STRUCT_COUNTERS));
+
+			break;
+		}
+	}
+
+#ifdef KERNEL_64_USERSPACE_32
+	{
+		/* Kernel will think that pointer should be 64-bits, and get
+		   padding.  So we accomodate here (assumption: alignment of
+		   `counters' is on 64-bit boundary). */
+		u_int64_t *kernptr = (u_int64_t *)&newcounters->counters;
+		if ((unsigned long)&newcounters->counters % 8 != 0) {
+			fprintf(stderr,
+				"counters alignment incorrect! Mail rusty!\n");
+			abort();
+		}
+		*kernptr = newcounters->counters;
+	}
+#endif /* KERNEL_64_USERSPACE_32 */
+
+	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_ADD_COUNTERS,
+		       newcounters, counterlen) < 0) {
+		free(repl->counters);
+		free(repl);
+		free(newcounters);
+		return 0;
+	}
+
+	free(repl->counters);
+	free(repl);
+	free(newcounters);
+
+ finished:
+	TC_FREE(handle);
+	return 1;
+}
+
+/* Get raw socket. */
+int
+TC_GET_RAW_SOCKET()
+{
+	return sockfd;
+}
+
+/* Translates errno numbers into more human-readable form than strerror. */
+const char *
+TC_STRERROR(int err)
+{
+	unsigned int i;
+	struct table_struct {
+		void *fn;
+		int err;
+		const char *message;
+	} table [] =
+	  { { TC_INIT, EPERM, "Permission denied (you must be root)" },
+	    { TC_INIT, EINVAL, "Module is wrong version" },
+	    { TC_INIT, ENOENT, 
+		    "Table does not exist (do you need to insmod?)" },
+	    { TC_DELETE_CHAIN, ENOTEMPTY, "Chain is not empty" },
+	    { TC_DELETE_CHAIN, EINVAL, "Can't delete built-in chain" },
+	    { TC_DELETE_CHAIN, EMLINK,
+	      "Can't delete chain with references left" },
+	    { TC_CREATE_CHAIN, EEXIST, "Chain already exists" },
+	    { TC_INSERT_ENTRY, E2BIG, "Index of insertion too big" },
+	    { TC_REPLACE_ENTRY, E2BIG, "Index of replacement too big" },
+	    { TC_DELETE_NUM_ENTRY, E2BIG, "Index of deletion too big" },
+	    { TC_READ_COUNTER, E2BIG, "Index of counter too big" },
+	    { TC_ZERO_COUNTER, E2BIG, "Index of counter too big" },
+	    { TC_INSERT_ENTRY, ELOOP, "Loop found in table" },
+	    { TC_INSERT_ENTRY, EINVAL, "Target problem" },
+	    /* EINVAL for CHECK probably means bad interface. */
+	    { TC_CHECK_PACKET, EINVAL,
+	      "Bad arguments (does that interface exist?)" },
+	    { TC_CHECK_PACKET, ENOSYS,
+	      "Checking will most likely never get implemented" },
+	    /* ENOENT for DELETE probably means no matching rule */
+	    { TC_DELETE_ENTRY, ENOENT,
+	      "Bad rule (does a matching rule exist in that chain?)" },
+	    { TC_SET_POLICY, ENOENT,
+	      "Bad built-in chain name" },
+	    { TC_SET_POLICY, EINVAL,
+	      "Bad policy name" },
+
+	    { NULL, 0, "Incompatible with this kernel" },
+	    { NULL, ENOPROTOOPT, "iptables who? (do you need to insmod?)" },
+	    { NULL, ENOSYS, "Will be implemented real soon.  I promise ;)" },
+	    { NULL, ENOMEM, "Memory allocation problem" },
+	    { NULL, ENOENT, "No chain/target/match by that name" },
+	  };
+
+	for (i = 0; i < sizeof(table)/sizeof(struct table_struct); i++) {
+		if ((!table[i].fn || table[i].fn == iptc_fn)
+		    && table[i].err == err)
+			return table[i].message;
+	}
+
+	return strerror(err);
+}
diff -urN iptables-1.2.8/libiptc2/foo.diff iptables-1.2.9/libiptc2/foo.diff
--- iptables-1.2.8/libiptc2/foo.diff	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/libiptc2/foo.diff	2003-06-30 19:13:13.000000000 +0200
@@ -0,0 +1,391 @@
+--- libiptc.c	2003-06-30 18:26:59.000000000 +0200
++++ libiptc.c	2003-06-30 18:27:24.000000000 +0200
+@@ -64,19 +61,35 @@
+ 	char error[TABLE_MAXNAMELEN];
+ };
+ 
+-struct chain_cache
++struct rule_head
+ {
++	struct list_head list;
++	
++	struct chain_head *chain;
++
++	unsigned int size;
++	STRUCT_ENTRY entry[0];
++}
++
++struct chain_head
++{
++	struct list_head list;
++
+ 	char name[TABLE_MAXNAMELEN];
+-	/* This is the first rule in chain. */
+-	unsigned int start_off;
+-	/* Last rule in chain */
+-	unsigned int end_off;
++	unsigned int hooknum;
++	struct list_head rules;
+ };
+ 
+ STRUCT_TC_HANDLE
+ {
+ 	/* Have changes been made? */
+ 	int changed;
++
++	struct list_head chains;
++	
++	struct chain_head *chain_iterator_cur;
++
++#if 0
+ 	/* Size in here reflects original state. */
+ 	STRUCT_GETINFO info;
+ 
+@@ -98,6 +111,7 @@
+ 	/* Number in here reflects current state. */
+ 	unsigned int new_number;
+ 	STRUCT_GET_ENTRIES entries;
++#endif
+ };
+ 
+ static void
+@@ -375,173 +389,25 @@
+ 	}
+ 	return 0;
+ }
+-
+-static inline int
+-add_chain(STRUCT_ENTRY *e, TC_HANDLE_T h, STRUCT_ENTRY **prev)
+-{
+-	unsigned int builtin;
+-
+-	/* Last entry.  End it. */
+-	if (entry2offset(h, e) + e->next_offset == h->entries.size) {
+-		/* This is the ERROR node at end of the table */
+-		h->cache_chain_heads[h->cache_num_chains-1].end_off = 
+-			entry2offset(h, *prev);
+-		return 0;
+-	}
+-
+-	/* We know this is the start of a new chain if it's an ERROR
+-	   target, or a hook entry point */
+-	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) == 0) {
+-		/* prev was last entry in previous chain */
+-		h->cache_chain_heads[h->cache_num_chains-1].end_off
+-			= entry2offset(h, *prev);
+-
+-		strcpy(h->cache_chain_heads[h->cache_num_chains].name,
+-		       (const char *)GET_TARGET(e)->data);
+-		h->cache_chain_heads[h->cache_num_chains].start_off
+-			= entry2offset(h, (void *)e + e->next_offset);
+-		h->cache_num_chains++;
+-	} else if ((builtin = is_hook_entry(e, h)) != 0) {
+-		if (h->cache_num_chains > 0)
+-			/* prev was last entry in previous chain */
+-			h->cache_chain_heads[h->cache_num_chains-1].end_off
+-				= entry2offset(h, *prev);
+-
+-		strcpy(h->cache_chain_heads[h->cache_num_chains].name,
+-		       h->hooknames[builtin-1]);
+-		h->cache_chain_heads[h->cache_num_chains].start_off
+-			= entry2offset(h, (void *)e);
+-		h->cache_num_chains++;
+-	}
+-
+-	*prev = e;
+-	return 0;
+-}
+-
+ static int alphasort(const void *a, const void *b)
+ {
+ 	return strcmp(((struct chain_cache *)a)->name,
+ 		      ((struct chain_cache *)b)->name);
+ }
+ 
+-static int populate_cache(TC_HANDLE_T h)
+-{
+-	unsigned int i;
+-	STRUCT_ENTRY *prev;
+-
+-	/* # chains < # rules / 2 + num builtins - 1 */
+-	h->cache_chain_heads = malloc((h->new_number / 2 + 4)
+-				      * sizeof(struct chain_cache));
+-	if (!h->cache_chain_heads) {
+-		errno = ENOMEM;
+-		return 0;
+-	}
+-
+-	h->cache_num_chains = 0;
+-	h->cache_num_builtins = 0;
+-
+-	/* Count builtins */
+-	for (i = 0; i < NUMHOOKS; i++) {
+-		if (h->info.valid_hooks & (1 << i))
+-			h->cache_num_builtins++;
+-	}
+-
+-	prev = NULL;
+-	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+-		      add_chain, h, &prev);
+-
+-	qsort(h->cache_chain_heads + h->cache_num_builtins,
+-	      h->cache_num_chains - h->cache_num_builtins,
+-	      sizeof(struct chain_cache), alphasort);
+-
+-	return 1;
+-}
+-
+-static int 
+-correct_cache(TC_HANDLE_T h, unsigned int offset, int delta)
+-{
+-	int i;		/* needs to be signed because deleting first
+-			   chain can make it drop to -1 */
+-
+-	if (!delta)
+-		return 1;
+-
+-	for (i = 0; i < h->cache_num_chains; i++) {
+-		struct chain_cache *cc = &h->cache_chain_heads[i];
+-
+-		if (delta < 0) {
+-			/* take care about deleted chains */
+-			if (cc->start_off >= offset+delta
+-			    && cc->end_off <= offset) {
+-				/* this chain is within the deleted range,
+-				 * let's remove it from the cache */
+-				void *start;
+-				unsigned int size;
+-
+-				h->cache_num_chains--;
+-				if (i+1 >= h->cache_num_chains)
+-					continue;
+-				start = &h->cache_chain_heads[i+1];
+-				size = (h->cache_num_chains-i)
+-					* sizeof(struct chain_cache);
+-				memmove(cc, start, size);
+-
+-				/* iterate over same index again, since
+-				 * it is now a different chain */
+-				i--;
+-				continue;
+-			}
+-		}
+-
+-		if (cc->start_off > offset)
+-			cc->start_off += delta;
+-
+-		if (cc->end_off >= offset)
+-			cc->end_off += delta;
+-	}
+-	/* HW_FIXME: sorting might be needed, but just in case a new chain was
+-	 * added */
+-
+-	return 1;
+-}
+-
+-static int
+-add_chain_cache(TC_HANDLE_T h, const char *name, unsigned int start_off,
+-		unsigned int end_off)
+-{
+-	struct chain_cache *ccs = realloc(h->cache_chain_heads, 
+-					  (h->new_number / 2 + 4 + 1)
+-					   * sizeof(struct chain_cache));
+-	struct chain_cache *newcc;
+-	
+-	if (!ccs)
+-		return 0;
+-
+-	h->cache_chain_heads = ccs;
+-	newcc = &h->cache_chain_heads[h->cache_num_chains];
+-	h->cache_num_chains++;
+-
+-	strncpy(newcc->name, name, TABLE_MAXNAMELEN-1);
+-	newcc->start_off = start_off;
+-	newcc->end_off = end_off;
+-
+-	return 1;
+-}
+-
+-/* Returns cache ptr if found, otherwise NULL. */
+-static struct chain_cache *
++/* Returns chain head if found, otherwise NULL. */
++static struct chain_head *
+ find_label(const char *name, TC_HANDLE_T handle)
+ {
+-	unsigned int i;
++	struct list_head *pos;
+ 
+-	if (handle->cache_chain_heads == NULL
+-	    && !populate_cache(handle))
++	if (!handle->chains)
+ 		return NULL;
+ 
+-	/* FIXME: Linear search through builtins, then binary --RR */
+-	for (i = 0; i < handle->cache_num_chains; i++) {
+-		if (strcmp(handle->cache_chain_heads[i].name, name) == 0)
+-			return &handle->cache_chain_heads[i];
++	list_for_each(pos, &handle->chains) {
++		struct chain_head *c = list_entry(pos, struct chain_head, list);
++		if (!strcmp(c->name, name))
++			return c;
+ 	}
+ 
+ 	return NULL;
+@@ -594,34 +460,30 @@
+ const char *
+ TC_FIRST_CHAIN(TC_HANDLE_T *handle)
+ {
+-	if ((*handle)->cache_chain_heads == NULL
+-	    && !populate_cache(*handle))
+-		return NULL;
++	(*handle)->chain_iterator_cur = (*handle)->chains;
+ 
+-	(*handle)->cache_chain_iteration
+-		= &(*handle)->cache_chain_heads[0];
+-
+-	return (*handle)->cache_chain_iteration->name;
++	return (*handle)->chains.name;
+ }
+ 
+ /* Iterator functions to run through the chains.  Returns NULL at end. */
+ const char *
+ TC_NEXT_CHAIN(TC_HANDLE_T *handle)
+ {
+-	(*handle)->cache_chain_iteration++;
++	struct chain_head *next = list_entry(&(*handle)->chain_iterator_cur->list.next, struct chain_head, list);
++	(*handle)->chain_iterator_cur = next;
+ 
+-	if ((*handle)->cache_chain_iteration - (*handle)->cache_chain_heads
+-	    == (*handle)->cache_num_chains)
++	if (next == (*handle)->chains)
+ 		return NULL;
+ 
+-	return (*handle)->cache_chain_iteration->name;
++	return next->name;
+ }
+ 
+ /* Get first rule in the given chain: NULL for empty chain. */
+ const STRUCT_ENTRY *
+ TC_FIRST_RULE(const char *chain, TC_HANDLE_T *handle)
+ {
+-	struct chain_cache *c;
++	struct chain_head *c;
++	struct rule_head *r;
+ 
+ 	c = find_label(chain, *handle);
+ 	if (!c) {
+@@ -630,22 +492,26 @@
+ 	}
+ 
+ 	/* Empty chain: single return/policy rule */
+-	if (c->start_off == c->end_off)
++	if (list_empty(c->rules))
+ 		return NULL;
+ 
+-	(*handle)->cache_rule_end = offset2entry(*handle, c->end_off);
+-	return offset2entry(*handle, c->start_off);
++	r = list_entry(&c->rules.next, struct rule_head, list);
++	(*handle)->rule_iterator_cur = r;
++
++	return r->entry;
+ }
+ 
+ /* Returns NULL when rules run out. */
+ const STRUCT_ENTRY *
+ TC_NEXT_RULE(const STRUCT_ENTRY *prev, TC_HANDLE_T *handle)
+ {
+-	if ((void *)prev + prev->next_offset
+-	    == (void *)(*handle)->cache_rule_end)
++	struct rule_head *r = list_entry((*handle)->rule_iterator_cur->list.next, struct rule_head, list);
++
++	if (r == r->chain)
+ 		return NULL;
+ 
+-	return (void *)prev + prev->next_offset;
++	/* NOTE: prev is without any influence ! */
++	return r->entry;
+ }
+ 
+ #if 0
+@@ -773,7 +639,7 @@
+ 	return target_name(*handle, e);
+ }
+ 
+-static inline int
++static int
+ correct_verdict(STRUCT_ENTRY *e,
+ 		char *base,
+ 		unsigned int offset, int delta_offset)
+@@ -874,16 +740,8 @@
+ 	newh->entries.size = (*handle)->entries.size + rules_size;
+ 	newh->hooknames = (*handle)->hooknames;
+ 
+-	newh->cache_chain_heads = (*handle)->cache_chain_heads;
+-	newh->cache_num_builtins = (*handle)->cache_num_builtins;
+-	newh->cache_num_chains = (*handle)->cache_num_chains;
+-	newh->cache_rule_end = (*handle)->cache_rule_end;
+-	newh->cache_chain_iteration = (*handle)->cache_chain_iteration;
+-	if (!correct_cache(newh, offset, rules_size)) {
+-		free(newh);
+-		return 0;
+-	}
+-
++	if ((*handle)->cache_chain_heads)
++		free((*handle)->cache_chain_heads);
+ 	free(*handle);
+ 	*handle = newh;
+ 
+@@ -942,10 +800,6 @@
+ 	(*handle)->new_number -= num_rules;
+ 	(*handle)->entries.size -= rules_size;
+ 
+-	/* Fix the chain cache */
+-	if (!correct_cache(*handle, offset, -(int)rules_size))
+-		return 0;
+-
+ 	return set_verdict(offset, -(int)rules_size, handle);
+ }
+ 
+@@ -1449,7 +1303,6 @@
+ 		STRUCT_ENTRY ret;
+ 		STRUCT_STANDARD_TARGET target;
+ 	} newc;
+-	unsigned int destination;
+ 
+ 	iptc_fn = TC_CREATE_CHAIN;
+ 
+@@ -1487,21 +1340,11 @@
+ 		= ALIGN(sizeof(STRUCT_STANDARD_TARGET));
+ 	newc.target.verdict = RETURN;
+ 
+-	destination = index2offset(*handle, (*handle)->new_number -1);
+-
+ 	/* Add just before terminal entry */
+ 	ret = insert_rules(2, sizeof(newc), &newc.head,
+-			   destination,
++			   index2offset(*handle, (*handle)->new_number - 1),
+ 			   (*handle)->new_number - 1,
+ 			   0, handle);
+-
+-	set_changed(*handle);
+-
+-	/* add chain cache info for this chain */
+-	add_chain_cache(*handle, chain, 
+-			destination+newc.head.next_offset, 
+-			destination+newc.head.next_offset);
+-
+ 	return ret;
+ }
+ 
+@@ -1629,11 +1472,6 @@
+ 
+ 	memset(t->error, 0, sizeof(t->error));
+ 	strcpy(t->error, newname);
+-
+-	/* update chain cache */
+-	memset(c->name, 0, sizeof(c->name));
+-	strcpy(c->name, newname);
+-
+ 	set_changed(*handle);
+ 
+ 	return 1;
diff -urN iptables-1.2.8/libiptc2/libip4tc.c iptables-1.2.9/libiptc2/libip4tc.c
--- iptables-1.2.8/libiptc2/libip4tc.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/libiptc2/libip4tc.c	2003-05-03 20:52:15.000000000 +0200
@@ -0,0 +1,507 @@
+/* Library which manipulates firewall rules.  Version 0.1. */
+
+/* Architecture of firewall rules is as follows:
+ *
+ * Chains go INPUT, FORWARD, OUTPUT then user chains.
+ * Each user chain starts with an ERROR node.
+ * Every chain ends with an unconditional jump: a RETURN for user chains,
+ * and a POLICY for built-ins.
+ */
+
+/* (C)1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
+   COPYING for details). */
+
+#include <assert.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#ifdef DEBUG_CONNTRACK
+#define inline
+#endif
+
+#if !defined(__GLIBC__) || (__GLIBC__ < 2)
+typedef unsigned int socklen_t;
+#endif
+
+#include "libiptc/libiptc.h"
+
+#define IP_VERSION	4
+#define IP_OFFSET	0x1FFF
+
+#define HOOK_PRE_ROUTING	NF_IP_PRE_ROUTING
+#define HOOK_LOCAL_IN		NF_IP_LOCAL_IN
+#define HOOK_FORWARD		NF_IP_FORWARD
+#define HOOK_LOCAL_OUT		NF_IP_LOCAL_OUT
+#define HOOK_POST_ROUTING	NF_IP_POST_ROUTING
+#ifdef NF_IP_DROPPING
+#define HOOK_DROPPING		NF_IP_DROPPING
+#endif
+
+#define STRUCT_ENTRY_TARGET	struct ipt_entry_target
+#define STRUCT_ENTRY		struct ipt_entry
+#define STRUCT_ENTRY_MATCH	struct ipt_entry_match
+#define STRUCT_GETINFO		struct ipt_getinfo
+#define STRUCT_GET_ENTRIES	struct ipt_get_entries
+#define STRUCT_COUNTERS		struct ipt_counters
+#define STRUCT_COUNTERS_INFO	struct ipt_counters_info
+#define STRUCT_STANDARD_TARGET	struct ipt_standard_target
+#define STRUCT_REPLACE		struct ipt_replace
+
+#define STRUCT_TC_HANDLE	struct iptc_handle
+#define TC_HANDLE_T		iptc_handle_t
+
+#define ENTRY_ITERATE		IPT_ENTRY_ITERATE
+#define TABLE_MAXNAMELEN	IPT_TABLE_MAXNAMELEN
+#define FUNCTION_MAXNAMELEN	IPT_FUNCTION_MAXNAMELEN
+
+#define GET_TARGET		ipt_get_target
+
+#define ERROR_TARGET		IPT_ERROR_TARGET
+#define NUMHOOKS		NF_IP_NUMHOOKS
+
+#define IPT_CHAINLABEL		ipt_chainlabel
+
+#define TC_DUMP_ENTRIES		dump_entries
+#define TC_IS_CHAIN		iptc_is_chain
+#define TC_FIRST_CHAIN		iptc_first_chain
+#define TC_NEXT_CHAIN		iptc_next_chain
+#define TC_FIRST_RULE		iptc_first_rule
+#define TC_NEXT_RULE		iptc_next_rule
+#define TC_GET_TARGET		iptc_get_target
+#define TC_BUILTIN		iptc_builtin
+#define TC_GET_POLICY		iptc_get_policy
+#define TC_INSERT_ENTRY		iptc_insert_entry
+#define TC_REPLACE_ENTRY	iptc_replace_entry
+#define TC_APPEND_ENTRY		iptc_append_entry
+#define TC_DELETE_ENTRY		iptc_delete_entry
+#define TC_DELETE_NUM_ENTRY	iptc_delete_num_entry
+#define TC_CHECK_PACKET		iptc_check_packet
+#define TC_FLUSH_ENTRIES	iptc_flush_entries
+#define TC_ZERO_ENTRIES		iptc_zero_entries
+#define TC_READ_COUNTER		iptc_read_counter
+#define TC_ZERO_COUNTER		iptc_zero_counter
+#define TC_SET_COUNTER		iptc_set_counter
+#define TC_CREATE_CHAIN		iptc_create_chain
+#define TC_GET_REFERENCES	iptc_get_references
+#define TC_DELETE_CHAIN		iptc_delete_chain
+#define TC_RENAME_CHAIN		iptc_rename_chain
+#define TC_SET_POLICY		iptc_set_policy
+#define TC_GET_RAW_SOCKET	iptc_get_raw_socket
+#define TC_INIT			iptc_init
+#define TC_FREE			iptc_free
+#define TC_COMMIT		iptc_commit
+#define TC_STRERROR		iptc_strerror
+
+#define TC_AF			AF_INET
+#define TC_IPPROTO		IPPROTO_IP
+
+#define SO_SET_REPLACE		IPT_SO_SET_REPLACE
+#define SO_SET_ADD_COUNTERS	IPT_SO_SET_ADD_COUNTERS
+#define SO_GET_INFO		IPT_SO_GET_INFO
+#define SO_GET_ENTRIES		IPT_SO_GET_ENTRIES
+#define SO_GET_VERSION		IPT_SO_GET_VERSION
+
+#define STANDARD_TARGET		IPT_STANDARD_TARGET
+#define LABEL_RETURN		IPTC_LABEL_RETURN
+#define LABEL_ACCEPT		IPTC_LABEL_ACCEPT
+#define LABEL_DROP		IPTC_LABEL_DROP
+#define LABEL_QUEUE		IPTC_LABEL_QUEUE
+
+#define ALIGN			IPT_ALIGN
+#define RETURN			IPT_RETURN
+
+#include "libiptc.c"
+
+#define IP_PARTS_NATIVE(n)			\
+(unsigned int)((n)>>24)&0xFF,			\
+(unsigned int)((n)>>16)&0xFF,			\
+(unsigned int)((n)>>8)&0xFF,			\
+(unsigned int)((n)&0xFF)
+
+#define IP_PARTS(n) IP_PARTS_NATIVE(ntohl(n))
+
+int
+dump_entry(STRUCT_ENTRY *e, const TC_HANDLE_T handle)
+{
+	size_t i;
+	STRUCT_ENTRY_TARGET *t;
+
+	printf("Entry %u (%lu):\n", entry2index(handle, e),
+	       entry2offset(handle, e));
+	printf("SRC IP: %u.%u.%u.%u/%u.%u.%u.%u\n",
+	       IP_PARTS(e->ip.src.s_addr),IP_PARTS(e->ip.smsk.s_addr));
+	printf("DST IP: %u.%u.%u.%u/%u.%u.%u.%u\n",
+	       IP_PARTS(e->ip.dst.s_addr),IP_PARTS(e->ip.dmsk.s_addr));
+	printf("Interface: `%s'/", e->ip.iniface);
+	for (i = 0; i < IFNAMSIZ; i++)
+		printf("%c", e->ip.iniface_mask[i] ? 'X' : '.');
+	printf("to `%s'/", e->ip.outiface);
+	for (i = 0; i < IFNAMSIZ; i++)
+		printf("%c", e->ip.outiface_mask[i] ? 'X' : '.');
+	printf("\nProtocol: %u\n", e->ip.proto);
+	printf("Flags: %02X\n", e->ip.flags);
+	printf("Invflags: %02X\n", e->ip.invflags);
+	printf("Counters: %llu packets, %llu bytes\n",
+	       e->counters.pcnt, e->counters.bcnt);
+	printf("Cache: %08X ", e->nfcache);
+	if (e->nfcache & NFC_ALTERED) printf("ALTERED ");
+	if (e->nfcache & NFC_UNKNOWN) printf("UNKNOWN ");
+	if (e->nfcache & NFC_IP_SRC) printf("IP_SRC ");
+	if (e->nfcache & NFC_IP_DST) printf("IP_DST ");
+	if (e->nfcache & NFC_IP_IF_IN) printf("IP_IF_IN ");
+	if (e->nfcache & NFC_IP_IF_OUT) printf("IP_IF_OUT ");
+	if (e->nfcache & NFC_IP_TOS) printf("IP_TOS ");
+	if (e->nfcache & NFC_IP_PROTO) printf("IP_PROTO ");
+	if (e->nfcache & NFC_IP_OPTIONS) printf("IP_OPTIONS ");
+	if (e->nfcache & NFC_IP_TCPFLAGS) printf("IP_TCPFLAGS ");
+	if (e->nfcache & NFC_IP_SRC_PT) printf("IP_SRC_PT ");
+	if (e->nfcache & NFC_IP_DST_PT) printf("IP_DST_PT ");
+	if (e->nfcache & NFC_IP_PROTO_UNKNOWN) printf("IP_PROTO_UNKNOWN ");
+	printf("\n");
+
+	IPT_MATCH_ITERATE(e, print_match);
+
+	t = GET_TARGET(e);
+	printf("Target name: `%s' [%u]\n", t->u.user.name, t->u.target_size);
+	if (strcmp(t->u.user.name, STANDARD_TARGET) == 0) {
+		int pos = *(int *)t->data;
+		if (pos < 0)
+			printf("verdict=%s\n",
+			       pos == -NF_ACCEPT-1 ? "NF_ACCEPT"
+			       : pos == -NF_DROP-1 ? "NF_DROP"
+			       : pos == -NF_QUEUE-1 ? "NF_QUEUE"
+			       : pos == RETURN ? "RETURN"
+			       : "UNKNOWN");
+		else
+			printf("verdict=%u\n", pos);
+	} else if (strcmp(t->u.user.name, IPT_ERROR_TARGET) == 0)
+		printf("error=`%s'\n", t->data);
+
+	printf("\n");
+	return 0;
+}
+
+static int
+is_same(const STRUCT_ENTRY *a, const STRUCT_ENTRY *b, unsigned char *matchmask)
+{
+	unsigned int i;
+	STRUCT_ENTRY_TARGET *ta, *tb;
+	unsigned char *mptr;
+
+	/* Always compare head structures: ignore mask here. */
+	if (a->ip.src.s_addr != b->ip.src.s_addr
+	    || a->ip.dst.s_addr != b->ip.dst.s_addr
+	    || a->ip.smsk.s_addr != b->ip.smsk.s_addr
+	    || a->ip.dmsk.s_addr != b->ip.dmsk.s_addr
+	    || a->ip.proto != b->ip.proto
+	    || a->ip.flags != b->ip.flags
+	    || a->ip.invflags != b->ip.invflags)
+		return 0;
+
+	for (i = 0; i < IFNAMSIZ; i++) {
+		if (a->ip.iniface_mask[i] != b->ip.iniface_mask[i])
+			return 0;
+		if ((a->ip.iniface[i] & a->ip.iniface_mask[i])
+		    != (b->ip.iniface[i] & b->ip.iniface_mask[i]))
+			return 0;
+		if (a->ip.outiface_mask[i] != b->ip.outiface_mask[i])
+			return 0;
+		if ((a->ip.outiface[i] & a->ip.outiface_mask[i])
+		    != (b->ip.outiface[i] & b->ip.outiface_mask[i]))
+			return 0;
+	}
+
+	if (a->nfcache != b->nfcache
+	    || a->target_offset != b->target_offset
+	    || a->next_offset != b->next_offset)
+		return 0;
+
+	mptr = matchmask + sizeof(STRUCT_ENTRY);
+	if (IPT_MATCH_ITERATE(a, match_different, a->elems, b->elems, &mptr))
+		return 0;
+
+	ta = GET_TARGET((STRUCT_ENTRY *)a);
+	tb = GET_TARGET((STRUCT_ENTRY *)b);
+	if (ta->u.target_size != tb->u.target_size)
+		return 0;
+	if (strcmp(ta->u.user.name, tb->u.user.name) != 0)
+		return 0;
+
+	mptr += sizeof(*ta);
+	if (target_different(ta->data, tb->data,
+			     ta->u.target_size - sizeof(*ta), mptr))
+		return 0;
+
+   	return 1;
+}
+
+/***************************** DEBUGGING ********************************/
+static inline int
+unconditional(const struct ipt_ip *ip)
+{
+	unsigned int i;
+
+	for (i = 0; i < sizeof(*ip)/sizeof(u_int32_t); i++)
+		if (((u_int32_t *)ip)[i])
+			return 0;
+
+	return 1;
+}
+
+static inline int
+check_match(const STRUCT_ENTRY_MATCH *m, unsigned int *off)
+{
+	assert(m->u.match_size >= sizeof(STRUCT_ENTRY_MATCH));
+	assert(ALIGN(m->u.match_size) == m->u.match_size);
+
+	(*off) += m->u.match_size;
+	return 0;
+}
+
+static inline int
+check_entry(const STRUCT_ENTRY *e, unsigned int *i, unsigned int *off,
+	    unsigned int user_offset, int *was_return,
+	    TC_HANDLE_T h)
+{
+	unsigned int toff;
+	STRUCT_STANDARD_TARGET *t;
+
+	assert(e->target_offset >= sizeof(STRUCT_ENTRY));
+	assert(e->next_offset >= e->target_offset
+	       + sizeof(STRUCT_ENTRY_TARGET));
+	toff = sizeof(STRUCT_ENTRY);
+	IPT_MATCH_ITERATE(e, check_match, &toff);
+
+	assert(toff == e->target_offset);
+
+	t = (STRUCT_STANDARD_TARGET *)
+		GET_TARGET((STRUCT_ENTRY *)e);
+	/* next_offset will have to be multiple of entry alignment. */
+	assert(e->next_offset == ALIGN(e->next_offset));
+	assert(e->target_offset == ALIGN(e->target_offset));
+	assert(t->target.u.target_size == ALIGN(t->target.u.target_size));
+	assert(!TC_IS_CHAIN(t->target.u.user.name, h));
+
+	if (strcmp(t->target.u.user.name, STANDARD_TARGET) == 0) {
+		assert(t->target.u.target_size
+		       == ALIGN(sizeof(STRUCT_STANDARD_TARGET)));
+
+		assert(t->verdict == -NF_DROP-1
+		       || t->verdict == -NF_ACCEPT-1
+		       || t->verdict == RETURN
+		       || t->verdict < (int)h->entries.size);
+
+		if (t->verdict >= 0) {
+			STRUCT_ENTRY *te = get_entry(h, t->verdict);
+			int idx;
+
+			idx = entry2index(h, te);
+			assert(strcmp(GET_TARGET(te)->u.user.name,
+				      IPT_ERROR_TARGET)
+			       != 0);
+			assert(te != e);
+
+			/* Prior node must be error node, or this node. */
+			assert(t->verdict == entry2offset(h, e)+e->next_offset
+			       || strcmp(GET_TARGET(index2entry(h, idx-1))
+					 ->u.user.name, IPT_ERROR_TARGET)
+			       == 0);
+		}
+
+		if (t->verdict == RETURN
+		    && unconditional(&e->ip)
+		    && e->target_offset == sizeof(*e))
+			*was_return = 1;
+		else
+			*was_return = 0;
+	} else if (strcmp(t->target.u.user.name, IPT_ERROR_TARGET) == 0) {
+		assert(t->target.u.target_size
+		       == ALIGN(sizeof(struct ipt_error_target)));
+
+		/* If this is in user area, previous must have been return */
+		if (*off > user_offset)
+			assert(*was_return);
+
+		*was_return = 0;
+	}
+	else *was_return = 0;
+
+	if (*off == user_offset)
+		assert(strcmp(t->target.u.user.name, IPT_ERROR_TARGET) == 0);
+
+	(*off) += e->next_offset;
+	(*i)++;
+	return 0;
+}
+
+#ifdef IPTC_DEBUG
+/* Do every conceivable sanity check on the handle */
+static void
+do_check(TC_HANDLE_T h, unsigned int line)
+{
+	unsigned int i, n;
+	unsigned int user_offset; /* Offset of first user chain */
+	int was_return;
+
+	assert(h->changed == 0 || h->changed == 1);
+	if (strcmp(h->info.name, "filter") == 0) {
+		assert(h->info.valid_hooks
+		       == (1 << NF_IP_LOCAL_IN
+			   | 1 << NF_IP_FORWARD
+			   | 1 << NF_IP_LOCAL_OUT));
+
+		/* Hooks should be first three */
+		assert(h->info.hook_entry[NF_IP_LOCAL_IN] == 0);
+
+		n = get_chain_end(h, 0);
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP_FORWARD] == n);
+
+		n = get_chain_end(h, n);
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP_LOCAL_OUT] == n);
+
+		user_offset = h->info.hook_entry[NF_IP_LOCAL_OUT];
+	} else if (strcmp(h->info.name, "nat") == 0) {
+		assert((h->info.valid_hooks
+		        == (1 << NF_IP_PRE_ROUTING
+			    | 1 << NF_IP_POST_ROUTING
+			    | 1 << NF_IP_LOCAL_OUT)) ||
+		       (h->info.valid_hooks
+			== (1 << NF_IP_PRE_ROUTING
+			    | 1 << NF_IP_LOCAL_IN
+			    | 1 << NF_IP_POST_ROUTING
+			    | 1 << NF_IP_LOCAL_OUT)));
+
+		assert(h->info.hook_entry[NF_IP_PRE_ROUTING] == 0);
+
+		n = get_chain_end(h, 0);
+
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP_POST_ROUTING] == n);
+		n = get_chain_end(h, n);
+
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP_LOCAL_OUT] == n);
+		user_offset = h->info.hook_entry[NF_IP_LOCAL_OUT];
+
+		if (h->info.valid_hooks & (1 << NF_IP_LOCAL_IN)) {
+			n = get_chain_end(h, n);
+			n += get_entry(h, n)->next_offset;
+			assert(h->info.hook_entry[NF_IP_LOCAL_IN] == n);
+			user_offset = h->info.hook_entry[NF_IP_LOCAL_IN];
+		}
+
+	} else if (strcmp(h->info.name, "mangle") == 0) {
+		/* This code is getting ugly because linux < 2.4.18-pre6 had
+		 * two mangle hooks, linux >= 2.4.18-pre6 has five mangle hooks
+		 * */
+		assert((h->info.valid_hooks
+			== (1 << NF_IP_PRE_ROUTING
+			    | 1 << NF_IP_LOCAL_OUT)) || 
+		       (h->info.valid_hooks
+			== (1 << NF_IP_PRE_ROUTING
+			    | 1 << NF_IP_LOCAL_IN
+			    | 1 << NF_IP_FORWARD
+			    | 1 << NF_IP_LOCAL_OUT
+			    | 1 << NF_IP_POST_ROUTING)));
+
+		/* Hooks should be first five */
+		assert(h->info.hook_entry[NF_IP_PRE_ROUTING] == 0);
+
+		n = get_chain_end(h, 0);
+
+		if (h->info.valid_hooks & (1 << NF_IP_LOCAL_IN)) {
+			n += get_entry(h, n)->next_offset;
+			assert(h->info.hook_entry[NF_IP_LOCAL_IN] == n);
+			n = get_chain_end(h, n);
+		}
+
+		if (h->info.valid_hooks & (1 << NF_IP_FORWARD)) {
+			n += get_entry(h, n)->next_offset;
+			assert(h->info.hook_entry[NF_IP_FORWARD] == n);
+			n = get_chain_end(h, n);
+		}
+
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP_LOCAL_OUT] == n);
+		user_offset = h->info.hook_entry[NF_IP_LOCAL_OUT];
+
+		if (h->info.valid_hooks & (1 << NF_IP_POST_ROUTING)) {
+			n = get_chain_end(h, n);
+			n += get_entry(h, n)->next_offset;
+			assert(h->info.hook_entry[NF_IP_POST_ROUTING] == n);
+			user_offset = h->info.hook_entry[NF_IP_POST_ROUTING];
+		}
+
+#ifdef NF_IP_DROPPING
+	} else if (strcmp(h->info.name, "drop") == 0) {
+		assert(h->info.valid_hooks == (1 << NF_IP_DROPPING));
+
+		/* Hook should be first */
+		assert(h->info.hook_entry[NF_IP_DROPPING] == 0);
+		user_offset = 0;
+#endif
+	} else {
+		fprintf(stderr, "Unknown table `%s'\n", h->info.name);
+		abort();
+	}
+
+	/* User chain == end of last builtin + policy entry */
+	user_offset = get_chain_end(h, user_offset);
+	user_offset += get_entry(h, user_offset)->next_offset;
+
+	/* Overflows should be end of entry chains, and unconditional
+           policy nodes. */
+	for (i = 0; i < NUMHOOKS; i++) {
+		STRUCT_ENTRY *e;
+		STRUCT_STANDARD_TARGET *t;
+
+		if (!(h->info.valid_hooks & (1 << i)))
+			continue;
+		assert(h->info.underflow[i]
+		       == get_chain_end(h, h->info.hook_entry[i]));
+
+		e = get_entry(h, get_chain_end(h, h->info.hook_entry[i]));
+		assert(unconditional(&e->ip));
+		assert(e->target_offset == sizeof(*e));
+		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+		assert(t->target.u.target_size == ALIGN(sizeof(*t)));
+		assert(e->next_offset == sizeof(*e) + ALIGN(sizeof(*t)));
+
+		assert(strcmp(t->target.u.user.name, STANDARD_TARGET)==0);
+		assert(t->verdict == -NF_DROP-1 || t->verdict == -NF_ACCEPT-1);
+
+		/* Hooks and underflows must be valid entries */
+		entry2index(h, get_entry(h, h->info.hook_entry[i]));
+		entry2index(h, get_entry(h, h->info.underflow[i]));
+	}
+
+	assert(h->info.size
+	       >= h->info.num_entries * (sizeof(STRUCT_ENTRY)
+					 +sizeof(STRUCT_STANDARD_TARGET)));
+
+	assert(h->entries.size
+	       >= (h->new_number
+		   * (sizeof(STRUCT_ENTRY)
+		      + sizeof(STRUCT_STANDARD_TARGET))));
+	assert(strcmp(h->info.name, h->entries.name) == 0);
+
+	i = 0; n = 0;
+	was_return = 0;
+	/* Check all the entries. */
+	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+		      check_entry, &i, &n, user_offset, &was_return, h);
+
+	assert(i == h->new_number);
+	assert(n == h->entries.size);
+
+	/* Final entry must be error node */
+	assert(strcmp(GET_TARGET(index2entry(h, h->new_number-1))
+		      ->u.user.name,
+		      ERROR_TARGET) == 0);
+}
+#endif /*IPTC_DEBUG*/
diff -urN iptables-1.2.8/libiptc2/libip6tc.c iptables-1.2.9/libiptc2/libip6tc.c
--- iptables-1.2.8/libiptc2/libip6tc.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/libiptc2/libip6tc.c	2003-06-30 18:16:54.000000000 +0200
@@ -0,0 +1,449 @@
+/* Library which manipulates firewall rules.  Version 0.1. */
+
+/* Architecture of firewall rules is as follows:
+ *
+ * Chains go INPUT, FORWARD, OUTPUT then user chains.
+ * Each user chain starts with an ERROR node.
+ * Every chain ends with an unconditional jump: a RETURN for user chains,
+ * and a POLICY for built-ins.
+ */
+
+/* (C)1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
+   COPYING for details). */
+
+#include <assert.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <arpa/inet.h>
+
+#ifdef DEBUG_CONNTRACK
+#define inline
+#endif
+
+#if !defined(__GLIBC__) || (__GLIBC__ < 2)
+typedef unsigned int socklen_t;
+#endif
+
+#include "libiptc/libip6tc.h"
+
+#define HOOK_PRE_ROUTING	NF_IP6_PRE_ROUTING
+#define HOOK_LOCAL_IN		NF_IP6_LOCAL_IN
+#define HOOK_FORWARD		NF_IP6_FORWARD
+#define HOOK_LOCAL_OUT		NF_IP6_LOCAL_OUT
+#define HOOK_POST_ROUTING	NF_IP6_POST_ROUTING
+
+#define STRUCT_ENTRY_TARGET	struct ip6t_entry_target
+#define STRUCT_ENTRY		struct ip6t_entry
+#define STRUCT_ENTRY_MATCH	struct ip6t_entry_match
+#define STRUCT_GETINFO		struct ip6t_getinfo
+#define STRUCT_GET_ENTRIES	struct ip6t_get_entries
+#define STRUCT_COUNTERS		struct ip6t_counters
+#define STRUCT_COUNTERS_INFO	struct ip6t_counters_info
+#define STRUCT_STANDARD_TARGET	struct ip6t_standard_target
+#define STRUCT_REPLACE		struct ip6t_replace
+
+#define STRUCT_TC_HANDLE	struct ip6tc_handle
+#define TC_HANDLE_T		ip6tc_handle_t
+
+#define ENTRY_ITERATE		IP6T_ENTRY_ITERATE
+#define TABLE_MAXNAMELEN	IP6T_TABLE_MAXNAMELEN
+#define FUNCTION_MAXNAMELEN	IP6T_FUNCTION_MAXNAMELEN
+
+#define GET_TARGET		ip6t_get_target
+
+#define ERROR_TARGET		IP6T_ERROR_TARGET
+#define NUMHOOKS		NF_IP6_NUMHOOKS
+
+#define IPT_CHAINLABEL		ip6t_chainlabel
+
+#define TC_DUMP_ENTRIES		dump_entries6
+#define TC_IS_CHAIN		ip6tc_is_chain
+#define TC_FIRST_CHAIN		ip6tc_first_chain
+#define TC_NEXT_CHAIN		ip6tc_next_chain
+#define TC_FIRST_RULE		ip6tc_first_rule
+#define TC_NEXT_RULE		ip6tc_next_rule
+#define TC_GET_TARGET		ip6tc_get_target
+#define TC_BUILTIN		ip6tc_builtin
+#define TC_GET_POLICY		ip6tc_get_policy
+#define TC_INSERT_ENTRY		ip6tc_insert_entry
+#define TC_REPLACE_ENTRY	ip6tc_replace_entry
+#define TC_APPEND_ENTRY		ip6tc_append_entry
+#define TC_DELETE_ENTRY		ip6tc_delete_entry
+#define TC_DELETE_NUM_ENTRY	ip6tc_delete_num_entry
+#define TC_CHECK_PACKET		ip6tc_check_packet
+#define TC_FLUSH_ENTRIES	ip6tc_flush_entries
+#define TC_ZERO_ENTRIES		ip6tc_zero_entries
+#define TC_ZERO_COUNTER		ip6tc_zero_counter
+#define TC_READ_COUNTER		ip6tc_read_counter
+#define TC_SET_COUNTER		ip6tc_set_counter
+#define TC_CREATE_CHAIN		ip6tc_create_chain
+#define TC_GET_REFERENCES	ip6tc_get_references
+#define TC_DELETE_CHAIN		ip6tc_delete_chain
+#define TC_RENAME_CHAIN		ip6tc_rename_chain
+#define TC_SET_POLICY		ip6tc_set_policy
+#define TC_GET_RAW_SOCKET	ip6tc_get_raw_socket
+#define TC_INIT			ip6tc_init
+#define TC_FREE			ip6tc_free
+#define TC_COMMIT		ip6tc_commit
+#define TC_STRERROR		ip6tc_strerror
+
+#define TC_AF			AF_INET6
+#define TC_IPPROTO		IPPROTO_IPV6
+
+#define SO_SET_REPLACE		IP6T_SO_SET_REPLACE
+#define SO_SET_ADD_COUNTERS	IP6T_SO_SET_ADD_COUNTERS
+#define SO_GET_INFO		IP6T_SO_GET_INFO
+#define SO_GET_ENTRIES		IP6T_SO_GET_ENTRIES
+#define SO_GET_VERSION		IP6T_SO_GET_VERSION
+
+#define STANDARD_TARGET		IP6T_STANDARD_TARGET
+#define LABEL_RETURN		IP6TC_LABEL_RETURN
+#define LABEL_ACCEPT		IP6TC_LABEL_ACCEPT
+#define LABEL_DROP		IP6TC_LABEL_DROP
+#define LABEL_QUEUE		IP6TC_LABEL_QUEUE
+
+#define ALIGN			IP6T_ALIGN
+#define RETURN			IP6T_RETURN
+
+#include "libiptc.c"
+
+#define BIT6(a, l) \
+ ((ntohl(a->in6_u.u6_addr32[(l) / 32]) >> (31 - ((l) & 31))) & 1)
+
+int
+ipv6_prefix_length(const struct in6_addr *a)
+{
+	int l, i;
+	for (l = 0; l < 128; l++) {
+		if (BIT6(a, l) == 0)
+			break;
+	}
+	for (i = l + 1; i < 128; i++) {
+		if (BIT6(a, i) == 1)
+			return -1;
+	}
+	return l;
+}
+
+static int
+dump_entry(struct ip6t_entry *e, const ip6tc_handle_t handle)
+{
+	size_t i;
+	char buf[40];
+	int len;
+	struct ip6t_entry_target *t;
+	
+	printf("Entry %u (%lu):\n", entry2index(handle, e),
+	       entry2offset(handle, e));
+	puts("SRC IP: ");
+	inet_ntop(AF_INET6, &e->ipv6.src, buf, sizeof buf);
+	puts(buf);
+	putchar('/');
+	len = ipv6_prefix_length(&e->ipv6.smsk);
+	if (len != -1)
+		printf("%d", len);
+	else {
+		inet_ntop(AF_INET6, &e->ipv6.smsk, buf, sizeof buf);
+		puts(buf);
+	}
+	putchar('\n');
+	
+	puts("DST IP: ");
+	inet_ntop(AF_INET6, &e->ipv6.dst, buf, sizeof buf);
+	puts(buf);
+	putchar('/');
+	len = ipv6_prefix_length(&e->ipv6.dmsk);
+	if (len != -1)
+		printf("%d", len);
+	else {
+		inet_ntop(AF_INET6, &e->ipv6.dmsk, buf, sizeof buf);
+		puts(buf);
+	}
+	putchar('\n');
+	
+	printf("Interface: `%s'/", e->ipv6.iniface);
+	for (i = 0; i < IFNAMSIZ; i++)
+		printf("%c", e->ipv6.iniface_mask[i] ? 'X' : '.');
+	printf("to `%s'/", e->ipv6.outiface);
+	for (i = 0; i < IFNAMSIZ; i++)
+		printf("%c", e->ipv6.outiface_mask[i] ? 'X' : '.');
+	printf("\nProtocol: %u\n", e->ipv6.proto);
+	if (e->ipv6.flags & IP6T_F_TOS)
+		printf("TOS: %u\n", e->ipv6.tos);
+	printf("Flags: %02X\n", e->ipv6.flags);
+	printf("Invflags: %02X\n", e->ipv6.invflags);
+	printf("Counters: %llu packets, %llu bytes\n",
+	       e->counters.pcnt, e->counters.bcnt);
+	printf("Cache: %08X ", e->nfcache);
+	if (e->nfcache & NFC_ALTERED) printf("ALTERED ");
+	if (e->nfcache & NFC_UNKNOWN) printf("UNKNOWN ");
+	if (e->nfcache & NFC_IP6_SRC) printf("IP6_SRC ");
+	if (e->nfcache & NFC_IP6_DST) printf("IP6_DST ");
+	if (e->nfcache & NFC_IP6_IF_IN) printf("IP6_IF_IN ");
+	if (e->nfcache & NFC_IP6_IF_OUT) printf("IP6_IF_OUT ");
+	if (e->nfcache & NFC_IP6_TOS) printf("IP6_TOS ");
+	if (e->nfcache & NFC_IP6_PROTO) printf("IP6_PROTO ");
+	if (e->nfcache & NFC_IP6_OPTIONS) printf("IP6_OPTIONS ");
+	if (e->nfcache & NFC_IP6_TCPFLAGS) printf("IP6_TCPFLAGS ");
+	if (e->nfcache & NFC_IP6_SRC_PT) printf("IP6_SRC_PT ");
+	if (e->nfcache & NFC_IP6_DST_PT) printf("IP6_DST_PT ");
+	if (e->nfcache & NFC_IP6_PROTO_UNKNOWN) printf("IP6_PROTO_UNKNOWN ");
+	printf("\n");
+	
+	IP6T_MATCH_ITERATE(e, print_match);
+
+	t = ip6t_get_target(e);
+	printf("Target name: `%s' [%u]\n", t->u.user.name, t->u.target_size);
+	if (strcmp(t->u.user.name, IP6T_STANDARD_TARGET) == 0) {
+		int pos = *(int *)t->data;
+		if (pos < 0)
+			printf("verdict=%s\n",
+			       pos == -NF_ACCEPT-1 ? "NF_ACCEPT"
+			       : pos == -NF_DROP-1 ? "NF_DROP"
+			       : pos == IP6T_RETURN ? "RETURN"
+			       : "UNKNOWN");
+		else
+			printf("verdict=%u\n", pos);
+	} else if (strcmp(t->u.user.name, IP6T_ERROR_TARGET) == 0)
+		printf("error=`%s'\n", t->data);
+
+	printf("\n");
+	return 0;
+}
+
+static int
+is_same(const STRUCT_ENTRY *a, const STRUCT_ENTRY *b,
+	unsigned char *matchmask)
+{
+	unsigned int i;
+	STRUCT_ENTRY_TARGET *ta, *tb;
+	unsigned char *mptr;
+
+	/* Always compare head structures: ignore mask here. */
+	if (memcmp(&a->ipv6.src, &b->ipv6.src, sizeof(struct in6_addr))
+	    || memcmp(&a->ipv6.dst, &b->ipv6.dst, sizeof(struct in6_addr))
+	    || memcmp(&a->ipv6.smsk, &b->ipv6.smsk, sizeof(struct in6_addr))
+	    || memcmp(&a->ipv6.dmsk, &b->ipv6.dmsk, sizeof(struct in6_addr))
+	    || a->ipv6.proto != b->ipv6.proto
+	    || a->ipv6.tos != b->ipv6.tos
+	    || a->ipv6.flags != b->ipv6.flags
+	    || a->ipv6.invflags != b->ipv6.invflags)
+		return 0;
+
+	for (i = 0; i < IFNAMSIZ; i++) {
+		if (a->ipv6.iniface_mask[i] != b->ipv6.iniface_mask[i])
+			return 0;
+		if ((a->ipv6.iniface[i] & a->ipv6.iniface_mask[i])
+		    != (b->ipv6.iniface[i] & b->ipv6.iniface_mask[i]))
+			return 0;
+		if (a->ipv6.outiface_mask[i] != b->ipv6.outiface_mask[i])
+			return 0;
+		if ((a->ipv6.outiface[i] & a->ipv6.outiface_mask[i])
+		    != (b->ipv6.outiface[i] & b->ipv6.outiface_mask[i]))
+			return 0;
+	}
+
+	if (a->nfcache != b->nfcache
+	    || a->target_offset != b->target_offset
+	    || a->next_offset != b->next_offset)
+		return 0;
+
+	mptr = matchmask + sizeof(STRUCT_ENTRY);
+	if (IP6T_MATCH_ITERATE(a, match_different, a->elems, b->elems, &mptr))
+		return 0;
+
+	ta = GET_TARGET((STRUCT_ENTRY *)a);
+	tb = GET_TARGET((STRUCT_ENTRY *)b);
+	if (ta->u.target_size != tb->u.target_size)
+		return 0;
+	if (strcmp(ta->u.user.name, tb->u.user.name) != 0)
+		return 0;
+	mptr += sizeof(*ta);
+
+	if (target_different(ta->data, tb->data,
+			     ta->u.target_size - sizeof(*ta), mptr))
+		return 0;
+
+	return 1;
+}
+
+/* All zeroes == unconditional rule. */
+static inline int
+unconditional(const struct ip6t_ip6 *ipv6)
+{
+	unsigned int i;
+
+	for (i = 0; i < sizeof(*ipv6); i++)
+		if (((char *)ipv6)[i])
+			break;
+
+	return (i == sizeof(*ipv6));
+}
+
+#ifdef IPTC_DEBUG
+/* Do every conceivable sanity check on the handle */
+static void
+do_check(TC_HANDLE_T h, unsigned int line)
+{
+	unsigned int i, n;
+	unsigned int user_offset; /* Offset of first user chain */
+	int was_return;
+
+	assert(h->changed == 0 || h->changed == 1);
+	if (strcmp(h->info.name, "filter") == 0) {
+		assert(h->info.valid_hooks
+		       == (1 << NF_IP6_LOCAL_IN
+			   | 1 << NF_IP6_FORWARD
+			   | 1 << NF_IP6_LOCAL_OUT));
+
+		/* Hooks should be first three */
+		assert(h->info.hook_entry[NF_IP6_LOCAL_IN] == 0);
+
+		n = get_chain_end(h, 0);
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP6_FORWARD] == n);
+
+		n = get_chain_end(h, n);
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
+
+		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
+	} else if (strcmp(h->info.name, "nat") == 0) {
+		assert((h->info.valid_hooks
+			== (1 << NF_IP6_PRE_ROUTING
+			    | 1 << NF_IP6_LOCAL_OUT
+			    | 1 << NF_IP6_POST_ROUTING)) ||
+		       (h->info.valid_hooks
+			== (1 << NF_IP6_PRE_ROUTING
+			    | 1 << NF_IP6_LOCAL_IN
+			    | 1 << NF_IP6_LOCAL_OUT
+			    | 1 << NF_IP6_POST_ROUTING)));
+
+		assert(h->info.hook_entry[NF_IP6_PRE_ROUTING] == 0);
+
+		n = get_chain_end(h, 0);
+
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP6_POST_ROUTING] == n);
+		n = get_chain_end(h, n);
+
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
+		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
+
+		if (h->info.valid_hooks & (1 << NF_IP6_LOCAL_IN)) {
+			n = get_chain_end(h, n);
+			n += get_entry(h, n)->next_offset;
+			assert(h->info.hook_entry[NF_IP6_LOCAL_IN] == n);
+			user_offset = h->info.hook_entry[NF_IP6_LOCAL_IN];
+		}
+
+	} else if (strcmp(h->info.name, "mangle") == 0) {
+		/* This code is getting ugly because linux < 2.4.18-pre6 had
+		 * two mangle hooks, linux >= 2.4.18-pre6 has five mangle hooks
+		 * */
+		assert((h->info.valid_hooks
+			== (1 << NF_IP6_PRE_ROUTING
+			    | 1 << NF_IP6_LOCAL_OUT)) ||
+		       (h->info.valid_hooks
+			== (1 << NF_IP6_PRE_ROUTING
+			    | 1 << NF_IP6_LOCAL_IN
+			    | 1 << NF_IP6_FORWARD
+			    | 1 << NF_IP6_LOCAL_OUT
+			    | 1 << NF_IP6_POST_ROUTING)));
+
+		/* Hooks should be first five */
+		assert(h->info.hook_entry[NF_IP6_PRE_ROUTING] == 0);
+
+		n = get_chain_end(h, 0);
+
+		if (h->info.valid_hooks & (1 << NF_IP6_LOCAL_IN)) {
+			n += get_entry(h, n)->next_offset;
+			assert(h->info.hook_entry[NF_IP6_LOCAL_IN] == n);
+			n = get_chain_end(h, n);
+		}
+
+		if (h->info.valid_hooks & (1 << NF_IP6_FORWARD)) {
+			n += get_entry(h, n)->next_offset;
+			assert(h->info.hook_entry[NF_IP6_FORWARD] == n);
+			n = get_chain_end(h, n);
+		}
+
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
+		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
+
+		if (h->info.valid_hooks & (1 << NF_IP6_POST_ROUTING)) {
+			n = get_chain_end(h, n);
+			n += get_entry(h, n)->next_offset;
+			assert(h->info.hook_entry[NF_IP6_POST_ROUTING] == n);
+			user_offset = h->info.hook_entry[NF_IP6_POST_ROUTING];
+		}
+	} else {
+                fprintf(stderr, "Unknown table `%s'\n", h->info.name);
+		abort();
+	}
+
+	/* User chain == end of last builtin + policy entry */
+	user_offset = get_chain_end(h, user_offset);
+	user_offset += get_entry(h, user_offset)->next_offset;
+
+	/* Overflows should be end of entry chains, and unconditional
+           policy nodes. */
+	for (i = 0; i < NUMHOOKS; i++) {
+		STRUCT_ENTRY *e;
+		STRUCT_STANDARD_TARGET *t;
+
+		if (!(h->info.valid_hooks & (1 << i)))
+			continue;
+		assert(h->info.underflow[i]
+		       == get_chain_end(h, h->info.hook_entry[i]));
+
+		e = get_entry(h, get_chain_end(h, h->info.hook_entry[i]));
+		assert(unconditional(&e->ipv6));
+		assert(e->target_offset == sizeof(*e));
+		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+		printf("target_size=%u, align=%u\n",
+			t->target.u.target_size, ALIGN(sizeof(*t)));
+		assert(t->target.u.target_size == ALIGN(sizeof(*t)));
+		assert(e->next_offset == sizeof(*e) + ALIGN(sizeof(*t)));
+
+		assert(strcmp(t->target.u.user.name, STANDARD_TARGET)==0);
+		assert(t->verdict == -NF_DROP-1 || t->verdict == -NF_ACCEPT-1);
+
+		/* Hooks and underflows must be valid entries */
+		entry2index(h, get_entry(h, h->info.hook_entry[i]));
+		entry2index(h, get_entry(h, h->info.underflow[i]));
+	}
+
+	assert(h->info.size
+	       >= h->info.num_entries * (sizeof(STRUCT_ENTRY)
+					 +sizeof(STRUCT_STANDARD_TARGET)));
+
+	assert(h->entries.size
+	       >= (h->new_number
+		   * (sizeof(STRUCT_ENTRY)
+		      + sizeof(STRUCT_STANDARD_TARGET))));
+	assert(strcmp(h->info.name, h->entries.name) == 0);
+
+	i = 0; n = 0;
+	was_return = 0;
+
+#if 0
+	/* Check all the entries. */
+	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+		      check_entry, &i, &n, user_offset, &was_return, h);
+
+	assert(i == h->new_number);
+	assert(n == h->entries.size);
+
+	/* Final entry must be error node */
+	assert(strcmp(GET_TARGET(index2entry(h, h->new_number-1))
+		      ->u.user.name,
+		      ERROR_TARGET) == 0);
+#endif
+}
+#endif /*IPTC_DEBUG*/
diff -urN iptables-1.2.8/libiptc2/libiptc.c iptables-1.2.9/libiptc2/libiptc.c
--- iptables-1.2.8/libiptc2/libiptc.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/libiptc2/libiptc.c	2003-07-23 16:58:21.000000000 +0200
@@ -0,0 +1,1830 @@
+/* Library which manipulates firewall rules.  Version $Revision: 1.41 $ */
+
+/* Architecture of firewall rules is as follows:
+ *
+ * Chains go INPUT, FORWARD, OUTPUT then user chains.
+ * Each user chain starts with an ERROR node.
+ * Every chain ends with an unconditional jump: a RETURN for user chains,
+ * and a POLICY for built-ins.
+ */
+
+/* (C) 1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
+ * COPYING for details). 
+ * (C) 2000-2003 by the Netfilter Core Team <coreteam@netfilter.org>
+ *
+ * 2003-Jun-20: Harald Welte <laforge@netfilter.org>:
+ *	- Reimplementation of chain cache to use offsets instead of entries
+ * 2003-Jun-23: Harald Welte <laforge@netfilter.org>:
+ * 	- speed optimization, sponsored by Astaro AG (http://www.astaro.com/)
+ * 	  don't rebuild the chain cache after every operation, instead fix it
+ * 	  up after a ruleset change.  
+ * 2003-Jun-30: Harald Welte <laforge@netfilter.org>:
+ * 	- reimplementation from scratch. *sigh*.  I hope nobody has to touch 
+ * 	  this code ever again.
+ */
+#include "linux_listhelp.h"
+
+#ifndef IPT_LIB_DIR
+#define IPT_LIB_DIR "/usr/local/lib/iptables"
+#endif
+
+static int sockfd = -1;
+static void *iptc_fn = NULL;
+
+static const char *hooknames[]
+= { [HOOK_PRE_ROUTING]  "PREROUTING",
+    [HOOK_LOCAL_IN]     "INPUT",
+    [HOOK_FORWARD]      "FORWARD",
+    [HOOK_LOCAL_OUT]    "OUTPUT",
+    [HOOK_POST_ROUTING] "POSTROUTING",
+#ifdef HOOK_DROPPING
+    [HOOK_DROPPING]	"DROPPING"
+#endif
+};
+
+struct counter_map
+{
+	enum {
+		COUNTER_MAP_NOMAP,
+		COUNTER_MAP_NORMAL_MAP,
+		COUNTER_MAP_ZEROED,
+		COUNTER_MAP_SET
+	} maptype;
+	unsigned int mappos;
+};
+
+/* Convenience structures */
+struct ipt_error_target
+{
+	STRUCT_ENTRY_TARGET t;
+	char error[TABLE_MAXNAMELEN];
+};
+
+struct rule_head
+{
+	struct list_head list;		/* list of rules in chain */
+	
+	struct chain_head *chain;	/* we're part of this chain */
+
+	struct chain_head *jumpto;	/* target of this rule, in case
+					   it is a jump rule */
+
+	struct counter_map counter_map;
+
+	unsigned int size;		/* size of rule */
+	STRUCT_ENTRY *entry_blob;	/* pointer to entry in blob */
+	STRUCT_ENTRY entry[0];
+};
+
+struct chain_head
+{
+	struct list_head list;
+
+	char name[TABLE_MAXNAMELEN];
+	unsigned int hooknum;
+	struct list_head rules;
+	struct rule_head *firstrule; 	/* first (ERROR) rule */
+	struct rule_head *lastrule;	/* last (RETURN) rule */
+};
+
+STRUCT_TC_HANDLE
+{
+	/* Have changes been made? */
+	int changed;
+
+	/* linked list of chains in this table */
+	struct list_head chains;
+	
+	/* current position of first_chain() / next_chain() */
+	struct chain_head *chain_iterator_cur;
+
+	/* current position of first_rule() / next_rule() */
+	struct rule_head *rule_iterator_cur;
+
+	/* the structure we receive from getsockopt() */
+	STRUCT_GETINFO info;
+
+	/* Array of hook names */
+	const char **hooknames;
+#if 0
+	/* Size in here reflects original state. */
+
+
+	/* Cached position of chain heads (NULL = no cache). */
+	unsigned int cache_num_chains;
+	unsigned int cache_num_builtins;
+	struct chain_cache *cache_chain_heads;
+
+	/* Chain iterator: current chain cache entry. */
+	struct chain_cache *cache_chain_iteration;
+
+	/* Rule iterator: terminal rule */
+	STRUCT_ENTRY *cache_rule_end;
+
+	/* Number in here reflects current state. */
+	unsigned int new_number;
+#endif
+	STRUCT_GET_ENTRIES entries;
+};
+
+static void
+set_changed(TC_HANDLE_T h)
+{
+	h->changed = 1;
+}
+
+#ifdef IPTC_DEBUG
+static void do_check(TC_HANDLE_T h, unsigned int line);
+#define CHECK(h) do { if (!getenv("IPTC_NO_CHECK")) do_check((h), __LINE__); } while(0)
+#else
+#define CHECK(h)
+#endif
+
+static struct rule_head *ruleh_alloc(unsigned int size)
+{
+	struct rule_head *ruleh = malloc(sizeof(*ruleh)+size);
+	if (!ruleh)
+		return NULL;
+	
+	memset(ruleh, 0, sizeof(*ruleh)+size);
+	ruleh->size = size;
+
+	return ruleh;
+}
+
+static void ruleh_free(struct rule_head *ruleh)
+{
+	list_del(&ruleh->list);
+	free(ruleh);
+}
+
+static struct chain_head *chainh_alloc(TC_HANDLE_T h, const char *name)
+{
+	struct chain_head *chainh = malloc(sizeof(*chainh));
+	if (!chainh)
+		return NULL;
+
+	memset(chainh, 0, sizeof(*chainh));
+	strncpy(chainh->name, name, sizeof(&chainh->name));
+	list_append(&chainh->list, &h->chains);
+
+	return chainh;
+}
+
+static void
+chainh_clean(struct chain_head *chainh)
+{
+	/* FIXME */
+	struct list_head *cur_item, *item2;
+
+	list_for_each_safe(cur_item, item2, &chainh->rules) {
+		struct rule_head *ruleh = list_entry(cur_item, 
+						     struct rule_head,
+						    list);
+		ruleh_free(ruleh);
+	}
+}
+
+static void 
+chainh_free(struct chain_head *chainh)
+{
+	chainh_clean(chainh);
+	list_del(&chainh->list);
+}
+
+static struct chain_head *
+chainh_find(TC_HANDLE_T h, const IPT_CHAINLABEL name)
+{
+	struct list_head *cur;
+
+	list_for_each(cur, &h->chains) {
+		struct chain_head *ch = list_entry(cur, struct chain_head, 
+						   list);
+		if (!strcmp(name, ch->name))
+			return ch;
+	}
+	return NULL;
+}
+
+/* Returns chain head if found, otherwise NULL. */
+static struct chain_head *
+find_label(const char *name, TC_HANDLE_T handle)
+{
+	return chainh_find(handle, name);
+}
+
+
+/* 
+ * functions that directly operate on the blob 
+ */
+
+static inline unsigned long
+entry2offset(const TC_HANDLE_T h, const STRUCT_ENTRY *e)
+{
+	return (void *)e - (void *)h->entries.entrytable;
+}
+
+static inline STRUCT_ENTRY *
+get_entry(TC_HANDLE_T h, unsigned int offset)
+{
+	return (STRUCT_ENTRY *)((char *)h->entries.entrytable + offset);
+}
+
+/* needed by entry2index */
+static inline int
+get_number(const STRUCT_ENTRY *i,
+	   const STRUCT_ENTRY *seek,
+	   unsigned int *pos)
+{
+	if (i == seek)
+		return 1;
+	(*pos)++;
+	return 0;
+}
+
+static unsigned int
+entry2index(const TC_HANDLE_T h, const STRUCT_ENTRY *seek)
+{
+	unsigned int pos = 0;
+
+	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+			  get_number, seek, &pos) == 0) {
+		fprintf(stderr, "ERROR: offset %i not an entry!\n",
+			(char *)seek - (char *)h->entries.entrytable);
+		abort();
+	}
+	return pos;
+}
+
+static inline int
+get_entry_n(STRUCT_ENTRY *i,
+	    unsigned int number,
+	    unsigned int *pos,
+	    STRUCT_ENTRY **pe)
+{
+	if (*pos == number) {
+		*pe = i;
+		return 1;
+	}
+	(*pos)++;
+	return 0;
+}
+
+static STRUCT_ENTRY *
+index2entry(TC_HANDLE_T h, unsigned int index)
+{
+	unsigned int pos = 0;
+	STRUCT_ENTRY *ret = NULL;
+
+	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+		      get_entry_n, index, &pos, &ret);
+
+	return ret;
+}
+
+static inline unsigned long
+index2offset(TC_HANDLE_T h, unsigned int index)
+{
+	return entry2offset(h, index2entry(h, index));
+}
+
+static char *
+get_errorlabel(TC_HANDLE_T h, unsigned int offset)
+{
+	STRUCT_ENTRY *e;
+
+	e = get_entry(h, offset);
+	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) != 0) {
+		fprintf(stderr, "ERROR: offset %u not an error node!\n",
+			offset);
+		abort();
+	}
+
+	return (char *)GET_TARGET(e)->data;
+}
+
+#if 0
+static inline STRUCT_ENTRY *
+offset2entry(TC_HANDLE_T h, unsigned int offset)
+{
+	return (STRUCT_ENTRY *) ((void *)h->entries.entrytable+offset);
+}
+
+static inline unsigned int
+offset2index(const TC_HANDLE_T h, unsigned int offset)
+{
+	return entry2index(h, offset2entry(h, offset));
+}
+
+
+#endif
+
+/* Allocate handle of given size */
+static TC_HANDLE_T
+alloc_tc_handle(const char *tablename, unsigned int size, 
+		unsigned int num_rules)
+{
+	size_t len;
+	TC_HANDLE_T h;
+
+	len = sizeof(STRUCT_TC_HANDLE)
+		+ size
+		+ num_rules * sizeof(struct counter_map);
+
+	if ((h = malloc(len)) == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	h->changed = 0;
+
+	strcpy(h->info.name, tablename);
+	strcpy(h->entries.name, tablename);
+	INIT_LIST_HEAD(&h->chains);
+
+	return h;
+}
+
+/* get the name of the chain that we jump to */
+static char *
+parse_jumptarget(const STRUCT_ENTRY *e, TC_HANDLE_T h)
+{
+	STRUCT_ENTRY *jumpto;
+	int spos, labelidx;
+
+	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) != 0) {
+		/* called for non-standard target */
+		return "__FIXME";
+	}
+	/* Standard target: evaluate */
+	spos = *(int *)GET_TARGET(e)->data;
+	if (spos < 0) {
+		return "__FIXME";
+	}
+
+	jumpto = get_entry(h, spos);
+
+	/* Fall through rule */
+	if (jumpto == (void *)e + e->next_offset)
+		return "";
+
+	/* Must point to head of a chain: ie. after error rule */
+	/* FIXME: this needs to deal with internal jump targets */
+	labelidx = entry2index(h, jumpto) - 1;
+	return get_errorlabel(h, index2offset(h, labelidx));
+}
+
+/* parser functions */
+
+struct rule_head *
+append_entrycopy(const STRUCT_ENTRY *e, struct rule_head *prev)
+{
+	struct rule_head *ruleh = ruleh_alloc(e->next_offset);
+	if (!ruleh)
+		return NULL;
+	
+	memcpy(&ruleh->entry, e, e->next_offset);
+	ruleh->chain = prev->chain;
+	ruleh->entry_blob = e;
+	list_append(&ruleh->list, &prev->list);
+
+	return ruleh;
+}
+
+/* have to return 0 on success, bcf ENTRY_ITERATE */
+static inline int 
+parse_entry(const STRUCT_ENTRY *e, TC_HANDLE_T h, struct chain_head **curchain)
+{
+	int i;
+	union tgt_u {
+		STRUCT_ENTRY_TARGET ent;
+		STRUCT_STANDARD_TARGET std;
+		struct ipt_error_target err;
+	} *tgt;
+
+	struct rule_head *lastrule = list_entry((*curchain)->rules.prev,
+						 struct rule_head, list);
+	struct rule_head *newrule;
+
+	tgt = (union tgt_u *) GET_TARGET(e);
+
+	if (e->target_offset == sizeof(STRUCT_ENTRY)
+	    && (strcmp(tgt->ent.u.user.name, IPT_STANDARD_TARGET) == 0)) {
+		/* jump to somewhere else */
+		char *targname;
+		struct chain_head *chainh;
+
+		newrule = append_entrycopy(e, lastrule);
+
+		targname = parse_jumptarget(e, h);
+		if (!(chainh = find_label(targname, h))) {
+			chainh = chainh_alloc(h, targname);
+		}
+		if (!chainh) {
+			errno = ENOMEM;
+			return 1;
+		}
+		newrule->jumpto = chainh;
+
+	} else if (e->target_offset == sizeof(STRUCT_ENTRY)
+		   && e->next_offset == sizeof(STRUCT_ENTRY)
+		   			+ ALIGN(sizeof(struct ipt_error_target))
+		   && !strcmp(tgt->ent.u.user.name, ERROR_TARGET)) {
+		/* chain head */
+		*curchain = chainh_find(h, tgt->err.error);
+		if (!(*curchain)) {
+			*curchain = chainh_alloc(h, tgt->err.error);
+			/* FIXME: error handling */
+		}
+		newrule = append_entrycopy(e, lastrule);
+		(*curchain)->firstrule = newrule;
+
+	} else if (e->target_offset == sizeof(STRUCT_ENTRY)
+		   && e->next_offset == sizeof(STRUCT_ENTRY)
+		   			+ ALIGN(sizeof(STRUCT_STANDARD_TARGET))
+		   && tgt->std.verdict == RETURN) {
+		/* chain end */
+		newrule = append_entrycopy(e, lastrule);
+		(*curchain)->lastrule = newrule;
+		*curchain = NULL;
+	} else {
+		/* normal rule */
+		newrule = append_entrycopy(e, lastrule);
+	}
+
+	/* create counter map entry */
+	newrule->counter_map.maptype = COUNTER_MAP_NORMAL_MAP;
+	newrule->counter_map.mappos = entry2index(h, e);
+
+	/* iterate over hook_entries, needed to connect builtin
+	 * chains with hook numbers */
+	for (i = 0; i < NUMHOOKS; i++) {
+		if (!(h->info.valid_hooks & (1 << i)))
+			continue;
+		if (h->info.hook_entry[i] == entry2offset(h, e)) {
+			/* found hook entry point */
+			if (*curchain)
+				(*curchain)->hooknum = i;
+		}
+		if (h->info.underflow[i] == entry2offset(h, e)) {
+			/* found underflow point */
+		}
+	}
+
+	return 0;
+}
+
+static int parse_ruleset(TC_HANDLE_T h)
+{
+	struct chain_head *curchain;
+	
+	/* iterate over ruleset; create linked list of rule_head/chain_head */
+	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size, 
+		      parse_entry, h, &curchain)) {
+		/* some error happened while iterating */
+		return 0;
+	}
+
+	return 1;
+}
+
+TC_HANDLE_T
+TC_INIT(const char *tablename)
+{
+	TC_HANDLE_T h;
+	STRUCT_GETINFO info;
+	int tmp;
+	socklen_t s;
+
+	iptc_fn = TC_INIT;
+
+	if (sockfd != -1) {
+		close(sockfd);
+		sockfd = -1;
+	}
+
+	if (strlen(tablename) >= TABLE_MAXNAMELEN) {
+		errno = EINVAL;
+		return NULL;
+	}
+	
+	sockfd = socket(TC_AF, SOCK_RAW, IPPROTO_RAW);
+	if (sockfd < 0)
+		return NULL;
+
+	s = sizeof(info);
+
+	strcpy(info.name, tablename);
+	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_INFO, &info, &s) < 0)
+		return NULL;
+
+	if ((h = alloc_tc_handle(info.name, info.size, info.num_entries))
+	    == NULL) {
+		close(sockfd);
+		sockfd = -1;
+		return NULL;
+	}
+
+/* Too hard --RR */
+#if 0
+	sprintf(pathname, "%s/%s", IPT_LIB_DIR, info.name);
+	dynlib = dlopen(pathname, RTLD_NOW);
+	if (!dynlib) {
+		errno = ENOENT;
+		return NULL;
+	}
+	h->hooknames = dlsym(dynlib, "hooknames");
+	if (!h->hooknames) {
+		errno = ENOENT;
+		return NULL;
+	}
+#else
+	h->hooknames = hooknames;
+#endif
+
+	/* Initialize current state */
+	h->info = info;
+	//h->new_number = h->info.num_entries;
+	//
+	h->entries.size = h->info.size;
+
+	tmp = sizeof(STRUCT_GET_ENTRIES) + h->info.size;
+
+	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_ENTRIES, &h->entries,
+		       &tmp) < 0) {
+		close(sockfd);
+		sockfd = -1;
+		free(h);
+		return NULL;
+	}
+
+	CHECK(h);
+	parse_ruleset(h);
+
+	return h;
+}
+
+void
+TC_FREE(TC_HANDLE_T *h)
+{
+	struct list_head *cur_item, *item2;
+
+	close(sockfd);
+	sockfd = -1;
+
+	/* free all chains */
+	list_for_each_safe(cur_item, item2, &(*h)->chains) {
+		struct chain_head *chead = list_entry(cur_item,
+						      struct chain_head,
+						      list);
+		chainh_free(chead);
+	}
+
+	/* FIXME: free all other ressources we might be using */
+
+	free(*h);
+	*h = NULL;
+}
+
+static inline int
+print_match(const STRUCT_ENTRY_MATCH *m)
+{
+	printf("Match name: `%s'\n", m->u.user.name);
+	return 0;
+}
+
+static int dump_entry(STRUCT_ENTRY *e, const TC_HANDLE_T handle);
+ 
+#if 0
+void
+TC_DUMP_ENTRIES(const TC_HANDLE_T handle)
+{
+	CHECK(handle);
+
+	printf("libiptc v%s.  %u entries, %u bytes.\n",
+	       IPTABLES_VERSION,
+	       handle->new_number, handle->entries.size);
+	printf("Table `%s'\n", handle->info.name);
+	printf("Hooks: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
+	       handle->info.hook_entry[HOOK_PRE_ROUTING],
+	       handle->info.hook_entry[HOOK_LOCAL_IN],
+	       handle->info.hook_entry[HOOK_FORWARD],
+	       handle->info.hook_entry[HOOK_LOCAL_OUT],
+	       handle->info.hook_entry[HOOK_POST_ROUTING]);
+	printf("Underflows: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
+	       handle->info.underflow[HOOK_PRE_ROUTING],
+	       handle->info.underflow[HOOK_LOCAL_IN],
+	       handle->info.underflow[HOOK_FORWARD],
+	       handle->info.underflow[HOOK_LOCAL_OUT],
+	       handle->info.underflow[HOOK_POST_ROUTING]);
+
+	ENTRY_ITERATE(handle->entries.entrytable, handle->entries.size,
+		      dump_entry, handle);
+}
+
+/* Returns 0 if not hook entry, else hooknumber + 1 */
+static inline unsigned int
+is_hook_entry(STRUCT_ENTRY *e, TC_HANDLE_T h)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUMHOOKS; i++) {
+		if ((h->info.valid_hooks & (1 << i))
+		    && get_entry(h, h->info.hook_entry[i]) == e)
+			return i+1;
+	}
+	return 0;
+}
+
+
+static int alphasort(const void *a, const void *b)
+{
+	return strcmp(((struct chain_cache *)a)->name,
+		      ((struct chain_cache *)b)->name);
+}
+#endif
+
+/* Does this chain exist? */
+int TC_IS_CHAIN(const char *chain, const TC_HANDLE_T handle)
+{
+	return find_label(chain, handle) != NULL;
+}
+
+#if 0
+/* Returns the position of the final (ie. unconditional) element. */
+static unsigned int
+get_chain_end(const TC_HANDLE_T handle, unsigned int start)
+{
+	unsigned int last_off, off;
+	STRUCT_ENTRY *e;
+
+	last_off = start;
+	e = get_entry(handle, start);
+
+	/* Terminate when we meet a error label or a hook entry. */
+	for (off = start + e->next_offset;
+	     off < handle->entries.size;
+	     last_off = off, off += e->next_offset) {
+		STRUCT_ENTRY_TARGET *t;
+		unsigned int i;
+
+		e = get_entry(handle, off);
+
+		/* We hit an entry point. */
+		for (i = 0; i < NUMHOOKS; i++) {
+			if ((handle->info.valid_hooks & (1 << i))
+			    && off == handle->info.hook_entry[i])
+				return last_off;
+		}
+
+		/* We hit a user chain label */
+		t = GET_TARGET(e);
+		if (strcmp(t->u.user.name, ERROR_TARGET) == 0)
+			return last_off;
+	}
+	/* SHOULD NEVER HAPPEN */
+	fprintf(stderr, "ERROR: Off end (%u) of chain from %u!\n",
+		handle->entries.size, off);
+	abort();
+}
+#endif
+
+/* Iterator functions to run through the chains. */
+const char *
+TC_FIRST_CHAIN(TC_HANDLE_T *handle)
+{
+	struct chain_head *firsthead = list_entry((*handle)->chains.next,
+						   struct chain_head, list);
+	(*handle)->chain_iterator_cur = firsthead;
+
+	return firsthead->name;
+}
+
+/* Iterator functions to run through the chains.  Returns NULL at end. */
+const char *
+TC_NEXT_CHAIN(TC_HANDLE_T *handle)
+{
+	struct chain_head *next = list_entry(&(*handle)->chain_iterator_cur->list.next, struct chain_head, list);
+	(*handle)->chain_iterator_cur = next;
+
+	if (&next->list == &(*handle)->chains)
+		return NULL;
+
+	return next->name;
+}
+
+/* Get first rule in the given chain: NULL for empty chain. */
+const STRUCT_ENTRY *
+TC_FIRST_RULE(const char *chain, TC_HANDLE_T *handle)
+{
+	struct chain_head *c;
+	struct rule_head *r;
+
+	c = find_label(chain, *handle);
+	if (!c) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	/* Empty chain: single return/policy rule */
+	if (list_empty(&c->rules))
+		return NULL;
+
+	r = list_entry(c->rules.next, struct rule_head, list);
+	(*handle)->rule_iterator_cur = r;
+
+	return r->entry;
+}
+
+/* Returns NULL when rules run out. */
+const STRUCT_ENTRY *
+TC_NEXT_RULE(const STRUCT_ENTRY *prev, TC_HANDLE_T *handle)
+{
+	struct rule_head *r = list_entry((*handle)->rule_iterator_cur->list.next, struct rule_head, list);
+
+	if (&r->list == &r->chain->rules)
+		return NULL;
+
+	/* NOTE: prev is without any influence ! */
+	return r->entry;
+}
+
+#if 0
+/* How many rules in this chain? */
+unsigned int
+TC_NUM_RULES(const char *chain, TC_HANDLE_T *handle)
+{
+	unsigned int off = 0;
+	STRUCT_ENTRY *start, *end;
+
+	CHECK(*handle);
+	if (!find_label(&off, chain, *handle)) {
+		errno = ENOENT;
+		return (unsigned int)-1;
+	}
+
+	start = get_entry(*handle, off);
+	end = get_entry(*handle, get_chain_end(*handle, off));
+
+	return entry2index(*handle, end) - entry2index(*handle, start);
+}
+
+/* Get n'th rule in this chain. */
+const STRUCT_ENTRY *TC_GET_RULE(const char *chain,
+				unsigned int n,
+				TC_HANDLE_T *handle)
+{
+	unsigned int pos = 0, chainindex;
+
+	CHECK(*handle);
+	if (!find_label(&pos, chain, *handle)) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	chainindex = entry2index(*handle, get_entry(*handle, pos));
+
+	return index2entry(*handle, chainindex + n);
+}
+#endif
+
+static const char *
+target_name(TC_HANDLE_T handle, const STRUCT_ENTRY *ce)
+{
+	int spos;
+
+	/* To avoid const warnings */
+	STRUCT_ENTRY *e = (STRUCT_ENTRY *)ce;
+
+	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) != 0)
+		return GET_TARGET(e)->u.user.name;
+
+	/* Standard target: evaluate */
+	spos = *(int *)GET_TARGET(e)->data;
+	if (spos < 0) {
+		if (spos == RETURN)
+			return LABEL_RETURN;
+		else if (spos == -NF_ACCEPT-1)
+			return LABEL_ACCEPT;
+		else if (spos == -NF_DROP-1)
+			return LABEL_DROP;
+		else if (spos == -NF_QUEUE-1)
+			return LABEL_QUEUE;
+
+		fprintf(stderr, "ERROR: entry %p not a valid target (%d)\n",
+			e, spos);
+		abort();
+	}
+
+#if 0
+//	jumpto = get_entry(handle, spos);
+
+	/* Fall through rule */
+	if (jumpto == (void *)e + e->next_offset)
+		return "";
+
+	/* Must point to head of a chain: ie. after error rule */
+	/* FIXME: this needs to deal with internal jump targets */
+	labelidx = entry2index(handle, jumpto) - 1;
+	return get_errorlabel(handle, index2offset(handle, labelidx));
+#endif
+	return "";
+}
+
+/* Returns a pointer to the target name of this position. */
+const char *TC_GET_TARGET(const STRUCT_ENTRY *e,
+			  TC_HANDLE_T *handle)
+{
+	return target_name(*handle, e);
+}
+
+/* Is this a built-in chain?  Actually returns hook + 1. */
+int
+TC_BUILTIN(const char *chain, const TC_HANDLE_T handle)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUMHOOKS; i++) {
+		if ((handle->info.valid_hooks & (1 << i))
+		    && handle->hooknames[i]
+		    && strcmp(handle->hooknames[i], chain) == 0)
+			return i+1;
+	}
+	return 0;
+}
+
+/* Get the policy of a given built-in chain */
+const char *
+TC_GET_POLICY(const char *chain,
+	      STRUCT_COUNTERS *counters,
+	      TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_head *chainh;
+	struct rule_head *ruleh;
+	int hook;
+
+	hook = TC_BUILTIN(chain, *handle);
+	if (hook == 0)
+		return NULL;
+
+	chainh = find_label(chain, *handle);
+	if (!chainh) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	ruleh = chainh->lastrule;
+
+	e = ruleh->entry;
+	*counters = e->counters;
+
+	return target_name(*handle, e);
+}
+
+#if 0
+static int
+correct_verdict(STRUCT_ENTRY *e,
+		char *base,
+		unsigned int offset, int delta_offset)
+{
+	STRUCT_STANDARD_TARGET *t = (void *)GET_TARGET(e);
+	unsigned int curr = (char *)e - base;
+
+	/* Trap: insert of fall-through rule.  Don't change fall-through
+	   verdict to jump-over-next-rule. */
+	if (strcmp(t->target.u.user.name, STANDARD_TARGET) == 0
+	    && t->verdict > (int)offset
+	    && !(curr == offset &&
+		 t->verdict == curr + e->next_offset)) {
+		t->verdict += delta_offset;
+	}
+
+	return 0;
+}
+
+/* Adjusts standard verdict jump positions after an insertion/deletion. */
+static int
+set_verdict(unsigned int offset, int delta_offset, TC_HANDLE_T *handle)
+{
+	ENTRY_ITERATE((*handle)->entries.entrytable,
+		      (*handle)->entries.size,
+		      correct_verdict, (char *)(*handle)->entries.entrytable,
+		      offset, delta_offset);
+
+	set_changed(*handle);
+	return 1;
+}
+#endif
+
+
+
+static int
+standard_map(STRUCT_ENTRY *e, int verdict)
+{
+	STRUCT_STANDARD_TARGET *t;
+
+	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+
+	if (t->target.u.target_size
+	    != ALIGN(sizeof(STRUCT_STANDARD_TARGET))) {
+		errno = EINVAL;
+		return 0;
+	}
+	/* memset for memcmp convenience on delete/replace */
+	memset(t->target.u.user.name, 0, FUNCTION_MAXNAMELEN);
+	strcpy(t->target.u.user.name, STANDARD_TARGET);
+	t->verdict = verdict;
+
+	return 1;
+}
+
+static int
+map_target(const TC_HANDLE_T handle,
+	   STRUCT_ENTRY *e,
+	   unsigned int offset,
+	   STRUCT_ENTRY_TARGET *old)
+{
+	STRUCT_ENTRY_TARGET *t = (STRUCT_ENTRY_TARGET *)GET_TARGET(e);
+
+	/* Save old target (except data, which we don't change, except for
+	   standard case, where we don't care). */
+	*old = *t;
+
+	/* Maybe it's empty (=> fall through) */
+	if (strcmp(t->u.user.name, "") == 0)
+		return standard_map(e, offset + e->next_offset);
+	/* Maybe it's a standard target name... */
+	else if (strcmp(t->u.user.name, LABEL_ACCEPT) == 0)
+		return standard_map(e, -NF_ACCEPT - 1);
+	else if (strcmp(t->u.user.name, LABEL_DROP) == 0)
+		return standard_map(e, -NF_DROP - 1);
+	else if (strcmp(t->u.user.name, LABEL_QUEUE) == 0)
+		return standard_map(e, -NF_QUEUE - 1);
+	else if (strcmp(t->u.user.name, LABEL_RETURN) == 0)
+		return standard_map(e, RETURN);
+	else if (TC_BUILTIN(t->u.user.name, handle)) {
+		/* Can't jump to builtins. */
+		errno = EINVAL;
+		return 0;
+	} else {
+		/* Maybe it's an existing chain name. */
+		struct chain_head *c;
+
+#if 0
+		/* FIXME */
+		c = find_label(t->u.user.name, handle);
+		if (c)
+			return standard_map(e, c->start_off);
+#endif
+	}
+
+	/* Must be a module?  If not, kernel will reject... */
+	/* memset to all 0 for your memcmp convenience. */
+	memset(t->u.user.name + strlen(t->u.user.name),
+	       0,
+	       FUNCTION_MAXNAMELEN - strlen(t->u.user.name));
+	return 1;
+}
+
+static void
+unmap_target(STRUCT_ENTRY *e, STRUCT_ENTRY_TARGET *old)
+{
+	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
+
+	/* Save old target (except data, which we don't change, except for
+	   standard case, where we don't care). */
+	*t = *old;
+}
+
+static struct rule_head *
+ruleh_get_n(struct chain_head *chead, int rulenum) 
+{
+	int i = 0;
+	struct list_head *list;
+
+	
+	list_for_each(list, &chead->rules) {
+		struct rule_head *rhead = list_entry(list, struct rule_head, 
+							list);
+		i++;
+		if (i == rulenum)
+			return rhead;
+	}
+	return NULL;
+}
+
+/* Insert the entry `e' in chain `chain' into position `rulenum'. */
+int
+TC_INSERT_ENTRY(const IPT_CHAINLABEL chain,
+		const STRUCT_ENTRY *e,
+		unsigned int rulenum,
+		TC_HANDLE_T *handle)
+{
+	struct chain_head *c;
+	struct rule_head *prev;
+
+	iptc_fn = TC_INSERT_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	prev = ruleh_get_n(c, rulenum-1);
+	if (!prev) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	if (append_entrycopy(e, prev))
+		return 1;
+
+	return 0;
+}
+
+/* Atomically replace rule `rulenum' in `chain' with `fw'. */
+int
+TC_REPLACE_ENTRY(const IPT_CHAINLABEL chain,
+		 const STRUCT_ENTRY *e,
+		 unsigned int rulenum,
+		 TC_HANDLE_T *handle)
+{
+	struct chain_head *c;
+	struct rule_head *repl;
+
+	iptc_fn = TC_REPLACE_ENTRY;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	repl = ruleh_get_n(c, rulenum);
+	if (!repl) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	if (!append_entrycopy(e, repl)) {
+		errno = ENOMEM;
+		return 0;
+	}
+
+	ruleh_free(repl);
+	return 1;
+}
+
+/* Append entry `e' to chain `chain'.  Equivalent to insert with
+   rulenum = length of chain. */
+int
+TC_APPEND_ENTRY(const IPT_CHAINLABEL chain,
+		const STRUCT_ENTRY *e,
+		TC_HANDLE_T *handle)
+{
+	struct chain_head *c;
+	struct rule_head *rhead;
+
+	iptc_fn = TC_APPEND_ENTRY;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	rhead = list_entry(c->rules.prev, struct rule_head, list);
+	if(append_entrycopy(e, rhead))
+		return 1;
+	
+	return 0;
+}
+
+static inline int
+match_different(const STRUCT_ENTRY_MATCH *a,
+		const unsigned char *a_elems,
+		const unsigned char *b_elems,
+		unsigned char **maskptr)
+{
+	const STRUCT_ENTRY_MATCH *b;
+	unsigned int i;
+
+	/* Offset of b is the same as a. */
+	b = (void *)b_elems + ((unsigned char *)a - a_elems);
+
+	if (a->u.match_size != b->u.match_size)
+		return 1;
+
+	if (strcmp(a->u.user.name, b->u.user.name) != 0)
+		return 1;
+
+	*maskptr += ALIGN(sizeof(*a));
+
+	for (i = 0; i < a->u.match_size - ALIGN(sizeof(*a)); i++)
+		if (((a->data[i] ^ b->data[i]) & (*maskptr)[i]) != 0)
+			return 1;
+	*maskptr += i;
+	return 0;
+}
+
+static inline int
+target_different(const unsigned char *a_targdata,
+		 const unsigned char *b_targdata,
+		 unsigned int tdatasize,
+		 const unsigned char *mask)
+{
+	unsigned int i;
+	for (i = 0; i < tdatasize; i++)
+		if (((a_targdata[i] ^ b_targdata[i]) & mask[i]) != 0)
+			return 1;
+
+	return 0;
+}
+
+static int
+is_same(const STRUCT_ENTRY *a,
+	const STRUCT_ENTRY *b,
+	unsigned char *matchmask);
+
+/* Delete the first rule in `chain' which matches `origfw'. */
+int
+TC_DELETE_ENTRY(const IPT_CHAINLABEL chain,
+		const STRUCT_ENTRY *origfw,
+		unsigned char *matchmask,
+		TC_HANDLE_T *handle)
+{
+	struct chain_head *c;
+	struct list_head *cur, *cur2;
+
+	iptc_fn = TC_DELETE_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	list_for_each_safe(cur, cur2, &c->rules) {
+		struct rule_head *rhead = list_entry(cur, struct rule_head, 
+							list);
+		if (is_same(rhead->entry, origfw, matchmask)) {
+			ruleh_free(rhead);
+			return 1;
+		}
+	}
+
+	errno = ENOENT;
+	return 0;
+}
+
+/* Delete the rule in position `rulenum' in `chain'. */
+int
+TC_DELETE_NUM_ENTRY(const IPT_CHAINLABEL chain,
+		    unsigned int rulenum,
+		    TC_HANDLE_T *handle)
+{
+	struct chain_head *chainh;
+	struct rule_head *rhead;
+
+	iptc_fn = TC_DELETE_NUM_ENTRY;
+
+	if (!(chainh = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	rhead = ruleh_get_n(chainh, rulenum);
+	if (!rhead) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	ruleh_free(rhead);
+
+	return 1;
+}
+
+/* Check the packet `fw' on chain `chain'.  Returns the verdict, or
+   NULL and sets errno. */
+const char *
+TC_CHECK_PACKET(const IPT_CHAINLABEL chain,
+		STRUCT_ENTRY *entry,
+		TC_HANDLE_T *handle)
+{
+	errno = ENOSYS;
+	return NULL;
+}
+
+/* Flushes the entries in the given chain (ie. empties chain). */
+int
+TC_FLUSH_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	struct list_head *cur, *cur2;
+	struct chain_head *chainh;
+
+	if (!(chainh = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	list_for_each_safe(cur, cur2, &chainh->rules) {
+		struct rule_head *ruleh = list_entry(cur, struct rule_head, 
+							list);
+		/* don't free the entry and policy/return entries */
+		if (ruleh != chainh->firstrule && ruleh != chainh->lastrule)
+			ruleh_free(ruleh);
+	}
+	return 1;
+}
+
+/* Zeroes the counters in a chain. */
+int
+TC_ZERO_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	struct chain_head *c;
+	struct list_head *cur;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	list_for_each(cur, c->rules.next) {
+		struct rule_head *r = list_entry(cur, struct rule_head, list);
+		if (r->counter_map.maptype == COUNTER_MAP_NORMAL_MAP)
+			r->counter_map.maptype = COUNTER_MAP_ZEROED;
+	}
+	set_changed(*handle);
+
+	return 1;
+}
+
+STRUCT_COUNTERS *
+TC_READ_COUNTER(const IPT_CHAINLABEL chain,
+		unsigned int rulenum,
+		TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_head *c;
+	struct rule_head *r;
+
+	iptc_fn = TC_READ_COUNTER;
+	CHECK(*handle);
+
+	if (!(c = find_label(chain, *handle) )
+	      || !(r = ruleh_get_n(c, rulenum))) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	return &r->entry->counters;
+}
+
+int
+TC_ZERO_COUNTER(const IPT_CHAINLABEL chain,
+		unsigned int rulenum,
+		TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_head *c;
+	struct rule_head *r;
+	
+	iptc_fn = TC_ZERO_COUNTER;
+	CHECK(*handle);
+
+	if (!(c = find_label(chain, *handle))
+	      || !(r = ruleh_get_n(c, rulenum))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	if (r->counter_map.maptype == COUNTER_MAP_NORMAL_MAP)
+		r->counter_map.maptype = COUNTER_MAP_ZEROED;
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+int 
+TC_SET_COUNTER(const IPT_CHAINLABEL chain,
+	       unsigned int rulenum,
+	       STRUCT_COUNTERS *counters,
+	       TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_head *c;
+	struct rule_head *r;
+
+	iptc_fn = TC_SET_COUNTER;
+	CHECK(*handle);
+
+	if (!(c = find_label(chain, *handle))
+	      || !(r = ruleh_get_n(c, rulenum))) {
+		errno = ENOENT;
+		return 0;
+	}
+	
+	r->counter_map.maptype = COUNTER_MAP_SET;
+	memcpy(&r->entry->counters, counters, sizeof(STRUCT_COUNTERS));
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+/* Creates a new chain. */
+/* To create a chain, create two rules: error node and unconditional
+ * return. */
+int
+TC_CREATE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	int ret;
+	struct chainstart {
+		STRUCT_ENTRY head;
+		struct ipt_error_target name;
+	} *newc1;
+	struct chainend {
+		STRUCT_ENTRY ret;
+		STRUCT_STANDARD_TARGET target;
+	} *newc2;
+	struct rule_head *newr1, *newr2;
+	struct chain_head *chead;
+
+	iptc_fn = TC_CREATE_CHAIN;
+
+	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
+           QUEUE, RETURN. */
+	if (find_label(chain, *handle)
+	    || strcmp(chain, LABEL_DROP) == 0
+	    || strcmp(chain, LABEL_ACCEPT) == 0
+	    || strcmp(chain, LABEL_QUEUE) == 0
+	    || strcmp(chain, LABEL_RETURN) == 0) {
+		errno = EEXIST;
+		return 0;
+	}
+
+	if (strlen(chain)+1 > sizeof(IPT_CHAINLABEL)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	chead = chainh_alloc(*handle, chain);
+	if (!chead) {
+		errno = ENOMEM;
+		return 0;
+	}
+	
+	newr1 = ruleh_alloc(sizeof(*newc1));
+	if (!newr1) {
+		chainh_free(chead);
+		return 0;
+	}
+	newc1 = (struct chainstart *) newr1->entry;
+
+	newr2 = ruleh_alloc(sizeof(*newc2));
+	if (!newr2) {
+		chainh_free(chead);
+		ruleh_free(newr1);
+		return 0;
+	}
+	newc2 = (struct chainend *) newr2->entry;
+
+	newc1->head.target_offset = sizeof(STRUCT_ENTRY);
+	newc1->head.next_offset
+		= sizeof(STRUCT_ENTRY)
+		+ ALIGN(sizeof(struct ipt_error_target));
+	strcpy(newc1->name.t.u.user.name, ERROR_TARGET);
+	newc1->name.t.u.target_size = ALIGN(sizeof(struct ipt_error_target));
+	strcpy(newc1->name.error, chain);
+
+	newc2->ret.target_offset = sizeof(STRUCT_ENTRY);
+	newc2->ret.next_offset
+		= sizeof(STRUCT_ENTRY)
+		+ ALIGN(sizeof(STRUCT_STANDARD_TARGET));
+	strcpy(newc2->target.target.u.user.name, STANDARD_TARGET);
+	newc2->target.target.u.target_size
+		= ALIGN(sizeof(STRUCT_STANDARD_TARGET));
+	newc2->target.verdict = RETURN;
+
+	list_prepend(&newr1->list, &chead->rules);
+	chead->firstrule = newr1;
+	list_append(&newr2->list, &chead->rules);
+	chead->lastrule = newr2;
+
+	return 1;
+}
+
+#if 0
+static int
+count_ref(STRUCT_ENTRY *e, unsigned int offset, unsigned int *ref)
+{
+	STRUCT_STANDARD_TARGET *t;
+
+	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) == 0) {
+		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+
+		if (t->verdict == offset)
+			(*ref)++;
+	}
+
+	return 0;
+}
+
+/* Get the number of references to this chain. */
+int
+TC_GET_REFERENCES(unsigned int *ref, const IPT_CHAINLABEL chain,
+		  TC_HANDLE_T *handle)
+{
+	struct chain_cache *c;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	*ref = 0;
+	ENTRY_ITERATE((*handle)->entries.entrytable,
+		      (*handle)->entries.size,
+		      count_ref, c->start_off, ref);
+	return 1;
+}
+#endif
+
+static unsigned int
+count_rules(struct chain_head *chainh)
+{
+	unsigned int numrules = 0;
+	struct list_head *cur;
+
+	list_for_each(cur, &chainh->rules) {
+		numrules++;
+	}
+
+	if (numrules <=2)
+		return 0;
+	else
+		return numrules-2;
+}
+
+/* Deletes a chain. */
+int
+TC_DELETE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	unsigned int references;
+	struct chain_head *chainh;
+
+#if 0
+	if (!TC_GET_REFERENCES(&references, chain, handle))
+		return 0;
+
+	iptc_fn = TC_DELETE_CHAIN;
+
+	if (TC_BUILTIN(chain, *handle)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	if (references > 0) {
+		errno = EMLINK;
+		return 0;
+	}
+#endif 
+
+	if (!(chainh = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	if (!(count_rules(chainh) == 0)) {
+		errno = ENOTEMPTY;
+		return 0;
+	}
+
+	chainh_free(chainh);
+	return 1;
+}
+
+/* Renames a chain. */
+int TC_RENAME_CHAIN(const IPT_CHAINLABEL oldname,
+		    const IPT_CHAINLABEL newname,
+		    TC_HANDLE_T *handle)
+{
+	struct chain_head *c;
+	struct rule_head *ruleh;
+	struct ipt_error_target *t;
+
+	iptc_fn = TC_RENAME_CHAIN;
+
+	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
+           QUEUE, RETURN. */
+	if (find_label(newname, *handle)
+	    || strcmp(newname, LABEL_DROP) == 0
+	    || strcmp(newname, LABEL_ACCEPT) == 0
+	    || strcmp(newname, LABEL_QUEUE) == 0
+	    || strcmp(newname, LABEL_RETURN) == 0) {
+		errno = EEXIST;
+		return 0;
+	}
+
+	if (!(c = find_label(oldname, *handle))
+	    || TC_BUILTIN(oldname, *handle)) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	if (strlen(newname)+1 > sizeof(IPT_CHAINLABEL)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	ruleh = list_entry(&c->rules.next, struct rule_head, list);
+
+	t = (struct ipt_error_target *)
+		GET_TARGET(ruleh->entry);
+
+	memset(t->error, 0, sizeof(t->error));
+	strcpy(t->error, newname);
+
+	return 1;
+}
+
+/* Sets the policy on a built-in chain. */
+int
+TC_SET_POLICY(const IPT_CHAINLABEL chain,
+	      const IPT_CHAINLABEL policy,
+	      STRUCT_COUNTERS *counters,
+	      TC_HANDLE_T *handle)
+{
+	int ctrindex;
+	unsigned int hook;
+	struct chain_head *chainh;
+	struct rule_head *policyrh;
+	STRUCT_ENTRY *e;
+	STRUCT_STANDARD_TARGET *t;
+
+	iptc_fn = TC_SET_POLICY;
+	/* Figure out which chain. */
+	hook = TC_BUILTIN(chain, *handle);
+	if (hook == 0) {
+		errno = ENOENT;
+		return 0;
+	} else
+		hook--;
+
+	if (!(chainh = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	policyrh = chainh->lastrule;
+	if (policyrh) {
+		printf("ERROR: Policy for `%s' non-existant", chain);
+		return 0;
+	}
+
+	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(policyrh->entry);
+
+	if (strcmp(policy, LABEL_ACCEPT) == 0)
+		t->verdict = -NF_ACCEPT - 1;
+	else if (strcmp(policy, LABEL_DROP) == 0)
+		t->verdict = -NF_DROP - 1;
+	else {
+		errno = EINVAL;
+		return 0;
+	}
+
+	ctrindex = entry2index(*handle, e);
+
+	if (counters) {
+		/* set byte and packet counters */
+		memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
+
+		policyrh->counter_map.maptype = COUNTER_MAP_SET;
+
+	} else {
+		policyrh->counter_map.maptype = COUNTER_MAP_NOMAP;
+		policyrh->counter_map.mappos = 0;
+	}
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+/* Without this, on gcc 2.7.2.3, we get:
+   libiptc.c: In function `TC_COMMIT':
+   libiptc.c:833: fixed or forbidden register was spilled.
+   This may be due to a compiler bug or to impossible asm
+   statements or clauses.
+*/
+static void
+subtract_counters(STRUCT_COUNTERS *answer,
+		  const STRUCT_COUNTERS *a,
+		  const STRUCT_COUNTERS *b)
+{
+	answer->pcnt = a->pcnt - b->pcnt;
+	answer->bcnt = a->bcnt - b->bcnt;
+}
+
+int
+TC_COMMIT(TC_HANDLE_T *handle)
+{
+	/* Replace, then map back the counters. */
+	STRUCT_REPLACE *repl;
+	STRUCT_COUNTERS_INFO *newcounters;
+	unsigned int i;
+	size_t counterlen;
+
+	CHECK(*handle);
+
+	counterlen = sizeof(STRUCT_COUNTERS_INFO)
+			+ sizeof(STRUCT_COUNTERS) * (*handle)->new_number;
+
+#if 0
+	TC_DUMP_ENTRIES(*handle);
+#endif
+
+	/* Don't commit if nothing changed. */
+	if (!(*handle)->changed)
+		goto finished;
+
+	repl = malloc(sizeof(*repl) + (*handle)->entries.size);
+	if (!repl) {
+		errno = ENOMEM;
+		return 0;
+	}
+
+	/* These are the old counters we will get from kernel */
+	repl->counters = malloc(sizeof(STRUCT_COUNTERS)
+				* (*handle)->info.num_entries);
+	if (!repl->counters) {
+		free(repl);
+		errno = ENOMEM;
+		return 0;
+	}
+
+	/* These are the counters we're going to put back, later. */
+	newcounters = malloc(counterlen);
+	if (!newcounters) {
+		free(repl->counters);
+		free(repl);
+		errno = ENOMEM;
+		return 0;
+	}
+
+	strcpy(repl->name, (*handle)->info.name);
+	repl->num_entries = (*handle)->new_number;
+	repl->size = (*handle)->entries.size;
+	memcpy(repl->hook_entry, (*handle)->info.hook_entry,
+	       sizeof(repl->hook_entry));
+	memcpy(repl->underflow, (*handle)->info.underflow,
+	       sizeof(repl->underflow));
+	repl->num_counters = (*handle)->info.num_entries;
+	repl->valid_hooks = (*handle)->info.valid_hooks;
+	memcpy(repl->entries, (*handle)->entries.entrytable,
+	       (*handle)->entries.size);
+
+	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_REPLACE, repl,
+		       sizeof(*repl) + (*handle)->entries.size) < 0) {
+		free(repl->counters);
+		free(repl);
+		free(newcounters);
+		return 0;
+	}
+
+	/* Put counters back. */
+	strcpy(newcounters->name, (*handle)->info.name);
+	newcounters->num_counters = (*handle)->new_number;
+	for (i = 0; i < (*handle)->new_number; i++) {
+		unsigned int mappos = (*handle)->counter_map[i].mappos;
+		switch ((*handle)->counter_map[i].maptype) {
+		case COUNTER_MAP_NOMAP:
+			newcounters->counters[i]
+				= ((STRUCT_COUNTERS){ 0, 0 });
+			break;
+
+		case COUNTER_MAP_NORMAL_MAP:
+			/* Original read: X.
+			 * Atomic read on replacement: X + Y.
+			 * Currently in kernel: Z.
+			 * Want in kernel: X + Y + Z.
+			 * => Add in X + Y
+			 * => Add in replacement read.
+			 */
+			newcounters->counters[i] = repl->counters[mappos];
+			break;
+
+		case COUNTER_MAP_ZEROED:
+			/* Original read: X.
+			 * Atomic read on replacement: X + Y.
+			 * Currently in kernel: Z.
+			 * Want in kernel: Y + Z.
+			 * => Add in Y.
+			 * => Add in (replacement read - original read).
+			 */
+			subtract_counters(&newcounters->counters[i],
+					  &repl->counters[mappos],
+					  &index2entry(*handle, i)->counters);
+			break;
+
+		case COUNTER_MAP_SET:
+			/* Want to set counter (iptables-restore) */
+
+			memcpy(&newcounters->counters[i],
+			       &index2entry(*handle, i)->counters,
+			       sizeof(STRUCT_COUNTERS));
+
+			break;
+		}
+	}
+
+#ifdef KERNEL_64_USERSPACE_32
+	{
+		/* Kernel will think that pointer should be 64-bits, and get
+		   padding.  So we accomodate here (assumption: alignment of
+		   `counters' is on 64-bit boundary). */
+		u_int64_t *kernptr = (u_int64_t *)&newcounters->counters;
+		if ((unsigned long)&newcounters->counters % 8 != 0) {
+			fprintf(stderr,
+				"counters alignment incorrect! Mail rusty!\n");
+			abort();
+		}
+		*kernptr = newcounters->counters;
+	}
+#endif /* KERNEL_64_USERSPACE_32 */
+
+	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_ADD_COUNTERS,
+		       newcounters, counterlen) < 0) {
+		free(repl->counters);
+		free(repl);
+		free(newcounters);
+		return 0;
+	}
+
+	free(repl->counters);
+	free(repl);
+	free(newcounters);
+
+ finished:
+	TC_FREE(handle);
+	return 1;
+}
+
+/* Get raw socket. */
+int
+TC_GET_RAW_SOCKET()
+{
+	return sockfd;
+}
+
+/* Translates errno numbers into more human-readable form than strerror. */
+const char *
+TC_STRERROR(int err)
+{
+	unsigned int i;
+	struct table_struct {
+		void *fn;
+		int err;
+		const char *message;
+	} table [] =
+	  { { TC_INIT, EPERM, "Permission denied (you must be root)" },
+	    { TC_INIT, EINVAL, "Module is wrong version" },
+	    { TC_INIT, ENOENT, 
+		    "Table does not exist (do you need to insmod?)" },
+	    { TC_DELETE_CHAIN, ENOTEMPTY, "Chain is not empty" },
+	    { TC_DELETE_CHAIN, EINVAL, "Can't delete built-in chain" },
+	    { TC_DELETE_CHAIN, EMLINK,
+	      "Can't delete chain with references left" },
+	    { TC_CREATE_CHAIN, EEXIST, "Chain already exists" },
+	    { TC_INSERT_ENTRY, E2BIG, "Index of insertion too big" },
+	    { TC_REPLACE_ENTRY, E2BIG, "Index of replacement too big" },
+	    { TC_DELETE_NUM_ENTRY, E2BIG, "Index of deletion too big" },
+	    { TC_READ_COUNTER, E2BIG, "Index of counter too big" },
+	    { TC_ZERO_COUNTER, E2BIG, "Index of counter too big" },
+	    { TC_INSERT_ENTRY, ELOOP, "Loop found in table" },
+	    { TC_INSERT_ENTRY, EINVAL, "Target problem" },
+	    /* EINVAL for CHECK probably means bad interface. */
+	    { TC_CHECK_PACKET, EINVAL,
+	      "Bad arguments (does that interface exist?)" },
+	    { TC_CHECK_PACKET, ENOSYS,
+	      "Checking will most likely never get implemented" },
+	    /* ENOENT for DELETE probably means no matching rule */
+	    { TC_DELETE_ENTRY, ENOENT,
+	      "Bad rule (does a matching rule exist in that chain?)" },
+	    { TC_SET_POLICY, ENOENT,
+	      "Bad built-in chain name" },
+	    { TC_SET_POLICY, EINVAL,
+	      "Bad policy name" },
+
+	    { NULL, 0, "Incompatible with this kernel" },
+	    { NULL, ENOPROTOOPT, "iptables who? (do you need to insmod?)" },
+	    { NULL, ENOSYS, "Will be implemented real soon.  I promise ;)" },
+	    { NULL, ENOMEM, "Memory allocation problem" },
+	    { NULL, ENOENT, "No chain/target/match by that name" },
+	  };
+
+	for (i = 0; i < sizeof(table)/sizeof(struct table_struct); i++) {
+		if ((!table[i].fn || table[i].fn == iptc_fn)
+		    && table[i].err == err)
+			return table[i].message;
+	}
+
+	return strerror(err);
+}
diff -urN iptables-1.2.8/libiptc2/libiptc.cvs.c iptables-1.2.9/libiptc2/libiptc.cvs.c
--- iptables-1.2.8/libiptc2/libiptc.cvs.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/libiptc2/libiptc.cvs.c	2003-06-30 21:03:53.000000000 +0200
@@ -0,0 +1,1920 @@
+/* Library which manipulates firewall rules.  Version $Revision: 1.40 $ */
+
+/* Architecture of firewall rules is as follows:
+ *
+ * Chains go INPUT, FORWARD, OUTPUT then user chains.
+ * Each user chain starts with an ERROR node.
+ * Every chain ends with an unconditional jump: a RETURN for user chains,
+ * and a POLICY for built-ins.
+ */
+
+/* (C) 1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
+ * COPYING for details). 
+ * (C) 2000-2003 by the Netfilter Core Team <coreteam@netfilter.org>
+ *
+ * 2003-Jun-20: Harald Welte <laforge@netfilter.org>:
+ *	- Reimplementation of chain cache to use offsets instead of entries
+ * 2003-Jun-23: Harald Welte <laforge@netfilter.org>:
+ * 	- performance optimization, sponsored by Astaro AG (http://www.astaro.com/)
+ * 	  don't rebuild the chain cache after every operation, instead fix it
+ * 	  up after a ruleset change.  
+ */
+
+#ifndef IPT_LIB_DIR
+#define IPT_LIB_DIR "/usr/local/lib/iptables"
+#endif
+
+#ifndef __OPTIMIZE__
+STRUCT_ENTRY_TARGET *
+GET_TARGET(STRUCT_ENTRY *e)
+{
+	return (void *)e + e->target_offset;
+}
+#endif
+
+static int sockfd = -1;
+static void *iptc_fn = NULL;
+
+static const char *hooknames[]
+= { [HOOK_PRE_ROUTING]  "PREROUTING",
+    [HOOK_LOCAL_IN]     "INPUT",
+    [HOOK_FORWARD]      "FORWARD",
+    [HOOK_LOCAL_OUT]    "OUTPUT",
+    [HOOK_POST_ROUTING] "POSTROUTING",
+#ifdef HOOK_DROPPING
+    [HOOK_DROPPING]	"DROPPING"
+#endif
+};
+
+struct counter_map
+{
+	enum {
+		COUNTER_MAP_NOMAP,
+		COUNTER_MAP_NORMAL_MAP,
+		COUNTER_MAP_ZEROED,
+		COUNTER_MAP_SET
+	} maptype;
+	unsigned int mappos;
+};
+
+/* Convenience structures */
+struct ipt_error_target
+{
+	STRUCT_ENTRY_TARGET t;
+	char error[TABLE_MAXNAMELEN];
+};
+
+struct chain_cache
+{
+	char name[TABLE_MAXNAMELEN];
+	/* This is the first rule in chain. */
+	unsigned int start_off;
+	/* Last rule in chain */
+	unsigned int end_off;
+};
+
+STRUCT_TC_HANDLE
+{
+	/* Have changes been made? */
+	int changed;
+	/* Size in here reflects original state. */
+	STRUCT_GETINFO info;
+
+	struct counter_map *counter_map;
+	/* Array of hook names */
+	const char **hooknames;
+
+	/* Cached position of chain heads (NULL = no cache). */
+	unsigned int cache_num_chains;
+	unsigned int cache_num_builtins;
+	struct chain_cache *cache_chain_heads;
+
+	/* Chain iterator: current chain cache entry. */
+	struct chain_cache *cache_chain_iteration;
+
+	/* Rule iterator: terminal rule */
+	STRUCT_ENTRY *cache_rule_end;
+
+	/* Number in here reflects current state. */
+	unsigned int new_number;
+	STRUCT_GET_ENTRIES entries;
+};
+
+static void
+set_changed(TC_HANDLE_T h)
+{
+	h->changed = 1;
+}
+
+#ifdef IPTC_DEBUG
+static void do_check(TC_HANDLE_T h, unsigned int line);
+#define CHECK(h) do { if (!getenv("IPTC_NO_CHECK")) do_check((h), __LINE__); } while(0)
+#else
+#define CHECK(h)
+#endif
+
+static inline int
+get_number(const STRUCT_ENTRY *i,
+	   const STRUCT_ENTRY *seek,
+	   unsigned int *pos)
+{
+	if (i == seek)
+		return 1;
+	(*pos)++;
+	return 0;
+}
+
+static unsigned int
+entry2index(const TC_HANDLE_T h, const STRUCT_ENTRY *seek)
+{
+	unsigned int pos = 0;
+
+	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+			  get_number, seek, &pos) == 0) {
+		fprintf(stderr, "ERROR: offset %i not an entry!\n",
+			(char *)seek - (char *)h->entries.entrytable);
+		abort();
+	}
+	return pos;
+}
+
+static inline int
+get_entry_n(STRUCT_ENTRY *i,
+	    unsigned int number,
+	    unsigned int *pos,
+	    STRUCT_ENTRY **pe)
+{
+	if (*pos == number) {
+		*pe = i;
+		return 1;
+	}
+	(*pos)++;
+	return 0;
+}
+
+static STRUCT_ENTRY *
+index2entry(TC_HANDLE_T h, unsigned int index)
+{
+	unsigned int pos = 0;
+	STRUCT_ENTRY *ret = NULL;
+
+	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+		      get_entry_n, index, &pos, &ret);
+
+	return ret;
+}
+
+static inline STRUCT_ENTRY *
+get_entry(TC_HANDLE_T h, unsigned int offset)
+{
+	return (STRUCT_ENTRY *)((char *)h->entries.entrytable + offset);
+}
+
+static inline unsigned long
+entry2offset(const TC_HANDLE_T h, const STRUCT_ENTRY *e)
+{
+	return (void *)e - (void *)h->entries.entrytable;
+}
+
+static inline unsigned long
+index2offset(TC_HANDLE_T h, unsigned int index)
+{
+	return entry2offset(h, index2entry(h, index));
+}
+
+static inline STRUCT_ENTRY *
+offset2entry(TC_HANDLE_T h, unsigned int offset)
+{
+	return (STRUCT_ENTRY *) ((void *)h->entries.entrytable+offset);
+}
+
+static inline unsigned int
+offset2index(const TC_HANDLE_T h, unsigned int offset)
+{
+	return entry2index(h, offset2entry(h, offset));
+}
+
+
+static const char *
+get_errorlabel(TC_HANDLE_T h, unsigned int offset)
+{
+	STRUCT_ENTRY *e;
+
+	e = get_entry(h, offset);
+	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) != 0) {
+		fprintf(stderr, "ERROR: offset %u not an error node!\n",
+			offset);
+		abort();
+	}
+
+	return (const char *)GET_TARGET(e)->data;
+}
+
+/* Allocate handle of given size */
+static TC_HANDLE_T
+alloc_handle(const char *tablename, unsigned int size, unsigned int num_rules)
+{
+	size_t len;
+	TC_HANDLE_T h;
+
+	len = sizeof(STRUCT_TC_HANDLE)
+		+ size
+		+ num_rules * sizeof(struct counter_map);
+
+	if ((h = malloc(len)) == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	h->changed = 0;
+	h->cache_num_chains = 0;
+	h->cache_chain_heads = NULL;
+	h->counter_map = (void *)h
+		+ sizeof(STRUCT_TC_HANDLE)
+		+ size;
+	strcpy(h->info.name, tablename);
+	strcpy(h->entries.name, tablename);
+
+	return h;
+}
+
+TC_HANDLE_T
+TC_INIT(const char *tablename)
+{
+	TC_HANDLE_T h;
+	STRUCT_GETINFO info;
+	unsigned int i;
+	int tmp;
+	socklen_t s;
+
+	iptc_fn = TC_INIT;
+
+	if (sockfd != -1) {
+		close(sockfd);
+		sockfd = -1;
+	}
+
+	if (strlen(tablename) >= TABLE_MAXNAMELEN) {
+		errno = EINVAL;
+		return NULL;
+	}
+	
+	sockfd = socket(TC_AF, SOCK_RAW, IPPROTO_RAW);
+	if (sockfd < 0)
+		return NULL;
+
+	s = sizeof(info);
+
+	strcpy(info.name, tablename);
+	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_INFO, &info, &s) < 0)
+		return NULL;
+
+	if ((h = alloc_handle(info.name, info.size, info.num_entries))
+	    == NULL) {
+		close(sockfd);
+		sockfd = -1;
+		return NULL;
+	}
+
+/* Too hard --RR */
+#if 0
+	sprintf(pathname, "%s/%s", IPT_LIB_DIR, info.name);
+	dynlib = dlopen(pathname, RTLD_NOW);
+	if (!dynlib) {
+		errno = ENOENT;
+		return NULL;
+	}
+	h->hooknames = dlsym(dynlib, "hooknames");
+	if (!h->hooknames) {
+		errno = ENOENT;
+		return NULL;
+	}
+#else
+	h->hooknames = hooknames;
+#endif
+
+	/* Initialize current state */
+	h->info = info;
+	h->new_number = h->info.num_entries;
+	for (i = 0; i < h->info.num_entries; i++)
+		h->counter_map[i]
+			= ((struct counter_map){COUNTER_MAP_NORMAL_MAP, i});
+
+	h->entries.size = h->info.size;
+
+	tmp = sizeof(STRUCT_GET_ENTRIES) + h->info.size;
+
+	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_ENTRIES, &h->entries,
+		       &tmp) < 0) {
+		close(sockfd);
+		sockfd = -1;
+		free(h);
+		return NULL;
+	}
+
+	CHECK(h);
+	return h;
+}
+
+void
+TC_FREE(TC_HANDLE_T *h)
+{
+	close(sockfd);
+	sockfd = -1;
+	if ((*h)->cache_chain_heads)
+		free((*h)->cache_chain_heads);
+	free(*h);
+	*h = NULL;
+}
+
+static inline int
+print_match(const STRUCT_ENTRY_MATCH *m)
+{
+	printf("Match name: `%s'\n", m->u.user.name);
+	return 0;
+}
+
+static int dump_entry(STRUCT_ENTRY *e, const TC_HANDLE_T handle);
+ 
+void
+TC_DUMP_ENTRIES(const TC_HANDLE_T handle)
+{
+	CHECK(handle);
+
+	printf("libiptc v%s.  %u entries, %u bytes.\n",
+	       IPTABLES_VERSION,
+	       handle->new_number, handle->entries.size);
+	printf("Table `%s'\n", handle->info.name);
+	printf("Hooks: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
+	       handle->info.hook_entry[HOOK_PRE_ROUTING],
+	       handle->info.hook_entry[HOOK_LOCAL_IN],
+	       handle->info.hook_entry[HOOK_FORWARD],
+	       handle->info.hook_entry[HOOK_LOCAL_OUT],
+	       handle->info.hook_entry[HOOK_POST_ROUTING]);
+	printf("Underflows: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
+	       handle->info.underflow[HOOK_PRE_ROUTING],
+	       handle->info.underflow[HOOK_LOCAL_IN],
+	       handle->info.underflow[HOOK_FORWARD],
+	       handle->info.underflow[HOOK_LOCAL_OUT],
+	       handle->info.underflow[HOOK_POST_ROUTING]);
+
+	ENTRY_ITERATE(handle->entries.entrytable, handle->entries.size,
+		      dump_entry, handle);
+}
+
+/* Returns 0 if not hook entry, else hooknumber + 1 */
+static inline unsigned int
+is_hook_entry(STRUCT_ENTRY *e, TC_HANDLE_T h)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUMHOOKS; i++) {
+		if ((h->info.valid_hooks & (1 << i))
+		    && get_entry(h, h->info.hook_entry[i]) == e)
+			return i+1;
+	}
+	return 0;
+}
+
+static inline int
+add_chain(STRUCT_ENTRY *e, TC_HANDLE_T h, STRUCT_ENTRY **prev)
+{
+	unsigned int builtin;
+
+	/* Last entry.  End it. */
+	if (entry2offset(h, e) + e->next_offset == h->entries.size) {
+		/* This is the ERROR node at end of the table */
+		h->cache_chain_heads[h->cache_num_chains-1].end_off = 
+			entry2offset(h, *prev);
+		return 0;
+	}
+
+	/* We know this is the start of a new chain if it's an ERROR
+	   target, or a hook entry point */
+	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) == 0) {
+		/* prev was last entry in previous chain */
+		h->cache_chain_heads[h->cache_num_chains-1].end_off
+			= entry2offset(h, *prev);
+
+		strcpy(h->cache_chain_heads[h->cache_num_chains].name,
+		       (const char *)GET_TARGET(e)->data);
+		h->cache_chain_heads[h->cache_num_chains].start_off
+			= entry2offset(h, (void *)e + e->next_offset);
+		h->cache_num_chains++;
+	} else if ((builtin = is_hook_entry(e, h)) != 0) {
+		if (h->cache_num_chains > 0)
+			/* prev was last entry in previous chain */
+			h->cache_chain_heads[h->cache_num_chains-1].end_off
+				= entry2offset(h, *prev);
+
+		strcpy(h->cache_chain_heads[h->cache_num_chains].name,
+		       h->hooknames[builtin-1]);
+		h->cache_chain_heads[h->cache_num_chains].start_off
+			= entry2offset(h, (void *)e);
+		h->cache_num_chains++;
+	}
+
+	*prev = e;
+	return 0;
+}
+
+static int alphasort(const void *a, const void *b)
+{
+	return strcmp(((struct chain_cache *)a)->name,
+		      ((struct chain_cache *)b)->name);
+}
+
+static int populate_cache(TC_HANDLE_T h)
+{
+	unsigned int i;
+	STRUCT_ENTRY *prev;
+
+	/* # chains < # rules / 2 + num builtins - 1 */
+	h->cache_chain_heads = malloc((h->new_number / 2 + 4)
+				      * sizeof(struct chain_cache));
+	if (!h->cache_chain_heads) {
+		errno = ENOMEM;
+		return 0;
+	}
+
+	h->cache_num_chains = 0;
+	h->cache_num_builtins = 0;
+
+	/* Count builtins */
+	for (i = 0; i < NUMHOOKS; i++) {
+		if (h->info.valid_hooks & (1 << i))
+			h->cache_num_builtins++;
+	}
+
+	prev = NULL;
+	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+		      add_chain, h, &prev);
+
+	qsort(h->cache_chain_heads + h->cache_num_builtins,
+	      h->cache_num_chains - h->cache_num_builtins,
+	      sizeof(struct chain_cache), alphasort);
+
+	return 1;
+}
+
+static int 
+correct_cache(TC_HANDLE_T h, unsigned int offset, int delta)
+{
+	int i;		/* needs to be signed because deleting first
+			   chain can make it drop to -1 */
+
+	if (!delta)
+		return 1;
+
+	for (i = 0; i < h->cache_num_chains; i++) {
+		struct chain_cache *cc = &h->cache_chain_heads[i];
+
+		if (delta < 0) {
+			/* take care about deleted chains */
+			if (cc->start_off >= offset+delta
+			    && cc->end_off <= offset) {
+				/* this chain is within the deleted range,
+				 * let's remove it from the cache */
+				void *start;
+				unsigned int size;
+
+				h->cache_num_chains--;
+				if (i+1 >= h->cache_num_chains)
+					continue;
+				start = &h->cache_chain_heads[i+1];
+				size = (h->cache_num_chains-i)
+					* sizeof(struct chain_cache);
+				memmove(cc, start, size);
+
+				/* iterate over same index again, since
+				 * it is now a different chain */
+				i--;
+				continue;
+			}
+		}
+
+		if (cc->start_off > offset)
+			cc->start_off += delta;
+
+		if (cc->end_off >= offset)
+			cc->end_off += delta;
+	}
+	/* HW_FIXME: sorting might be needed, but just in case a new chain was
+	 * added */
+
+	return 1;
+}
+
+static int
+add_chain_cache(TC_HANDLE_T h, const char *name, unsigned int start_off,
+		unsigned int end_off)
+{
+	struct chain_cache *ccs = realloc(h->cache_chain_heads, 
+					  (h->new_number / 2 + 4 + 1)
+					   * sizeof(struct chain_cache));
+	struct chain_cache *newcc;
+	
+	if (!ccs)
+		return 0;
+
+	h->cache_chain_heads = ccs;
+	newcc = &h->cache_chain_heads[h->cache_num_chains];
+	h->cache_num_chains++;
+
+	strncpy(newcc->name, name, TABLE_MAXNAMELEN-1);
+	newcc->start_off = start_off;
+	newcc->end_off = end_off;
+
+	return 1;
+}
+
+/* Returns cache ptr if found, otherwise NULL. */
+static struct chain_cache *
+find_label(const char *name, TC_HANDLE_T handle)
+{
+	unsigned int i;
+
+	if (handle->cache_chain_heads == NULL
+	    && !populate_cache(handle))
+		return NULL;
+
+	/* FIXME: Linear search through builtins, then binary --RR */
+	for (i = 0; i < handle->cache_num_chains; i++) {
+		if (strcmp(handle->cache_chain_heads[i].name, name) == 0)
+			return &handle->cache_chain_heads[i];
+	}
+
+	return NULL;
+}
+
+/* Does this chain exist? */
+int TC_IS_CHAIN(const char *chain, const TC_HANDLE_T handle)
+{
+	return find_label(chain, handle) != NULL;
+}
+
+/* Returns the position of the final (ie. unconditional) element. */
+static unsigned int
+get_chain_end(const TC_HANDLE_T handle, unsigned int start)
+{
+	unsigned int last_off, off;
+	STRUCT_ENTRY *e;
+
+	last_off = start;
+	e = get_entry(handle, start);
+
+	/* Terminate when we meet a error label or a hook entry. */
+	for (off = start + e->next_offset;
+	     off < handle->entries.size;
+	     last_off = off, off += e->next_offset) {
+		STRUCT_ENTRY_TARGET *t;
+		unsigned int i;
+
+		e = get_entry(handle, off);
+
+		/* We hit an entry point. */
+		for (i = 0; i < NUMHOOKS; i++) {
+			if ((handle->info.valid_hooks & (1 << i))
+			    && off == handle->info.hook_entry[i])
+				return last_off;
+		}
+
+		/* We hit a user chain label */
+		t = GET_TARGET(e);
+		if (strcmp(t->u.user.name, ERROR_TARGET) == 0)
+			return last_off;
+	}
+	/* SHOULD NEVER HAPPEN */
+	fprintf(stderr, "ERROR: Off end (%u) of chain from %u!\n",
+		handle->entries.size, off);
+	abort();
+}
+
+/* Iterator functions to run through the chains. */
+const char *
+TC_FIRST_CHAIN(TC_HANDLE_T *handle)
+{
+	if ((*handle)->cache_chain_heads == NULL
+	    && !populate_cache(*handle))
+		return NULL;
+
+	(*handle)->cache_chain_iteration
+		= &(*handle)->cache_chain_heads[0];
+
+	return (*handle)->cache_chain_iteration->name;
+}
+
+/* Iterator functions to run through the chains.  Returns NULL at end. */
+const char *
+TC_NEXT_CHAIN(TC_HANDLE_T *handle)
+{
+	(*handle)->cache_chain_iteration++;
+
+	if ((*handle)->cache_chain_iteration - (*handle)->cache_chain_heads
+	    == (*handle)->cache_num_chains)
+		return NULL;
+
+	return (*handle)->cache_chain_iteration->name;
+}
+
+/* Get first rule in the given chain: NULL for empty chain. */
+const STRUCT_ENTRY *
+TC_FIRST_RULE(const char *chain, TC_HANDLE_T *handle)
+{
+	struct chain_cache *c;
+
+	c = find_label(chain, *handle);
+	if (!c) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	/* Empty chain: single return/policy rule */
+	if (c->start_off == c->end_off)
+		return NULL;
+
+	(*handle)->cache_rule_end = offset2entry(*handle, c->end_off);
+	return offset2entry(*handle, c->start_off);
+}
+
+/* Returns NULL when rules run out. */
+const STRUCT_ENTRY *
+TC_NEXT_RULE(const STRUCT_ENTRY *prev, TC_HANDLE_T *handle)
+{
+	if ((void *)prev + prev->next_offset
+	    == (void *)(*handle)->cache_rule_end)
+		return NULL;
+
+	return (void *)prev + prev->next_offset;
+}
+
+#if 0
+/* How many rules in this chain? */
+unsigned int
+TC_NUM_RULES(const char *chain, TC_HANDLE_T *handle)
+{
+	unsigned int off = 0;
+	STRUCT_ENTRY *start, *end;
+
+	CHECK(*handle);
+	if (!find_label(&off, chain, *handle)) {
+		errno = ENOENT;
+		return (unsigned int)-1;
+	}
+
+	start = get_entry(*handle, off);
+	end = get_entry(*handle, get_chain_end(*handle, off));
+
+	return entry2index(*handle, end) - entry2index(*handle, start);
+}
+
+/* Get n'th rule in this chain. */
+const STRUCT_ENTRY *TC_GET_RULE(const char *chain,
+				unsigned int n,
+				TC_HANDLE_T *handle)
+{
+	unsigned int pos = 0, chainindex;
+
+	CHECK(*handle);
+	if (!find_label(&pos, chain, *handle)) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	chainindex = entry2index(*handle, get_entry(*handle, pos));
+
+	return index2entry(*handle, chainindex + n);
+}
+#endif
+
+static const char *
+target_name(TC_HANDLE_T handle, const STRUCT_ENTRY *ce)
+{
+	int spos;
+	unsigned int labelidx;
+	STRUCT_ENTRY *jumpto;
+
+	/* To avoid const warnings */
+	STRUCT_ENTRY *e = (STRUCT_ENTRY *)ce;
+
+	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) != 0)
+		return GET_TARGET(e)->u.user.name;
+
+	/* Standard target: evaluate */
+	spos = *(int *)GET_TARGET(e)->data;
+	if (spos < 0) {
+		if (spos == RETURN)
+			return LABEL_RETURN;
+		else if (spos == -NF_ACCEPT-1)
+			return LABEL_ACCEPT;
+		else if (spos == -NF_DROP-1)
+			return LABEL_DROP;
+		else if (spos == -NF_QUEUE-1)
+			return LABEL_QUEUE;
+
+		fprintf(stderr, "ERROR: off %lu/%u not a valid target (%i)\n",
+			entry2offset(handle, e), handle->entries.size,
+			spos);
+		abort();
+	}
+
+	jumpto = get_entry(handle, spos);
+
+	/* Fall through rule */
+	if (jumpto == (void *)e + e->next_offset)
+		return "";
+
+	/* Must point to head of a chain: ie. after error rule */
+	labelidx = entry2index(handle, jumpto) - 1;
+	return get_errorlabel(handle, index2offset(handle, labelidx));
+}
+
+/* Returns a pointer to the target name of this position. */
+const char *TC_GET_TARGET(const STRUCT_ENTRY *e,
+			  TC_HANDLE_T *handle)
+{
+	return target_name(*handle, e);
+}
+
+/* Is this a built-in chain?  Actually returns hook + 1. */
+int
+TC_BUILTIN(const char *chain, const TC_HANDLE_T handle)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUMHOOKS; i++) {
+		if ((handle->info.valid_hooks & (1 << i))
+		    && handle->hooknames[i]
+		    && strcmp(handle->hooknames[i], chain) == 0)
+			return i+1;
+	}
+	return 0;
+}
+
+/* Get the policy of a given built-in chain */
+const char *
+TC_GET_POLICY(const char *chain,
+	      STRUCT_COUNTERS *counters,
+	      TC_HANDLE_T *handle)
+{
+	unsigned int start;
+	STRUCT_ENTRY *e;
+	int hook;
+
+	hook = TC_BUILTIN(chain, *handle);
+	if (hook != 0)
+		start = (*handle)->info.hook_entry[hook-1];
+	else
+		return NULL;
+
+	e = get_entry(*handle, get_chain_end(*handle, start));
+	*counters = e->counters;
+
+	return target_name(*handle, e);
+}
+
+static inline int
+correct_verdict(STRUCT_ENTRY *e,
+		char *base,
+		unsigned int offset, int delta_offset)
+{
+	STRUCT_STANDARD_TARGET *t = (void *)GET_TARGET(e);
+	unsigned int curr = (char *)e - base;
+
+	/* Trap: insert of fall-through rule.  Don't change fall-through
+	   verdict to jump-over-next-rule. */
+	if (strcmp(t->target.u.user.name, STANDARD_TARGET) == 0
+	    && t->verdict > (int)offset
+	    && !(curr == offset &&
+		 t->verdict == curr + e->next_offset)) {
+		t->verdict += delta_offset;
+	}
+
+	return 0;
+}
+
+/* Adjusts standard verdict jump positions after an insertion/deletion. */
+static int
+set_verdict(unsigned int offset, int delta_offset, TC_HANDLE_T *handle)
+{
+	ENTRY_ITERATE((*handle)->entries.entrytable,
+		      (*handle)->entries.size,
+		      correct_verdict, (char *)(*handle)->entries.entrytable,
+		      offset, delta_offset);
+
+	set_changed(*handle);
+	return 1;
+}
+
+/* If prepend is set, then we are prepending to a chain: if the
+ * insertion position is an entry point, keep the entry point. */
+static int
+insert_rules(unsigned int num_rules, unsigned int rules_size,
+	     const STRUCT_ENTRY *insert,
+	     unsigned int offset, unsigned int num_rules_offset,
+	     int prepend,
+	     TC_HANDLE_T *handle)
+{
+	TC_HANDLE_T newh;
+	STRUCT_GETINFO newinfo;
+	unsigned int i;
+
+	if (offset >= (*handle)->entries.size) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	newinfo = (*handle)->info;
+
+	/* Fix up entry points. */
+	for (i = 0; i < NUMHOOKS; i++) {
+		/* Entry points to START of chain, so keep same if
+                   inserting on at that point. */
+		if ((*handle)->info.hook_entry[i] > offset)
+			newinfo.hook_entry[i] += rules_size;
+
+		/* Underflow always points to END of chain (policy),
+		   so if something is inserted at same point, it
+		   should be advanced. */
+		if ((*handle)->info.underflow[i] >= offset)
+			newinfo.underflow[i] += rules_size;
+	}
+
+	newh = alloc_handle((*handle)->info.name,
+			    (*handle)->entries.size + rules_size,
+			    (*handle)->new_number + num_rules);
+	if (!newh)
+		return 0;
+	newh->info = newinfo;
+
+	/* Copy pre... */
+	memcpy(newh->entries.entrytable, (*handle)->entries.entrytable,offset);
+	/* ... Insert new ... */
+	memcpy((char *)newh->entries.entrytable + offset, insert, rules_size);
+	/* ... copy post */
+	memcpy((char *)newh->entries.entrytable + offset + rules_size,
+	       (char *)(*handle)->entries.entrytable + offset,
+	       (*handle)->entries.size - offset);
+
+	/* Move counter map. */
+	/* Copy pre... */
+	memcpy(newh->counter_map, (*handle)->counter_map,
+	       sizeof(struct counter_map) * num_rules_offset);
+	/* ... copy post */
+	memcpy(newh->counter_map + num_rules_offset + num_rules,
+	       (*handle)->counter_map + num_rules_offset,
+	       sizeof(struct counter_map) * ((*handle)->new_number
+					     - num_rules_offset));
+	/* Set intermediates to no counter copy */
+	for (i = 0; i < num_rules; i++)
+		newh->counter_map[num_rules_offset+i]
+			= ((struct counter_map){ COUNTER_MAP_SET, 0 });
+
+	newh->new_number = (*handle)->new_number + num_rules;
+	newh->entries.size = (*handle)->entries.size + rules_size;
+	newh->hooknames = (*handle)->hooknames;
+
+	newh->cache_chain_heads = (*handle)->cache_chain_heads;
+	newh->cache_num_builtins = (*handle)->cache_num_builtins;
+	newh->cache_num_chains = (*handle)->cache_num_chains;
+	newh->cache_rule_end = (*handle)->cache_rule_end;
+	newh->cache_chain_iteration = (*handle)->cache_chain_iteration;
+	if (!correct_cache(newh, offset, rules_size)) {
+		free(newh);
+		return 0;
+	}
+
+	free(*handle);
+	*handle = newh;
+
+	return set_verdict(offset, rules_size, handle);
+}
+
+static int
+delete_rules(unsigned int num_rules, unsigned int rules_size,
+	     unsigned int offset, unsigned int num_rules_offset,
+	     TC_HANDLE_T *handle)
+{
+	unsigned int i;
+
+	if (offset + rules_size > (*handle)->entries.size) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	/* Fix up entry points. */
+	for (i = 0; i < NUMHOOKS; i++) {
+		/* In practice, we never delete up to a hook entry,
+		   since the built-in chains are always first,
+		   so these two are never equal */
+		if ((*handle)->info.hook_entry[i] >= offset + rules_size)
+			(*handle)->info.hook_entry[i] -= rules_size;
+		else if ((*handle)->info.hook_entry[i] > offset) {
+			fprintf(stderr, "ERROR: Deleting entry %u %u %u\n",
+				i, (*handle)->info.hook_entry[i], offset);
+			abort();
+		}
+
+		/* Underflow points to policy (terminal) rule in
+                   built-in, so sequality is valid here (when deleting
+                   the last rule). */
+		if ((*handle)->info.underflow[i] >= offset + rules_size)
+			(*handle)->info.underflow[i] -= rules_size;
+		else if ((*handle)->info.underflow[i] > offset) {
+			fprintf(stderr, "ERROR: Deleting uflow %u %u %u\n",
+				i, (*handle)->info.underflow[i], offset);
+			abort();
+		}
+	}
+
+	/* Move the rules down. */
+	memmove((char *)(*handle)->entries.entrytable + offset,
+		(char *)(*handle)->entries.entrytable + offset + rules_size,
+		(*handle)->entries.size - (offset + rules_size));
+
+	/* Move the counter map down. */
+	memmove(&(*handle)->counter_map[num_rules_offset],
+		&(*handle)->counter_map[num_rules_offset + num_rules],
+		sizeof(struct counter_map)
+		* ((*handle)->new_number - (num_rules + num_rules_offset)));
+
+	/* Fix numbers */
+	(*handle)->new_number -= num_rules;
+	(*handle)->entries.size -= rules_size;
+
+	/* Fix the chain cache */
+	if (!correct_cache(*handle, offset, -(int)rules_size))
+		return 0;
+
+	return set_verdict(offset, -(int)rules_size, handle);
+}
+
+static int
+standard_map(STRUCT_ENTRY *e, int verdict)
+{
+	STRUCT_STANDARD_TARGET *t;
+
+	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+
+	if (t->target.u.target_size
+	    != ALIGN(sizeof(STRUCT_STANDARD_TARGET))) {
+		errno = EINVAL;
+		return 0;
+	}
+	/* memset for memcmp convenience on delete/replace */
+	memset(t->target.u.user.name, 0, FUNCTION_MAXNAMELEN);
+	strcpy(t->target.u.user.name, STANDARD_TARGET);
+	t->verdict = verdict;
+
+	return 1;
+}
+
+static int
+map_target(const TC_HANDLE_T handle,
+	   STRUCT_ENTRY *e,
+	   unsigned int offset,
+	   STRUCT_ENTRY_TARGET *old)
+{
+	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
+
+	/* Save old target (except data, which we don't change, except for
+	   standard case, where we don't care). */
+	*old = *t;
+
+	/* Maybe it's empty (=> fall through) */
+	if (strcmp(t->u.user.name, "") == 0)
+		return standard_map(e, offset + e->next_offset);
+	/* Maybe it's a standard target name... */
+	else if (strcmp(t->u.user.name, LABEL_ACCEPT) == 0)
+		return standard_map(e, -NF_ACCEPT - 1);
+	else if (strcmp(t->u.user.name, LABEL_DROP) == 0)
+		return standard_map(e, -NF_DROP - 1);
+	else if (strcmp(t->u.user.name, LABEL_QUEUE) == 0)
+		return standard_map(e, -NF_QUEUE - 1);
+	else if (strcmp(t->u.user.name, LABEL_RETURN) == 0)
+		return standard_map(e, RETURN);
+	else if (TC_BUILTIN(t->u.user.name, handle)) {
+		/* Can't jump to builtins. */
+		errno = EINVAL;
+		return 0;
+	} else {
+		/* Maybe it's an existing chain name. */
+		struct chain_cache *c;
+
+		c = find_label(t->u.user.name, handle);
+		if (c)
+			return standard_map(e, c->start_off);
+	}
+
+	/* Must be a module?  If not, kernel will reject... */
+	/* memset to all 0 for your memcmp convenience. */
+	memset(t->u.user.name + strlen(t->u.user.name),
+	       0,
+	       FUNCTION_MAXNAMELEN - strlen(t->u.user.name));
+	return 1;
+}
+
+static void
+unmap_target(STRUCT_ENTRY *e, STRUCT_ENTRY_TARGET *old)
+{
+	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
+
+	/* Save old target (except data, which we don't change, except for
+	   standard case, where we don't care). */
+	*t = *old;
+}
+
+/* Insert the entry `fw' in chain `chain' into position `rulenum'. */
+int
+TC_INSERT_ENTRY(const IPT_CHAINLABEL chain,
+		const STRUCT_ENTRY *e,
+		unsigned int rulenum,
+		TC_HANDLE_T *handle)
+{
+	unsigned int chainindex, offset;
+	STRUCT_ENTRY_TARGET old;
+	struct chain_cache *c;
+	STRUCT_ENTRY *tmp;
+	int ret;
+
+	iptc_fn = TC_INSERT_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+
+	tmp = index2entry(*handle, chainindex + rulenum);
+	if (!tmp || tmp > offset2entry(*handle, c->end_off)) {
+		errno = E2BIG;
+		return 0;
+	}
+	offset = index2offset(*handle, chainindex + rulenum);
+
+	/* Mapping target actually alters entry, but that's
+           transparent to the caller. */
+	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
+		return 0;
+
+	ret = insert_rules(1, e->next_offset, e, offset,
+			   chainindex + rulenum, rulenum == 0, handle);
+	unmap_target((STRUCT_ENTRY *)e, &old);
+	return ret;
+}
+
+/* Atomically replace rule `rulenum' in `chain' with `fw'. */
+int
+TC_REPLACE_ENTRY(const IPT_CHAINLABEL chain,
+		 const STRUCT_ENTRY *e,
+		 unsigned int rulenum,
+		 TC_HANDLE_T *handle)
+{
+	unsigned int chainindex, offset;
+	STRUCT_ENTRY_TARGET old;
+	struct chain_cache *c;
+	STRUCT_ENTRY *tmp;
+	int ret;
+
+	iptc_fn = TC_REPLACE_ENTRY;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+
+	tmp = index2entry(*handle, chainindex + rulenum);
+	if (!tmp || tmp >= offset2entry(*handle, c->end_off)) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	offset = index2offset(*handle, chainindex + rulenum);
+	/* Replace = delete and insert. */
+	if (!delete_rules(1, get_entry(*handle, offset)->next_offset,
+			  offset, chainindex + rulenum, handle))
+		return 0;
+
+	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
+		return 0;
+
+	ret = insert_rules(1, e->next_offset, e, offset,
+			   chainindex + rulenum, 1, handle);
+	unmap_target((STRUCT_ENTRY *)e, &old);
+	return ret;
+}
+
+/* Append entry `fw' to chain `chain'.  Equivalent to insert with
+   rulenum = length of chain. */
+int
+TC_APPEND_ENTRY(const IPT_CHAINLABEL chain,
+		const STRUCT_ENTRY *e,
+		TC_HANDLE_T *handle)
+{
+	struct chain_cache *c;
+	STRUCT_ENTRY_TARGET old;
+	int ret;
+
+	iptc_fn = TC_APPEND_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	if (!map_target(*handle, (STRUCT_ENTRY *)e,
+			c->end_off, &old))
+		return 0;
+
+	ret = insert_rules(1, e->next_offset, e, c->end_off, 
+			   offset2index(*handle, c->end_off), 0, handle);
+	unmap_target((STRUCT_ENTRY *)e, &old);
+	return ret;
+}
+
+static inline int
+match_different(const STRUCT_ENTRY_MATCH *a,
+		const unsigned char *a_elems,
+		const unsigned char *b_elems,
+		unsigned char **maskptr)
+{
+	const STRUCT_ENTRY_MATCH *b;
+	unsigned int i;
+
+	/* Offset of b is the same as a. */
+	b = (void *)b_elems + ((unsigned char *)a - a_elems);
+
+	if (a->u.match_size != b->u.match_size)
+		return 1;
+
+	if (strcmp(a->u.user.name, b->u.user.name) != 0)
+		return 1;
+
+	*maskptr += ALIGN(sizeof(*a));
+
+	for (i = 0; i < a->u.match_size - ALIGN(sizeof(*a)); i++)
+		if (((a->data[i] ^ b->data[i]) & (*maskptr)[i]) != 0)
+			return 1;
+	*maskptr += i;
+	return 0;
+}
+
+static inline int
+target_different(const unsigned char *a_targdata,
+		 const unsigned char *b_targdata,
+		 unsigned int tdatasize,
+		 const unsigned char *mask)
+{
+	unsigned int i;
+	for (i = 0; i < tdatasize; i++)
+		if (((a_targdata[i] ^ b_targdata[i]) & mask[i]) != 0)
+			return 1;
+
+	return 0;
+}
+
+static int
+is_same(const STRUCT_ENTRY *a,
+	const STRUCT_ENTRY *b,
+	unsigned char *matchmask);
+
+/* Delete the first rule in `chain' which matches `fw'. */
+int
+TC_DELETE_ENTRY(const IPT_CHAINLABEL chain,
+		const STRUCT_ENTRY *origfw,
+		unsigned char *matchmask,
+		TC_HANDLE_T *handle)
+{
+	unsigned int offset;
+	struct chain_cache *c;
+	STRUCT_ENTRY *e, *fw;
+
+	iptc_fn = TC_DELETE_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	fw = malloc(origfw->next_offset);
+	if (fw == NULL) {
+		errno = ENOMEM;
+		return 0;
+	}
+
+	for (offset = c->start_off; offset < c->end_off;
+	     offset += e->next_offset) {
+		STRUCT_ENTRY_TARGET discard;
+
+		memcpy(fw, origfw, origfw->next_offset);
+
+		/* FIXME: handle this in is_same --RR */
+		if (!map_target(*handle, fw, offset, &discard)) {
+			free(fw);
+			return 0;
+		}
+		e = get_entry(*handle, offset);
+
+#if 0
+		printf("Deleting:\n");
+		dump_entry(newe);
+#endif
+		if (is_same(e, fw, matchmask)) {
+			int ret;
+			ret = delete_rules(1, e->next_offset,
+					   offset, entry2index(*handle, e),
+					   handle);
+			free(fw);
+			return ret;
+		}
+	}
+
+	free(fw);
+	errno = ENOENT;
+	return 0;
+}
+
+/* Delete the rule in position `rulenum' in `chain'. */
+int
+TC_DELETE_NUM_ENTRY(const IPT_CHAINLABEL chain,
+		    unsigned int rulenum,
+		    TC_HANDLE_T *handle)
+{
+	unsigned int index;
+	int ret;
+	STRUCT_ENTRY *e;
+	struct chain_cache *c;
+
+	iptc_fn = TC_DELETE_NUM_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	index = offset2index(*handle, c->start_off) + rulenum;
+
+	if (index >= offset2index(*handle, c->end_off)) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	e = index2entry(*handle, index);
+	if (e == NULL) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	ret = delete_rules(1, e->next_offset, entry2offset(*handle, e),
+			   index, handle);
+	return ret;
+}
+
+/* Check the packet `fw' on chain `chain'.  Returns the verdict, or
+   NULL and sets errno. */
+const char *
+TC_CHECK_PACKET(const IPT_CHAINLABEL chain,
+		STRUCT_ENTRY *entry,
+		TC_HANDLE_T *handle)
+{
+	errno = ENOSYS;
+	return NULL;
+}
+
+/* Flushes the entries in the given chain (ie. empties chain). */
+int
+TC_FLUSH_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	unsigned int startindex, endindex;
+	STRUCT_ENTRY *startentry, *endentry;
+	struct chain_cache *c;
+	int ret;
+
+	iptc_fn = TC_FLUSH_ENTRIES;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+	startindex = offset2index(*handle, c->start_off);
+	endindex = offset2index(*handle, c->end_off);
+	startentry = offset2entry(*handle, c->start_off);
+	endentry = offset2entry(*handle, c->end_off);
+
+	ret = delete_rules(endindex - startindex,
+			   (char *)endentry - (char *)startentry,
+			   c->start_off, startindex,
+			   handle);
+	return ret;
+}
+
+/* Zeroes the counters in a chain. */
+int
+TC_ZERO_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	unsigned int i, end;
+	struct chain_cache *c;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	i = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
+
+	for (; i <= end; i++) {
+		if ((*handle)->counter_map[i].maptype ==COUNTER_MAP_NORMAL_MAP)
+			(*handle)->counter_map[i].maptype = COUNTER_MAP_ZEROED;
+	}
+	set_changed(*handle);
+
+	return 1;
+}
+
+STRUCT_COUNTERS *
+TC_READ_COUNTER(const IPT_CHAINLABEL chain,
+		unsigned int rulenum,
+		TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_cache *c;
+	unsigned int chainindex, end;
+
+	iptc_fn = TC_READ_COUNTER;
+	CHECK(*handle);
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
+
+	if (chainindex + rulenum > end) {
+		errno = E2BIG;
+		return NULL;
+	}
+
+	e = index2entry(*handle, chainindex + rulenum);
+
+	return &e->counters;
+}
+
+int
+TC_ZERO_COUNTER(const IPT_CHAINLABEL chain,
+		unsigned int rulenum,
+		TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_cache *c;
+	unsigned int chainindex, end;
+	
+	iptc_fn = TC_ZERO_COUNTER;
+	CHECK(*handle);
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
+
+	if (chainindex + rulenum > end) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	e = index2entry(*handle, chainindex + rulenum);
+
+	if ((*handle)->counter_map[chainindex + rulenum].maptype
+			== COUNTER_MAP_NORMAL_MAP) {
+		(*handle)->counter_map[chainindex + rulenum].maptype
+			 = COUNTER_MAP_ZEROED;
+	}
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+int 
+TC_SET_COUNTER(const IPT_CHAINLABEL chain,
+	       unsigned int rulenum,
+	       STRUCT_COUNTERS *counters,
+	       TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_cache *c;
+	unsigned int chainindex, end;
+
+	iptc_fn = TC_SET_COUNTER;
+	CHECK(*handle);
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
+
+	if (chainindex + rulenum > end) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	e = index2entry(*handle, chainindex + rulenum);
+
+	(*handle)->counter_map[chainindex + rulenum].maptype
+		= COUNTER_MAP_SET;
+
+	memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+/* Creates a new chain. */
+/* To create a chain, create two rules: error node and unconditional
+ * return. */
+int
+TC_CREATE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	int ret;
+	struct {
+		STRUCT_ENTRY head;
+		struct ipt_error_target name;
+		STRUCT_ENTRY ret;
+		STRUCT_STANDARD_TARGET target;
+	} newc;
+	unsigned int destination;
+
+	iptc_fn = TC_CREATE_CHAIN;
+
+	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
+           QUEUE, RETURN. */
+	if (find_label(chain, *handle)
+	    || strcmp(chain, LABEL_DROP) == 0
+	    || strcmp(chain, LABEL_ACCEPT) == 0
+	    || strcmp(chain, LABEL_QUEUE) == 0
+	    || strcmp(chain, LABEL_RETURN) == 0) {
+		errno = EEXIST;
+		return 0;
+	}
+
+	if (strlen(chain)+1 > sizeof(IPT_CHAINLABEL)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	memset(&newc, 0, sizeof(newc));
+	newc.head.target_offset = sizeof(STRUCT_ENTRY);
+	newc.head.next_offset
+		= sizeof(STRUCT_ENTRY)
+		+ ALIGN(sizeof(struct ipt_error_target));
+	strcpy(newc.name.t.u.user.name, ERROR_TARGET);
+	newc.name.t.u.target_size = ALIGN(sizeof(struct ipt_error_target));
+	strcpy(newc.name.error, chain);
+
+	newc.ret.target_offset = sizeof(STRUCT_ENTRY);
+	newc.ret.next_offset
+		= sizeof(STRUCT_ENTRY)
+		+ ALIGN(sizeof(STRUCT_STANDARD_TARGET));
+	strcpy(newc.target.target.u.user.name, STANDARD_TARGET);
+	newc.target.target.u.target_size
+		= ALIGN(sizeof(STRUCT_STANDARD_TARGET));
+	newc.target.verdict = RETURN;
+
+	destination = index2offset(*handle, (*handle)->new_number -1);
+
+	/* Add just before terminal entry */
+	ret = insert_rules(2, sizeof(newc), &newc.head,
+			   destination,
+			   (*handle)->new_number - 1,
+			   0, handle);
+
+	set_changed(*handle);
+
+	/* add chain cache info for this chain */
+	add_chain_cache(*handle, chain, 
+			destination+newc.head.next_offset, 
+			destination+newc.head.next_offset);
+
+	return ret;
+}
+
+static int
+count_ref(STRUCT_ENTRY *e, unsigned int offset, unsigned int *ref)
+{
+	STRUCT_STANDARD_TARGET *t;
+
+	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) == 0) {
+		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+
+		if (t->verdict == offset)
+			(*ref)++;
+	}
+
+	return 0;
+}
+
+/* Get the number of references to this chain. */
+int
+TC_GET_REFERENCES(unsigned int *ref, const IPT_CHAINLABEL chain,
+		  TC_HANDLE_T *handle)
+{
+	struct chain_cache *c;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	*ref = 0;
+	ENTRY_ITERATE((*handle)->entries.entrytable,
+		      (*handle)->entries.size,
+		      count_ref, c->start_off, ref);
+	return 1;
+}
+
+/* Deletes a chain. */
+int
+TC_DELETE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	unsigned int labelidx, labeloff;
+	unsigned int references;
+	struct chain_cache *c;
+	int ret;
+	STRUCT_ENTRY *start;
+
+	if (!TC_GET_REFERENCES(&references, chain, handle))
+		return 0;
+
+	iptc_fn = TC_DELETE_CHAIN;
+
+	if (TC_BUILTIN(chain, *handle)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	if (references > 0) {
+		errno = EMLINK;
+		return 0;
+	}
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	if (c->start_off != c->end_off) {
+		errno = ENOTEMPTY;
+		return 0;
+	}
+
+	/* Need label index: preceeds chain start */
+	labelidx = offset2index(*handle, c->start_off) - 1;
+	labeloff = index2offset(*handle, labelidx);
+
+	start = offset2entry(*handle, c->start_off);
+
+	ret = delete_rules(2,
+			   get_entry(*handle, labeloff)->next_offset
+			   + start->next_offset,
+			   labeloff, labelidx, handle);
+	return ret;
+}
+
+/* Renames a chain. */
+int TC_RENAME_CHAIN(const IPT_CHAINLABEL oldname,
+		    const IPT_CHAINLABEL newname,
+		    TC_HANDLE_T *handle)
+{
+	unsigned int labeloff, labelidx;
+	struct chain_cache *c;
+	struct ipt_error_target *t;
+
+	iptc_fn = TC_RENAME_CHAIN;
+
+	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
+           QUEUE, RETURN. */
+	if (find_label(newname, *handle)
+	    || strcmp(newname, LABEL_DROP) == 0
+	    || strcmp(newname, LABEL_ACCEPT) == 0
+	    || strcmp(newname, LABEL_QUEUE) == 0
+	    || strcmp(newname, LABEL_RETURN) == 0) {
+		errno = EEXIST;
+		return 0;
+	}
+
+	if (!(c = find_label(oldname, *handle))
+	    || TC_BUILTIN(oldname, *handle)) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	if (strlen(newname)+1 > sizeof(IPT_CHAINLABEL)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	/* Need label index: preceeds chain start */
+	labelidx = offset2index(*handle, c->start_off) - 1;
+	labeloff = index2offset(*handle, labelidx);
+
+	t = (struct ipt_error_target *)
+		GET_TARGET(get_entry(*handle, labeloff));
+
+	memset(t->error, 0, sizeof(t->error));
+	strcpy(t->error, newname);
+
+	/* update chain cache */
+	memset(c->name, 0, sizeof(c->name));
+	strcpy(c->name, newname);
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+/* Sets the policy on a built-in chain. */
+int
+TC_SET_POLICY(const IPT_CHAINLABEL chain,
+	      const IPT_CHAINLABEL policy,
+	      STRUCT_COUNTERS *counters,
+	      TC_HANDLE_T *handle)
+{
+	unsigned int hook;
+	unsigned int policyoff, ctrindex;
+	STRUCT_ENTRY *e;
+	STRUCT_STANDARD_TARGET *t;
+
+	iptc_fn = TC_SET_POLICY;
+	/* Figure out which chain. */
+	hook = TC_BUILTIN(chain, *handle);
+	if (hook == 0) {
+		errno = ENOENT;
+		return 0;
+	} else
+		hook--;
+
+	policyoff = get_chain_end(*handle, (*handle)->info.hook_entry[hook]);
+	if (policyoff != (*handle)->info.underflow[hook]) {
+		printf("ERROR: Policy for `%s' offset %u != underflow %u\n",
+		       chain, policyoff, (*handle)->info.underflow[hook]);
+		return 0;
+	}
+
+	e = get_entry(*handle, policyoff);
+	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+
+	if (strcmp(policy, LABEL_ACCEPT) == 0)
+		t->verdict = -NF_ACCEPT - 1;
+	else if (strcmp(policy, LABEL_DROP) == 0)
+		t->verdict = -NF_DROP - 1;
+	else {
+		errno = EINVAL;
+		return 0;
+	}
+
+	ctrindex = entry2index(*handle, e);
+
+	if (counters) {
+		/* set byte and packet counters */
+		memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
+
+		(*handle)->counter_map[ctrindex].maptype
+			= COUNTER_MAP_SET;
+
+	} else {
+		(*handle)->counter_map[ctrindex]
+			= ((struct counter_map){ COUNTER_MAP_NOMAP, 0 });
+	}
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+/* Without this, on gcc 2.7.2.3, we get:
+   libiptc.c: In function `TC_COMMIT':
+   libiptc.c:833: fixed or forbidden register was spilled.
+   This may be due to a compiler bug or to impossible asm
+   statements or clauses.
+*/
+static void
+subtract_counters(STRUCT_COUNTERS *answer,
+		  const STRUCT_COUNTERS *a,
+		  const STRUCT_COUNTERS *b)
+{
+	answer->pcnt = a->pcnt - b->pcnt;
+	answer->bcnt = a->bcnt - b->bcnt;
+}
+
+int
+TC_COMMIT(TC_HANDLE_T *handle)
+{
+	/* Replace, then map back the counters. */
+	STRUCT_REPLACE *repl;
+	STRUCT_COUNTERS_INFO *newcounters;
+	unsigned int i;
+	size_t counterlen;
+
+	CHECK(*handle);
+
+	counterlen = sizeof(STRUCT_COUNTERS_INFO)
+			+ sizeof(STRUCT_COUNTERS) * (*handle)->new_number;
+
+#if 0
+	TC_DUMP_ENTRIES(*handle);
+#endif
+
+	/* Don't commit if nothing changed. */
+	if (!(*handle)->changed)
+		goto finished;
+
+	repl = malloc(sizeof(*repl) + (*handle)->entries.size);
+	if (!repl) {
+		errno = ENOMEM;
+		return 0;
+	}
+
+	/* These are the old counters we will get from kernel */
+	repl->counters = malloc(sizeof(STRUCT_COUNTERS)
+				* (*handle)->info.num_entries);
+	if (!repl->counters) {
+		free(repl);
+		errno = ENOMEM;
+		return 0;
+	}
+
+	/* These are the counters we're going to put back, later. */
+	newcounters = malloc(counterlen);
+	if (!newcounters) {
+		free(repl->counters);
+		free(repl);
+		errno = ENOMEM;
+		return 0;
+	}
+
+	strcpy(repl->name, (*handle)->info.name);
+	repl->num_entries = (*handle)->new_number;
+	repl->size = (*handle)->entries.size;
+	memcpy(repl->hook_entry, (*handle)->info.hook_entry,
+	       sizeof(repl->hook_entry));
+	memcpy(repl->underflow, (*handle)->info.underflow,
+	       sizeof(repl->underflow));
+	repl->num_counters = (*handle)->info.num_entries;
+	repl->valid_hooks = (*handle)->info.valid_hooks;
+	memcpy(repl->entries, (*handle)->entries.entrytable,
+	       (*handle)->entries.size);
+
+	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_REPLACE, repl,
+		       sizeof(*repl) + (*handle)->entries.size) < 0) {
+		free(repl->counters);
+		free(repl);
+		free(newcounters);
+		return 0;
+	}
+
+	/* Put counters back. */
+	strcpy(newcounters->name, (*handle)->info.name);
+	newcounters->num_counters = (*handle)->new_number;
+	for (i = 0; i < (*handle)->new_number; i++) {
+		unsigned int mappos = (*handle)->counter_map[i].mappos;
+		switch ((*handle)->counter_map[i].maptype) {
+		case COUNTER_MAP_NOMAP:
+			newcounters->counters[i]
+				= ((STRUCT_COUNTERS){ 0, 0 });
+			break;
+
+		case COUNTER_MAP_NORMAL_MAP:
+			/* Original read: X.
+			 * Atomic read on replacement: X + Y.
+			 * Currently in kernel: Z.
+			 * Want in kernel: X + Y + Z.
+			 * => Add in X + Y
+			 * => Add in replacement read.
+			 */
+			newcounters->counters[i] = repl->counters[mappos];
+			break;
+
+		case COUNTER_MAP_ZEROED:
+			/* Original read: X.
+			 * Atomic read on replacement: X + Y.
+			 * Currently in kernel: Z.
+			 * Want in kernel: Y + Z.
+			 * => Add in Y.
+			 * => Add in (replacement read - original read).
+			 */
+			subtract_counters(&newcounters->counters[i],
+					  &repl->counters[mappos],
+					  &index2entry(*handle, i)->counters);
+			break;
+
+		case COUNTER_MAP_SET:
+			/* Want to set counter (iptables-restore) */
+
+			memcpy(&newcounters->counters[i],
+			       &index2entry(*handle, i)->counters,
+			       sizeof(STRUCT_COUNTERS));
+
+			break;
+		}
+	}
+
+#ifdef KERNEL_64_USERSPACE_32
+	{
+		/* Kernel will think that pointer should be 64-bits, and get
+		   padding.  So we accomodate here (assumption: alignment of
+		   `counters' is on 64-bit boundary). */
+		u_int64_t *kernptr = (u_int64_t *)&newcounters->counters;
+		if ((unsigned long)&newcounters->counters % 8 != 0) {
+			fprintf(stderr,
+				"counters alignment incorrect! Mail rusty!\n");
+			abort();
+		}
+		*kernptr = newcounters->counters;
+	}
+#endif /* KERNEL_64_USERSPACE_32 */
+
+	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_ADD_COUNTERS,
+		       newcounters, counterlen) < 0) {
+		free(repl->counters);
+		free(repl);
+		free(newcounters);
+		return 0;
+	}
+
+	free(repl->counters);
+	free(repl);
+	free(newcounters);
+
+ finished:
+	TC_FREE(handle);
+	return 1;
+}
+
+/* Get raw socket. */
+int
+TC_GET_RAW_SOCKET()
+{
+	return sockfd;
+}
+
+/* Translates errno numbers into more human-readable form than strerror. */
+const char *
+TC_STRERROR(int err)
+{
+	unsigned int i;
+	struct table_struct {
+		void *fn;
+		int err;
+		const char *message;
+	} table [] =
+	  { { TC_INIT, EPERM, "Permission denied (you must be root)" },
+	    { TC_INIT, EINVAL, "Module is wrong version" },
+	    { TC_INIT, ENOENT, 
+		    "Table does not exist (do you need to insmod?)" },
+	    { TC_DELETE_CHAIN, ENOTEMPTY, "Chain is not empty" },
+	    { TC_DELETE_CHAIN, EINVAL, "Can't delete built-in chain" },
+	    { TC_DELETE_CHAIN, EMLINK,
+	      "Can't delete chain with references left" },
+	    { TC_CREATE_CHAIN, EEXIST, "Chain already exists" },
+	    { TC_INSERT_ENTRY, E2BIG, "Index of insertion too big" },
+	    { TC_REPLACE_ENTRY, E2BIG, "Index of replacement too big" },
+	    { TC_DELETE_NUM_ENTRY, E2BIG, "Index of deletion too big" },
+	    { TC_READ_COUNTER, E2BIG, "Index of counter too big" },
+	    { TC_ZERO_COUNTER, E2BIG, "Index of counter too big" },
+	    { TC_INSERT_ENTRY, ELOOP, "Loop found in table" },
+	    { TC_INSERT_ENTRY, EINVAL, "Target problem" },
+	    /* EINVAL for CHECK probably means bad interface. */
+	    { TC_CHECK_PACKET, EINVAL,
+	      "Bad arguments (does that interface exist?)" },
+	    { TC_CHECK_PACKET, ENOSYS,
+	      "Checking will most likely never get implemented" },
+	    /* ENOENT for DELETE probably means no matching rule */
+	    { TC_DELETE_ENTRY, ENOENT,
+	      "Bad rule (does a matching rule exist in that chain?)" },
+	    { TC_SET_POLICY, ENOENT,
+	      "Bad built-in chain name" },
+	    { TC_SET_POLICY, EINVAL,
+	      "Bad policy name" },
+
+	    { NULL, 0, "Incompatible with this kernel" },
+	    { NULL, ENOPROTOOPT, "iptables who? (do you need to insmod?)" },
+	    { NULL, ENOSYS, "Will be implemented real soon.  I promise ;)" },
+	    { NULL, ENOMEM, "Memory allocation problem" },
+	    { NULL, ENOENT, "No chain/target/match by that name" },
+	  };
+
+	for (i = 0; i < sizeof(table)/sizeof(struct table_struct); i++) {
+		if ((!table[i].fn || table[i].fn == iptc_fn)
+		    && table[i].err == err)
+			return table[i].message;
+	}
+
+	return strerror(err);
+}
diff -urN iptables-1.2.8/libiptc2/libiptc2.c iptables-1.2.9/libiptc2/libiptc2.c
--- iptables-1.2.8/libiptc2/libiptc2.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/libiptc2/libiptc2.c	2003-06-30 18:27:24.000000000 +0200
@@ -0,0 +1,1758 @@
+/* Library which manipulates firewall rules.  Version $Revision: 1.39 $ */
+
+/* Architecture of firewall rules is as follows:
+ *
+ * Chains go INPUT, FORWARD, OUTPUT then user chains.
+ * Each user chain starts with an ERROR node.
+ * Every chain ends with an unconditional jump: a RETURN for user chains,
+ * and a POLICY for built-ins.
+ */
+
+/* (C) 1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
+ * COPYING for details). 
+ * (C) 2000-2003 by the Netfilter Core Team <coreteam@netfilter.org>
+ *
+ * 2003-Jun-20: Harald Welte <laforge@netfilter.org:
+ *	- Reimplementation of chain cache to use offsets instead of entries
+ * 
+ */
+
+#ifndef IPT_LIB_DIR
+#define IPT_LIB_DIR "/usr/local/lib/iptables"
+#endif
+
+#ifndef __OPTIMIZE__
+STRUCT_ENTRY_TARGET *
+GET_TARGET(STRUCT_ENTRY *e)
+{
+	return (void *)e + e->target_offset;
+}
+#endif
+
+static int sockfd = -1;
+static void *iptc_fn = NULL;
+
+static const char *hooknames[]
+= { [HOOK_PRE_ROUTING]  "PREROUTING",
+    [HOOK_LOCAL_IN]     "INPUT",
+    [HOOK_FORWARD]      "FORWARD",
+    [HOOK_LOCAL_OUT]    "OUTPUT",
+    [HOOK_POST_ROUTING] "POSTROUTING",
+#ifdef HOOK_DROPPING
+    [HOOK_DROPPING]	"DROPPING"
+#endif
+};
+
+struct counter_map
+{
+	enum {
+		COUNTER_MAP_NOMAP,
+		COUNTER_MAP_NORMAL_MAP,
+		COUNTER_MAP_ZEROED,
+		COUNTER_MAP_SET
+	} maptype;
+	unsigned int mappos;
+};
+
+/* Convenience structures */
+struct ipt_error_target
+{
+	STRUCT_ENTRY_TARGET t;
+	char error[TABLE_MAXNAMELEN];
+};
+
+struct rule_head
+{
+	struct list_head list;
+	
+	struct chain_head *chain;
+
+	unsigned int size;
+	STRUCT_ENTRY entry[0];
+}
+
+struct chain_head
+{
+	struct list_head list;
+
+	char name[TABLE_MAXNAMELEN];
+	unsigned int hooknum;
+	struct list_head rules;
+};
+
+STRUCT_TC_HANDLE
+{
+	/* Have changes been made? */
+	int changed;
+
+	struct list_head chains;
+	
+	struct chain_head *chain_iterator_cur;
+
+#if 0
+	/* Size in here reflects original state. */
+	STRUCT_GETINFO info;
+
+	struct counter_map *counter_map;
+	/* Array of hook names */
+	const char **hooknames;
+
+	/* Cached position of chain heads (NULL = no cache). */
+	unsigned int cache_num_chains;
+	unsigned int cache_num_builtins;
+	struct chain_cache *cache_chain_heads;
+
+	/* Chain iterator: current chain cache entry. */
+	struct chain_cache *cache_chain_iteration;
+
+	/* Rule iterator: terminal rule */
+	STRUCT_ENTRY *cache_rule_end;
+
+	/* Number in here reflects current state. */
+	unsigned int new_number;
+	STRUCT_GET_ENTRIES entries;
+#endif
+};
+
+static void
+set_changed(TC_HANDLE_T h)
+{
+	h->changed = 1;
+}
+
+#ifdef IPTC_DEBUG
+static void do_check(TC_HANDLE_T h, unsigned int line);
+#define CHECK(h) do { if (!getenv("IPTC_NO_CHECK")) do_check((h), __LINE__); } while(0)
+#else
+#define CHECK(h)
+#endif
+
+static inline int
+get_number(const STRUCT_ENTRY *i,
+	   const STRUCT_ENTRY *seek,
+	   unsigned int *pos)
+{
+	if (i == seek)
+		return 1;
+	(*pos)++;
+	return 0;
+}
+
+static unsigned int
+entry2index(const TC_HANDLE_T h, const STRUCT_ENTRY *seek)
+{
+	unsigned int pos = 0;
+
+	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+			  get_number, seek, &pos) == 0) {
+		fprintf(stderr, "ERROR: offset %i not an entry!\n",
+			(char *)seek - (char *)h->entries.entrytable);
+		abort();
+	}
+	return pos;
+}
+
+static inline int
+get_entry_n(STRUCT_ENTRY *i,
+	    unsigned int number,
+	    unsigned int *pos,
+	    STRUCT_ENTRY **pe)
+{
+	if (*pos == number) {
+		*pe = i;
+		return 1;
+	}
+	(*pos)++;
+	return 0;
+}
+
+static STRUCT_ENTRY *
+index2entry(TC_HANDLE_T h, unsigned int index)
+{
+	unsigned int pos = 0;
+	STRUCT_ENTRY *ret = NULL;
+
+	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
+		      get_entry_n, index, &pos, &ret);
+
+	return ret;
+}
+
+static inline STRUCT_ENTRY *
+get_entry(TC_HANDLE_T h, unsigned int offset)
+{
+	return (STRUCT_ENTRY *)((char *)h->entries.entrytable + offset);
+}
+
+static inline unsigned long
+entry2offset(const TC_HANDLE_T h, const STRUCT_ENTRY *e)
+{
+	return (void *)e - (void *)h->entries.entrytable;
+}
+
+static inline unsigned long
+index2offset(TC_HANDLE_T h, unsigned int index)
+{
+	return entry2offset(h, index2entry(h, index));
+}
+
+static inline STRUCT_ENTRY *
+offset2entry(TC_HANDLE_T h, unsigned int offset)
+{
+	return (STRUCT_ENTRY *) ((void *)h->entries.entrytable+offset);
+}
+
+static inline unsigned int
+offset2index(const TC_HANDLE_T h, unsigned int offset)
+{
+	return entry2index(h, offset2entry(h, offset));
+}
+
+
+static const char *
+get_errorlabel(TC_HANDLE_T h, unsigned int offset)
+{
+	STRUCT_ENTRY *e;
+
+	e = get_entry(h, offset);
+	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) != 0) {
+		fprintf(stderr, "ERROR: offset %u not an error node!\n",
+			offset);
+		abort();
+	}
+
+	return (const char *)GET_TARGET(e)->data;
+}
+
+/* Allocate handle of given size */
+static TC_HANDLE_T
+alloc_handle(const char *tablename, unsigned int size, unsigned int num_rules)
+{
+	size_t len;
+	TC_HANDLE_T h;
+
+	len = sizeof(STRUCT_TC_HANDLE)
+		+ size
+		+ num_rules * sizeof(struct counter_map);
+
+	if ((h = malloc(len)) == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	h->changed = 0;
+	h->cache_num_chains = 0;
+	h->cache_chain_heads = NULL;
+	h->counter_map = (void *)h
+		+ sizeof(STRUCT_TC_HANDLE)
+		+ size;
+	strcpy(h->info.name, tablename);
+	strcpy(h->entries.name, tablename);
+
+	return h;
+}
+
+TC_HANDLE_T
+TC_INIT(const char *tablename)
+{
+	TC_HANDLE_T h;
+	STRUCT_GETINFO info;
+	unsigned int i;
+	int tmp;
+	socklen_t s;
+
+	iptc_fn = TC_INIT;
+
+	if (sockfd != -1) {
+		close(sockfd);
+		sockfd = -1;
+	}
+
+	if (strlen(tablename) >= TABLE_MAXNAMELEN) {
+		errno = EINVAL;
+		return NULL;
+	}
+	
+	sockfd = socket(TC_AF, SOCK_RAW, IPPROTO_RAW);
+	if (sockfd < 0)
+		return NULL;
+
+	s = sizeof(info);
+
+	strcpy(info.name, tablename);
+	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_INFO, &info, &s) < 0)
+		return NULL;
+
+	if ((h = alloc_handle(info.name, info.size, info.num_entries))
+	    == NULL) {
+		close(sockfd);
+		sockfd = -1;
+		return NULL;
+	}
+
+/* Too hard --RR */
+#if 0
+	sprintf(pathname, "%s/%s", IPT_LIB_DIR, info.name);
+	dynlib = dlopen(pathname, RTLD_NOW);
+	if (!dynlib) {
+		errno = ENOENT;
+		return NULL;
+	}
+	h->hooknames = dlsym(dynlib, "hooknames");
+	if (!h->hooknames) {
+		errno = ENOENT;
+		return NULL;
+	}
+#else
+	h->hooknames = hooknames;
+#endif
+
+	/* Initialize current state */
+	h->info = info;
+	h->new_number = h->info.num_entries;
+	for (i = 0; i < h->info.num_entries; i++)
+		h->counter_map[i]
+			= ((struct counter_map){COUNTER_MAP_NORMAL_MAP, i});
+
+	h->entries.size = h->info.size;
+
+	tmp = sizeof(STRUCT_GET_ENTRIES) + h->info.size;
+
+	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_ENTRIES, &h->entries,
+		       &tmp) < 0) {
+		close(sockfd);
+		sockfd = -1;
+		free(h);
+		return NULL;
+	}
+
+	CHECK(h);
+	return h;
+}
+
+void
+TC_FREE(TC_HANDLE_T *h)
+{
+	close(sockfd);
+	sockfd = -1;
+	if ((*h)->cache_chain_heads)
+		free((*h)->cache_chain_heads);
+	free(*h);
+	*h = NULL;
+}
+
+static inline int
+print_match(const STRUCT_ENTRY_MATCH *m)
+{
+	printf("Match name: `%s'\n", m->u.user.name);
+	return 0;
+}
+
+static int dump_entry(STRUCT_ENTRY *e, const TC_HANDLE_T handle);
+ 
+void
+TC_DUMP_ENTRIES(const TC_HANDLE_T handle)
+{
+	CHECK(handle);
+
+	printf("libiptc v%s.  %u entries, %u bytes.\n",
+	       IPTABLES_VERSION,
+	       handle->new_number, handle->entries.size);
+	printf("Table `%s'\n", handle->info.name);
+	printf("Hooks: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
+	       handle->info.hook_entry[HOOK_PRE_ROUTING],
+	       handle->info.hook_entry[HOOK_LOCAL_IN],
+	       handle->info.hook_entry[HOOK_FORWARD],
+	       handle->info.hook_entry[HOOK_LOCAL_OUT],
+	       handle->info.hook_entry[HOOK_POST_ROUTING]);
+	printf("Underflows: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
+	       handle->info.underflow[HOOK_PRE_ROUTING],
+	       handle->info.underflow[HOOK_LOCAL_IN],
+	       handle->info.underflow[HOOK_FORWARD],
+	       handle->info.underflow[HOOK_LOCAL_OUT],
+	       handle->info.underflow[HOOK_POST_ROUTING]);
+
+	ENTRY_ITERATE(handle->entries.entrytable, handle->entries.size,
+		      dump_entry, handle);
+}
+
+/* Returns 0 if not hook entry, else hooknumber + 1 */
+static inline unsigned int
+is_hook_entry(STRUCT_ENTRY *e, TC_HANDLE_T h)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUMHOOKS; i++) {
+		if ((h->info.valid_hooks & (1 << i))
+		    && get_entry(h, h->info.hook_entry[i]) == e)
+			return i+1;
+	}
+	return 0;
+}
+static int alphasort(const void *a, const void *b)
+{
+	return strcmp(((struct chain_cache *)a)->name,
+		      ((struct chain_cache *)b)->name);
+}
+
+/* Returns chain head if found, otherwise NULL. */
+static struct chain_head *
+find_label(const char *name, TC_HANDLE_T handle)
+{
+	struct list_head *pos;
+
+	if (!handle->chains)
+		return NULL;
+
+	list_for_each(pos, &handle->chains) {
+		struct chain_head *c = list_entry(pos, struct chain_head, list);
+		if (!strcmp(c->name, name))
+			return c;
+	}
+
+	return NULL;
+}
+
+/* Does this chain exist? */
+int TC_IS_CHAIN(const char *chain, const TC_HANDLE_T handle)
+{
+	return find_label(chain, handle) != NULL;
+}
+
+/* Returns the position of the final (ie. unconditional) element. */
+static unsigned int
+get_chain_end(const TC_HANDLE_T handle, unsigned int start)
+{
+	unsigned int last_off, off;
+	STRUCT_ENTRY *e;
+
+	last_off = start;
+	e = get_entry(handle, start);
+
+	/* Terminate when we meet a error label or a hook entry. */
+	for (off = start + e->next_offset;
+	     off < handle->entries.size;
+	     last_off = off, off += e->next_offset) {
+		STRUCT_ENTRY_TARGET *t;
+		unsigned int i;
+
+		e = get_entry(handle, off);
+
+		/* We hit an entry point. */
+		for (i = 0; i < NUMHOOKS; i++) {
+			if ((handle->info.valid_hooks & (1 << i))
+			    && off == handle->info.hook_entry[i])
+				return last_off;
+		}
+
+		/* We hit a user chain label */
+		t = GET_TARGET(e);
+		if (strcmp(t->u.user.name, ERROR_TARGET) == 0)
+			return last_off;
+	}
+	/* SHOULD NEVER HAPPEN */
+	fprintf(stderr, "ERROR: Off end (%u) of chain from %u!\n",
+		handle->entries.size, off);
+	abort();
+}
+
+/* Iterator functions to run through the chains. */
+const char *
+TC_FIRST_CHAIN(TC_HANDLE_T *handle)
+{
+	(*handle)->chain_iterator_cur = (*handle)->chains;
+
+	return (*handle)->chains.name;
+}
+
+/* Iterator functions to run through the chains.  Returns NULL at end. */
+const char *
+TC_NEXT_CHAIN(TC_HANDLE_T *handle)
+{
+	struct chain_head *next = list_entry(&(*handle)->chain_iterator_cur->list.next, struct chain_head, list);
+	(*handle)->chain_iterator_cur = next;
+
+	if (next == (*handle)->chains)
+		return NULL;
+
+	return next->name;
+}
+
+/* Get first rule in the given chain: NULL for empty chain. */
+const STRUCT_ENTRY *
+TC_FIRST_RULE(const char *chain, TC_HANDLE_T *handle)
+{
+	struct chain_head *c;
+	struct rule_head *r;
+
+	c = find_label(chain, *handle);
+	if (!c) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	/* Empty chain: single return/policy rule */
+	if (list_empty(c->rules))
+		return NULL;
+
+	r = list_entry(&c->rules.next, struct rule_head, list);
+	(*handle)->rule_iterator_cur = r;
+
+	return r->entry;
+}
+
+/* Returns NULL when rules run out. */
+const STRUCT_ENTRY *
+TC_NEXT_RULE(const STRUCT_ENTRY *prev, TC_HANDLE_T *handle)
+{
+	struct rule_head *r = list_entry((*handle)->rule_iterator_cur->list.next, struct rule_head, list);
+
+	if (r == r->chain)
+		return NULL;
+
+	/* NOTE: prev is without any influence ! */
+	return r->entry;
+}
+
+#if 0
+/* How many rules in this chain? */
+unsigned int
+TC_NUM_RULES(const char *chain, TC_HANDLE_T *handle)
+{
+	unsigned int off = 0;
+	STRUCT_ENTRY *start, *end;
+
+	CHECK(*handle);
+	if (!find_label(&off, chain, *handle)) {
+		errno = ENOENT;
+		return (unsigned int)-1;
+	}
+
+	start = get_entry(*handle, off);
+	end = get_entry(*handle, get_chain_end(*handle, off));
+
+	return entry2index(*handle, end) - entry2index(*handle, start);
+}
+
+/* Get n'th rule in this chain. */
+const STRUCT_ENTRY *TC_GET_RULE(const char *chain,
+				unsigned int n,
+				TC_HANDLE_T *handle)
+{
+	unsigned int pos = 0, chainindex;
+
+	CHECK(*handle);
+	if (!find_label(&pos, chain, *handle)) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	chainindex = entry2index(*handle, get_entry(*handle, pos));
+
+	return index2entry(*handle, chainindex + n);
+}
+#endif
+
+static const char *
+target_name(TC_HANDLE_T handle, const STRUCT_ENTRY *ce)
+{
+	int spos;
+	unsigned int labelidx;
+	STRUCT_ENTRY *jumpto;
+
+	/* To avoid const warnings */
+	STRUCT_ENTRY *e = (STRUCT_ENTRY *)ce;
+
+	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) != 0)
+		return GET_TARGET(e)->u.user.name;
+
+	/* Standard target: evaluate */
+	spos = *(int *)GET_TARGET(e)->data;
+	if (spos < 0) {
+		if (spos == RETURN)
+			return LABEL_RETURN;
+		else if (spos == -NF_ACCEPT-1)
+			return LABEL_ACCEPT;
+		else if (spos == -NF_DROP-1)
+			return LABEL_DROP;
+		else if (spos == -NF_QUEUE-1)
+			return LABEL_QUEUE;
+
+		fprintf(stderr, "ERROR: off %lu/%u not a valid target (%i)\n",
+			entry2offset(handle, e), handle->entries.size,
+			spos);
+		abort();
+	}
+
+	jumpto = get_entry(handle, spos);
+
+	/* Fall through rule */
+	if (jumpto == (void *)e + e->next_offset)
+		return "";
+
+	/* Must point to head of a chain: ie. after error rule */
+	labelidx = entry2index(handle, jumpto) - 1;
+	return get_errorlabel(handle, index2offset(handle, labelidx));
+}
+
+/* Returns a pointer to the target name of this position. */
+const char *TC_GET_TARGET(const STRUCT_ENTRY *e,
+			  TC_HANDLE_T *handle)
+{
+	return target_name(*handle, e);
+}
+
+/* Is this a built-in chain?  Actually returns hook + 1. */
+int
+TC_BUILTIN(const char *chain, const TC_HANDLE_T handle)
+{
+	unsigned int i;
+
+	for (i = 0; i < NUMHOOKS; i++) {
+		if ((handle->info.valid_hooks & (1 << i))
+		    && handle->hooknames[i]
+		    && strcmp(handle->hooknames[i], chain) == 0)
+			return i+1;
+	}
+	return 0;
+}
+
+/* Get the policy of a given built-in chain */
+const char *
+TC_GET_POLICY(const char *chain,
+	      STRUCT_COUNTERS *counters,
+	      TC_HANDLE_T *handle)
+{
+	unsigned int start;
+	STRUCT_ENTRY *e;
+	int hook;
+
+	hook = TC_BUILTIN(chain, *handle);
+	if (hook != 0)
+		start = (*handle)->info.hook_entry[hook-1];
+	else
+		return NULL;
+
+	e = get_entry(*handle, get_chain_end(*handle, start));
+	*counters = e->counters;
+
+	return target_name(*handle, e);
+}
+
+static int
+correct_verdict(STRUCT_ENTRY *e,
+		char *base,
+		unsigned int offset, int delta_offset)
+{
+	STRUCT_STANDARD_TARGET *t = (void *)GET_TARGET(e);
+	unsigned int curr = (char *)e - base;
+
+	/* Trap: insert of fall-through rule.  Don't change fall-through
+	   verdict to jump-over-next-rule. */
+	if (strcmp(t->target.u.user.name, STANDARD_TARGET) == 0
+	    && t->verdict > (int)offset
+	    && !(curr == offset &&
+		 t->verdict == curr + e->next_offset)) {
+		t->verdict += delta_offset;
+	}
+
+	return 0;
+}
+
+/* Adjusts standard verdict jump positions after an insertion/deletion. */
+static int
+set_verdict(unsigned int offset, int delta_offset, TC_HANDLE_T *handle)
+{
+	ENTRY_ITERATE((*handle)->entries.entrytable,
+		      (*handle)->entries.size,
+		      correct_verdict, (char *)(*handle)->entries.entrytable,
+		      offset, delta_offset);
+
+	set_changed(*handle);
+	return 1;
+}
+
+/* If prepend is set, then we are prepending to a chain: if the
+ * insertion position is an entry point, keep the entry point. */
+static int
+insert_rules(unsigned int num_rules, unsigned int rules_size,
+	     const STRUCT_ENTRY *insert,
+	     unsigned int offset, unsigned int num_rules_offset,
+	     int prepend,
+	     TC_HANDLE_T *handle)
+{
+	TC_HANDLE_T newh;
+	STRUCT_GETINFO newinfo;
+	unsigned int i;
+
+	if (offset >= (*handle)->entries.size) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	newinfo = (*handle)->info;
+
+	/* Fix up entry points. */
+	for (i = 0; i < NUMHOOKS; i++) {
+		/* Entry points to START of chain, so keep same if
+                   inserting on at that point. */
+		if ((*handle)->info.hook_entry[i] > offset)
+			newinfo.hook_entry[i] += rules_size;
+
+		/* Underflow always points to END of chain (policy),
+		   so if something is inserted at same point, it
+		   should be advanced. */
+		if ((*handle)->info.underflow[i] >= offset)
+			newinfo.underflow[i] += rules_size;
+	}
+
+	newh = alloc_handle((*handle)->info.name,
+			    (*handle)->entries.size + rules_size,
+			    (*handle)->new_number + num_rules);
+	if (!newh)
+		return 0;
+	newh->info = newinfo;
+
+	/* Copy pre... */
+	memcpy(newh->entries.entrytable, (*handle)->entries.entrytable,offset);
+	/* ... Insert new ... */
+	memcpy((char *)newh->entries.entrytable + offset, insert, rules_size);
+	/* ... copy post */
+	memcpy((char *)newh->entries.entrytable + offset + rules_size,
+	       (char *)(*handle)->entries.entrytable + offset,
+	       (*handle)->entries.size - offset);
+
+	/* Move counter map. */
+	/* Copy pre... */
+	memcpy(newh->counter_map, (*handle)->counter_map,
+	       sizeof(struct counter_map) * num_rules_offset);
+	/* ... copy post */
+	memcpy(newh->counter_map + num_rules_offset + num_rules,
+	       (*handle)->counter_map + num_rules_offset,
+	       sizeof(struct counter_map) * ((*handle)->new_number
+					     - num_rules_offset));
+	/* Set intermediates to no counter copy */
+	for (i = 0; i < num_rules; i++)
+		newh->counter_map[num_rules_offset+i]
+			= ((struct counter_map){ COUNTER_MAP_SET, 0 });
+
+	newh->new_number = (*handle)->new_number + num_rules;
+	newh->entries.size = (*handle)->entries.size + rules_size;
+	newh->hooknames = (*handle)->hooknames;
+
+	if ((*handle)->cache_chain_heads)
+		free((*handle)->cache_chain_heads);
+	free(*handle);
+	*handle = newh;
+
+	return set_verdict(offset, rules_size, handle);
+}
+
+static int
+delete_rules(unsigned int num_rules, unsigned int rules_size,
+	     unsigned int offset, unsigned int num_rules_offset,
+	     TC_HANDLE_T *handle)
+{
+	unsigned int i;
+
+	if (offset + rules_size > (*handle)->entries.size) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	/* Fix up entry points. */
+	for (i = 0; i < NUMHOOKS; i++) {
+		/* In practice, we never delete up to a hook entry,
+		   since the built-in chains are always first,
+		   so these two are never equal */
+		if ((*handle)->info.hook_entry[i] >= offset + rules_size)
+			(*handle)->info.hook_entry[i] -= rules_size;
+		else if ((*handle)->info.hook_entry[i] > offset) {
+			fprintf(stderr, "ERROR: Deleting entry %u %u %u\n",
+				i, (*handle)->info.hook_entry[i], offset);
+			abort();
+		}
+
+		/* Underflow points to policy (terminal) rule in
+                   built-in, so sequality is valid here (when deleting
+                   the last rule). */
+		if ((*handle)->info.underflow[i] >= offset + rules_size)
+			(*handle)->info.underflow[i] -= rules_size;
+		else if ((*handle)->info.underflow[i] > offset) {
+			fprintf(stderr, "ERROR: Deleting uflow %u %u %u\n",
+				i, (*handle)->info.underflow[i], offset);
+			abort();
+		}
+	}
+
+	/* Move the rules down. */
+	memmove((char *)(*handle)->entries.entrytable + offset,
+		(char *)(*handle)->entries.entrytable + offset + rules_size,
+		(*handle)->entries.size - (offset + rules_size));
+
+	/* Move the counter map down. */
+	memmove(&(*handle)->counter_map[num_rules_offset],
+		&(*handle)->counter_map[num_rules_offset + num_rules],
+		sizeof(struct counter_map)
+		* ((*handle)->new_number - (num_rules + num_rules_offset)));
+
+	/* Fix numbers */
+	(*handle)->new_number -= num_rules;
+	(*handle)->entries.size -= rules_size;
+
+	return set_verdict(offset, -(int)rules_size, handle);
+}
+
+static int
+standard_map(STRUCT_ENTRY *e, int verdict)
+{
+	STRUCT_STANDARD_TARGET *t;
+
+	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+
+	if (t->target.u.target_size
+	    != ALIGN(sizeof(STRUCT_STANDARD_TARGET))) {
+		errno = EINVAL;
+		return 0;
+	}
+	/* memset for memcmp convenience on delete/replace */
+	memset(t->target.u.user.name, 0, FUNCTION_MAXNAMELEN);
+	strcpy(t->target.u.user.name, STANDARD_TARGET);
+	t->verdict = verdict;
+
+	return 1;
+}
+
+static int
+map_target(const TC_HANDLE_T handle,
+	   STRUCT_ENTRY *e,
+	   unsigned int offset,
+	   STRUCT_ENTRY_TARGET *old)
+{
+	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
+
+	/* Save old target (except data, which we don't change, except for
+	   standard case, where we don't care). */
+	*old = *t;
+
+	/* Maybe it's empty (=> fall through) */
+	if (strcmp(t->u.user.name, "") == 0)
+		return standard_map(e, offset + e->next_offset);
+	/* Maybe it's a standard target name... */
+	else if (strcmp(t->u.user.name, LABEL_ACCEPT) == 0)
+		return standard_map(e, -NF_ACCEPT - 1);
+	else if (strcmp(t->u.user.name, LABEL_DROP) == 0)
+		return standard_map(e, -NF_DROP - 1);
+	else if (strcmp(t->u.user.name, LABEL_QUEUE) == 0)
+		return standard_map(e, -NF_QUEUE - 1);
+	else if (strcmp(t->u.user.name, LABEL_RETURN) == 0)
+		return standard_map(e, RETURN);
+	else if (TC_BUILTIN(t->u.user.name, handle)) {
+		/* Can't jump to builtins. */
+		errno = EINVAL;
+		return 0;
+	} else {
+		/* Maybe it's an existing chain name. */
+		struct chain_cache *c;
+
+		c = find_label(t->u.user.name, handle);
+		if (c)
+			return standard_map(e, c->start_off);
+	}
+
+	/* Must be a module?  If not, kernel will reject... */
+	/* memset to all 0 for your memcmp convenience. */
+	memset(t->u.user.name + strlen(t->u.user.name),
+	       0,
+	       FUNCTION_MAXNAMELEN - strlen(t->u.user.name));
+	return 1;
+}
+
+static void
+unmap_target(STRUCT_ENTRY *e, STRUCT_ENTRY_TARGET *old)
+{
+	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
+
+	/* Save old target (except data, which we don't change, except for
+	   standard case, where we don't care). */
+	*t = *old;
+}
+
+/* Insert the entry `fw' in chain `chain' into position `rulenum'. */
+int
+TC_INSERT_ENTRY(const IPT_CHAINLABEL chain,
+		const STRUCT_ENTRY *e,
+		unsigned int rulenum,
+		TC_HANDLE_T *handle)
+{
+	unsigned int chainindex, offset;
+	STRUCT_ENTRY_TARGET old;
+	struct chain_cache *c;
+	STRUCT_ENTRY *tmp;
+	int ret;
+
+	iptc_fn = TC_INSERT_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+
+	tmp = index2entry(*handle, chainindex + rulenum);
+	if (!tmp || tmp > offset2entry(*handle, c->end_off)) {
+		errno = E2BIG;
+		return 0;
+	}
+	offset = index2offset(*handle, chainindex + rulenum);
+
+	/* Mapping target actually alters entry, but that's
+           transparent to the caller. */
+	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
+		return 0;
+
+	ret = insert_rules(1, e->next_offset, e, offset,
+			   chainindex + rulenum, rulenum == 0, handle);
+	unmap_target((STRUCT_ENTRY *)e, &old);
+	return ret;
+}
+
+/* Atomically replace rule `rulenum' in `chain' with `fw'. */
+int
+TC_REPLACE_ENTRY(const IPT_CHAINLABEL chain,
+		 const STRUCT_ENTRY *e,
+		 unsigned int rulenum,
+		 TC_HANDLE_T *handle)
+{
+	unsigned int chainindex, offset;
+	STRUCT_ENTRY_TARGET old;
+	struct chain_cache *c;
+	STRUCT_ENTRY *tmp;
+	int ret;
+
+	iptc_fn = TC_REPLACE_ENTRY;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+
+	tmp = index2entry(*handle, chainindex + rulenum);
+	if (!tmp || tmp >= offset2entry(*handle, c->end_off)) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	offset = index2offset(*handle, chainindex + rulenum);
+	/* Replace = delete and insert. */
+	if (!delete_rules(1, get_entry(*handle, offset)->next_offset,
+			  offset, chainindex + rulenum, handle))
+		return 0;
+
+	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
+		return 0;
+
+	ret = insert_rules(1, e->next_offset, e, offset,
+			   chainindex + rulenum, 1, handle);
+	unmap_target((STRUCT_ENTRY *)e, &old);
+	return ret;
+}
+
+/* Append entry `fw' to chain `chain'.  Equivalent to insert with
+   rulenum = length of chain. */
+int
+TC_APPEND_ENTRY(const IPT_CHAINLABEL chain,
+		const STRUCT_ENTRY *e,
+		TC_HANDLE_T *handle)
+{
+	struct chain_cache *c;
+	STRUCT_ENTRY_TARGET old;
+	int ret;
+
+	iptc_fn = TC_APPEND_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	if (!map_target(*handle, (STRUCT_ENTRY *)e,
+			c->end_off, &old))
+		return 0;
+
+	ret = insert_rules(1, e->next_offset, e, c->end_off, 
+			   offset2index(*handle, c->end_off), 0, handle);
+	unmap_target((STRUCT_ENTRY *)e, &old);
+	return ret;
+}
+
+static inline int
+match_different(const STRUCT_ENTRY_MATCH *a,
+		const unsigned char *a_elems,
+		const unsigned char *b_elems,
+		unsigned char **maskptr)
+{
+	const STRUCT_ENTRY_MATCH *b;
+	unsigned int i;
+
+	/* Offset of b is the same as a. */
+	b = (void *)b_elems + ((unsigned char *)a - a_elems);
+
+	if (a->u.match_size != b->u.match_size)
+		return 1;
+
+	if (strcmp(a->u.user.name, b->u.user.name) != 0)
+		return 1;
+
+	*maskptr += ALIGN(sizeof(*a));
+
+	for (i = 0; i < a->u.match_size - ALIGN(sizeof(*a)); i++)
+		if (((a->data[i] ^ b->data[i]) & (*maskptr)[i]) != 0)
+			return 1;
+	*maskptr += i;
+	return 0;
+}
+
+static inline int
+target_different(const unsigned char *a_targdata,
+		 const unsigned char *b_targdata,
+		 unsigned int tdatasize,
+		 const unsigned char *mask)
+{
+	unsigned int i;
+	for (i = 0; i < tdatasize; i++)
+		if (((a_targdata[i] ^ b_targdata[i]) & mask[i]) != 0)
+			return 1;
+
+	return 0;
+}
+
+static int
+is_same(const STRUCT_ENTRY *a,
+	const STRUCT_ENTRY *b,
+	unsigned char *matchmask);
+
+/* Delete the first rule in `chain' which matches `fw'. */
+int
+TC_DELETE_ENTRY(const IPT_CHAINLABEL chain,
+		const STRUCT_ENTRY *origfw,
+		unsigned char *matchmask,
+		TC_HANDLE_T *handle)
+{
+	unsigned int offset;
+	struct chain_cache *c;
+	STRUCT_ENTRY *e, *fw;
+
+	iptc_fn = TC_DELETE_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	fw = malloc(origfw->next_offset);
+	if (fw == NULL) {
+		errno = ENOMEM;
+		return 0;
+	}
+
+	for (offset = c->start_off; offset < c->end_off;
+	     offset += e->next_offset) {
+		STRUCT_ENTRY_TARGET discard;
+
+		memcpy(fw, origfw, origfw->next_offset);
+
+		/* FIXME: handle this in is_same --RR */
+		if (!map_target(*handle, fw, offset, &discard)) {
+			free(fw);
+			return 0;
+		}
+		e = get_entry(*handle, offset);
+
+#if 0
+		printf("Deleting:\n");
+		dump_entry(newe);
+#endif
+		if (is_same(e, fw, matchmask)) {
+			int ret;
+			ret = delete_rules(1, e->next_offset,
+					   offset, entry2index(*handle, e),
+					   handle);
+			free(fw);
+			return ret;
+		}
+	}
+
+	free(fw);
+	errno = ENOENT;
+	return 0;
+}
+
+/* Delete the rule in position `rulenum' in `chain'. */
+int
+TC_DELETE_NUM_ENTRY(const IPT_CHAINLABEL chain,
+		    unsigned int rulenum,
+		    TC_HANDLE_T *handle)
+{
+	unsigned int index;
+	int ret;
+	STRUCT_ENTRY *e;
+	struct chain_cache *c;
+
+	iptc_fn = TC_DELETE_NUM_ENTRY;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	index = offset2index(*handle, c->start_off) + rulenum;
+
+	if (index >= offset2index(*handle, c->end_off)) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	e = index2entry(*handle, index);
+	if (e == NULL) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	ret = delete_rules(1, e->next_offset, entry2offset(*handle, e),
+			   index, handle);
+	return ret;
+}
+
+/* Check the packet `fw' on chain `chain'.  Returns the verdict, or
+   NULL and sets errno. */
+const char *
+TC_CHECK_PACKET(const IPT_CHAINLABEL chain,
+		STRUCT_ENTRY *entry,
+		TC_HANDLE_T *handle)
+{
+	errno = ENOSYS;
+	return NULL;
+}
+
+/* Flushes the entries in the given chain (ie. empties chain). */
+int
+TC_FLUSH_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	unsigned int startindex, endindex;
+	STRUCT_ENTRY *startentry, *endentry;
+	struct chain_cache *c;
+	int ret;
+
+	iptc_fn = TC_FLUSH_ENTRIES;
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+	startindex = offset2index(*handle, c->start_off);
+	endindex = offset2index(*handle, c->end_off);
+	startentry = offset2entry(*handle, c->start_off);
+	endentry = offset2entry(*handle, c->end_off);
+
+	ret = delete_rules(endindex - startindex,
+			   (char *)endentry - (char *)startentry,
+			   c->start_off, startindex,
+			   handle);
+	return ret;
+}
+
+/* Zeroes the counters in a chain. */
+int
+TC_ZERO_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	unsigned int i, end;
+	struct chain_cache *c;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	i = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
+
+	for (; i <= end; i++) {
+		if ((*handle)->counter_map[i].maptype ==COUNTER_MAP_NORMAL_MAP)
+			(*handle)->counter_map[i].maptype = COUNTER_MAP_ZEROED;
+	}
+	set_changed(*handle);
+
+	return 1;
+}
+
+STRUCT_COUNTERS *
+TC_READ_COUNTER(const IPT_CHAINLABEL chain,
+		unsigned int rulenum,
+		TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_cache *c;
+	unsigned int chainindex, end;
+
+	iptc_fn = TC_READ_COUNTER;
+	CHECK(*handle);
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return NULL;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
+
+	if (chainindex + rulenum > end) {
+		errno = E2BIG;
+		return NULL;
+	}
+
+	e = index2entry(*handle, chainindex + rulenum);
+
+	return &e->counters;
+}
+
+int
+TC_ZERO_COUNTER(const IPT_CHAINLABEL chain,
+		unsigned int rulenum,
+		TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_cache *c;
+	unsigned int chainindex, end;
+	
+	iptc_fn = TC_ZERO_COUNTER;
+	CHECK(*handle);
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
+
+	if (chainindex + rulenum > end) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	e = index2entry(*handle, chainindex + rulenum);
+
+	if ((*handle)->counter_map[chainindex + rulenum].maptype
+			== COUNTER_MAP_NORMAL_MAP) {
+		(*handle)->counter_map[chainindex + rulenum].maptype
+			 = COUNTER_MAP_ZEROED;
+	}
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+int 
+TC_SET_COUNTER(const IPT_CHAINLABEL chain,
+	       unsigned int rulenum,
+	       STRUCT_COUNTERS *counters,
+	       TC_HANDLE_T *handle)
+{
+	STRUCT_ENTRY *e;
+	struct chain_cache *c;
+	unsigned int chainindex, end;
+
+	iptc_fn = TC_SET_COUNTER;
+	CHECK(*handle);
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	chainindex = offset2index(*handle, c->start_off);
+	end = offset2index(*handle, c->end_off);
+
+	if (chainindex + rulenum > end) {
+		errno = E2BIG;
+		return 0;
+	}
+
+	e = index2entry(*handle, chainindex + rulenum);
+
+	(*handle)->counter_map[chainindex + rulenum].maptype
+		= COUNTER_MAP_SET;
+
+	memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+/* Creates a new chain. */
+/* To create a chain, create two rules: error node and unconditional
+ * return. */
+int
+TC_CREATE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	int ret;
+	struct {
+		STRUCT_ENTRY head;
+		struct ipt_error_target name;
+		STRUCT_ENTRY ret;
+		STRUCT_STANDARD_TARGET target;
+	} newc;
+
+	iptc_fn = TC_CREATE_CHAIN;
+
+	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
+           QUEUE, RETURN. */
+	if (find_label(chain, *handle)
+	    || strcmp(chain, LABEL_DROP) == 0
+	    || strcmp(chain, LABEL_ACCEPT) == 0
+	    || strcmp(chain, LABEL_QUEUE) == 0
+	    || strcmp(chain, LABEL_RETURN) == 0) {
+		errno = EEXIST;
+		return 0;
+	}
+
+	if (strlen(chain)+1 > sizeof(IPT_CHAINLABEL)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	memset(&newc, 0, sizeof(newc));
+	newc.head.target_offset = sizeof(STRUCT_ENTRY);
+	newc.head.next_offset
+		= sizeof(STRUCT_ENTRY)
+		+ ALIGN(sizeof(struct ipt_error_target));
+	strcpy(newc.name.t.u.user.name, ERROR_TARGET);
+	newc.name.t.u.target_size = ALIGN(sizeof(struct ipt_error_target));
+	strcpy(newc.name.error, chain);
+
+	newc.ret.target_offset = sizeof(STRUCT_ENTRY);
+	newc.ret.next_offset
+		= sizeof(STRUCT_ENTRY)
+		+ ALIGN(sizeof(STRUCT_STANDARD_TARGET));
+	strcpy(newc.target.target.u.user.name, STANDARD_TARGET);
+	newc.target.target.u.target_size
+		= ALIGN(sizeof(STRUCT_STANDARD_TARGET));
+	newc.target.verdict = RETURN;
+
+	/* Add just before terminal entry */
+	ret = insert_rules(2, sizeof(newc), &newc.head,
+			   index2offset(*handle, (*handle)->new_number - 1),
+			   (*handle)->new_number - 1,
+			   0, handle);
+	return ret;
+}
+
+static int
+count_ref(STRUCT_ENTRY *e, unsigned int offset, unsigned int *ref)
+{
+	STRUCT_STANDARD_TARGET *t;
+
+	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) == 0) {
+		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+
+		if (t->verdict == offset)
+			(*ref)++;
+	}
+
+	return 0;
+}
+
+/* Get the number of references to this chain. */
+int
+TC_GET_REFERENCES(unsigned int *ref, const IPT_CHAINLABEL chain,
+		  TC_HANDLE_T *handle)
+{
+	struct chain_cache *c;
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	*ref = 0;
+	ENTRY_ITERATE((*handle)->entries.entrytable,
+		      (*handle)->entries.size,
+		      count_ref, c->start_off, ref);
+	return 1;
+}
+
+/* Deletes a chain. */
+int
+TC_DELETE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
+{
+	unsigned int labelidx, labeloff;
+	unsigned int references;
+	struct chain_cache *c;
+	int ret;
+	STRUCT_ENTRY *start;
+
+	if (!TC_GET_REFERENCES(&references, chain, handle))
+		return 0;
+
+	iptc_fn = TC_DELETE_CHAIN;
+
+	if (TC_BUILTIN(chain, *handle)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	if (references > 0) {
+		errno = EMLINK;
+		return 0;
+	}
+
+	if (!(c = find_label(chain, *handle))) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	if (c->start_off != c->end_off) {
+		errno = ENOTEMPTY;
+		return 0;
+	}
+
+	/* Need label index: preceeds chain start */
+	labelidx = offset2index(*handle, c->start_off) - 1;
+	labeloff = index2offset(*handle, labelidx);
+
+	start = offset2entry(*handle, c->start_off);
+
+	ret = delete_rules(2,
+			   get_entry(*handle, labeloff)->next_offset
+			   + start->next_offset,
+			   labeloff, labelidx, handle);
+	return ret;
+}
+
+/* Renames a chain. */
+int TC_RENAME_CHAIN(const IPT_CHAINLABEL oldname,
+		    const IPT_CHAINLABEL newname,
+		    TC_HANDLE_T *handle)
+{
+	unsigned int labeloff, labelidx;
+	struct chain_cache *c;
+	struct ipt_error_target *t;
+
+	iptc_fn = TC_RENAME_CHAIN;
+
+	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
+           QUEUE, RETURN. */
+	if (find_label(newname, *handle)
+	    || strcmp(newname, LABEL_DROP) == 0
+	    || strcmp(newname, LABEL_ACCEPT) == 0
+	    || strcmp(newname, LABEL_QUEUE) == 0
+	    || strcmp(newname, LABEL_RETURN) == 0) {
+		errno = EEXIST;
+		return 0;
+	}
+
+	if (!(c = find_label(oldname, *handle))
+	    || TC_BUILTIN(oldname, *handle)) {
+		errno = ENOENT;
+		return 0;
+	}
+
+	if (strlen(newname)+1 > sizeof(IPT_CHAINLABEL)) {
+		errno = EINVAL;
+		return 0;
+	}
+
+	/* Need label index: preceeds chain start */
+	labelidx = offset2index(*handle, c->start_off) - 1;
+	labeloff = index2offset(*handle, labelidx);
+
+	t = (struct ipt_error_target *)
+		GET_TARGET(get_entry(*handle, labeloff));
+
+	memset(t->error, 0, sizeof(t->error));
+	strcpy(t->error, newname);
+	set_changed(*handle);
+
+	return 1;
+}
+
+/* Sets the policy on a built-in chain. */
+int
+TC_SET_POLICY(const IPT_CHAINLABEL chain,
+	      const IPT_CHAINLABEL policy,
+	      STRUCT_COUNTERS *counters,
+	      TC_HANDLE_T *handle)
+{
+	unsigned int hook;
+	unsigned int policyoff, ctrindex;
+	STRUCT_ENTRY *e;
+	STRUCT_STANDARD_TARGET *t;
+
+	iptc_fn = TC_SET_POLICY;
+	/* Figure out which chain. */
+	hook = TC_BUILTIN(chain, *handle);
+	if (hook == 0) {
+		errno = ENOENT;
+		return 0;
+	} else
+		hook--;
+
+	policyoff = get_chain_end(*handle, (*handle)->info.hook_entry[hook]);
+	if (policyoff != (*handle)->info.underflow[hook]) {
+		printf("ERROR: Policy for `%s' offset %u != underflow %u\n",
+		       chain, policyoff, (*handle)->info.underflow[hook]);
+		return 0;
+	}
+
+	e = get_entry(*handle, policyoff);
+	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
+
+	if (strcmp(policy, LABEL_ACCEPT) == 0)
+		t->verdict = -NF_ACCEPT - 1;
+	else if (strcmp(policy, LABEL_DROP) == 0)
+		t->verdict = -NF_DROP - 1;
+	else {
+		errno = EINVAL;
+		return 0;
+	}
+
+	ctrindex = entry2index(*handle, e);
+
+	if (counters) {
+		/* set byte and packet counters */
+		memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
+
+		(*handle)->counter_map[ctrindex].maptype
+			= COUNTER_MAP_SET;
+
+	} else {
+		(*handle)->counter_map[ctrindex]
+			= ((struct counter_map){ COUNTER_MAP_NOMAP, 0 });
+	}
+
+	set_changed(*handle);
+
+	return 1;
+}
+
+/* Without this, on gcc 2.7.2.3, we get:
+   libiptc.c: In function `TC_COMMIT':
+   libiptc.c:833: fixed or forbidden register was spilled.
+   This may be due to a compiler bug or to impossible asm
+   statements or clauses.
+*/
+static void
+subtract_counters(STRUCT_COUNTERS *answer,
+		  const STRUCT_COUNTERS *a,
+		  const STRUCT_COUNTERS *b)
+{
+	answer->pcnt = a->pcnt - b->pcnt;
+	answer->bcnt = a->bcnt - b->bcnt;
+}
+
+int
+TC_COMMIT(TC_HANDLE_T *handle)
+{
+	/* Replace, then map back the counters. */
+	STRUCT_REPLACE *repl;
+	STRUCT_COUNTERS_INFO *newcounters;
+	unsigned int i;
+	size_t counterlen;
+
+	CHECK(*handle);
+
+	counterlen = sizeof(STRUCT_COUNTERS_INFO)
+			+ sizeof(STRUCT_COUNTERS) * (*handle)->new_number;
+
+#if 0
+	TC_DUMP_ENTRIES(*handle);
+#endif
+
+	/* Don't commit if nothing changed. */
+	if (!(*handle)->changed)
+		goto finished;
+
+	repl = malloc(sizeof(*repl) + (*handle)->entries.size);
+	if (!repl) {
+		errno = ENOMEM;
+		return 0;
+	}
+
+	/* These are the old counters we will get from kernel */
+	repl->counters = malloc(sizeof(STRUCT_COUNTERS)
+				* (*handle)->info.num_entries);
+	if (!repl->counters) {
+		free(repl);
+		errno = ENOMEM;
+		return 0;
+	}
+
+	/* These are the counters we're going to put back, later. */
+	newcounters = malloc(counterlen);
+	if (!newcounters) {
+		free(repl->counters);
+		free(repl);
+		errno = ENOMEM;
+		return 0;
+	}
+
+	strcpy(repl->name, (*handle)->info.name);
+	repl->num_entries = (*handle)->new_number;
+	repl->size = (*handle)->entries.size;
+	memcpy(repl->hook_entry, (*handle)->info.hook_entry,
+	       sizeof(repl->hook_entry));
+	memcpy(repl->underflow, (*handle)->info.underflow,
+	       sizeof(repl->underflow));
+	repl->num_counters = (*handle)->info.num_entries;
+	repl->valid_hooks = (*handle)->info.valid_hooks;
+	memcpy(repl->entries, (*handle)->entries.entrytable,
+	       (*handle)->entries.size);
+
+	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_REPLACE, repl,
+		       sizeof(*repl) + (*handle)->entries.size) < 0) {
+		free(repl->counters);
+		free(repl);
+		free(newcounters);
+		return 0;
+	}
+
+	/* Put counters back. */
+	strcpy(newcounters->name, (*handle)->info.name);
+	newcounters->num_counters = (*handle)->new_number;
+	for (i = 0; i < (*handle)->new_number; i++) {
+		unsigned int mappos = (*handle)->counter_map[i].mappos;
+		switch ((*handle)->counter_map[i].maptype) {
+		case COUNTER_MAP_NOMAP:
+			newcounters->counters[i]
+				= ((STRUCT_COUNTERS){ 0, 0 });
+			break;
+
+		case COUNTER_MAP_NORMAL_MAP:
+			/* Original read: X.
+			 * Atomic read on replacement: X + Y.
+			 * Currently in kernel: Z.
+			 * Want in kernel: X + Y + Z.
+			 * => Add in X + Y
+			 * => Add in replacement read.
+			 */
+			newcounters->counters[i] = repl->counters[mappos];
+			break;
+
+		case COUNTER_MAP_ZEROED:
+			/* Original read: X.
+			 * Atomic read on replacement: X + Y.
+			 * Currently in kernel: Z.
+			 * Want in kernel: Y + Z.
+			 * => Add in Y.
+			 * => Add in (replacement read - original read).
+			 */
+			subtract_counters(&newcounters->counters[i],
+					  &repl->counters[mappos],
+					  &index2entry(*handle, i)->counters);
+			break;
+
+		case COUNTER_MAP_SET:
+			/* Want to set counter (iptables-restore) */
+
+			memcpy(&newcounters->counters[i],
+			       &index2entry(*handle, i)->counters,
+			       sizeof(STRUCT_COUNTERS));
+
+			break;
+		}
+	}
+
+#ifdef KERNEL_64_USERSPACE_32
+	{
+		/* Kernel will think that pointer should be 64-bits, and get
+		   padding.  So we accomodate here (assumption: alignment of
+		   `counters' is on 64-bit boundary). */
+		u_int64_t *kernptr = (u_int64_t *)&newcounters->counters;
+		if ((unsigned long)&newcounters->counters % 8 != 0) {
+			fprintf(stderr,
+				"counters alignment incorrect! Mail rusty!\n");
+			abort();
+		}
+		*kernptr = newcounters->counters;
+	}
+#endif /* KERNEL_64_USERSPACE_32 */
+
+	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_ADD_COUNTERS,
+		       newcounters, counterlen) < 0) {
+		free(repl->counters);
+		free(repl);
+		free(newcounters);
+		return 0;
+	}
+
+	free(repl->counters);
+	free(repl);
+	free(newcounters);
+
+ finished:
+	TC_FREE(handle);
+	return 1;
+}
+
+/* Get raw socket. */
+int
+TC_GET_RAW_SOCKET()
+{
+	return sockfd;
+}
+
+/* Translates errno numbers into more human-readable form than strerror. */
+const char *
+TC_STRERROR(int err)
+{
+	unsigned int i;
+	struct table_struct {
+		void *fn;
+		int err;
+		const char *message;
+	} table [] =
+	  { { TC_INIT, EPERM, "Permission denied (you must be root)" },
+	    { TC_INIT, EINVAL, "Module is wrong version" },
+	    { TC_INIT, ENOENT, 
+		    "Table does not exist (do you need to insmod?)" },
+	    { TC_DELETE_CHAIN, ENOTEMPTY, "Chain is not empty" },
+	    { TC_DELETE_CHAIN, EINVAL, "Can't delete built-in chain" },
+	    { TC_DELETE_CHAIN, EMLINK,
+	      "Can't delete chain with references left" },
+	    { TC_CREATE_CHAIN, EEXIST, "Chain already exists" },
+	    { TC_INSERT_ENTRY, E2BIG, "Index of insertion too big" },
+	    { TC_REPLACE_ENTRY, E2BIG, "Index of replacement too big" },
+	    { TC_DELETE_NUM_ENTRY, E2BIG, "Index of deletion too big" },
+	    { TC_READ_COUNTER, E2BIG, "Index of counter too big" },
+	    { TC_ZERO_COUNTER, E2BIG, "Index of counter too big" },
+	    { TC_INSERT_ENTRY, ELOOP, "Loop found in table" },
+	    { TC_INSERT_ENTRY, EINVAL, "Target problem" },
+	    /* EINVAL for CHECK probably means bad interface. */
+	    { TC_CHECK_PACKET, EINVAL,
+	      "Bad arguments (does that interface exist?)" },
+	    { TC_CHECK_PACKET, ENOSYS,
+	      "Checking will most likely never get implemented" },
+	    /* ENOENT for DELETE probably means no matching rule */
+	    { TC_DELETE_ENTRY, ENOENT,
+	      "Bad rule (does a matching rule exist in that chain?)" },
+	    { TC_SET_POLICY, ENOENT,
+	      "Bad built-in chain name" },
+	    { TC_SET_POLICY, EINVAL,
+	      "Bad policy name" },
+
+	    { NULL, 0, "Incompatible with this kernel" },
+	    { NULL, ENOPROTOOPT, "iptables who? (do you need to insmod?)" },
+	    { NULL, ENOSYS, "Will be implemented real soon.  I promise ;)" },
+	    { NULL, ENOMEM, "Memory allocation problem" },
+	    { NULL, ENOENT, "No chain/target/match by that name" },
+	  };
+
+	for (i = 0; i < sizeof(table)/sizeof(struct table_struct); i++) {
+		if ((!table[i].fn || table[i].fn == iptc_fn)
+		    && table[i].err == err)
+			return table[i].message;
+	}
+
+	return strerror(err);
+}
diff -urN iptables-1.2.8/libiptc2/linux_list.h iptables-1.2.9/libiptc2/linux_list.h
--- iptables-1.2.8/libiptc2/linux_list.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/libiptc2/linux_list.h	2003-07-23 14:19:46.000000000 +0200
@@ -0,0 +1,161 @@
+#ifndef _LINUXLIST_H
+#define _LINUXLIST_H
+
+
+/*
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+	struct list_head name = LIST_HEAD_INIT(name)
+
+#define INIT_LIST_HEAD(ptr) do { \
+	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/*
+ * Insert a new entry between two known consecutive entries. 
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static __inline__ void __list_add(struct list_head * new,
+	struct list_head * prev,
+	struct list_head * next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+/**
+ * list_add - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static __inline__ void list_add(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head, head->next);
+}
+
+/**
+ * list_add_tail - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static __inline__ void list_add_tail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static __inline__ void __list_del(struct list_head * prev,
+				  struct list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * list_del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
+ */
+static __inline__ void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+}
+
+/**
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @entry: the element to delete from the list.
+ */
+static __inline__ void list_del_init(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	INIT_LIST_HEAD(entry); 
+}
+
+/**
+ * list_empty - tests whether a list is empty
+ * @head: the list to test.
+ */
+static __inline__ int list_empty(struct list_head *head)
+{
+	return head->next == head;
+}
+
+/**
+ * list_splice - join two lists
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ */
+static __inline__ void list_splice(struct list_head *list, struct list_head *head)
+{
+	struct list_head *first = list->next;
+
+	if (first != list) {
+		struct list_head *last = list->prev;
+		struct list_head *at = head->next;
+
+		first->prev = head;
+		head->next = first;
+
+		last->next = at;
+		at->prev = last;
+	}
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:	the &struct list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member) \
+	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
+
+/**
+ * list_for_each	-	iterate over a list
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+        	
+/**
+ * list_for_each_safe	-	iterate over a list safe against removal of list entry
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @n:		another &struct list_head to use as temporary storage
+ * @head:	the head for your list.
+ */
+#define list_for_each_safe(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); \
+		pos = n, n = pos->next)
+
+#endif
diff -urN iptables-1.2.8/libiptc2/linux_listhelp.h iptables-1.2.9/libiptc2/linux_listhelp.h
--- iptables-1.2.8/libiptc2/linux_listhelp.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.9/libiptc2/linux_listhelp.h	2003-07-23 14:19:47.000000000 +0200
@@ -0,0 +1,99 @@
+#ifndef _LINUX_LISTHELP_H
+#define _LINUX_LISTHELP_H
+#include <stdlib.h>
+#include <string.h>
+#include "linux_list.h"
+
+/* Header to do more comprehensive job than linux/list.h; assume list
+   is first entry in structure. */
+
+/* Return pointer to first true entry, if any, or NULL.  A macro
+   required to allow inlining of cmpfn. */
+#define LIST_FIND(head, cmpfn, type, args...)		\
+({							\
+	const struct list_head *__i = (head);		\
+							\
+	do {						\
+		__i = __i->next;			\
+		if (__i == (head)) {			\
+			__i = NULL;			\
+			break;				\
+		}					\
+	} while (!cmpfn((const type)__i , ## args));	\
+	(type)__i;					\
+})
+
+#define LIST_FIND_W(head, cmpfn, type, args...)	\
+({						\
+	const struct list_head *__i = (head);	\
+						\
+	do {					\
+		__i = __i->next;		\
+		if (__i == (head)) {		\
+			__i = NULL;		\
+			break;			\
+		}				\
+	} while (!cmpfn((type)__i , ## args));	\
+	(type)__i;				\
+})
+
+static inline int
+__list_cmp_same(const void *p1, const void *p2) { return p1 == p2; }
+
+/* Is this entry in the list? */
+static inline int
+list_inlist(struct list_head *head, const void *entry)
+{
+	return LIST_FIND(head, __list_cmp_same, void *, entry) != NULL;
+}
+
+/* Delete from list. */
+#define LIST_DELETE(head, oldentry) list_del((struct list_head *)oldentry)
+
+/* Append. */
+static inline void
+list_append(struct list_head *head, void *new)
+{
+	list_add((new), (head)->prev);
+}
+
+/* Prepend. */
+static inline void
+list_prepend(struct list_head *head, void *new)
+{
+	list_add(new, head);
+}
+
+/* Insert according to ordering function; insert before first true. */
+#define LIST_INSERT(head, new, cmpfn)				\
+do {								\
+	struct list_head *__i;					\
+	for (__i = (head)->next;				\
+	     !cmpfn((new), (typeof (new))__i) && __i != (head);	\
+	     __i = __i->next);					\
+	list_add((struct list_head *)(new), __i->prev);		\
+} while(0)
+
+/* If the field after the list_head is a nul-terminated string, you
+   can use these functions. */
+static inline int __list_cmp_name(const void *i, const char *name)
+{
+	return strcmp(name, i+sizeof(struct list_head)) == 0;
+}
+
+/* Returns false if same name already in list, otherwise does insert. */
+static inline int
+list_named_insert(struct list_head *head, void *new)
+{
+	if (LIST_FIND(head, __list_cmp_name, void *,
+		      new + sizeof(struct list_head)))
+		return 0;
+	list_prepend(head, new);
+	return 1;
+}
+
+/* Find this named element in the list. */
+#define list_named_find(head, name)			\
+LIST_FIND(head, __list_cmp_name, void *, name)
+
+#endif /*_LISTHELP_H*/
