diff -urN iptables-1.3.4/Makefile iptables-1.3.5/Makefile
--- iptables-1.3.4/Makefile	2005-10-31 20:10:20.000000000 +0100
+++ iptables-1.3.5/Makefile	2006-02-01 13:14:38.000000000 +0100
@@ -14,8 +14,8 @@
 ifndef KERNEL_DIR
 KERNEL_DIR=/usr/src/linux
 endif
-IPTABLES_VERSION:=1.3.4
-OLD_IPTABLES_VERSION:=1.3.3
+IPTABLES_VERSION:=1.3.5
+OLD_IPTABLES_VERSION:=1.3.4
 
 PREFIX:=/usr/local
 LIBDIR:=$(PREFIX)/lib
diff -urN iptables-1.3.4/extensions/.pool-test iptables-1.3.5/extensions/.pool-test
--- iptables-1.3.4/extensions/.pool-test	2004-10-10 11:56:24.000000000 +0200
+++ iptables-1.3.5/extensions/.pool-test	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#! /bin/sh
-[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ip_pool.h ] && echo pool POOL
diff -urN iptables-1.3.4/extensions/Makefile iptables-1.3.5/extensions/Makefile
--- iptables-1.3.4/extensions/Makefile	2005-07-28 16:53:10.000000000 +0200
+++ iptables-1.3.5/extensions/Makefile	2006-02-01 13:14:31.000000000 +0100
@@ -5,8 +5,8 @@
 # header files are present in the include/linux directory of this iptables
 # package (HW)
 #
-PF_EXT_SLIB:=ah addrtype comment connlimit connmark conntrack dscp ecn esp hashlimit helper icmp iprange length limit mac mark multiport owner physdev pkttype realm rpc sctp standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NFQUEUE NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE TTL ULOG
-PF6_EXT_SLIB:=eui64 hl icmpv6 length limit mac mark multiport owner physdev standard tcp udp HL LOG NFQUEUE MARK TRACE
+PF_EXT_SLIB:=ah addrtype comment connlimit connmark conntrack dscp ecn esp hashlimit helper icmp iprange length limit mac mark multiport owner physdev pkttype policy realm rpc sctp standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NFQUEUE NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE TTL ULOG
+PF6_EXT_SLIB:=connmark eui64 hl icmpv6 length limit mac mark multiport owner physdev policy standard state tcp udp CONNMARK HL LOG NFQUEUE MARK TRACE
 
 # Optionals
 PF_EXT_SLIB_OPTS:=$(foreach T,$(wildcard extensions/.*-test),$(shell KERNEL_DIR=$(KERNEL_DIR) $(T)))
diff -urN iptables-1.3.4/extensions/libip6t_CONNMARK.c iptables-1.3.5/extensions/libip6t_CONNMARK.c
--- iptables-1.3.4/extensions/libip6t_CONNMARK.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.5/extensions/libip6t_CONNMARK.c	2006-01-30 09:40:05.000000000 +0100
@@ -0,0 +1,220 @@
+/* Shared library add-on to iptables to add CONNMARK target support.
+ *
+ * (C) 2002,2004 MARA Systems AB <http://www.marasystems.com>
+ * by Henrik Nordstrom <hno@marasystems.com>
+ *
+ * Version 1.1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include "../include/linux/netfilter_ipv4/ipt_CONNMARK.h"
+
+#if 0
+struct markinfo {
+	struct ipt_entry_target t;
+	struct ipt_connmark_target_info mark;
+};
+#endif
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"CONNMARK target v%s options:\n"
+"  --set-mark value[/mask]       Set conntrack mark value\n"
+"  --save-mark [--mask mask]     Save the packet nfmark in the connection\n"
+"  --restore-mark [--mask mask]  Restore saved nfmark value\n"
+"\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "set-mark", 1, 0, '1' },
+	{ "save-mark", 0, 0, '2' },
+	{ "restore-mark", 0, 0, '3' },
+	{ "mask", 1, 0, '4' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ip6t_entry_target *t, unsigned int *nfcache)
+{
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      struct ip6t_entry_target **target)
+{
+	struct ipt_connmark_target_info *markinfo
+		= (struct ipt_connmark_target_info *)(*target)->data;
+
+	markinfo->mask = 0xffffffffUL;
+
+	switch (c) {
+		char *end;
+	case '1':
+		markinfo->mode = IPT_CONNMARK_SET;
+
+		markinfo->mark = strtoul(optarg, &end, 0);
+		if (*end == '/' && end[1] != '\0')
+		    markinfo->mask = strtoul(end+1, &end, 0);
+
+		if (*end != '\0' || end == optarg)
+			exit_error(PARAMETER_PROBLEM, "Bad MARK value `%s'", optarg);
+		if (*flags)
+			exit_error(PARAMETER_PROBLEM,
+			           "CONNMARK target: Can't specify --set-mark twice");
+		*flags = 1;
+		break;
+	case '2':
+		markinfo->mode = IPT_CONNMARK_SAVE;
+		if (*flags)
+			exit_error(PARAMETER_PROBLEM,
+			           "CONNMARK target: Can't specify --save-mark twice");
+		*flags = 1;
+		break;
+	case '3':
+		markinfo->mode = IPT_CONNMARK_RESTORE;
+		if (*flags)
+			exit_error(PARAMETER_PROBLEM,
+			           "CONNMARK target: Can't specify --restore-mark twice");
+		*flags = 1;
+		break;
+	case '4':
+		if (!*flags)
+			exit_error(PARAMETER_PROBLEM,
+			           "CONNMARK target: Can't specify --mask without a operation");
+		markinfo->mask = strtoul(optarg, &end, 0);
+
+		if (*end != '\0' || end == optarg)
+			exit_error(PARAMETER_PROBLEM, "Bad MASK value `%s'", optarg);
+		break;
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+		           "CONNMARK target: No operation specified");
+}
+
+static void
+print_mark(unsigned long mark)
+{
+	printf("0x%lx", mark);
+}
+
+static void
+print_mask(const char *text, unsigned long mask)
+{
+	if (mask != 0xffffffffUL)
+		printf("%s0x%lx", text, mask);
+}
+
+
+/* Prints out the target info. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_target *target,
+      int numeric)
+{
+	const struct ipt_connmark_target_info *markinfo =
+		(const struct ipt_connmark_target_info *)target->data;
+	switch (markinfo->mode) {
+	case IPT_CONNMARK_SET:
+	    printf("CONNMARK set ");
+	    print_mark(markinfo->mark);
+	    print_mask("/", markinfo->mask);
+	    printf(" ");
+	    break;
+	case IPT_CONNMARK_SAVE:
+	    printf("CONNMARK save ");
+	    print_mask("mask ", markinfo->mask);
+	    printf(" ");
+	    break;
+	case IPT_CONNMARK_RESTORE:
+	    printf("CONNMARK restore ");
+	    print_mask("mask ", markinfo->mask);
+	    break;
+	default:
+	    printf("ERROR: UNKNOWN CONNMARK MODE ");
+	    break;
+	}
+}
+
+/* Saves the target into in parsable form to stdout. */
+static void
+save(const struct ip6t_ip6 *ip, const struct ip6t_entry_target *target)
+{
+	const struct ipt_connmark_target_info *markinfo =
+		(const struct ipt_connmark_target_info *)target->data;
+
+	switch (markinfo->mode) {
+	case IPT_CONNMARK_SET:
+	    printf("--set-mark ");
+	    print_mark(markinfo->mark);
+	    print_mask("/", markinfo->mask);
+	    printf(" ");
+	    break;
+	case IPT_CONNMARK_SAVE:
+	    printf("--save-mark ");
+	    print_mask("--mask ", markinfo->mask);
+	    break;
+	case IPT_CONNMARK_RESTORE:
+	    printf("--restore-mark ");
+	    print_mask("--mask ", markinfo->mask);
+	    break;
+	default:
+	    printf("ERROR: UNKNOWN CONNMARK MODE ");
+	    break;
+	}
+}
+
+static struct ip6tables_target connmark_target = {
+    .name          = "CONNMARK",
+    .version       = IPTABLES_VERSION,
+    .size          = IP6T_ALIGN(sizeof(struct ipt_connmark_target_info)),
+    .userspacesize = IP6T_ALIGN(sizeof(struct ipt_connmark_target_info)),
+    .help          = &help,
+    .init          = &init,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
+};
+
+void _init(void)
+{
+	register_target6(&connmark_target);
+}
diff -urN iptables-1.3.4/extensions/libip6t_HL.man iptables-1.3.5/extensions/libip6t_HL.man
--- iptables-1.3.4/extensions/libip6t_HL.man	2004-10-10 11:56:25.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_HL.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,17 +1,17 @@
-This is used to modify the IPv6 HOPLIMIT header field.  The HOPLIMIT field is 
-similar to what is known as TTL value in IPv4.  Setting or incrementing the
-HOPLIMIT field can potentially be very dangerous, so it should be avoided at
-any cost.  
-.TP
-.B Don't ever set or increment the value on packets that leave your local network!
+This is used to modify the Hop Limit field in IPv6 header. The Hop Limit field
+is similar to what is known as TTL value in IPv4.  Setting or incrementing the
+Hop Limit field can potentially be very dangerous, so it should be avoided at
+any cost. This target is only valid in
 .B mangle
 table.
 .TP
+.B Don't ever set or increment the value on packets that leave your local network!
+.TP
 .BI "--hl-set " "value"
-Set the HOPLIMIT value to `value'.
+Set the Hop Limit to `value'.
 .TP
 .BI "--hl-dec " "value"
-Decrement the HOPLIMIT value `value' times.
+Decrement the Hop Limit `value' times.
 .TP
 .BI "--hl-inc " "value"
-Increment the HOPLIMIT value `value' times.
+Increment the Hop Limit `value' times.
diff -urN iptables-1.3.4/extensions/libip6t_REJECT.man iptables-1.3.5/extensions/libip6t_REJECT.man
--- iptables-1.3.4/extensions/libip6t_REJECT.man	2004-10-10 11:56:26.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_REJECT.man	2006-01-30 09:41:00.000000000 +0100
@@ -23,7 +23,7 @@
 .B " icmp6-port-unreachable"
 .B " port-unreach"
 .fi
-which return the appropriate IPv6-ICMP error message (\fBport-unreach\fP is
+which return the appropriate ICMPv6 error message (\fBport-unreach\fP is
 the default). Finally, the option
 .B tcp-reset
 can be used on rules which only match the TCP protocol: this causes a
@@ -31,4 +31,6 @@
 .I ident
 (113/tcp) probes which frequently occur when sending mail to broken mail
 hosts (which won't accept your mail otherwise).
+.B tcp-reset
+can only be used with kernel versions 2.6.14 or latter.
 
diff -urN iptables-1.3.4/extensions/libip6t_ah.man iptables-1.3.5/extensions/libip6t_ah.man
--- iptables-1.3.4/extensions/libip6t_ah.man	2004-10-10 11:56:25.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_ah.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,3 +1,10 @@
-This module matches the SPIs in AH header of IPSec packets.
+This module matches the parameters in Authentication header of IPsec packets.
 .TP
 .BR "--ahspi " "[!] \fIspi\fP[:\fIspi\fP]"
+Matches SPI.
+.TP
+.BR "--ahlen " "[!] \fIlength"
+Total length of this header in octets.
+.TP
+.BI "--ahres"
+Matches if the reserved field is filled with zero.
diff -urN iptables-1.3.4/extensions/libip6t_condition.man iptables-1.3.5/extensions/libip6t_condition.man
--- iptables-1.3.4/extensions/libip6t_condition.man	2004-10-10 11:56:25.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_condition.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,4 +1,4 @@
 This matches if a specific /proc filename is '0' or '1'.
 .TP
-.BI "--condition " "[!] filename"
+.BR "--condition " "[!] \fIfilename"
 Match on boolean value stored in /proc/net/ip6t_condition/filename file
diff -urN iptables-1.3.4/extensions/libip6t_connmark.c iptables-1.3.5/extensions/libip6t_connmark.c
--- iptables-1.3.4/extensions/libip6t_connmark.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.5/extensions/libip6t_connmark.c	2006-01-30 09:40:05.000000000 +0100
@@ -0,0 +1,151 @@
+/* Shared library add-on to iptables to add connmark matching support.
+ *
+ * (C) 2002,2004 MARA Systems AB <http://www.marasystems.com>
+ * by Henrik Nordstrom <hno@marasystems.com>
+ *
+ * Version 1.1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <ip6tables.h>
+#include "../include/linux/netfilter_ipv4/ipt_connmark.h"
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"CONNMARK match v%s options:\n"
+"[!] --mark value[/mask]         Match nfmark value with optional mask\n"
+"\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "mark", 1, 0, '1' },
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ip6t_entry_match *m, unsigned int *nfcache)
+{
+	/* Can't cache this. */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct ipt_connmark_info *markinfo = (struct ipt_connmark_info *)(*match)->data;
+
+	switch (c) {
+		char *end;
+	case '1':
+		check_inverse(optarg, &invert, &optind, 0);
+
+		markinfo->mark = strtoul(optarg, &end, 0);
+		markinfo->mask = 0xffffffffUL;
+		
+		if (*end == '/')
+			markinfo->mask = strtoul(end+1, &end, 0);
+
+		if (*end != '\0' || end == optarg)
+			exit_error(PARAMETER_PROBLEM, "Bad MARK value `%s'", optarg);
+		if (invert)
+			markinfo->invert = 1;
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static void
+print_mark(unsigned long mark, unsigned long mask, int numeric)
+{
+	if(mask != 0xffffffffUL)
+		printf("0x%lx/0x%lx ", mark, mask);
+	else
+		printf("0x%lx ", mark);
+}
+
+/* Final check; must have specified --mark. */
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+			   "MARK match: You must specify `--mark'");
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	struct ipt_connmark_info *info = (struct ipt_connmark_info *)match->data;
+
+	printf("CONNMARK match ");
+	if (info->invert)
+		printf("!");
+	print_mark(info->mark, info->mask, numeric);
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void
+save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+	struct ipt_connmark_info *info = (struct ipt_connmark_info *)match->data;
+
+	if (info->invert)
+		printf("! ");
+
+	printf("--mark ");
+	print_mark(info->mark, info->mask, 0);
+}
+
+static struct ip6tables_match connmark_match = {
+    .name          = "connmark",
+    .version       = IPTABLES_VERSION,
+    .size          = IP6T_ALIGN(sizeof(struct ipt_connmark_info)),
+    .userspacesize = IP6T_ALIGN(sizeof(struct ipt_connmark_info)),
+    .help          = &help,
+    .init          = &init,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
+};
+
+void _init(void)
+{
+	register_match6(&connmark_match);
+}
diff -urN iptables-1.3.4/extensions/libip6t_dst.man iptables-1.3.5/extensions/libip6t_dst.man
--- iptables-1.3.4/extensions/libip6t_dst.man	2004-10-10 11:56:24.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_dst.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,7 +1,7 @@
-This module matches the IPv6 destination header options
+This module matches the parameters in Destination Options header
 .TP
-.BI "--dst-len" "[!]" "length"
-Total length of this header
+.BR "--dst-len " "[!] \fIlength"
+Total length of this header in octets.
 .TP
-.BI "--dst-opts " "TYPE[:LEN],[,TYPE[:LEN]...]"
-Options and it's length (List).
+.BR "--dst-opts " "\fItype\fP[:\fIlength\fP][,\fItype\fP[:\fIlength\fP]...]"
+numeric type of option and the length of the option data in octets.
diff -urN iptables-1.3.4/extensions/libip6t_esp.man iptables-1.3.5/extensions/libip6t_esp.man
--- iptables-1.3.4/extensions/libip6t_esp.man	2004-10-10 11:56:27.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_esp.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,3 +1,3 @@
-This module matches the SPIs in ESP header of IPSec packets.
+This module matches the SPIs in ESP header of IPsec packets.
 .TP
 .BR "--espspi " "[!] \fIspi\fP[:\fIspi\fP]"
diff -urN iptables-1.3.4/extensions/libip6t_eui64.man iptables-1.3.5/extensions/libip6t_eui64.man
--- iptables-1.3.4/extensions/libip6t_eui64.man	2004-10-10 11:56:26.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_eui64.man	2006-01-30 09:41:00.000000000 +0100
@@ -1 +1,10 @@
-This module matches the EUI64 part of a stateless autoconfigured IPv6 address.  It compares the source MAC address with the lower 64 bits of the IPv6 address. 
+This module matches the EUI-64 part of a stateless autoconfigured IPv6 address.
+It compares the EUI-64 derived from the source MAC address in Ehternet frame
+with the lower 64 bits of the IPv6 source address. But "Universal/Local"
+bit is not compared. This module doesn't match other link layer frame, and
+is only valid in the
+.BR PREROUTING ,
+.BR INPUT
+and
+.BR FORWARD
+chains.
diff -urN iptables-1.3.4/extensions/libip6t_frag.man iptables-1.3.5/extensions/libip6t_frag.man
--- iptables-1.3.4/extensions/libip6t_frag.man	2004-10-10 11:56:26.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_frag.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,19 +1,20 @@
-This module matches the time IPv6 fragmentathion header
+This module matches the parameters in Fragment header.
 .TP
-.BI "--fragid " "[!]" "id[:id]"
-Matches the given fragmentation ID (range).
+.BR "--fragid " "[!] \fIid\fP[:\fIid\fP]"
+Matches the given Identification or range of it.
 .TP
-.BI "--fraglen " "[!]" "length"
-Matches the total length of this header.
+.BR "--fraglen " "[!] \fIlength\fP"
+This option cannot be used with kernel version 2.6.10 or later. The length of
+Fragment header is static and this option doesn't make sense.
 .TP
-.BI "--fragres "
-Matches the reserved field, too.
+.BR "--fragres "
+Matches if the reserved fields are filled with zero.
 .TP
-.BI "--fragfirst "
+.BR "--fragfirst "
 Matches on the first fragment.
 .TP
-.BI "[--fragmore]"
+.BR "[--fragmore]"
 Matches if there are more fragments.
 .TP
-.BI "[--fraglast]"
+.BR "[--fraglast]"
 Matches if this is the last fragement.
diff -urN iptables-1.3.4/extensions/libip6t_fuzzy.man iptables-1.3.5/extensions/libip6t_fuzzy.man
--- iptables-1.3.4/extensions/libip6t_fuzzy.man	2004-10-10 11:56:24.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_fuzzy.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,6 +1,6 @@
 This module matches a rate limit based on a fuzzy logic controller [FLC]
 .TP
-.BI "--lower-limit  "number"
+.BI "--lower-limit " "number"
 Specifies the lower limit (in packets per second).
 .TP
 .BI "--upper-limit " "number"
diff -urN iptables-1.3.4/extensions/libip6t_hbh.man iptables-1.3.5/extensions/libip6t_hbh.man
--- iptables-1.3.4/extensions/libip6t_hbh.man	2004-10-10 11:56:25.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_hbh.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,7 +1,7 @@
-This module matches the IPv6 hop-by-hop header options
+This module matches the parameters in Hop-by-Hop Options header
 .TP
-.BI "--hbh-len" "[!]" "length"
-Total length of this header
+.BR "--hbh-len " "[!] \fIlength\fP"
+Total length of this header in octets.
 .TP
-.BI "--hbh-opts " "TYPE[:LEN],[,TYPE[:LEN]...]"
-Options and it's length (List).
+.BR "--hbh-opts " "\fItype\fP[:\fIlength\fP][,\fItype\fP[:\fIlength\fP]...]"
+numeric type of option and the length of the option data in octets.
diff -urN iptables-1.3.4/extensions/libip6t_hl.man iptables-1.3.5/extensions/libip6t_hl.man
--- iptables-1.3.4/extensions/libip6t_hl.man	2004-10-10 11:56:26.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_hl.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,10 +1,10 @@
-This module matches the HOPLIMIT field in the IPv6 header.
+This module matches the Hop Limit field in the IPv6 header.
 .TP
-.BI "--hl-eq " "value"
-Matches if HOPLIMIT equals the given value.
+.BR "--hl-eq " "[!] \fIvalue\fP"
+Matches if Hop Limit equals \fIvalue\fP.
 .TP
-.BI "--hl-lt " "ttl"
-Matches if HOPLIMIT is less than the given value.
+.BI "--hl-lt " "value"
+Matches if Hop Limit is less than \fIvalue\fP.
 .TP
-.BI "--hl-gt " "ttl"
-Matches if HOPLIMIT is greater than the given value.
+.BI "--hl-gt " "value"
+Matches if Hop Limit is greater than \fIvalue\fP.
diff -urN iptables-1.3.4/extensions/libip6t_icmpv6.man iptables-1.3.5/extensions/libip6t_icmpv6.man
--- iptables-1.3.4/extensions/libip6t_icmpv6.man	2004-10-10 11:56:27.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_icmpv6.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,9 +1,14 @@
 This extension is loaded if `--protocol ipv6-icmp' or `--protocol icmpv6' is
 specified. It provides the following option:
 .TP
-.BR "--icmpv6-type " "[!] \fItypename\fP"
-This allows specification of the ICMP type, which can be a numeric
-IPv6-ICMP type, or one of the IPv6-ICMP type names shown by the command
+.BR "--icmpv6-type " "[!] \fItype\fP[/\fIcode\fP]|\fItypename\fP"
+This allows specification of the ICMPv6 type, which can be a numeric
+ICMPv6
+.IR type ,
+.IR type
+and
+.IR code ,
+or one of the ICMPv6 type names shown by the command
 .nf
  ip6tables -p ipv6-icmp -h
 .fi
diff -urN iptables-1.3.4/extensions/libip6t_ipv6header.man iptables-1.3.5/extensions/libip6t_ipv6header.man
--- iptables-1.3.4/extensions/libip6t_ipv6header.man	2004-10-10 11:56:24.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_ipv6header.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,10 +1,29 @@
-This module matches on IPv6 option headers
+This module matches IPv6 extension headers and/or upper layer header.
 .TP
-.BI "--header " "[!]" "headers"
-Matches the given type of headers.  
-Names: hop,dst,route,frag,auth,esp,none,proto
-Long Names: hop-by-hop,ipv6-opts,ipv6-route,ipv6-frag,ah,esp,ipv6-nonxt,protocol
-Numbers: 0,60,43,44,51,50,59
+.BR "--header " "[!] \fIheader\fP[,\fIheader\fP...]"
+Matches the packet which EXACTLY includes all specified headers. The headers
+encapsulated with ESP header are out of scope.
+.IR header
+can be
+.IR hop | hop-by-hop
+(Hop-by-Hop Options header),
+.IR dst
+(Destination Options header),
+.IR route
+(Routing header),
+.IR frag
+(Fragment header),
+.IR auth
+(Authentication header),
+.IR esp
+(Encapsulating Security Payload header),
+.IR none
+(No Next header) which matches 59 in the 'Next Header field' of IPv6 header or any IPv6 extension headers, or
+.IR proto
+which matches any upper layer protocol header. A protocol name from /etc/protocols and numeric value also allowed. The number 255 is equivalent to
+.IR proto .
 .TP
-.BI "--soft"
-The header CONTAINS the specified extensions.
+.BR "[--soft]"
+Matches if the packet includes all specified headers with
+.BR --header ,
+AT LEAST.
diff -urN iptables-1.3.4/extensions/libip6t_length.man iptables-1.3.5/extensions/libip6t_length.man
--- iptables-1.3.4/extensions/libip6t_length.man	2004-10-10 11:56:25.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_length.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,4 +1,4 @@
-This module matches the length of a packet against a specific value
-or range of values.
+This module matches the length of the IPv6 payload in octets, or range of it.
+IPv6 header itself isn't counted.
 .TP
-.BR "--length " "\fIlength\fP[:\fIlength\fP]"
+.BR "--length " "[!] \fIlength\fP[:\fIlength\fP]"
diff -urN iptables-1.3.4/extensions/libip6t_mark.man iptables-1.3.5/extensions/libip6t_mark.man
--- iptables-1.3.4/extensions/libip6t_mark.man	2004-10-10 11:56:26.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_mark.man	2006-01-30 09:41:00.000000000 +0100
@@ -4,6 +4,6 @@
 target below).
 .TP
 .BR "--mark " "\fIvalue\fP[/\fImask\fP]"
-Matches packets with the given unsigned mark value (if a mask is
-specified, this is logically ANDed with the mask before the
+Matches packets with the given unsigned mark value (if a \fImask\fP is
+specified, this is logically ANDed with the \fImask\fP before the
 comparison).
diff -urN iptables-1.3.4/extensions/libip6t_multiport.man iptables-1.3.5/extensions/libip6t_multiport.man
--- iptables-1.3.4/extensions/libip6t_multiport.man	2005-06-24 18:34:18.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_multiport.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,6 +1,7 @@
 This module matches a set of source or destination ports.  Up to 15
 ports can be specified.  A port range (port:port) counts as two
-ports.  It can only be used in conjunction with
+ports, but range isn't supported now. It can only be used in conjunction
+with
 .B "-p tcp"
 or
 .BR "-p udp" .
diff -urN iptables-1.3.4/extensions/libip6t_owner.man iptables-1.3.5/extensions/libip6t_owner.man
--- iptables-1.3.4/extensions/libip6t_owner.man	2004-10-10 11:56:24.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_owner.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,7 +1,7 @@
 This module attempts to match various characteristics of the packet
 creator, for locally-generated packets.  It is only valid in the
 .B OUTPUT
-chain, and even this some packets (such as ICMP ping responses) may
+chain, and even this some packets (such as ICMPv6 ping responses) may
 have no owner, and hence never match.  This is regarded as experimental.
 .TP
 .BI "--uid-owner " "userid"
diff -urN iptables-1.3.4/extensions/libip6t_physdev.man iptables-1.3.5/extensions/libip6t_physdev.man
--- iptables-1.3.4/extensions/libip6t_physdev.man	2004-10-10 11:56:25.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_physdev.man	2006-01-30 09:41:00.000000000 +0100
@@ -3,7 +3,7 @@
 a transparent bridging IP firewall and is only useful for kernel versions
 above version 2.5.44.
 .TP
-.B --physdev-in name
+.BR --physdev-in " [!] \fIname\fP"
 Name of a bridge port via which a packet is received (only for
 packets entering the
 .BR INPUT ,
@@ -14,7 +14,7 @@
 interface which begins with this name will match. If the packet didn't arrive
 through a bridge device, this packet won't match this option, unless '!' is used.
 .TP
-.B --physdev-out name
+.BR --physdev-out " [!] \fIname\fP"
 Name of a bridge port via which a packet is going to be sent (for packets
 entering the
 .BR FORWARD ,
@@ -31,12 +31,12 @@
 the output device will be, then the packet won't match this option, unless
 '!' is used.
 .TP
-.B --physdev-is-in
+.RB "[!] " --physdev-is-in
 Matches if the packet has entered through a bridge interface.
 .TP
-.B --physdev-is-out
+.RB "[!] " --physdev-is-out
 Matches if the packet will leave through a bridge interface.
 .TP
-.B --physdev-is-bridged
+.RB "[!] " --physdev-is-bridged
 Matches if the packet is being bridged and therefore is not being routed.
 This is only useful in the FORWARD and POSTROUTING chains.
diff -urN iptables-1.3.4/extensions/libip6t_policy.c iptables-1.3.5/extensions/libip6t_policy.c
--- iptables-1.3.4/extensions/libip6t_policy.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.5/extensions/libip6t_policy.c	2006-02-01 13:55:01.000000000 +0100
@@ -0,0 +1,478 @@
+/* Shared library add-on to iptables to add policy support. */
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <netdb.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <ip6tables.h>
+
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include "../include/linux/netfilter_ipv6/ip6t_policy.h"
+
+/*
+ * HACK: global pointer to current matchinfo for making
+ * final checks and adjustments in final_check.
+ */
+static struct ip6t_policy_info *policy_info;
+
+static void help(void)
+{
+	printf(
+"policy v%s options:\n"
+"  --dir in|out			match policy applied during decapsulation/\n"
+"				policy to be applied during encapsulation\n"
+"  --pol none|ipsec		match policy\n"
+"  --strict 			match entire policy instead of single element\n"
+"				at any position\n"
+"[!] --reqid reqid		match reqid\n"
+"[!] --spi spi			match SPI\n"
+"[!] --proto proto		match protocol (ah/esp/ipcomp)\n"
+"[!] --mode mode 		match mode (transport/tunnel)\n"
+"[!] --tunnel-src addr/masklen	match tunnel source\n"
+"[!] --tunnel-dst addr/masklen	match tunnel destination\n"
+"  --next 			begin next element in policy\n",
+	IPTABLES_VERSION);
+}
+
+static struct option opts[] =
+{
+	{
+		.name		= "dir",
+		.has_arg	= 1,
+		.val		= '1',
+	},
+	{
+		.name		= "pol",
+		.has_arg	= 1,
+		.val		= '2',
+	},
+	{
+		.name		= "strict",
+		.val		= '3'
+	},
+	{
+		.name		= "reqid",
+		.has_arg	= 1,
+		.val		= '4',
+	},
+	{
+		.name		= "spi",
+		.has_arg	= 1,
+		.val		= '5'
+	},
+	{
+		.name		= "tunnel-src",
+		.has_arg	= 1,
+		.val		= '6'
+	},
+	{
+		.name		= "tunnel-dst",
+		.has_arg	= 1,
+		.val		= '7'
+	},
+	{
+		.name		= "proto",
+		.has_arg	= 1,
+		.val		= '8'
+	},
+	{
+		.name		= "mode",
+		.has_arg	= 1,
+		.val		= '9'
+	},
+	{
+		.name		= "next",
+		.val		= 'a'
+	},
+	{ }
+};
+
+/* FIXME - Duplicated code from ip6tables.c */
+/* Duplicated to stop too many changes in other files .... */
+static void
+in6addrcpy(struct in6_addr *dst, struct in6_addr *src)
+{
+        memcpy(dst, src, sizeof(struct in6_addr));
+        /* dst->s6_addr = src->s6_addr; */
+}
+
+static char *
+addr_to_numeric(const struct in6_addr *addrp)
+{
+        /* 0000:0000:0000:0000:0000:000.000.000.000
+	 * 0000:0000:0000:0000:0000:0000:0000:0000 */
+        static char buf[50+1];
+        return (char *)inet_ntop(AF_INET6, addrp, buf, sizeof(buf));
+}
+
+static char *
+mask_to_numeric(const struct in6_addr *addrp)
+{
+        static char buf[50+2];
+        int l = ipv6_prefix_length(addrp);
+        if (l == -1) {
+		strcpy(buf, "/");
+		strcat(buf, addr_to_numeric(addrp));
+		return buf;
+	}
+	sprintf(buf, "/%d", l);
+	return buf;
+}
+
+/* These should be in include/ip6tables.h... */
+extern u_int16_t parse_protocol(const char *s);
+extern void parse_hostnetworkmask(const char *name, struct in6_addr **addrpp,
+		struct in6_addr *maskp, unsigned int *naddrs);
+
+/* End duplicated code from ip6tables.c */
+
+static void init(struct ip6t_entry_match *m, unsigned int *nfcache)
+{
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static int parse_direction(char *s)
+{
+	if (strcmp(s, "in") == 0)
+		return IP6T_POLICY_MATCH_IN;
+	if (strcmp(s, "out") == 0)
+		return IP6T_POLICY_MATCH_OUT;
+	exit_error(PARAMETER_PROBLEM, "policy_match: invalid dir `%s'", s);
+}
+
+static int parse_policy(char *s)
+{
+	if (strcmp(s, "none") == 0)
+		return IP6T_POLICY_MATCH_NONE;
+	if (strcmp(s, "ipsec") == 0)
+		return 0;
+	exit_error(PARAMETER_PROBLEM, "policy match: invalid policy `%s'", s);
+}
+
+static int parse_mode(char *s)
+{
+	if (strcmp(s, "transport") == 0)
+		return IP6T_POLICY_MODE_TRANSPORT;
+	if (strcmp(s, "tunnel") == 0)
+		return IP6T_POLICY_MODE_TUNNEL;
+	exit_error(PARAMETER_PROBLEM, "policy match: invalid mode `%s'", s);
+}
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+                 const struct ip6t_entry *entry,
+                 unsigned int *nfcache,
+                 struct ip6t_entry_match **match)
+{
+	struct ip6t_policy_info *info = (void *)(*match)->data;
+	struct ip6t_policy_elem *e = &info->pol[info->len];
+	struct in6_addr *addr = NULL, mask;
+	unsigned int naddr = 0;
+	int mode;
+
+	check_inverse(optarg, &invert, &optind, 0);
+
+	switch (c) {
+	case '1':
+		if (info->flags & (IP6T_POLICY_MATCH_IN|IP6T_POLICY_MATCH_OUT))
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --dir option");
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: can't invert --dir option");
+
+		info->flags |= parse_direction(argv[optind-1]);
+		break;
+	case '2':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: can't invert --policy option");
+
+		info->flags |= parse_policy(argv[optind-1]);
+		break;
+	case '3':
+		if (info->flags & IP6T_POLICY_MATCH_STRICT)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --strict option");
+
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: can't invert --strict option");
+
+		info->flags |= IP6T_POLICY_MATCH_STRICT;
+		break;
+	case '4':
+		if (e->match.reqid)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --reqid option");
+
+		e->match.reqid = 1;
+		e->invert.reqid = invert;
+		e->reqid = strtol(argv[optind-1], NULL, 10);
+		break;
+	case '5':
+		if (e->match.spi)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --spi option");
+
+		e->match.spi = 1;
+		e->invert.spi = invert;
+		e->spi = strtol(argv[optind-1], NULL, 0x10);
+		break;
+	case '6':
+		if (e->match.saddr)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --tunnel-src option");
+
+		parse_hostnetworkmask(argv[optind-1], &addr, &mask, &naddr);
+		if (naddr > 1)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: name resolves to multiple IPs");
+
+		e->match.saddr = 1;
+		e->invert.saddr = invert;
+		in6addrcpy(&e->saddr.a6, addr);
+		in6addrcpy(&e->smask.a6, &mask);
+                break;
+	case '7':
+		if (e->match.daddr)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --tunnel-dst option");
+
+		parse_hostnetworkmask(argv[optind-1], &addr, &mask, &naddr);
+		if (naddr > 1)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: name resolves to multiple IPs");
+
+		e->match.daddr = 1;
+		e->invert.daddr = invert;
+		in6addrcpy(&e->daddr.a6, addr);
+		in6addrcpy(&e->dmask.a6, &mask);
+		break;
+	case '8':
+		if (e->match.proto)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --proto option");
+
+		e->proto = parse_protocol(argv[optind-1]);
+		if (e->proto != IPPROTO_AH && e->proto != IPPROTO_ESP &&
+		    e->proto != IPPROTO_COMP)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: protocol must ah/esp/ipcomp");
+		e->match.proto = 1;
+		e->invert.proto = invert;
+		break;
+	case '9':
+		if (e->match.mode)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --mode option");
+
+		mode = parse_mode(argv[optind-1]);
+		e->match.mode = 1;
+		e->invert.mode = invert;
+		e->mode = mode;
+		break;
+	case 'a':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: can't invert --next option");
+
+		if (++info->len == IP6T_POLICY_MAX_ELEM)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: maximum policy depth reached");
+		break;
+	default:
+		return 0;
+	}
+
+	policy_info = info;
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	struct ip6t_policy_info *info = policy_info;
+	struct ip6t_policy_elem *e;
+	int i;
+
+	if (info == NULL)
+		exit_error(PARAMETER_PROBLEM,
+		           "policy match: no parameters given");
+
+	if (!(info->flags & (IP6T_POLICY_MATCH_IN|IP6T_POLICY_MATCH_OUT)))
+		exit_error(PARAMETER_PROBLEM,
+		           "policy match: neither --in nor --out specified");
+
+	if (info->flags & IP6T_POLICY_MATCH_NONE) {
+		if (info->flags & IP6T_POLICY_MATCH_STRICT)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: policy none but --strict given");
+
+		if (info->len != 0)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: policy none but policy given");
+	} else
+		info->len++;	/* increase len by 1, no --next after last element */
+
+	if (!(info->flags & IP6T_POLICY_MATCH_STRICT) && info->len > 1)
+		exit_error(PARAMETER_PROBLEM,
+		           "policy match: multiple elements but no --strict");
+
+	for (i = 0; i < info->len; i++) {
+		e = &info->pol[i];
+
+                if (info->flags & IP6T_POLICY_MATCH_STRICT &&
+		    !(e->match.reqid || e->match.spi || e->match.saddr ||
+                      e->match.daddr || e->match.proto || e->match.mode))
+                        exit_error(PARAMETER_PROBLEM,
+                                   "policy match: empty policy element");
+
+		if ((e->match.saddr || e->match.daddr)
+		    && ((e->mode == IP6T_POLICY_MODE_TUNNEL && e->invert.mode) ||
+		        (e->mode == IP6T_POLICY_MODE_TRANSPORT && !e->invert.mode)))
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: --tunnel-src/--tunnel-dst "
+			           "is only valid in tunnel mode");
+	}
+}
+
+static void print_mode(char *prefix, u_int8_t mode, int numeric)
+{
+	printf("%smode ", prefix);
+
+	switch (mode) {
+	case IP6T_POLICY_MODE_TRANSPORT:
+		printf("transport ");
+		break;
+	case IP6T_POLICY_MODE_TUNNEL:
+		printf("tunnel ");
+		break;
+	default:
+		printf("??? ");
+		break;
+	}
+}
+
+static void print_proto(char *prefix, u_int8_t proto, int numeric)
+{
+	struct protoent *p = NULL;
+
+	printf("%sproto ", prefix);
+	if (!numeric)
+		p = getprotobynumber(proto);
+	if (p != NULL)
+		printf("%s ", p->p_name);
+	else
+		printf("%u ", proto);
+}
+
+#define PRINT_INVERT(x)		\
+do {				\
+	if (x)			\
+		printf("! ");	\
+} while(0)
+
+static void print_entry(char *prefix, const struct ip6t_policy_elem *e,
+                        int numeric)
+{
+	if (e->match.reqid) {
+		PRINT_INVERT(e->invert.reqid);
+		printf("%sreqid %u ", prefix, e->reqid);
+	}
+	if (e->match.spi) {
+		PRINT_INVERT(e->invert.spi);
+		printf("%sspi 0x%x ", prefix, e->spi);
+	}
+	if (e->match.proto) {
+		PRINT_INVERT(e->invert.proto);
+		print_proto(prefix, e->proto, numeric);
+	}
+	if (e->match.mode) {
+		PRINT_INVERT(e->invert.mode);
+		print_mode(prefix, e->mode, numeric);
+	}
+	if (e->match.daddr) {
+		PRINT_INVERT(e->invert.daddr);
+		printf("%stunnel-dst %s%s ", prefix,
+		       addr_to_numeric((struct in6_addr *)&e->daddr),
+		       mask_to_numeric((struct in6_addr *)&e->dmask));
+	}
+	if (e->match.saddr) {
+		PRINT_INVERT(e->invert.saddr);
+		printf("%stunnel-src %s%s ", prefix,
+		       addr_to_numeric((struct in6_addr *)&e->saddr),
+		       mask_to_numeric((struct in6_addr *)&e->smask));
+	}
+}
+
+static void print_flags(char *prefix, const struct ip6t_policy_info *info)
+{
+	if (info->flags & IP6T_POLICY_MATCH_IN)
+		printf("%sdir in ", prefix);
+	else
+		printf("%sdir out ", prefix);
+
+	if (info->flags & IP6T_POLICY_MATCH_NONE)
+		printf("%spol none ", prefix);
+	else
+		printf("%spol ipsec ", prefix);
+
+	if (info->flags & IP6T_POLICY_MATCH_STRICT)
+		printf("%sstrict ", prefix);
+}
+
+static void print(const struct ip6t_ip6 *ip,
+                  const struct ip6t_entry_match *match,
+		  int numeric)
+{
+	const struct ip6t_policy_info *info = (void *)match->data;
+	unsigned int i;
+
+	printf("policy match ");
+	print_flags("", info);
+	for (i = 0; i < info->len; i++) {
+		if (info->len > 1)
+			printf("[%u] ", i);
+		print_entry("", &info->pol[i], numeric);
+	}
+
+	printf("\n");
+}
+
+static void save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+	const struct ip6t_policy_info *info = (void *)match->data;
+	unsigned int i;
+
+	print_flags("--", info);
+	for (i = 0; i < info->len; i++) {
+		print_entry("--", &info->pol[i], 0);
+		if (i + 1 < info->len)
+			printf("--next ");
+	}
+}
+
+struct ip6tables_match policy = {
+	.name		= "policy",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_policy_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_policy_info)),
+	.help		= help,
+	.init		= init,
+	.parse		= parse,
+	.final_check	= final_check,
+	.print		= print,
+	.save		= save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match6(&policy);
+}
diff -urN iptables-1.3.4/extensions/libip6t_policy.man iptables-1.3.5/extensions/libip6t_policy.man
--- iptables-1.3.4/extensions/libip6t_policy.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.5/extensions/libip6t_policy.man	2006-01-30 09:40:05.000000000 +0100
@@ -0,0 +1,48 @@
+This modules matches the policy used by IPsec for handling a packet.
+.TP
+.BI "--dir " "in|out"
+Used to select whether to match the policy used for decapsulation or the
+policy that will be used for encapsulation.
+.B in
+is valid in the
+.B PREROUTING, INPUT and FORWARD
+chains,
+.B out
+is valid in the
+.B POSTROUTING, OUTPUT and FORWARD
+chains.
+.TP
+.BI "--pol " "none|ipsec"
+Matches if the packet is subject to IPsec processing.
+.TP
+.BI "--strict"
+Selects whether to match the exact policy or match if any rule of
+the policy matches the given policy.
+.TP
+.BI "--reqid " "id"
+Matches the reqid of the policy rule. The reqid can be specified with
+.B setkey(8)
+using
+.B unique:id
+as level.
+.TP
+.BI "--spi " "spi"
+Matches the SPI of the SA.
+.TP
+.BI "--proto " "ah|esp|ipcomp"
+Matches the encapsulation protocol.
+.TP
+.BI "--mode " "tunnel|transport"
+Matches the encapsulation mode.
+.TP
+.BI "--tunnel-src " "addr[/mask]"
+Matches the source end-point address of a tunnel mode SA.
+Only valid with --mode tunnel.
+.TP
+.BI "--tunnel-dst " "addr[/mask]"
+Matches the destination end-point address of a tunnel mode SA.
+Only valid with --mode tunnel.
+.TP
+.BI "--next"
+Start the next element in the policy specification. Can only be used with
+--strict
diff -urN iptables-1.3.4/extensions/libip6t_rt.man iptables-1.3.5/extensions/libip6t_rt.man
--- iptables-1.3.4/extensions/libip6t_rt.man	2004-10-10 11:56:24.000000000 +0200
+++ iptables-1.3.5/extensions/libip6t_rt.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,19 +1,19 @@
 Match on IPv6 routing header
 .TP
-.BI "--rt-type " "[!]" "type"
+.BR "--rt-type" " [!] \fItype\fP"
 Match the type (numeric).
 .TP
-.BI "--rt-segsleft" "[!]" "num[:num]"
+.BR "--rt-segsleft" " [!] \fInum\fP[:\fInum\fP]"
 Match the `segments left' field (range).
 .TP
-.BI "--rt-len" "[!]" "length"
-Match the length of this header
+.BR "--rt-len" " [!] \fIlength\fP"
+Match the length of this header.
 .TP
-.BI "--rt-0-res"
+.BR "--rt-0-res"
 Match the reserved field, too (type=0)
 .TP
-.BI "--rt-0-addrs ADDR[,ADDR...]
+.BR "--rt-0-addrs" " \fIADDR\fP[,\fIADDR\fP...]"
 Match type=0 addresses (list).
 .TP
-.BI "--rt-0-not-strict"
+.BR "--rt-0-not-strict"
 List of type=0 addresses is not a strict list.
diff -urN iptables-1.3.4/extensions/libip6t_state.c iptables-1.3.5/extensions/libip6t_state.c
--- iptables-1.3.4/extensions/libip6t_state.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.5/extensions/libip6t_state.c	2006-01-30 09:40:05.000000000 +0100
@@ -0,0 +1,163 @@
+/* Ugly hack to make state matching for ipv6 work before iptables-1.4.x is finished */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ip6tables.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ipt_state.h>
+
+#ifndef IPT_STATE_UNTRACKED
+#define IPT_STATE_UNTRACKED (1 << (IP_CT_NUMBER + 1))
+#endif
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"state v%s options:\n"
+" [!] --state [INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED][,...]\n"
+"				State(s) to match\n"
+"\n", IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "state", 1, 0, '1' },
+	{0}
+};
+
+static int
+parse_state(const char *state, size_t strlen, struct ipt_state_info *sinfo)
+{
+	if (strncasecmp(state, "INVALID", strlen) == 0)
+		sinfo->statemask |= IPT_STATE_INVALID;
+	else if (strncasecmp(state, "NEW", strlen) == 0)
+		sinfo->statemask |= IPT_STATE_BIT(IP_CT_NEW);
+	else if (strncasecmp(state, "ESTABLISHED", strlen) == 0)
+		sinfo->statemask |= IPT_STATE_BIT(IP_CT_ESTABLISHED);
+	else if (strncasecmp(state, "RELATED", strlen) == 0)
+		sinfo->statemask |= IPT_STATE_BIT(IP_CT_RELATED);
+	else if (strncasecmp(state, "UNTRACKED", strlen) == 0)
+		sinfo->statemask |= IPT_STATE_UNTRACKED;
+	else
+		return 0;
+	return 1;
+}
+
+static void
+parse_states(const char *arg, struct ipt_state_info *sinfo)
+{
+	const char *comma;
+
+	while ((comma = strchr(arg, ',')) != NULL) {
+		if (comma == arg || !parse_state(arg, comma-arg, sinfo))
+			exit_error(PARAMETER_PROBLEM, "Bad state `%s'", arg);
+		arg = comma+1;
+	}
+
+	if (strlen(arg) == 0 || !parse_state(arg, strlen(arg), sinfo))
+		exit_error(PARAMETER_PROBLEM, "Bad state `%s'", arg);
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct ipt_state_info *sinfo = (struct ipt_state_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		check_inverse(optarg, &invert, &optind, 0);
+
+		parse_states(argv[optind-1], sinfo);
+		if (invert)
+			sinfo->statemask = ~sinfo->statemask;
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; must have specified --state. */
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM, "You must specify `--state'");
+}
+
+static void print_state(unsigned int statemask)
+{
+	const char *sep = "";
+
+	if (statemask & IPT_STATE_INVALID) {
+		printf("%sINVALID", sep);
+		sep = ",";
+	}
+	if (statemask & IPT_STATE_BIT(IP_CT_NEW)) {
+		printf("%sNEW", sep);
+		sep = ",";
+	}
+	if (statemask & IPT_STATE_BIT(IP_CT_RELATED)) {
+		printf("%sRELATED", sep);
+		sep = ",";
+	}
+	if (statemask & IPT_STATE_BIT(IP_CT_ESTABLISHED)) {
+		printf("%sESTABLISHED", sep);
+		sep = ",";
+	}
+	if (statemask & IPT_STATE_UNTRACKED) {
+		printf("%sUNTRACKED", sep);
+		sep = ",";
+	}
+	printf(" ");
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	struct ipt_state_info *sinfo = (struct ipt_state_info *)match->data;
+
+	printf("state ");
+	print_state(sinfo->statemask);
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+	struct ipt_state_info *sinfo = (struct ipt_state_info *)match->data;
+
+	printf("--state ");
+	print_state(sinfo->statemask);
+}
+
+static struct ip6tables_match state = { 
+	.next		= NULL,
+	.name		= "state",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ipt_state_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ipt_state_info)),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match6(&state);
+}
diff -urN iptables-1.3.4/extensions/libipt_CLASSIFY.c iptables-1.3.5/extensions/libipt_CLASSIFY.c
--- iptables-1.3.4/extensions/libipt_CLASSIFY.c	2005-01-04 11:38:34.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_CLASSIFY.c	2006-01-30 09:43:10.000000000 +0100
@@ -32,7 +32,7 @@
 {
 }
 
-int string_to_priority(const unsigned char *s, unsigned int *p)
+int string_to_priority(const char *s, unsigned int *p)
 {
 	unsigned int i, j;
 
diff -urN iptables-1.3.4/extensions/libipt_CLUSTERIP.c iptables-1.3.5/extensions/libipt_CLUSTERIP.c
--- iptables-1.3.4/extensions/libipt_CLUSTERIP.c	2005-10-31 20:03:50.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_CLUSTERIP.c	2006-01-30 09:43:11.000000000 +0100
@@ -120,7 +120,7 @@
 			exit_error(PARAMETER_PROBLEM, "Can only specify MAC combined with `--new'\n");
 		if (*flags & PARAM_MAC)
 			exit_error(PARAMETER_PROBLEM, "Can only specify MAC once\n");
-		parse_mac(optarg, cipinfo->clustermac);
+		parse_mac(optarg, (char *)cipinfo->clustermac);
 		if (!(cipinfo->clustermac[0] & 0x01))
 			exit_error(PARAMETER_PROBLEM, "MAC has to be a multicast ethernet address\n");
 		*flags |= PARAM_MAC;
@@ -169,7 +169,7 @@
 	if (flags == 0)
 		return;
 
-	if (flags & (PARAM_NEW|PARAM_HMODE|PARAM_MAC|PARAM_TOTALNODE|PARAM_LOCALNODE)
+	if ((flags & (PARAM_NEW|PARAM_HMODE|PARAM_MAC|PARAM_TOTALNODE|PARAM_LOCALNODE))
 		== (PARAM_NEW|PARAM_HMODE|PARAM_MAC|PARAM_TOTALNODE|PARAM_LOCALNODE))
 		return;
 
diff -urN iptables-1.3.4/extensions/libipt_DNAT.man iptables-1.3.5/extensions/libipt_DNAT.man
--- iptables-1.3.4/extensions/libipt_DNAT.man	2005-10-31 20:03:50.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_DNAT.man	2006-01-22 16:54:15.000000000 +0100
@@ -24,7 +24,7 @@
 In Kernels up to 2.6.10 you can add several --to-destination options.  For
 those kernels, if you specify more than one destination address, either via an
 address range or multiple --to-destination options, a simple round-robin (one
-after another in cycle) load balancing takes place between these adresses.
+after another in cycle) load balancing takes place between these addresses.
 Later Kernels (>= 2.6.11-rc1) don't have the ability to NAT to multiple ranges
 anymore.
 
diff -urN iptables-1.3.4/extensions/libipt_POOL.c iptables-1.3.5/extensions/libipt_POOL.c
--- iptables-1.3.4/extensions/libipt_POOL.c	2005-02-19 20:19:17.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_POOL.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,152 +0,0 @@
-/* Shared library add-on to iptables to add IP pool mangling target. */
-#include <stdio.h>
-#include <netdb.h>
-#include <string.h>
-#include <stdlib.h>
-#include <getopt.h>
-#include <ctype.h>
-
-#include <iptables.h>
-#include <linux/netfilter_ipv4/ip_tables.h>
-#include <linux/netfilter_ipv4/ip_nat_rule.h>
-#include <linux/netfilter_ipv4/ip_pool.h>
-#include <linux/netfilter_ipv4/ipt_pool.h>
-
-#include <libippool/ip_pool_support.h>
-
-/* FIXME --RR */
-#define ip_pool_init           ip_POOL_init
-#define ip_pool_get_index      ip_POOL_get_index
-#define ip_pool_get_name       ip_POOL_get_name
-#include "../ippool/libippool.c"
-
-/* Function which prints out usage message. */
-static void
-help(void)
-{
-	printf(
-"POOL v%s options:\n"
-" --add-srcip <pool>\n"
-" --del-srcip <pool>\n"
-" --add-dstip <pool>\n"
-" --del-dstip <pool>\n"
-"				add/del src/dst IP from pool.\n\n",
-IPTABLES_VERSION);
-}
-
-static struct option opts[] = {
-	{ "add-srcip", 1, 0, '1' },
-	{ "del-srcip", 1, 0, '2' },
-	{ "add-dstip", 1, 0, '3' },
-	{ "del-dstip", 1, 0, '4' },
-	{ 0 }
-};
-
-/* Initialize the target. */
-static void
-init(struct ipt_entry_target *target, unsigned int *nfcache)
-{
-	struct ipt_pool_info *ipi = (struct ipt_pool_info *) target->data;
-
-	ipi->src = ipi->dst = IP_POOL_NONE;
-	ipi->flags = 0;
-
-}
-
-/* Function which parses command options; returns true if it
-   ate an option */
-static int
-parse(int c, char **argv, int invert, unsigned int *flags,
-      const struct ipt_entry *entry,
-      struct ipt_entry_target **target)
-{
-	struct ipt_pool_info *ipi = (struct ipt_pool_info *) (*target)->data;
-	switch (c) {
-	case '1':	/* --add-srcip <pool> */
-		ipi->src = ip_pool_get_index(optarg);
-		ipi->flags &= ~IPT_POOL_DEL_SRC;
-		break;
-	case '2':	/* --del-srcip <pool> */
-		ipi->src = ip_pool_get_index(optarg);
-		ipi->flags |= IPT_POOL_DEL_SRC;
-		break;
-	case '3':	/* --add-dstip <pool> */
-		ipi->dst = ip_pool_get_index(optarg);
-		ipi->flags &= ~IPT_POOL_DEL_DST;
-		break;
-	case '4':	/* --del-dstip <pool> */
-		ipi->dst = ip_pool_get_index(optarg);
-		ipi->flags |= IPT_POOL_DEL_DST;
-		break;
-	default:
-		return 0;
-	}
-	return 1;
-}
-
-/* Final check; don't care. */
-static void final_check(unsigned int flags)
-{
-}
-
-/* Prints out the targinfo. */
-static void
-print(const struct ipt_ip *ip,
-      const struct ipt_entry_target *target,
-      int numeric)
-{
-	char buf[256];
-	struct ipt_pool_info *ipi = (struct ipt_pool_info *) target->data;
-
-	printf("POOL");
-	if (ipi->src != IP_POOL_NONE) {
-		printf(" --%s-srcip %s",
-			(ipi->flags & IPT_POOL_DEL_SRC) ? "del" : "add",
-			ip_pool_get_name(buf, sizeof(buf), ipi->src, numeric));
-	}
-	if (ipi->dst != IP_POOL_NONE) {
-		printf(" --%s-dstip %s",
-			(ipi->flags & IPT_POOL_DEL_DST) ? "del" : "add",
-			ip_pool_get_name(buf, sizeof(buf), ipi->dst, numeric));
-	}
-}
-
-/* Saves the union ipt_targinfo in parsable form to stdout. */
-static void
-save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
-{
-	char buf[256];
-	struct ipt_pool_info *ipi = (struct ipt_pool_info *) target->data;
-
-	printf("-j POOL");
-	if (ipi->src != IP_POOL_NONE) {
-		printf(" --%s-srcip %s",
-			(ipi->flags & IPT_POOL_DEL_SRC) ? "del" : "add",
-			ip_pool_get_name(buf, sizeof(buf), ipi->src, 0));
-	}
-	if (ipi->dst != IP_POOL_NONE) {
-		printf(" --%s-dstip %s",
-			(ipi->flags & IPT_POOL_DEL_DST) ? "del" : "add",
-			ip_pool_get_name(buf, sizeof(buf), ipi->dst, 0));
-	}
-}
-
-static struct iptables_target ipt_pool_target = { 
-	.next		= NULL,
-	.name		= "POOL",
-	.version	= IPTABLES_VERSION,
-	.size		= IPT_ALIGN(sizeof(struct ipt_pool_info)),
-	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_pool_info)),
-	.help		= &help,
-	.init		= &init,
-	.parse		= &parse,
-	.final_check	= &final_check,
-	.print		= &print,
-	.save		= &save,
-	.extra_opts	= opts
-};
-
-void _init(void)
-{
-	register_target(&ipt_pool_target);
-}
diff -urN iptables-1.3.4/extensions/libipt_REJECT.c iptables-1.3.5/extensions/libipt_REJECT.c
--- iptables-1.3.4/extensions/libipt_REJECT.c	2005-04-15 11:34:17.000000000 +0200
+++ iptables-1.3.5/extensions/libipt_REJECT.c	2006-01-30 09:43:12.000000000 +0100
@@ -44,7 +44,7 @@
 	 IPT_ICMP_NET_PROHIBITED, "ICMP network prohibited"},
 	{"icmp-host-prohibited", "host-prohib",
 	 IPT_ICMP_HOST_PROHIBITED, "ICMP host prohibited"},
-	{"tcp-reset", "tcp-reset",
+	{"tcp-reset", "tcp-rst",
 	 IPT_TCP_RESET, "TCP RST packet"},
 	{"icmp-admin-prohibited", "admin-prohib",
 	 IPT_ICMP_ADMIN_PROHIBITED, "ICMP administratively prohibited (*)"}
diff -urN iptables-1.3.4/extensions/libipt_SNAT.man iptables-1.3.5/extensions/libipt_SNAT.man
--- iptables-1.3.4/extensions/libipt_SNAT.man	2005-10-31 20:03:50.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_SNAT.man	2006-01-22 16:54:22.000000000 +0100
@@ -23,6 +23,6 @@
 In Kernels up to 2.6.10, you can add several --to-source options.  For those
 kernels, if you specify more than one source address, either via an address
 range or multiple --to-source options, a simple round-robin (one after another
-in cycle) takes place between these adresses.
+in cycle) takes place between these addresses.
 Later Kernels (>= 2.6.11-rc1) don't have the ability to NAT to multiple ranges
 anymore.
diff -urN iptables-1.3.4/extensions/libipt_TCPMSS.man iptables-1.3.5/extensions/libipt_TCPMSS.man
--- iptables-1.3.4/extensions/libipt_TCPMSS.man	2004-10-10 11:56:26.000000000 +0200
+++ iptables-1.3.5/extensions/libipt_TCPMSS.man	2005-12-10 19:58:16.000000000 +0100
@@ -3,6 +3,9 @@
 outgoing interface's MTU minus 40).  Of course, it can only be used
 in conjunction with
 .BR "-p tcp" .
+It is only valid in the
+.BR mangle
+table.
 .br
 This target is used to overcome criminally braindead ISPs or servers
 which block ICMP Fragmentation Needed packets.  The symptoms of this
@@ -25,7 +28,7 @@
 Workaround: activate this option and add a rule to your firewall
 configuration like:
 .nf
- iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN \\
+ iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN \\
              -j TCPMSS --clamp-mss-to-pmtu
 .fi
 .TP
diff -urN iptables-1.3.4/extensions/libipt_ah.man iptables-1.3.5/extensions/libipt_ah.man
--- iptables-1.3.4/extensions/libipt_ah.man	2004-10-10 11:56:24.000000000 +0200
+++ iptables-1.3.5/extensions/libipt_ah.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,3 +1,3 @@
-This module matches the SPIs in AH header of IPSec packets.
+This module matches the SPIs in Authentication header of IPsec packets.
 .TP
 .BR "--ahspi " "[!] \fIspi\fP[:\fIspi\fP]"
diff -urN iptables-1.3.4/extensions/libipt_condition.man iptables-1.3.5/extensions/libipt_condition.man
--- iptables-1.3.4/extensions/libipt_condition.man	2004-10-10 11:56:26.000000000 +0200
+++ iptables-1.3.5/extensions/libipt_condition.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,4 +1,4 @@
 This matches if a specific /proc filename is '0' or '1'.
 .TP
-.BI "--condition " "[!] filename"
+.BI "--condition " "[!] \fIfilename\fP"
 Match on boolean value stored in /proc/net/ipt_condition/filename file
diff -urN iptables-1.3.4/extensions/libipt_connbytes.c iptables-1.3.5/extensions/libipt_connbytes.c
--- iptables-1.3.4/extensions/libipt_connbytes.c	2005-10-31 20:03:50.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_connbytes.c	2006-01-30 09:43:11.000000000 +0100
@@ -105,7 +105,7 @@
 {
 	if (flags != 7)
 		exit_error(PARAMETER_PROBLEM, "You must specify `--connbytes'"
-			   "`--connbytes-direction' and `--connbytes-mode'");
+			   "`--connbytes-dir' and `--connbytes-mode'");
 }
 
 static void print_mode(struct ipt_connbytes_info *sinfo)
@@ -181,7 +181,7 @@
 	fputs("--connbytes-mode ", stdout);
 	print_mode(sinfo);
 
-	fputs("--connbytes-direction ", stdout);
+	fputs("--connbytes-dir ", stdout);
 	print_direction(sinfo);
 }
 
diff -urN iptables-1.3.4/extensions/libipt_conntrack.c iptables-1.3.5/extensions/libipt_conntrack.c
--- iptables-1.3.4/extensions/libipt_conntrack.c	2005-10-31 20:03:50.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_conntrack.c	2006-01-30 09:43:10.000000000 +0100
@@ -442,6 +442,13 @@
 		print_state(sinfo->statemask);
 	}
 
+	if(sinfo->flags & IPT_CONNTRACK_PROTO) {
+		printf("%sctproto ", optpfx);
+        	if (sinfo->invflags & IPT_CONNTRACK_PROTO)
+                	printf("! ");
+		printf("%u ", sinfo->tuple[IP_CT_DIR_ORIGINAL].dst.protonum);
+	}
+
 	if(sinfo->flags & IPT_CONNTRACK_ORIGSRC) {
 		printf("%sctorigsrc ", optpfx);
 
diff -urN iptables-1.3.4/extensions/libipt_dstlimit.man iptables-1.3.5/extensions/libipt_dstlimit.man
--- iptables-1.3.4/extensions/libipt_dstlimit.man	2004-10-10 11:56:25.000000000 +0200
+++ iptables-1.3.5/extensions/libipt_dstlimit.man	2006-01-30 09:40:06.000000000 +0100
@@ -2,6 +2,8 @@
 destination IP or per destination port base.  As opposed to the `limit' match,
 every destination ip / destination port has it's own limit.
 .TP
+THIS MODULE IS DEPRECATED AND HAS BEEN REPLACED BY ``hashlimit''
+.TP
 .BI "--dstlimit " "avg"
 Maximum average match rate (packets per second unless followed by /sec /minute /hour /day postfixes).
 .TP
diff -urN iptables-1.3.4/extensions/libipt_esp.man iptables-1.3.5/extensions/libipt_esp.man
--- iptables-1.3.4/extensions/libipt_esp.man	2004-10-10 11:56:27.000000000 +0200
+++ iptables-1.3.5/extensions/libipt_esp.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,3 +1,3 @@
-This module matches the SPIs in ESP header of IPSec packets.
+This module matches the SPIs in ESP header of IPsec packets.
 .TP
 .BR "--espspi " "[!] \fIspi\fP[:\fIspi\fP]"
diff -urN iptables-1.3.4/extensions/libipt_fuzzy.man iptables-1.3.5/extensions/libipt_fuzzy.man
--- iptables-1.3.4/extensions/libipt_fuzzy.man	2004-10-10 11:56:26.000000000 +0200
+++ iptables-1.3.5/extensions/libipt_fuzzy.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,6 +1,6 @@
 This module matches a rate limit based on a fuzzy logic controller [FLC]
 .TP
-.BI "--lower-limit  "number"
+.BI "--lower-limit " "number"
 Specifies the lower limit (in packets per second).
 .TP
 .BI "--upper-limit " "number"
diff -urN iptables-1.3.4/extensions/libipt_length.man iptables-1.3.5/extensions/libipt_length.man
--- iptables-1.3.4/extensions/libipt_length.man	2004-10-10 11:56:24.000000000 +0200
+++ iptables-1.3.5/extensions/libipt_length.man	2006-01-30 09:41:00.000000000 +0100
@@ -1,4 +1,4 @@
 This module matches the length of a packet against a specific value
 or range of values.
 .TP
-.BR "--length " "\fIlength\fP[:\fIlength\fP]"
+.BR "--length " "[!] \fIlength\fP[:\fIlength\fP]"
diff -urN iptables-1.3.4/extensions/libipt_mark.man iptables-1.3.5/extensions/libipt_mark.man
--- iptables-1.3.4/extensions/libipt_mark.man	2004-10-10 11:56:27.000000000 +0200
+++ iptables-1.3.5/extensions/libipt_mark.man	2006-01-30 09:41:00.000000000 +0100
@@ -4,6 +4,6 @@
 target below).
 .TP
 .BR "--mark " "\fIvalue\fP[/\fImask\fP]"
-Matches packets with the given unsigned mark value (if a mask is
-specified, this is logically ANDed with the mask before the
+Matches packets with the given unsigned mark value (if a \fImask\fP is
+specified, this is logically ANDed with the \fImask\fP before the
 comparison).
diff -urN iptables-1.3.4/extensions/libipt_physdev.man iptables-1.3.5/extensions/libipt_physdev.man
--- iptables-1.3.4/extensions/libipt_physdev.man	2004-10-10 11:56:25.000000000 +0200
+++ iptables-1.3.5/extensions/libipt_physdev.man	2006-01-30 09:41:00.000000000 +0100
@@ -3,7 +3,7 @@
 a transparent bridging IP firewall and is only useful for kernel versions
 above version 2.5.44.
 .TP
-.B --physdev-in name
+.BR --physdev-in " [!] \fIname\fP"
 Name of a bridge port via which a packet is received (only for
 packets entering the
 .BR INPUT ,
@@ -14,7 +14,7 @@
 interface which begins with this name will match. If the packet didn't arrive
 through a bridge device, this packet won't match this option, unless '!' is used.
 .TP
-.B --physdev-out name
+.BR --physdev-out " [!] \fIname\fP"
 Name of a bridge port via which a packet is going to be sent (for packets
 entering the
 .BR FORWARD ,
@@ -31,12 +31,12 @@
 the output device will be, then the packet won't match this option, unless
 '!' is used.
 .TP
-.B --physdev-is-in
+.RB "[!] " --physdev-is-in
 Matches if the packet has entered through a bridge interface.
 .TP
-.B --physdev-is-out
+.RB "[!] " --physdev-is-out
 Matches if the packet will leave through a bridge interface.
 .TP
-.B --physdev-is-bridged
+.RB "[!] " --physdev-is-bridged
 Matches if the packet is being bridged and therefore is not being routed.
 This is only useful in the FORWARD and POSTROUTING chains.
diff -urN iptables-1.3.4/extensions/libipt_policy.c iptables-1.3.5/extensions/libipt_policy.c
--- iptables-1.3.4/extensions/libipt_policy.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_policy.c	2006-02-01 13:53:59.000000000 +0100
@@ -0,0 +1,436 @@
+/* Shared library add-on to iptables to add policy support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <netdb.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <iptables.h>
+
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include "../include/linux/netfilter_ipv4/ipt_policy.h"
+
+/*
+ * HACK: global pointer to current matchinfo for making
+ * final checks and adjustments in final_check.
+ */
+static struct ipt_policy_info *policy_info;
+
+static void help(void)
+{
+	printf(
+"policy v%s options:\n"
+"  --dir in|out			match policy applied during decapsulation/\n"
+"				policy to be applied during encapsulation\n"
+"  --pol none|ipsec		match policy\n"
+"  --strict 			match entire policy instead of single element\n"
+"				at any position\n"
+"[!] --reqid reqid		match reqid\n"
+"[!] --spi spi			match SPI\n"
+"[!] --proto proto		match protocol (ah/esp/ipcomp)\n"
+"[!] --mode mode 		match mode (transport/tunnel)\n"
+"[!] --tunnel-src addr/mask	match tunnel source\n"
+"[!] --tunnel-dst addr/mask	match tunnel destination\n"
+"  --next 			begin next element in policy\n",
+	IPTABLES_VERSION);
+}
+
+static struct option opts[] =
+{
+	{
+		.name		= "dir",
+		.has_arg	= 1,
+		.val		= '1',
+	},
+	{
+		.name		= "pol",
+		.has_arg	= 1,
+		.val		= '2',
+	},
+	{
+		.name		= "strict",
+		.val		= '3'
+	},
+	{
+		.name		= "reqid",
+		.has_arg	= 1,
+		.val		= '4',
+	},
+	{
+		.name		= "spi",
+		.has_arg	= 1,
+		.val		= '5'
+	},
+	{
+		.name		= "tunnel-src",
+		.has_arg	= 1,
+		.val		= '6'
+	},
+	{
+		.name		= "tunnel-dst",
+		.has_arg	= 1,
+		.val		= '7'
+	},
+	{
+		.name		= "proto",
+		.has_arg	= 1,
+		.val		= '8'
+	},
+	{
+		.name		= "mode",
+		.has_arg	= 1,
+		.val		= '9'
+	},
+	{
+		.name		= "next",
+		.val		= 'a'
+	},
+	{ }
+};
+
+static void init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static int parse_direction(char *s)
+{
+	if (strcmp(s, "in") == 0)
+		return IPT_POLICY_MATCH_IN;
+	if (strcmp(s, "out") == 0)
+		return IPT_POLICY_MATCH_OUT;
+	exit_error(PARAMETER_PROBLEM, "policy_match: invalid dir `%s'", s);
+}
+
+static int parse_policy(char *s)
+{
+	if (strcmp(s, "none") == 0)
+		return IPT_POLICY_MATCH_NONE;
+	if (strcmp(s, "ipsec") == 0)
+		return 0;
+	exit_error(PARAMETER_PROBLEM, "policy match: invalid policy `%s'", s);
+}
+
+static int parse_mode(char *s)
+{
+	if (strcmp(s, "transport") == 0)
+		return IPT_POLICY_MODE_TRANSPORT;
+	if (strcmp(s, "tunnel") == 0)
+		return IPT_POLICY_MODE_TUNNEL;
+	exit_error(PARAMETER_PROBLEM, "policy match: invalid mode `%s'", s);
+}
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+                 const struct ipt_entry *entry,
+                 unsigned int *nfcache,
+                 struct ipt_entry_match **match)
+{
+	struct ipt_policy_info *info = (void *)(*match)->data;
+	struct ipt_policy_elem *e = &info->pol[info->len];
+	struct in_addr *addr = NULL, mask;
+	unsigned int naddr = 0;
+	int mode;
+
+	check_inverse(optarg, &invert, &optind, 0);
+
+	switch (c) {
+	case '1':
+		if (info->flags & (IPT_POLICY_MATCH_IN|IPT_POLICY_MATCH_OUT))
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --dir option");
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: can't invert --dir option");
+
+		info->flags |= parse_direction(argv[optind-1]);
+		break;
+	case '2':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: can't invert --policy option");
+
+		info->flags |= parse_policy(argv[optind-1]);
+		break;
+	case '3':
+		if (info->flags & IPT_POLICY_MATCH_STRICT)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --strict option");
+
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: can't invert --strict option");
+
+		info->flags |= IPT_POLICY_MATCH_STRICT;
+		break;
+	case '4':
+		if (e->match.reqid)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --reqid option");
+
+		e->match.reqid = 1;
+		e->invert.reqid = invert;
+		e->reqid = strtol(argv[optind-1], NULL, 10);
+		break;
+	case '5':
+		if (e->match.spi)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --spi option");
+
+		e->match.spi = 1;
+		e->invert.spi = invert;
+		e->spi = strtol(argv[optind-1], NULL, 0x10);
+		break;
+	case '6':
+		if (e->match.saddr)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --tunnel-src option");
+
+		parse_hostnetworkmask(argv[optind-1], &addr, &mask, &naddr);
+		if (naddr > 1)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: name resolves to multiple IPs");
+
+		e->match.saddr = 1;
+		e->invert.saddr = invert;
+		e->saddr.a4 = addr[0];
+		e->smask.a4 = mask;
+                break;
+	case '7':
+		if (e->match.daddr)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --tunnel-dst option");
+
+		parse_hostnetworkmask(argv[optind-1], &addr, &mask, &naddr);
+		if (naddr > 1)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: name resolves to multiple IPs");
+
+		e->match.daddr = 1;
+		e->invert.daddr = invert;
+		e->daddr.a4 = addr[0];
+		e->dmask.a4 = mask;
+		break;
+	case '8':
+		if (e->match.proto)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --proto option");
+
+		e->proto = parse_protocol(argv[optind-1]);
+		if (e->proto != IPPROTO_AH && e->proto != IPPROTO_ESP &&
+		    e->proto != IPPROTO_COMP)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: protocol must ah/esp/ipcomp");
+		e->match.proto = 1;
+		e->invert.proto = invert;
+		break;
+	case '9':
+		if (e->match.mode)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: double --mode option");
+
+		mode = parse_mode(argv[optind-1]);
+		e->match.mode = 1;
+		e->invert.mode = invert;
+		e->mode = mode;
+		break;
+	case 'a':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: can't invert --next option");
+
+		if (++info->len == IPT_POLICY_MAX_ELEM)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: maximum policy depth reached");
+		break;
+	default:
+		return 0;
+	}
+
+	policy_info = info;
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	struct ipt_policy_info *info = policy_info;
+	struct ipt_policy_elem *e;
+	int i;
+
+	if (info == NULL)
+		exit_error(PARAMETER_PROBLEM,
+		           "policy match: no parameters given");
+
+	if (!(info->flags & (IPT_POLICY_MATCH_IN|IPT_POLICY_MATCH_OUT)))
+		exit_error(PARAMETER_PROBLEM,
+		           "policy match: neither --in nor --out specified");
+
+	if (info->flags & IPT_POLICY_MATCH_NONE) {
+		if (info->flags & IPT_POLICY_MATCH_STRICT)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: policy none but --strict given");
+
+		if (info->len != 0)
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: policy none but policy given");
+	} else
+		info->len++;	/* increase len by 1, no --next after last element */
+
+	if (!(info->flags & IPT_POLICY_MATCH_STRICT) && info->len > 1)
+		exit_error(PARAMETER_PROBLEM,
+		           "policy match: multiple elements but no --strict");
+
+	for (i = 0; i < info->len; i++) {
+		e = &info->pol[i];
+
+		if (info->flags & IPT_POLICY_MATCH_STRICT &&
+		    !(e->match.reqid || e->match.spi || e->match.saddr ||
+		      e->match.daddr || e->match.proto || e->match.mode))
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: empty policy element");
+
+		if ((e->match.saddr || e->match.daddr)
+		    && ((e->mode == IPT_POLICY_MODE_TUNNEL && e->invert.mode) ||
+		        (e->mode == IPT_POLICY_MODE_TRANSPORT && !e->invert.mode)))
+			exit_error(PARAMETER_PROBLEM,
+			           "policy match: --tunnel-src/--tunnel-dst "
+			           "is only valid in tunnel mode");
+	}
+}
+
+static void print_mode(char *prefix, u_int8_t mode, int numeric)
+{
+	printf("%smode ", prefix);
+
+	switch (mode) {
+	case IPT_POLICY_MODE_TRANSPORT:
+		printf("transport ");
+		break;
+	case IPT_POLICY_MODE_TUNNEL:
+		printf("tunnel ");
+		break;
+	default:
+		printf("??? ");
+		break;
+	}
+}
+
+static void print_proto(char *prefix, u_int8_t proto, int numeric)
+{
+	struct protoent *p = NULL;
+
+	printf("%sproto ", prefix);
+	if (!numeric)
+		p = getprotobynumber(proto);
+	if (p != NULL)
+		printf("%s ", p->p_name);
+	else
+		printf("%u ", proto);
+}
+
+#define PRINT_INVERT(x)		\
+do {				\
+	if (x)			\
+		printf("! ");	\
+} while(0)
+
+static void print_entry(char *prefix, const struct ipt_policy_elem *e,
+                        int numeric)
+{
+	if (e->match.reqid) {
+		PRINT_INVERT(e->invert.reqid);
+		printf("%sreqid %u ", prefix, e->reqid);
+	}
+	if (e->match.spi) {
+		PRINT_INVERT(e->invert.spi);
+		printf("%sspi 0x%x ", prefix, e->spi);
+	}
+	if (e->match.proto) {
+		PRINT_INVERT(e->invert.proto);
+		print_proto(prefix, e->proto, numeric);
+	}
+	if (e->match.mode) {
+		PRINT_INVERT(e->invert.mode);
+		print_mode(prefix, e->mode, numeric);
+	}
+	if (e->match.daddr) {
+		PRINT_INVERT(e->invert.daddr);
+		printf("%stunnel-dst %s%s ", prefix,
+		       addr_to_dotted((struct in_addr *)&e->daddr),
+		       mask_to_dotted((struct in_addr *)&e->dmask));
+	}
+	if (e->match.saddr) {
+		PRINT_INVERT(e->invert.saddr);
+		printf("%stunnel-src %s%s ", prefix,
+		       addr_to_dotted((struct in_addr *)&e->saddr),
+		       mask_to_dotted((struct in_addr *)&e->smask));
+	}
+}
+
+static void print_flags(char *prefix, const struct ipt_policy_info *info)
+{
+	if (info->flags & IPT_POLICY_MATCH_IN)
+		printf("%sdir in ", prefix);
+	else
+		printf("%sdir out ", prefix);
+
+	if (info->flags & IPT_POLICY_MATCH_NONE)
+		printf("%spol none ", prefix);
+	else
+		printf("%spol ipsec ", prefix);
+
+	if (info->flags & IPT_POLICY_MATCH_STRICT)
+		printf("%sstrict ", prefix);
+}
+
+static void print(const struct ipt_ip *ip,
+                  const struct ipt_entry_match *match,
+		  int numeric)
+{
+	const struct ipt_policy_info *info = (void *)match->data;
+	unsigned int i;
+
+	printf("policy match ");
+	print_flags("", info);
+	for (i = 0; i < info->len; i++) {
+		if (info->len > 1)
+			printf("[%u] ", i);
+		print_entry("", &info->pol[i], numeric);
+	}
+}
+
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	const struct ipt_policy_info *info = (void *)match->data;
+	unsigned int i;
+
+	print_flags("--", info);
+	for (i = 0; i < info->len; i++) {
+		print_entry("--", &info->pol[i], 0);
+		if (i + 1 < info->len)
+			printf("--next ");
+	}
+}
+
+struct iptables_match policy = {
+	.name		= "policy",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_policy_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_policy_info)),
+	.help		= help,
+	.init		= init,
+	.parse		= parse,
+	.final_check	= final_check,
+	.print		= print,
+	.save		= save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&policy);
+}
diff -urN iptables-1.3.4/extensions/libipt_policy.man iptables-1.3.5/extensions/libipt_policy.man
--- iptables-1.3.4/extensions/libipt_policy.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_policy.man	2006-01-30 09:40:06.000000000 +0100
@@ -0,0 +1,48 @@
+This modules matches the policy used by IPsec for handling a packet.
+.TP
+.BI "--dir " "in|out"
+Used to select whether to match the policy used for decapsulation or the
+policy that will be used for encapsulation.
+.B in
+is valid in the
+.B PREROUTING, INPUT and FORWARD
+chains,
+.B out
+is valid in the
+.B POSTROUTING, OUTPUT and FORWARD
+chains.
+.TP
+.BI "--pol " "none|ipsec"
+Matches if the packet is subject to IPsec processing.
+.TP
+.BI "--strict"
+Selects whether to match the exact policy or match if any rule of
+the policy matches the given policy.
+.TP
+.BI "--reqid " "id"
+Matches the reqid of the policy rule. The reqid can be specified with
+.B setkey(8)
+using
+.B unique:id
+as level.
+.TP
+.BI "--spi " "spi"
+Matches the SPI of the SA.
+.TP
+.BI "--proto " "ah|esp|ipcomp"
+Matches the encapsulation protocol.
+.TP
+.BI "--mode " "tunnel|transport"
+Matches the encapsulation mode.
+.TP
+.BI "--tunnel-src " "addr[/mask]"
+Matches the source end-point address of a tunnel mode SA.
+Only valid with --mode tunnel.
+.TP
+.BI "--tunnel-dst " "addr[/mask]"
+Matches the destination end-point address of a tunnel mode SA.
+Only valid with --mode tunnel.
+.TP
+.BI "--next"
+Start the next element in the policy specification. Can only be used with
+--strict
diff -urN iptables-1.3.4/extensions/libipt_pool.c iptables-1.3.5/extensions/libipt_pool.c
--- iptables-1.3.4/extensions/libipt_pool.c	2005-02-19 20:19:17.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_pool.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-/* Shared library add-on to iptables to add IP address pool matching. */
-#include <stdio.h>
-#include <netdb.h>
-#include <string.h>
-#include <stdlib.h>
-#include <getopt.h>
-#include <ctype.h>
-
-#include <iptables.h>
-#include <linux/netfilter_ipv4/ip_conntrack.h>
-#include <linux/netfilter_ipv4/ipt_pool.h>
-
-#include <libippool/ip_pool_support.h>
-
-/* FIXME --RR */
-#include "../ippool/libippool.c"
-
-/* Function which prints out usage message. */
-static void
-help(void)
-{
-	printf(
-"pool v%s options:\n"
-" [!] --srcpool NAME|INDEX\n"
-" [!] --dstpool NAME|INDEX\n"
-"			Pool index (or name from %s) to match\n"
-"\n", IPTABLES_VERSION, IPPOOL_CONF);
-}
-
-static struct option opts[] = {
-	{ "srcpool", 1, 0, '1' },
-	{ "dstpool", 1, 0, '2' },
-	{0}
-};
-
-/* Initialize the match. */
-static void
-init(struct ipt_entry_match *match, unsigned int *nfcache)
-{
-	struct ipt_pool_info *info =
-		(struct ipt_pool_info *)match->data;
-
-	info->src = IP_POOL_NONE;
-	info->dst = IP_POOL_NONE;
-	info->flags = 0;
-}
-
-/* Function which parses command options; returns true if it ate an option */
-static int
-parse(int c, char **argv, int invert, unsigned int *flags,
-      const struct ipt_entry *entry,
-      unsigned int *nfcache,
-      struct ipt_entry_match **match)
-{
-	struct ipt_pool_info *info =
-		(struct ipt_pool_info *)(*match)->data;
-
-	switch (c) {
-	case '1':
-		check_inverse(optarg, &invert, &optind, 0);
-		info->src = ip_pool_get_index(argv[optind-1]);
-		if (invert) info->flags |= IPT_POOL_INV_SRC;
-		*flags = 1;
-		break;
-	case '2':
-		check_inverse(optarg, &invert, &optind, 0);
-		info->dst = ip_pool_get_index(argv[optind-1]);
-		if (invert) info->flags |= IPT_POOL_INV_DST;
-		*flags = 1;
-		break;
-
-	default:
-		return 0;
-	}
-
-	return 1;
-}
-
-/* Final check; must have specified --srcpool or --dstpool. */
-static void final_check(unsigned int flags)
-{
-	if (!flags)
-		exit_error(PARAMETER_PROBLEM, "You must specify either `--srcpool or --dstpool'");
-}
-
-/* Prints out the matchinfo. */
-static void
-print(const struct ipt_ip *ip,
-      const struct ipt_entry_match *match,
-      int numeric)
-{
-	char buf[256];
-	struct ipt_pool_info *info =
-		(struct ipt_pool_info *)match->data;
-
-	if (info->src != IP_POOL_NONE)
-		printf("%ssrcpool %s ",
-			(info->flags & IPT_POOL_INV_SRC) ? "!" : "",
-			ip_pool_get_name(buf, sizeof(buf), info->src, 0));
-	if (info->dst != IP_POOL_NONE)
-		printf("%sdstpool %s ",
-			(info->flags & IPT_POOL_INV_DST) ? "!" : "",
-			ip_pool_get_name(buf, sizeof(buf), info->dst, 0));
-}
-
-/* Saves the matchinfo in parsable form to stdout. */
-static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
-{
-	char buf[256];
-	struct ipt_pool_info *info =
-		(struct ipt_pool_info *)match->data;
-
-	if (info->src != IP_POOL_NONE)
-		printf("%s--srcpool %s ",
-			(info->flags & IPT_POOL_INV_SRC) ? "! " : "",
-			ip_pool_get_name(buf, sizeof(buf), info->src, 0));
-	if (info->dst != IP_POOL_NONE)
-		printf("%s--dstpool %s ",
-			(info->flags & IPT_POOL_INV_DST) ? "! " : "",
-			ip_pool_get_name(buf, sizeof(buf), info->dst, 0));
-}
-
-static struct iptables_match pool = { 
-	.next		= NULL,
-	.name		= "pool",
-	.version	= IPTABLES_VERSION,
-	.size		= IPT_ALIGN(sizeof(struct ipt_pool_info)),
-	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_pool_info)),
-	.help		= &help,
-	.init		= &init,
-	.parse		= &parse,
-	.final_check	= &final_check,
-	.print		= &print,
-	.save		= &save,
-	.extra_opts	= opts
-};
-
-void _init(void)
-{
-	register_match(&pool);
-}
diff -urN iptables-1.3.4/extensions/libipt_sctp.c iptables-1.3.5/extensions/libipt_sctp.c
--- iptables-1.3.4/extensions/libipt_sctp.c	2005-02-19 20:19:17.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_sctp.c	2006-02-01 13:44:26.000000000 +0100
@@ -16,8 +16,21 @@
 
 #include <iptables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#endif
+
 #include <linux/netfilter_ipv4/ipt_sctp.h>
 
+/* Some ZS!#@:$%*#$! has replaced the ELEMCOUNT macro in ipt_sctp.h with
+ * ARRAY_SIZE without noticing that this file is used from userserspace,
+ * and userspace doesn't have ARRAY_SIZE */
+
+#ifndef ELEMCOUNT
+#define ELEMCOUNT ARRAY_SIZE
+#endif
+
 #if 0
 #define DEBUGP(format, first...) printf(format, ##first)
 #define static
diff -urN iptables-1.3.4/extensions/libipt_string.c iptables-1.3.5/extensions/libipt_string.c
--- iptables-1.3.4/extensions/libipt_string.c	2005-10-31 20:03:50.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_string.c	2006-01-30 09:54:02.000000000 +0100
@@ -63,7 +63,7 @@
 }
 
 static void
-parse_string(const unsigned char *s, struct ipt_string_info *info)
+parse_string(const char *s, struct ipt_string_info *info)
 {	
 	if (strlen(s) <= IPT_STRING_MAX_PATTERN_SIZE) {
 		strncpy(info->pattern, s, IPT_STRING_MAX_PATTERN_SIZE);
@@ -74,7 +74,7 @@
 }
 
 static void
-parse_algo(const unsigned char *s, struct ipt_string_info *info)
+parse_algo(const char *s, struct ipt_string_info *info)
 {
 	if (strlen(s) <= IPT_STRING_MAX_ALGO_NAME_SIZE) {
 		strncpy(info->algo, s, IPT_STRING_MAX_ALGO_NAME_SIZE);
@@ -84,7 +84,7 @@
 }
 
 static void
-parse_hex_string(const unsigned char *s, struct ipt_string_info *info)
+parse_hex_string(const char *s, struct ipt_string_info *info)
 {
 	int i=0, slen, sindex=0, schar;
 	short hex_f = 0, literal_f = 0;
@@ -327,9 +327,9 @@
 	}
 	printf("--algo %s ", info->algo);
 	if (info->from_offset != 0)
-		printf("--from-offset %u ", info->from_offset);
+		printf("--from %u ", info->from_offset);
 	if (info->to_offset != 0)
-		printf("--to-offset %u ", info->to_offset);
+		printf("--to %u ", info->to_offset);
 }
 
 
diff -urN iptables-1.3.4/extensions/libipt_string.man iptables-1.3.5/extensions/libipt_string.man
--- iptables-1.3.4/extensions/libipt_string.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.5/extensions/libipt_string.man	2006-01-06 00:23:33.000000000 +0100
@@ -0,0 +1,15 @@
+This modules matches a given string by using some pattern matching strategy. It requires a linux kernel >= 2.6.14.
+.TP
+.BI "--algo  " "bm|kmp"
+Select the pattern matching strategy. (bm = Boyer-Moore, kmp = Knuth-Pratt-Morris)
+.TP
+.BI "--from " "offset"
+Set the offset from which it starts looking for any matching. If not passed, default is 0.
+.TP
+.BI "--to " "offset"
+Set the offset from which it starts looking for any matching. If not passed, default is the packet size.
+.TP
+.BI "--string " "pattern"
+Matches the given pattern.
+.BI "--hex-string " "pattern"
+Matches the given pattern in hex notation.
diff -urN iptables-1.3.4/extensions/libipt_tos.c iptables-1.3.5/extensions/libipt_tos.c
--- iptables-1.3.4/extensions/libipt_tos.c	2005-07-28 16:53:09.000000000 +0200
+++ iptables-1.3.5/extensions/libipt_tos.c	2006-01-30 09:43:10.000000000 +0100
@@ -51,7 +51,7 @@
 parse_tos(const char *s, struct ipt_tos_info *info)
 {
 	unsigned int i;
-	int tos;
+	unsigned int tos;
 
 	if (string_to_number(s, 0, 255, &tos) != -1) {
 		if (tos == IPTOS_LOWDELAY
diff -urN iptables-1.3.4/extensions/libipt_ttl.c iptables-1.3.5/extensions/libipt_ttl.c
--- iptables-1.3.4/extensions/libipt_ttl.c	2005-07-28 16:53:09.000000000 +0200
+++ iptables-1.3.5/extensions/libipt_ttl.c	2006-01-30 09:43:10.000000000 +0100
@@ -1,7 +1,7 @@
 /* Shared library add-on to iptables to add TTL matching support 
  * (C) 2000 by Harald Welte <laforge@gnumonks.org>
  *
- * $Id: libipt_ttl.c 4136 2005-07-19 22:03:49Z /C=DE/ST=Berlin/L=Berlin/O=Netfilter Project/OU=Development/CN=laforge/emailAddress=laforge@netfilter.org $
+ * $Id: libipt_ttl.c 4544 2005-11-18 17:59:56Z /C=DE/ST=Berlin/L=Berlin/O=Netfilter Project/OU=Development/CN=kaber/emailAddress=kaber@netfilter.org $
  *
  * This program is released under the terms of GNU GPL */
 
@@ -33,12 +33,12 @@
 
 	check_inverse(optarg, &invert, &optind, 0);
 
-	if (string_to_number(optarg, 0, 255, &value) == -1)
-		exit_error(PARAMETER_PROBLEM,
-		           "ttl: Expected value between 0 and 255");
-
 	switch (c) {
 		case '2':
+			if (string_to_number(optarg, 0, 255, &value) == -1)
+				exit_error(PARAMETER_PROBLEM,
+				           "ttl: Expected value between 0 and 255");
+
 			if (invert)
 				info->mode = IPT_TTL_NE;
 			else
@@ -48,6 +48,10 @@
 			info->ttl = value;
 			break;
 		case '3':
+			if (string_to_number(optarg, 0, 255, &value) == -1)
+				exit_error(PARAMETER_PROBLEM,
+				           "ttl: Expected value between 0 and 255");
+
 			if (invert) 
 				exit_error(PARAMETER_PROBLEM,
 						"ttl: unexpected `!'");
@@ -56,6 +60,10 @@
 			info->ttl = value;
 			break;
 		case '4':
+			if (string_to_number(optarg, 0, 255, &value) == -1)
+				exit_error(PARAMETER_PROBLEM,
+				           "ttl: Expected value between 0 and 255");
+
 			if (invert)
 				exit_error(PARAMETER_PROBLEM,
 						"ttl: unexpected `!'");
diff -urN iptables-1.3.4/include/ip6tables.h iptables-1.3.5/include/ip6tables.h
--- iptables-1.3.4/include/ip6tables.h	2005-06-24 18:34:17.000000000 +0200
+++ iptables-1.3.5/include/ip6tables.h	2006-01-30 09:43:09.000000000 +0100
@@ -130,6 +130,7 @@
 
 enum ip6t_tryload {
 	DONT_LOAD,
+	DURING_LOAD,
 	TRY_LOAD,
 	LOAD_MUST_SUCCEED
 };
diff -urN iptables-1.3.4/include/iptables.h iptables-1.3.5/include/iptables.h
--- iptables-1.3.4/include/iptables.h	2005-10-31 20:03:49.000000000 +0100
+++ iptables-1.3.5/include/iptables.h	2006-01-30 09:43:09.000000000 +0100
@@ -162,6 +162,7 @@
 
 enum ipt_tryload {
 	DONT_LOAD,
+	DURING_LOAD,
 	TRY_LOAD,
 	LOAD_MUST_SUCCEED
 };
diff -urN iptables-1.3.4/include/libippool/ip_pool_support.h iptables-1.3.5/include/libippool/ip_pool_support.h
--- iptables-1.3.4/include/libippool/ip_pool_support.h	2004-10-10 11:56:23.000000000 +0200
+++ iptables-1.3.5/include/libippool/ip_pool_support.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,26 +0,0 @@
-/* support function prototypes for IP pool management (config file, mostly) */
-#ifndef _IP_POOL_SUPPORT_H
-#define _IP_POOL_SUPPORT_H
-
-#include <iptables.h>
-#include <linux/netfilter_ipv4/ip_conntrack.h>
-#include <linux/netfilter_ipv4/ip_pool.h>
-
-#ifndef IPPOOL_CONF
-#define IPPOOL_CONF "/etc/ippool.conf"
-#endif
-
-/* called just to draw in this support .o */
-void ip_pool_init(void);
-
-/* given a pool name (or number), return pool index, possibly reading .conf */
-ip_pool_t ip_pool_get_index(char *name);
-
-/* given a pool index, and a buffer to store a name, search for the index
- * in the .conf file, and give the textual name, if present; if not, the
- * numeric index is returned. If numeric_flag == 1, the numeric index is
- * always returned
- */
-char *ip_pool_get_name(char *buf, int size, ip_pool_t index, int numeric_flag);
-
-#endif /*_IP_POOL_SUPPORT_H*/
diff -urN iptables-1.3.4/include/linux/netfilter_ipv4/ipt_conntrack.h iptables-1.3.5/include/linux/netfilter_ipv4/ipt_conntrack.h
--- iptables-1.3.4/include/linux/netfilter_ipv4/ipt_conntrack.h	2005-07-10 16:47:14.000000000 +0200
+++ iptables-1.3.5/include/linux/netfilter_ipv4/ipt_conntrack.h	2006-02-01 13:48:01.000000000 +0100
@@ -13,7 +13,7 @@
 #define KERNEL_VERSION(a,b,c) (((a) << 16) | ((b) << 8) | (c))
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,18)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,18)) || !defined IPS_EXPECTED
 #define IPS_EXPECTED	(1 << 0)
 #define IPS_SEEN_REPLY	(1 << 1)
 #define IPS_ASSURED	(1 << 2)
diff -urN iptables-1.3.4/include/linux/netfilter_ipv4/ipt_policy.h iptables-1.3.5/include/linux/netfilter_ipv4/ipt_policy.h
--- iptables-1.3.4/include/linux/netfilter_ipv4/ipt_policy.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.5/include/linux/netfilter_ipv4/ipt_policy.h	2006-02-01 13:52:25.000000000 +0100
@@ -0,0 +1,62 @@
+#ifndef _IPT_POLICY_H
+#define _IPT_POLICY_H
+
+#define IPT_POLICY_MAX_ELEM	4
+
+#ifndef __KERNEL__
+#include <netinet/in.h>
+#endif
+
+enum ipt_policy_flags
+{
+	IPT_POLICY_MATCH_IN	= 0x1,
+	IPT_POLICY_MATCH_OUT	= 0x2,
+	IPT_POLICY_MATCH_NONE	= 0x4,
+	IPT_POLICY_MATCH_STRICT	= 0x8,
+};
+
+enum ipt_policy_modes
+{
+	IPT_POLICY_MODE_TRANSPORT,
+	IPT_POLICY_MODE_TUNNEL
+};
+
+struct ipt_policy_spec
+{
+	u_int8_t	saddr:1,
+			daddr:1,
+			proto:1,
+			mode:1,
+			spi:1,
+			reqid:1;
+};
+
+union ipt_policy_addr
+{
+	struct in_addr	a4;
+	struct in6_addr	a6;
+};
+
+struct ipt_policy_elem
+{
+	union ipt_policy_addr	saddr;
+	union ipt_policy_addr	smask;
+	union ipt_policy_addr	daddr;
+	union ipt_policy_addr	dmask;
+	u_int32_t		spi;
+	u_int32_t		reqid;
+	u_int8_t		proto;
+	u_int8_t		mode;
+
+	struct ipt_policy_spec	match;
+	struct ipt_policy_spec	invert;
+};
+
+struct ipt_policy_info
+{
+	struct ipt_policy_elem pol[IPT_POLICY_MAX_ELEM];
+	u_int16_t flags;
+	u_int16_t len;
+};
+
+#endif /* _IPT_POLICY_H */
diff -urN iptables-1.3.4/include/linux/netfilter_ipv6/ip6t_policy.h iptables-1.3.5/include/linux/netfilter_ipv6/ip6t_policy.h
--- iptables-1.3.4/include/linux/netfilter_ipv6/ip6t_policy.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.3.5/include/linux/netfilter_ipv6/ip6t_policy.h	2006-02-01 13:14:31.000000000 +0100
@@ -0,0 +1,58 @@
+#ifndef _IP6T_POLICY_H
+#define _IP6T_POLICY_H
+
+#define IP6T_POLICY_MAX_ELEM	4
+
+enum ip6t_policy_flags
+{
+	IP6T_POLICY_MATCH_IN		= 0x1,
+	IP6T_POLICY_MATCH_OUT		= 0x2,
+	IP6T_POLICY_MATCH_NONE		= 0x4,
+	IP6T_POLICY_MATCH_STRICT	= 0x8,
+};
+
+enum ip6t_policy_modes
+{
+	IP6T_POLICY_MODE_TRANSPORT,
+	IP6T_POLICY_MODE_TUNNEL
+};
+
+struct ip6t_policy_spec
+{
+	u_int8_t	saddr:1,
+			daddr:1,
+			proto:1,
+			mode:1,
+			spi:1,
+			reqid:1;
+};
+
+union ip6t_policy_addr
+{
+	struct in_addr	a4;
+	struct in6_addr	a6;
+};
+
+struct ip6t_policy_elem
+{
+	union ip6t_policy_addr	saddr;
+	union ip6t_policy_addr	smask;
+	union ip6t_policy_addr	daddr;
+	union ip6t_policy_addr	dmask;
+	u_int32_t		spi;
+	u_int32_t		reqid;
+	u_int8_t		proto;
+	u_int8_t		mode;
+
+	struct ip6t_policy_spec	match;
+	struct ip6t_policy_spec	invert;
+};
+
+struct ip6t_policy_info
+{
+	struct ip6t_policy_elem pol[IP6T_POLICY_MAX_ELEM];
+	u_int16_t flags;
+	u_int16_t len;
+};
+
+#endif /* _IP6T_POLICY_H */
diff -urN iptables-1.3.4/ip6tables.8.in iptables-1.3.5/ip6tables.8.in
--- iptables-1.3.4/ip6tables.8.in	2005-07-29 15:28:56.000000000 +0200
+++ iptables-1.3.5/ip6tables.8.in	2006-01-30 09:41:00.000000000 +0100
@@ -1,4 +1,4 @@
-.TH IP6TABLES 8 "Mar 09, 2002" "" ""
+.TH IP6TABLES 8 "Jan 22, 2006" "" ""
 .\"
 .\" Man page written by Andras Kis-Szabo <kisza@sch.bme.hu>
 .\" It is based on iptables man page.
@@ -131,6 +131,16 @@
 (for altering packets being routed through the box), and
 .B POSTROUTING
 (for altering packets as they are about to go out).
+.TP
+.BR "raw" :
+This table is used mainly for configuring exemptions from connection
+tracking in combination with the NOTRACK target.  It registers at the netfilter
+hooks with higher priority and is thus called before nf_conntrack, or any other
+IP6 tables.  It provides the following built-in chains:
+.B PREROUTING
+(for packets arriving via any network interface)
+.B OUTPUT
+(for packets generated by local processes)
 .RE
 .SH OPTIONS
 The options that are recognized by
@@ -231,11 +241,18 @@
 The specified protocol can be one of
 .IR tcp ,
 .IR udp ,
-.IR ipv6-icmp|icmpv6 ,
-or
+.IR icmpv6 ,
+.IR esp ,
 .IR all ,
 or it can be a numeric value, representing one of these protocols or a
-different one.  A protocol name from /etc/protocols is also allowed.
+different one. A protocol name from /etc/protocols is also allowed.
+But IPv6 extension headers except
+.IR esp
+are not allowed.
+.IR esp ,
+and
+.IR ipv6-nonext
+can be used with Kernel version 2.6.11 or later.
 A "!" argument before the protocol inverts the
 test.  The number zero is equivalent to
 .IR all .
diff -urN iptables-1.3.4/ip6tables.c iptables-1.3.5/ip6tables.c
--- iptables-1.3.4/ip6tables.c	2005-07-29 15:28:56.000000000 +0200
+++ iptables-1.3.5/ip6tables.c	2006-01-30 09:43:12.000000000 +0100
@@ -734,7 +734,7 @@
   	}
 
 #ifndef NO_SHARED_LIBS
-	if (!ptr && tryload != DONT_LOAD) {
+	if (!ptr && tryload != DONT_LOAD && tryload != DURING_LOAD) {
 		char path[strlen(lib_dir) + sizeof("/libip6t_.so")
 			 + strlen(name)];
 		if (!icmphack)
@@ -986,7 +986,7 @@
 	}
 
 #ifndef NO_SHARED_LIBS
-	if (!ptr && tryload != DONT_LOAD) {
+	if (!ptr && tryload != DONT_LOAD && tryload != DURING_LOAD) {
 		char path[strlen(lib_dir) + sizeof("/libip6t_.so")
 			 + strlen(name)];
 		sprintf(path, "%s/libip6t_%s.so", lib_dir, name);
@@ -1058,7 +1058,7 @@
 		exit(1);
 	}
 
-	if (find_match(me->name, DONT_LOAD, NULL)) {
+	if (find_match(me->name, DURING_LOAD, NULL)) {
 		fprintf(stderr, "%s: match `%s' already registered.\n",
 			program_name, me->name);
 		exit(1);
@@ -1088,7 +1088,7 @@
 		exit(1);
 	}
 
-	if (find_target(me->name, DONT_LOAD)) {
+	if (find_target(me->name, DURING_LOAD)) {
 		fprintf(stderr, "%s: target `%s' already registered.\n",
 			program_name, me->name);
 		exit(1);
diff -urN iptables-1.3.4/ippool/Makefile iptables-1.3.5/ippool/Makefile
--- iptables-1.3.4/ippool/Makefile	2004-10-10 11:56:27.000000000 +0200
+++ iptables-1.3.5/ippool/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-EXTRAS+=$(shell [ -f $(KERNEL_DIR)/include/linux/netfilter_ipv4/ip_pool.h ] && echo ippool/libippool.a ippool/ippool)
-
-ifndef TOPLEVEL_INCLUDED
-local:
-	cd .. && $(MAKE) $(KERN_TARGETS) $(SHARED_LIBS) $(EXTRAS)
-
-else
-EXTRA_DEPENDS+=$(shell [ -f $(KERNEL_DIR)/include/linux/netfilter_ipv4/ip_pool.h ] && echo ippool/libippool.d)
-
-ippool/libippool.a: ippool/libippool.a(ippool/libippool.o)
-
-ippool/libippool.d: %.d: %.c
-	@-$(CC) -M -MG $(CFLAGS) $< | sed -e 's@^.*\.o:@$*.d $*.a($*.o):@' > $@
-
-ippool/ippool.o: ippool/ippool.c
-ippool/ippool: ippool/ippool.o ippool/libippool.a
-	$(CC) $(CFLAGS) -o $@ $^
-endif
diff -urN iptables-1.3.4/ippool/ippool.c iptables-1.3.5/ippool/ippool.c
--- iptables-1.3.4/ippool/ippool.c	2004-10-10 11:56:27.000000000 +0200
+++ iptables-1.3.5/ippool/ippool.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,589 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include <getopt.h>
-#include <arpa/inet.h>
-#include <linux/netfilter_ipv4/ip_pool.h>
-#include <libippool/ip_pool_support.h>
-
-/* translate errnos, as returned by our *sockopt() functions */
-static char *errno2msg(int op, int err)
-{
-	switch(err) {
-	case ERANGE:
-		return "Address out of pool range";
-	}
-	return strerror(err);
-}
-
-static void usage(char *msg)
-{
-	if (msg) fprintf(stderr, "ERROR: %s\n", msg);
-	fprintf(stderr,
-"Usage: ippool [-LADCNF] [POOL] [args]\n"
-"The POOL argument is either a number, or a name from %s\n"
-, IPPOOL_CONF);
-	fprintf(stderr,
-"ippool [-n] [-l|-L POOL] [-u] [-v]\n"
-	"\tLists all (-l), or a single (-L) pool.\n"
-	"\tWith -u, summarized usage counts are listed.\n"
-	"\tWith -v, each pool membership is shown, one per line.\n"
-"ippool [-n] [-f|-F [POOL]]\n"
-	"\tflushes POOL (or all pools.)\n"
-"ippool [-n] [-x|-X [POOL]]\n"
-	"\tremoves POOL (or all pools.)\n"
-"ippool [-n] -B\n"
-	"\tcreates all fully specified pools found in the config file.\n"
-"ippool [-n] -N POOL [-t type] [FIRST LAST]\n"
-	"\tcreates POOL of IP addresses FIRST to LAST (inclusive).  If a\n"
-	"\tpool name from the config file %s is used, type and\n"
-	"\taddress information can be defined there.  The -t argument\n"
-	"\tgives the type (default bitmap).\n"
-"ippool [-n] -A POOL ADDR\n"
-	"\tadds ADDR to POOL\n"
-"ippool [-n] -D POOL ADDR\n"
-	"\tremoves ADDR from POOL\n"
-"ippool [-n] -C POOL ADDR\n"
-	"\ttests ADDR against membership in POOL\n"
-, IPPOOL_CONF);
-	exit(1);
-}
-
-/* config file parsing */
-
-#define IP_POOL_T_NONE		0
-#define IP_POOL_T_BITMAP	1
-
-static int conf_type = IP_POOL_T_NONE;
-static unsigned long conf_addr = 0;
-static unsigned long conf_addr2 = 0;
-
-#define SCAN_EOF (IP_POOL_NONE-1)
-
-static ip_pool_t get_index_line(
-	FILE *fp,
-	char **namep,
-	char **typep,
-	char **argp
-) {
-	char *p;
-	ip_pool_t index;
-	static char buf[256];
-
-	if (namep) *namep = 0;
-	if (typep) *typep = 0;
-	if (argp) *argp = 0;
-
-	if (!fgets(buf, sizeof(buf), fp)) return SCAN_EOF;
-
-	p = strtok(buf, " \t\n");
-	if (!p || *p == '#') return IP_POOL_NONE;
-	index = atoi(p);
-
-	p = strtok(0, " \t\n");
-	if (!p || *p == '#') return index;
-	if (namep) *namep = p;
-
-	p = strtok(0, " \t\n");
-	if (!p || *p == '#') return index;
-	if (typep) *typep = p;
-
-	p = strtok(0, "#\n");
-	if (argp) *argp = p;
-
-	return index;
-}
-
-static ip_pool_t get_index(char *name)
-{
-	FILE *fp;
-	char *poolname, *type, *arg, *p;
-	ip_pool_t res;
-
-	if (isdigit(*name))
-		return atoi(name);
-	fp = fopen(IPPOOL_CONF, "r");
-	if (!fp) {
-		fprintf(stderr, "cannot open %s - no pool names", IPPOOL_CONF);
-		exit(1);
-	}
-	while (SCAN_EOF != (res=get_index_line(fp, &poolname, &type, &arg))) {
-		if (poolname && 0 == strcmp(poolname, name)) {
-			if (!type || (0 == strcmp(type, "bitmap"))) {
-				conf_type = IP_POOL_T_BITMAP;
-				p = strtok(arg, " \t");
-				if (p) {
-					conf_addr = inet_addr(p);
-					p = strtok(0, " \t");
-					if (p)
-						conf_addr2 = inet_addr(p);
-					else
-						conf_addr = 0;
-				}
-			}
-			break;
-		}
-	}
-	fclose(fp);
-	if (res == SCAN_EOF) {
-		fprintf(stderr, "pool '%s' not found in %s\n",
-			name, IPPOOL_CONF);
-		exit(1);
-	}
-	return res;
-}
-
-static char *get_name(ip_pool_t index)
-{
-	FILE *fp;
-	static char sbuf[256];
-	int ok = 0;
-
-	fp = fopen(IPPOOL_CONF, "r");
-	if (fp) {
-		while (fgets(sbuf, sizeof(sbuf), fp)) {
-			char *p = strtok(sbuf, " \t\n");
-
-			if (!p || *p == '#') continue;
-			if (index != atoi(p)) continue;
-			p = strtok(0, " \t\n");
-			if (!p || *p == '#') continue;
-			memmove(sbuf, p, strlen(p)+1);
-			ok = 1;
-			break;
-		}
-		fclose(fp);
-	}
-	if (!ok) sprintf(sbuf, "%d", index);
-	return sbuf;
-}
-
-/* user/kernel interaction */
-
-static int fd = -1;
-static int flag_n = 0;		/* do not do anything; just brag about it */
-static int flag_v = 0;		/* be verbose (list members) */
-static int flag_q = 0;		/* be quiet */
-static int flag_u = 0;		/* show usage counts in listings */
-static char *flag_t = "bitmap";	/* pool type */
-
-static ip_pool_t high_nr(void)
-{
-	struct ip_pool_request req;
-	int reqlen = sizeof(req);
-
-	req.op = IP_POOL_HIGH_NR;
-	if (0 > getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen)) {
-		fprintf(stderr,
-			"IP_POOL_HIGH_NR failed: %s\n",
-			errno2msg(IP_POOL_HIGH_NR, errno));
-		exit(1);
-	}
-	return req.index;
-}
-
-static void do_list(ip_pool_t pool)
-{
-	struct ip_pool_request req;
-	int reqlen = sizeof(req);
-	u_int32_t first_ip;
-	u_int32_t last_ip;
-
-	req.op = IP_POOL_LOOKUP;
-	req.index = pool;
-	req.addr = req.addr2 = 0;
-	reqlen = sizeof(req);
-	if (0 == getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen)) {
-		struct in_addr ina;
-		ina.s_addr = req.addr;
-		printf("%s %s", get_name(req.index), inet_ntoa(ina));
-		ina.s_addr = req.addr2;
-		printf(" %s", inet_ntoa(ina));
-		first_ip = ntohl(req.addr);
-		last_ip = ntohl(req.addr2);
-		if (flag_u) {
-			req.op = IP_POOL_USAGE;
-			req.index = pool;
-			reqlen = sizeof(req);
-			if (0 == getsockopt(fd, SOL_IP, SO_IP_POOL,
-						&req, &reqlen)) {
-				printf(" %d %d", req.addr, req.addr2);
-			} else {
-				printf(" - -");
-			}
-		}
-		printf("\n");
-		if (flag_v) {
-			while (first_ip <= last_ip) {
-				req.op = IP_POOL_TEST_ADDR;
-				req.index = pool;
-				ina.s_addr = req.addr = htonl(first_ip);
-				reqlen = sizeof(req);
-				if (0 == getsockopt(fd, SOL_IP, SO_IP_POOL,
-							&req, &reqlen)) {
-					if (req.addr) printf("\t%s\n",
-							inet_ntoa(ina));
-				}
-				first_ip++;
-			}
-		}
-	}
-}
-
-static void do_list_all(void)
-{
-	ip_pool_t i, highest = high_nr();
-
-	for (i=0; i<=highest; i++)
-		do_list(i);
-}
-
-static void do_flush(ip_pool_t pool)
-{
-	struct ip_pool_request req;
-	int reqlen = sizeof(req);
-
-	req.op = IP_POOL_FLUSH;
-	req.index = pool;
-	if (flag_n) {
-		printf("ippool -F %d\n", req.index);
-		return;
-	}
-	if (0 > getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen)) {
-		int err = errno;
-		fprintf(stderr,
-			"IP_POOL_FLUSH %s failed: %s\n",
-			get_name(pool), errno2msg(IP_POOL_FLUSH, err));
-		exit(1);
-	}
-}
-
-static void do_flush_all(void)
-{
-	ip_pool_t i, highest = high_nr();
-
-	for (i=0; i<=highest; i++)
-		do_flush(i);
-}
-
-static void do_destroy(ip_pool_t pool)
-{
-	struct ip_pool_request req;
-	int reqlen = sizeof(req);
-
-	req.op = IP_POOL_DESTROY;
-	req.index = pool;
-	if (flag_n) {
-		printf("ippool -X %d\n", req.index);
-		return;
-	}
-	if (0 > getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen)) {
-		int err = errno;
-		fprintf(stderr,
-			"IP_POOL_DESTROY %s failed: %s\n",
-			get_name(pool), errno2msg(IP_POOL_DESTROY, err));
-		exit(1);
-	}
-}
-
-static void do_destroy_all(void)
-{
-	ip_pool_t i, highest = high_nr();
-
-	for (i=0; i<=highest; i++)
-		do_destroy(i);
-}
-
-static int do_adddel(ip_pool_t pool, char *straddr, int op)
-{
-	struct ip_pool_request req;
-	int res;
-	int reqlen = sizeof(req);
-
-	req.op = op;
-	req.index = pool;
-	req.addr = inet_addr(straddr);
-	req.addr2 = 0;
-	if (flag_n) {
-		printf("ippool -%c %s %s\n",
-				(op == IP_POOL_ADD_ADDR) ? 'A' : 'D',
-				get_name(req.index), straddr);
-		return 0;
-	}
-	res = getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen);
-	if (0 > res) {
-		int err = errno;
-		fprintf(stderr,
-			"IP_POOL_ADD/DEL %s in %s failed: %s\n",
-			straddr, get_name(pool), errno2msg(op, err));
-		exit(1);
-	}
-	if (!flag_q)
-		printf("%s %s %d %d\n", get_name(pool), straddr, req.addr,
-			op == IP_POOL_ADD_ADDR ? 1 : 0);
-	return req.addr;
-}
-
-static int do_check(ip_pool_t pool, char *straddr)
-{
-	struct ip_pool_request req;
-	int reqlen = sizeof(req);
-
-	req.op = IP_POOL_TEST_ADDR;
-	req.index = pool;
-	req.addr = inet_addr(straddr);
-	if (0 > getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen)) {
-		int err = errno;
-		fprintf(stderr,
-			"IP_POOL_TEST_ADDR %s in %s failed: %s\n",
-			straddr, get_name(pool),
-			errno2msg(IP_POOL_TEST_ADDR, err));
-		exit(1);
-	}
-	if (!flag_q)
-		printf("%s %s %d\n", get_name(req.index), straddr, req.addr);
-	return !req.addr;
-}
-
-static void do_new(ip_pool_t pool, int argc, char **argv)
-{
-	struct ip_pool_request req;
-	int reqlen = sizeof(req);
-
-	req.op = IP_POOL_INIT;
-	req.index = pool;
-	if (argc >= 2) {
-		conf_type = IP_POOL_T_BITMAP;
-		conf_addr = inet_addr(argv[0]);
-		conf_addr2 = inet_addr(argv[1]);
-	}
-	if (conf_type != IP_POOL_T_BITMAP || conf_addr == 0 || conf_addr2 == 0)
-		usage("bad pool specification");
-	req.addr = conf_addr;
-	req.addr2 = conf_addr2;
-	if (flag_n) {
-		printf("ippool -N %s [-T %s] ...\n", get_name(pool),
-					conf_type == IP_POOL_T_BITMAP
-						? "bitmap"
-						: "???");
-		return;
-	}
-	if (0 > getsockopt(fd, SOL_IP, SO_IP_POOL, &req, &reqlen)) {
-		struct in_addr ina;
-		int err = errno;
-		ina.s_addr = conf_addr;
-		fprintf(stderr,
-			"IP_POOL_INIT %s [%s-",
-			get_name(pool), inet_ntoa(ina));
-		ina.s_addr = conf_addr2;
-		fprintf(stderr,
-			"%s] failed: %s\n",
-			inet_ntoa(ina), errno2msg(IP_POOL_INIT, err));
-		exit(1);
-	}
-}
-
-static void do_new_all(void)
-{
-	FILE *fp;
-	char *poolname, *type, *arg, *p;
-	int res;
-
-	fp = fopen(IPPOOL_CONF, "r");
-	if (!fp) {
-		fprintf(stderr, "cannot open %s - no pool names", IPPOOL_CONF);
-		exit(1);
-	}
-	while (SCAN_EOF != (res=get_index_line(fp, &poolname, &type, &arg))) {
-		if (poolname && type && (0 == strcmp(type, "bitmap"))) {
-			conf_type = IP_POOL_T_BITMAP;
-			p = strtok(arg, " \t");
-			if (p) {
-				conf_addr = inet_addr(p);
-				p = strtok(0, " \t");
-				if (p)
-					conf_addr2 = inet_addr(p);
-				else
-					conf_addr = 0;
-			}
-			if (conf_addr != 0) {
-				if (flag_v)
-					printf("ippool -N %s (%s) [%s]\n",
-						poolname, type, arg);
-				do_new(res, 0, 0);
-			}
-		}
-	}
-	fclose(fp);
-}
-
-int main(int argc, char **argv)
-{
-	int opt;
-	int op;
-#define OP_NONE		0
-#define OP_LIST		1
-#define OP_LIST_ALL	2
-#define OP_FLUSH	3
-#define OP_FLUSH_ALL	4
-#define OP_DESTROY	5
-#define OP_DESTROY_ALL	6
-#define OP_ADD		7
-#define OP_DEL		8
-#define OP_CHECK	9
-#define OP_NEW		10
-#define OP_NEW_ALL	11
-#define OP_HIGHEST	12
-	char *op_pool;
-
-	fd = socket(AF_INET, SOCK_DGRAM, 0);
-	if (fd < 0) {
-		fprintf(stderr, "cannot get DGRAM socket: %s\n",
-			strerror(errno));
-		exit(1);
-	}
-	op_pool = 0;
-	op = OP_NONE;
-	/* GRRR. I thought getopt() would allow an "L*" specifier, for an -L
-	 * taking an optional argument. Does not work. Bad.
-	 * Adding -l for -L without argument, also -f/-F and -x/-X.
-	 */
-	while (EOF != (opt=getopt( argc, argv, "HhnvuqA:D:C:N:t:L:F:X:lfxB")))
-	switch(opt) {
-		case 'l':
-			if (op != OP_NONE) usage("conflicting operations");
-			op = OP_LIST_ALL;
-			break;
-		case 'L':
-			if (op != OP_NONE) usage("conflicting operations");
-			op = OP_LIST;
-			op_pool = optarg;
-			break;
-		case 'f':
-			if (op != OP_NONE) usage("conflicting operations");
-			op = OP_FLUSH_ALL;
-			break;
-		case 'F':
-			if (op != OP_NONE) usage("conflicting operations");
-			op = OP_FLUSH;
-			op_pool = optarg;
-			break;
-		case 'x':
-			if (op != OP_NONE) usage("conflicting operations");
-			op = OP_DESTROY_ALL;
-			break;
-		case 'X':
-			if (op != OP_NONE) usage("conflicting operations");
-			op = OP_DESTROY;
-			op_pool = optarg;
-			break;
-		case 'A':
-			if (op != OP_NONE) usage("conflicting operations");
-			op = OP_ADD;
-			op_pool = optarg;
-			break;
-		case 'D':
-			if (op != OP_NONE) usage("conflicting operations");
-			op = OP_DEL;
-			op_pool = optarg;
-			break;
-		case 'C':
-			if (op != OP_NONE) usage("conflicting operations");
-			op = OP_CHECK;
-			op_pool = optarg;
-			break;
-		case 'B':
-			if (op != OP_NONE) usage("conflicting operations");
-			op = OP_NEW_ALL;
-			break;
-		case 'N':
-			if (op != OP_NONE) usage("conflicting operations");
-			op = OP_NEW;
-			op_pool = optarg;
-			break;
-		case 'H':
-			if (op != OP_NONE) usage("conflicting operations");
-			op = OP_HIGHEST;
-			break;
-		case 't':
-			flag_t = optarg;
-			break;
-		case 'n':
-			flag_n = 1;
-			break;
-		case 'v':
-			flag_v = 1;
-			break;
-		case 'u':
-			flag_u = 1;
-			break;
-		case 'q':
-			flag_q = 1;
-			break;
-		case 'h':
-			usage(0);
-		default:
-			usage("bad option");
-	}
-	if (op == OP_NONE)
-		usage("no operation specified");
-	if (op == OP_LIST_ALL) {
-		do_list_all();
-		return 0;
-	}
-	if (op == OP_LIST) {
-		do_list(get_index(op_pool));
-		return 0;
-	}
-	if (op == OP_FLUSH_ALL) {
-		do_flush_all();
-		return 0;
-	}
-	if (op == OP_FLUSH) {
-		do_flush(get_index(op_pool));
-		return 0;
-	}
-	if (op == OP_DESTROY_ALL) {
-		do_destroy_all();
-		return 0;
-	}
-	if (op == OP_DESTROY) {
-		do_destroy(get_index(op_pool));
-		return 0;
-	}
-	if (op == OP_CHECK) {
-		if (optind >= argc)
-			usage("missing address to check");
-		return do_check(get_index(op_pool), argv[optind]);
-	}
-	if (op == OP_NEW_ALL) {
-		do_new_all();
-		return 0;
-	}
-	if (op == OP_NEW) {
-		do_new(get_index(op_pool), argc-optind, argv+optind);
-		return 0;
-	}
-	if (op == OP_ADD) {
-		if (optind >= argc)
-			usage("missing address to add");
-		return do_adddel(get_index(op_pool),
-				argv[optind], IP_POOL_ADD_ADDR);
-	}
-	if (op == OP_DEL) {
-		if (optind >= argc)
-			usage("missing address to delete");
-		return do_adddel(get_index(op_pool),
-				argv[optind], IP_POOL_DEL_ADDR);
-	}
-	if (op == OP_HIGHEST) {
-		printf("%d\n", high_nr());
-		return 0;
-	}
-	usage("no operation specified");
-	return 0;
-}
diff -urN iptables-1.3.4/ippool/libippool.c iptables-1.3.5/ippool/libippool.c
--- iptables-1.3.4/ippool/libippool.c	2004-10-10 11:56:27.000000000 +0200
+++ iptables-1.3.5/ippool/libippool.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,72 +0,0 @@
-/* support functions for ip_pool modules */
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <ctype.h>
-
-#include <libippool/ip_pool_support.h>
-
-void ip_pool_init(void)
-{
-}
-
-ip_pool_t ip_pool_get_index(char *name)
-{
-	FILE *fp;
-	char buf[256];
-
-	if (isdigit(*name))
-		return atoi(name);
-	fp = fopen(IPPOOL_CONF, "r");
-	if (!fp) exit_error(PARAMETER_PROBLEM,
-			"cannot open %s - no pool names", IPPOOL_CONF);
-	while (fgets(buf, sizeof(buf), fp)) {
-		char *p = strtok(buf, " \t\n");
-		ip_pool_t index;
-
-		if (!p || *p == '#') continue;
-		index = atoi(p);
-		p = strtok(0, " \t\n");
-		if (p && 0 == strcmp(p, name)) {
-			fclose(fp);
-			return index;
-		}
-	}
-	exit_error(PARAMETER_PROBLEM,
-		"pool '%s' not found in %s\n", name, IPPOOL_CONF);
-}
-
-char *ip_pool_get_name(char *buf, int size, ip_pool_t index, int numeric)
-{
-	FILE *fp;
-	int ok = 0;
-
-	/* make sure we have enough room, at least for a %d */
-	if (size < 16)
-		exit_error(PARAMETER_PROBLEM,
-			"ip_pool_support:get_name buf too small (%d vs. 16)\n",
-			size);
-	if (numeric)
-		goto do_numeric;
-	fp = fopen(IPPOOL_CONF, "r");
-	if (fp) {
-		while (fgets(buf, size, fp)) {
-			char *p = strtok(buf, " \t\n");
-
-			if (!p || *p == '#') continue;
-			if (index != atoi(p)) continue;
-			p = strtok(0, " \t\n");
-			if (!p || *p == '#') continue;
-			memmove(buf, p, strlen(p)+1);
-			ok = 1;
-			break;
-		}
-		fclose(fp);
-	}
-	if (!ok) {
-do_numeric:
-		sprintf(buf, "%d", index);
-	}
-	return buf;
-}
diff -urN iptables-1.3.4/iptables-save.c iptables-1.3.5/iptables-save.c
--- iptables-1.3.4/iptables-save.c	2005-04-15 11:30:16.000000000 +0200
+++ iptables-1.3.5/iptables-save.c	2005-11-24 18:03:00.000000000 +0100
@@ -197,7 +197,11 @@
 	/* Print target name */	
 	target_name = iptc_get_target(e, h);
 	if (target_name && (*target_name != '\0'))
+#ifdef IPT_F_GOTO
+		printf("-%c %s ", e->ip.flags & IPT_F_GOTO ? 'g' : 'j', target_name);
+#else
 		printf("-j %s ", target_name);
+#endif
 
 	/* Print targinfo part */
 	t = ipt_get_target((struct ipt_entry *)e);
diff -urN iptables-1.3.4/iptables.8.in iptables-1.3.5/iptables.8.in
--- iptables-1.3.4/iptables.8.in	2005-07-29 15:28:56.000000000 +0200
+++ iptables-1.3.5/iptables.8.in	2005-11-22 23:21:39.000000000 +0100
@@ -222,9 +222,10 @@
 .TP
 .BR "-X, --delete-chain " "[\fIchain\fP]"
 Delete the optional user-defined chain specified.  There must be no references
-to the chain.  If there are, you must delete or replace the referring
-rules before the chain can be deleted.  If no argument is given, it
-will attempt to delete every non-builtin chain in the table.
+to the chain.  If there are, you must delete or replace the referring rules
+before the chain can be deleted.  The chain must be empty, i.e. not contain
+any rules.  If no argument is given, it will attempt to delete every
+non-builtin chain in the table.
 .TP
 .BI "-P, --policy " "chain target"
 Set the policy for the chain to the given target.  See the section
@@ -296,10 +297,18 @@
 the fate of the packet immediately, or an extension (see
 .B EXTENSIONS
 below).  If this
-option is omitted in a rule, then matching the rule will have no
+option is omitted in a rule (and
+.B -g
+is not used), then matching the rule will have no
 effect on the packet's fate, but the counters on the rule will be
 incremented.
 .TP
+.BI "-g, --goto " "chain"
+This specifies that the processing should continue in a user
+specified chain. Unlike the --jump option return will not continue
+processing in this chain but instead in the chain that called us via
+--jump.
+.TP
 .BR "-i, --in-interface " "[!] \fIname\fP"
 Name of an interface via which a packet was received (only for
 packets entering the 
diff -urN iptables-1.3.4/iptables.c iptables-1.3.5/iptables.c
--- iptables-1.3.4/iptables.c	2005-10-31 20:03:50.000000000 +0100
+++ iptables-1.3.5/iptables.c	2006-01-30 09:43:09.000000000 +0100
@@ -135,6 +135,7 @@
 	{ "line-numbers", 0, 0, '0' },
 	{ "modprobe", 1, 0, 'M' },
 	{ "set-counters", 1, 0, 'c' },
+	{ "goto", 1, 0, 'g' },
 	{ 0 }
 };
 
@@ -402,6 +403,10 @@
 "				network interface name ([+] for wildcard)\n"
 "  --jump	-j target\n"
 "				target for rule (may load target extension)\n"
+#ifdef IPT_F_GOTO
+"  --goto      -g chain\n"
+"                              jump to chain with no return\n"
+#endif
 "  --match	-m match\n"
 "				extended match (may load extension)\n"
 "  --numeric	-n		numeric output of addresses and ports\n"
@@ -680,7 +685,7 @@
 	}
 
 #ifndef NO_SHARED_LIBS
-	if (!ptr && tryload != DONT_LOAD) {
+	if (!ptr && tryload != DONT_LOAD && tryload != DURING_LOAD) {
 		char path[strlen(lib_dir) + sizeof("/libipt_.so")
 			 + strlen(name)];
 		sprintf(path, "%s/libipt_%s.so", lib_dir, name);
@@ -989,7 +994,7 @@
 	}
 
 #ifndef NO_SHARED_LIBS
-	if (!ptr && tryload != DONT_LOAD) {
+	if (!ptr && tryload != DONT_LOAD && tryload != DURING_LOAD) {
 		char path[strlen(lib_dir) + sizeof("/libipt_.so")
 			 + strlen(name)];
 		sprintf(path, "%s/libipt_%s.so", lib_dir, name);
@@ -1114,7 +1119,7 @@
 		exit(1);
 	}
 
-	old = find_match(me->name, DONT_LOAD, NULL);
+	old = find_match(me->name, DURING_LOAD, NULL);
 	if (old) {
 		if (old->revision == me->revision) {
 			fprintf(stderr,
@@ -1170,7 +1175,7 @@
 		exit(1);
 	}
 
-	old = find_target(me->name, DONT_LOAD);
+	old = find_target(me->name, DURING_LOAD);
 	if (old) {
 		struct iptables_target **i;
 
@@ -1410,6 +1415,11 @@
 	if (format & FMT_NOTABLE)
 		fputs("  ", stdout);
 
+#ifdef IPT_F_GOTO
+	if(fw->ip.flags & IPT_F_GOTO)
+		printf("[goto] ");
+#endif
+
 	IPT_MATCH_ITERATE(fw, print_match, &fw->ip, format & FMT_NUMERIC);
 
 	if (target) {
@@ -1867,7 +1877,7 @@
 	opterr = 0;
 
 	while ((c = getopt_long(argc, argv,
-	   "-A:D:R:I:L::M:F::Z::N:X::E:P:Vh::o:p:s:d:j:i:fbvnt:m:xc:",
+	   "-A:D:R:I:L::M:F::Z::N:X::E:P:Vh::o:p:s:d:j:i:fbvnt:m:xc:g:",
 					   opts, NULL)) != -1) {
 		switch (c) {
 			/*
@@ -2035,6 +2045,15 @@
 			dhostnetworkmask = argv[optind-1];
 			break;
 
+#ifdef IPT_F_GOTO
+		case 'g':
+			set_option(&options, OPT_JUMP, &fw.ip.invflags,
+				   invert);
+			fw.ip.flags |= IPT_F_GOTO;
+			jumpto = parse_target(optarg);
+			break;
+#endif
+
 		case 'j':
 			set_option(&options, OPT_JUMP, &fw.ip.invflags,
 				   invert);
@@ -2377,7 +2396,9 @@
 			target->t = fw_calloc(1, size);
 			target->t->u.target_size = size;
 			strcpy(target->t->u.user.name, jumpto);
-			set_revision(target->t->u.user.name, target->revision);
+			if (!iptc_is_chain(jumpto, *handle))
+				set_revision(target->t->u.user.name,
+					     target->revision);
 			if (target->init != NULL)
 				target->init(target->t, &fw.nfcache);
 		}
@@ -2387,6 +2408,11 @@
 			 * We cannot know if the plugin is corrupt, non
 			 * existant OR if the user just misspelled a
 			 * chain. */
+#ifdef IPT_F_GOTO
+			if (fw.ip.flags & IPT_F_GOTO)
+				exit_error(PARAMETER_PROBLEM,
+					   "goto '%s' is not a chain\n", jumpto);
+#endif
 			find_target(jumpto, LOAD_MUST_SUCCEED);
 		} else {
 			e = generate_entry(&fw, matches, target->t);
diff -urN iptables-1.3.4/libiptc/libiptc.c iptables-1.3.5/libiptc/libiptc.c
--- iptables-1.3.4/libiptc/libiptc.c	2005-10-31 20:03:49.000000000 +0100
+++ iptables-1.3.5/libiptc/libiptc.c	2006-01-30 09:43:09.000000000 +0100
@@ -1,4 +1,4 @@
-/* Library which manipulates firewall rules.  Version $Revision: 4207 $ */
+/* Library which manipulates firewall rules.  Version $Revision: 4511 $ */
 
 /* Architecture of firewall rules is as follows:
  *
@@ -2034,13 +2034,13 @@
 	new_number = iptcc_compile_table_prep(*handle, &new_size);
 	if (new_number < 0) {
 		errno = ENOMEM;
-		return 0;
+		goto out_zero;
 	}
 
 	repl = malloc(sizeof(*repl) + new_size);
 	if (!repl) {
 		errno = ENOMEM;
-		return 0;
+		goto out_zero;
 	}
 	memset(repl, 0, sizeof(*repl) + new_size);
 
@@ -2055,17 +2055,14 @@
 	repl->counters = malloc(sizeof(STRUCT_COUNTERS)
 				* (*handle)->info.num_entries);
 	if (!repl->counters) {
-		free(repl);
 		errno = ENOMEM;
-		return 0;
+		goto out_free_repl;
 	}
 	/* These are the counters we're going to put back, later. */
 	newcounters = malloc(counterlen);
 	if (!newcounters) {
-		free(repl->counters);
-		free(repl);
 		errno = ENOMEM;
-		return 0;
+		goto out_free_repl_counters;
 	}
 	memset(newcounters, 0, counterlen);
 
@@ -2082,9 +2079,7 @@
 	ret = iptcc_compile_table(*handle, repl);
 	if (ret < 0) {
 		errno = ret;
-		free(repl->counters);
-		free(repl);
-		return 0;
+		goto out_free_newcounters;
 	}
 
 
@@ -2099,12 +2094,11 @@
 	}
 #endif
 
-	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_REPLACE, repl,
-		       sizeof(*repl) + repl->size) < 0) {
-		free(repl->counters);
-		free(repl);
-		free(newcounters);
-		return 0;
+	ret = setsockopt(sockfd, TC_IPPROTO, SO_SET_REPLACE, repl,
+			 sizeof(*repl) + repl->size);
+	if (ret < 0) {
+		errno = ret;
+		goto out_free_newcounters;
 	}
 
 	/* Put counters back. */
@@ -2194,21 +2188,29 @@
 	}
 #endif
 
-	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_ADD_COUNTERS,
-		       newcounters, counterlen) < 0) {
-		free(repl->counters);
-		free(repl);
-		free(newcounters);
-		return 0;
+	ret = setsockopt(sockfd, TC_IPPROTO, SO_SET_ADD_COUNTERS,
+			 newcounters, counterlen);
+	if (ret < 0) {
+		errno = ret;
+		goto out_free_newcounters;
 	}
 
 	free(repl->counters);
 	free(repl);
 	free(newcounters);
 
- finished:
+finished:
 	TC_FREE(handle);
 	return 1;
+
+out_free_newcounters:
+	free(newcounters);
+out_free_repl_counters:
+	free(repl->counters);
+out_free_repl:
+	free(repl);
+out_zero:
+	return 0;
 }
 
 /* Get raw socket. */
