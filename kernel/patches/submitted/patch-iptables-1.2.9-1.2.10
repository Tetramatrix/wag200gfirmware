diff -urN iptables-1.2.9/.#iptables.c.1.54 iptables-1.2.10/.#iptables.c.1.54
--- iptables-1.2.9/.#iptables.c.1.54	2003-03-05 08:34:35.000000000 +0100
+++ iptables-1.2.10/.#iptables.c.1.54	1970-01-01 01:00:00.000000000 +0100
@@ -1,2298 +0,0 @@
-/* Code to take an iptables-style command line and do it. */
-
-/*
- * Author: Paul.Russell@rustcorp.com.au and mneuling@radlogic.com.au
- *
- * (C) 2000-2002 by the netfilter coreteam <coreteam@netfilter.org>:
- * 		    Paul 'Rusty' Russell <rusty@rustcorp.com.au>
- * 		    Marc Boucher <marc+nf@mbsi.ca>
- * 		    James Morris <jmorris@intercode.com.au>
- * 		    Harald Welte <laforge@gnumonks.org>
- * 		    Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
- *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
- *
- *	This program is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *	GNU General Public License for more details.
- *
- *	You should have received a copy of the GNU General Public License
- *	along with this program; if not, write to the Free Software
- *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include <getopt.h>
-#include <string.h>
-#include <netdb.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <dlfcn.h>
-#include <ctype.h>
-#include <stdarg.h>
-#include <limits.h>
-#include <unistd.h>
-#include <iptables.h>
-#include <fcntl.h>
-#include <sys/wait.h>
-
-#ifndef TRUE
-#define TRUE 1
-#endif
-#ifndef FALSE
-#define FALSE 0
-#endif
-
-#ifndef IPT_LIB_DIR
-#define IPT_LIB_DIR "/usr/local/lib/iptables"
-#endif
-
-#ifndef PROC_SYS_MODPROBE
-#define PROC_SYS_MODPROBE "/proc/sys/kernel/modprobe"
-#endif
-
-#define FMT_NUMERIC	0x0001
-#define FMT_NOCOUNTS	0x0002
-#define FMT_KILOMEGAGIGA 0x0004
-#define FMT_OPTIONS	0x0008
-#define FMT_NOTABLE	0x0010
-#define FMT_NOTARGET	0x0020
-#define FMT_VIA		0x0040
-#define FMT_NONEWLINE	0x0080
-#define FMT_LINENUMBERS 0x0100
-
-#define FMT_PRINT_RULE (FMT_NOCOUNTS | FMT_OPTIONS | FMT_VIA \
-			| FMT_NUMERIC | FMT_NOTABLE)
-#define FMT(tab,notab) ((format) & FMT_NOTABLE ? (notab) : (tab))
-
-
-#define CMD_NONE		0x0000U
-#define CMD_INSERT		0x0001U
-#define CMD_DELETE		0x0002U
-#define CMD_DELETE_NUM		0x0004U
-#define CMD_REPLACE		0x0008U
-#define CMD_APPEND		0x0010U
-#define CMD_LIST		0x0020U
-#define CMD_FLUSH		0x0040U
-#define CMD_ZERO		0x0080U
-#define CMD_NEW_CHAIN		0x0100U
-#define CMD_DELETE_CHAIN	0x0200U
-#define CMD_SET_POLICY		0x0400U
-#define CMD_CHECK		0x0800U
-#define CMD_RENAME_CHAIN	0x1000U
-#define NUMBER_OF_CMD	13
-static const char cmdflags[] = { 'I', 'D', 'D', 'R', 'A', 'L', 'F', 'Z',
-				 'N', 'X', 'P', 'E' };
-
-#define OPTION_OFFSET 256
-
-#define OPT_NONE	0x00000U
-#define OPT_NUMERIC	0x00001U
-#define OPT_SOURCE	0x00002U
-#define OPT_DESTINATION	0x00004U
-#define OPT_PROTOCOL	0x00008U
-#define OPT_JUMP	0x00010U
-#define OPT_VERBOSE	0x00020U
-#define OPT_EXPANDED	0x00040U
-#define OPT_VIANAMEIN	0x00080U
-#define OPT_VIANAMEOUT	0x00100U
-#define OPT_FRAGMENT    0x00200U
-#define OPT_LINENUMBERS 0x00400U
-#define OPT_COUNTERS	0x00800U
-#define NUMBER_OF_OPT	12
-static const char optflags[NUMBER_OF_OPT]
-= { 'n', 's', 'd', 'p', 'j', 'v', 'x', 'i', 'o', 'f', '3', 'c'};
-
-static struct option original_opts[] = {
-	{ "append", 1, 0, 'A' },
-	{ "delete", 1, 0,  'D' },
-	{ "insert", 1, 0,  'I' },
-	{ "replace", 1, 0,  'R' },
-	{ "list", 2, 0,  'L' },
-	{ "flush", 2, 0,  'F' },
-	{ "zero", 2, 0,  'Z' },
-	{ "new-chain", 1, 0,  'N' },
-	{ "delete-chain", 2, 0,  'X' },
-	{ "rename-chain", 1, 0,  'E' },
-	{ "policy", 1, 0,  'P' },
-	{ "source", 1, 0, 's' },
-	{ "destination", 1, 0,  'd' },
-	{ "src", 1, 0,  's' }, /* synonym */
-	{ "dst", 1, 0,  'd' }, /* synonym */
-	{ "protocol", 1, 0,  'p' },
-	{ "in-interface", 1, 0, 'i' },
-	{ "jump", 1, 0, 'j' },
-	{ "table", 1, 0, 't' },
-	{ "match", 1, 0, 'm' },
-	{ "numeric", 0, 0, 'n' },
-	{ "out-interface", 1, 0, 'o' },
-	{ "verbose", 0, 0, 'v' },
-	{ "exact", 0, 0, 'x' },
-	{ "fragments", 0, 0, 'f' },
-	{ "version", 0, 0, 'V' },
-	{ "help", 2, 0, 'h' },
-	{ "line-numbers", 0, 0, '0' },
-	{ "modprobe", 1, 0, 'M' },
-	{ "set-counters", 1, 0, 'c' },
-	{ 0 }
-};
-
-/* we need this for iptables-restore.  iptables-restore.c sets line to the
- * current line of the input file, in order  to give a more precise error
- * message.  iptables itself doesn't need this, so it is initialized to the
- * magic number of -1 */
-int line = -1;
-
-#ifndef __OPTIMIZE__
-struct ipt_entry_target *
-ipt_get_target(struct ipt_entry *e)
-{
-	return (void *)e + e->target_offset;
-}
-#endif
-
-static struct option *opts = original_opts;
-static unsigned int global_option_offset = 0;
-
-/* Table of legal combinations of commands and options.  If any of the
- * given commands make an option legal, that option is legal (applies to
- * CMD_LIST and CMD_ZERO only).
- * Key:
- *  +  compulsory
- *  x  illegal
- *     optional
- */
-
-static char commands_v_options[NUMBER_OF_CMD][NUMBER_OF_OPT] =
-/* Well, it's better than "Re: Linux vs FreeBSD" */
-{
-	/*     -n  -s  -d  -p  -j  -v  -x  -i  -o  -f  --line */
-/*INSERT*/    {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
-/*DELETE*/    {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
-/*DELETE_NUM*/{'x','x','x','x','x',' ','x','x','x','x','x'},
-/*REPLACE*/   {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
-/*APPEND*/    {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
-/*LIST*/      {' ','x','x','x','x',' ',' ','x','x','x',' '},
-/*FLUSH*/     {'x','x','x','x','x',' ','x','x','x','x','x'},
-/*ZERO*/      {'x','x','x','x','x',' ','x','x','x','x','x'},
-/*NEW_CHAIN*/ {'x','x','x','x','x',' ','x','x','x','x','x'},
-/*DEL_CHAIN*/ {'x','x','x','x','x',' ','x','x','x','x','x'},
-/*SET_POLICY*/{'x','x','x','x','x',' ','x','x','x','x','x'},
-/*CHECK*/     {'x','+','+','+','x',' ','x',' ',' ',' ','x'},
-/*RENAME*/    {'x','x','x','x','x',' ','x','x','x','x','x'}
-};
-
-static int inverse_for_options[NUMBER_OF_OPT] =
-{
-/* -n */ 0,
-/* -s */ IPT_INV_SRCIP,
-/* -d */ IPT_INV_DSTIP,
-/* -p */ IPT_INV_PROTO,
-/* -j */ 0,
-/* -v */ 0,
-/* -x */ 0,
-/* -i */ IPT_INV_VIA_IN,
-/* -o */ IPT_INV_VIA_OUT,
-/* -f */ IPT_INV_FRAG,
-/*--line*/ 0
-};
-
-const char *program_version;
-const char *program_name;
-
-/* Keeping track of external matches and targets: linked lists.  */
-struct iptables_match *iptables_matches = NULL;
-struct iptables_target *iptables_targets = NULL;
-
-/* Extra debugging from libiptc */
-extern void dump_entries(const iptc_handle_t handle);
-
-/* A few hardcoded protocols for 'all' and in case the user has no
-   /etc/protocols */
-struct pprot {
-	char *name;
-	u_int8_t num;
-};
-
-/* Primitive headers... */
-/* defined in netinet/in.h */
-#if 0
-#ifndef IPPROTO_ESP
-#define IPPROTO_ESP 50
-#endif
-#ifndef IPPROTO_AH
-#define IPPROTO_AH 51
-#endif
-#endif
-
-static const struct pprot chain_protos[] = {
-	{ "tcp", IPPROTO_TCP },
-	{ "udp", IPPROTO_UDP },
-	{ "icmp", IPPROTO_ICMP },
-	{ "esp", IPPROTO_ESP },
-	{ "ah", IPPROTO_AH },
-	{ "all", 0 },
-};
-
-static char *
-proto_to_name(u_int8_t proto, int nolookup)
-{
-	unsigned int i;
-
-	if (proto && !nolookup) {
-		struct protoent *pent = getprotobynumber(proto);
-		if (pent)
-			return pent->p_name;
-	}
-
-	for (i = 0; i < sizeof(chain_protos)/sizeof(struct pprot); i++)
-		if (chain_protos[i].num == proto)
-			return chain_protos[i].name;
-
-	return NULL;
-}
-
-struct in_addr *
-dotted_to_addr(const char *dotted)
-{
-	static struct in_addr addr;
-	unsigned char *addrp;
-	char *p, *q;
-	unsigned int onebyte;
-	int i;
-	char buf[20];
-
-	/* copy dotted string, because we need to modify it */
-	strncpy(buf, dotted, sizeof(buf) - 1);
-	addrp = (unsigned char *) &(addr.s_addr);
-
-	p = buf;
-	for (i = 0; i < 3; i++) {
-		if ((q = strchr(p, '.')) == NULL)
-			return (struct in_addr *) NULL;
-
-		*q = '\0';
-		if (string_to_number(p, 0, 255, &onebyte) == -1)
-			return (struct in_addr *) NULL;
-
-		addrp[i] = (unsigned char) onebyte;
-		p = q + 1;
-	}
-
-	/* we've checked 3 bytes, now we check the last one */
-	if (string_to_number(p, 0, 255, &onebyte) == -1)
-		return (struct in_addr *) NULL;
-
-	addrp[3] = (unsigned char) onebyte;
-
-	return &addr;
-}
-
-static struct in_addr *
-network_to_addr(const char *name)
-{
-	struct netent *net;
-	static struct in_addr addr;
-
-	if ((net = getnetbyname(name)) != NULL) {
-		if (net->n_addrtype != AF_INET)
-			return (struct in_addr *) NULL;
-		addr.s_addr = htonl((unsigned long) net->n_net);
-		return &addr;
-	}
-
-	return (struct in_addr *) NULL;
-}
-
-static void
-inaddrcpy(struct in_addr *dst, struct in_addr *src)
-{
-	/* memcpy(dst, src, sizeof(struct in_addr)); */
-	dst->s_addr = src->s_addr;
-}
-
-void
-exit_error(enum exittype status, char *msg, ...)
-{
-	va_list args;
-
-	va_start(args, msg);
-	fprintf(stderr, "%s v%s: ", program_name, program_version);
-	vfprintf(stderr, msg, args);
-	va_end(args);
-	fprintf(stderr, "\n");
-	if (status == PARAMETER_PROBLEM)
-		exit_tryhelp(status);
-	if (status == VERSION_PROBLEM)
-		fprintf(stderr,
-			"Perhaps iptables or your kernel needs to be upgraded.\n");
-	exit(status);
-}
-
-void
-exit_tryhelp(int status)
-{
-	if (line != -1)
-		fprintf(stderr, "Error occurred at line: %d\n", line);
-	fprintf(stderr, "Try `%s -h' or '%s --help' for more information.\n",
-			program_name, program_name );
-	exit(status);
-}
-
-void
-exit_printhelp(void)
-{
-	struct iptables_match *m = NULL;
-	struct iptables_target *t = NULL;
-
-	printf("%s v%s\n\n"
-"Usage: %s -[AD] chain rule-specification [options]\n"
-"       %s -[RI] chain rulenum rule-specification [options]\n"
-"       %s -D chain rulenum [options]\n"
-"       %s -[LFZ] [chain] [options]\n"
-"       %s -[NX] chain\n"
-"       %s -E old-chain-name new-chain-name\n"
-"       %s -P chain target [options]\n"
-"       %s -h (print this help information)\n\n",
-	       program_name, program_version, program_name, program_name,
-	       program_name, program_name, program_name, program_name,
-	       program_name, program_name);
-
-	printf(
-"Commands:\n"
-"Either long or short options are allowed.\n"
-"  --append  -A chain		Append to chain\n"
-"  --delete  -D chain		Delete matching rule from chain\n"
-"  --delete  -D chain rulenum\n"
-"				Delete rule rulenum (1 = first) from chain\n"
-"  --insert  -I chain [rulenum]\n"
-"				Insert in chain as rulenum (default 1=first)\n"
-"  --replace -R chain rulenum\n"
-"				Replace rule rulenum (1 = first) in chain\n"
-"  --list    -L [chain]		List the rules in a chain or all chains\n"
-"  --flush   -F [chain]		Delete all rules in  chain or all chains\n"
-"  --zero    -Z [chain]		Zero counters in chain or all chains\n"
-"  --new     -N chain		Create a new user-defined chain\n"
-"  --delete-chain\n"
-"            -X [chain]		Delete a user-defined chain\n"
-"  --policy  -P chain target\n"
-"				Change policy on chain to target\n"
-"  --rename-chain\n"
-"            -E old-chain new-chain\n"
-"				Change chain name, (moving any references)\n"
-
-"Options:\n"
-"  --proto	-p [!] proto	protocol: by number or name, eg. `tcp'\n"
-"  --source	-s [!] address[/mask]\n"
-"				source specification\n"
-"  --destination -d [!] address[/mask]\n"
-"				destination specification\n"
-"  --in-interface -i [!] input name[+]\n"
-"				network interface name ([+] for wildcard)\n"
-"  --jump	-j target\n"
-"				target for rule (may load target extension)\n"
-"  --match	-m match\n"
-"				extended match (may load extension)\n"
-"  --numeric	-n		numeric output of addresses and ports\n"
-"  --out-interface -o [!] output name[+]\n"
-"				network interface name ([+] for wildcard)\n"
-"  --table	-t table	table to manipulate (default: `filter')\n"
-"  --verbose	-v		verbose mode\n"
-"  --line-numbers		print line numbers when listing\n"
-"  --exact	-x		expand numbers (display exact values)\n"
-"[!] --fragment	-f		match second or further fragments only\n"
-"  --modprobe=<command>		try to insert modules using this command\n"
-"  --set-counters PKTS BYTES	set the counter during insert/append\n"
-"[!] --version	-V		print package version.\n");
-
-	/* Print out any special helps. A user might like to be able
-	   to add a --help to the commandline, and see expected
-	   results. So we call help for all matches & targets */
-	for (t=iptables_targets;t;t=t->next) {
-		printf("\n");
-		t->help();
-	}
-	for (m=iptables_matches;m;m=m->next) {
-		printf("\n");
-		m->help();
-	}
-	exit(0);
-}
-
-static void
-generic_opt_check(int command, int options)
-{
-	int i, j, legal = 0;
-
-	/* Check that commands are valid with options.  Complicated by the
-	 * fact that if an option is legal with *any* command given, it is
-	 * legal overall (ie. -z and -l).
-	 */
-	for (i = 0; i < NUMBER_OF_OPT; i++) {
-		legal = 0; /* -1 => illegal, 1 => legal, 0 => undecided. */
-
-		for (j = 0; j < NUMBER_OF_CMD; j++) {
-			if (!(command & (1<<j)))
-				continue;
-
-			if (!(options & (1<<i))) {
-				if (commands_v_options[j][i] == '+')
-					exit_error(PARAMETER_PROBLEM,
-						   "You need to supply the `-%c' "
-						   "option for this command\n",
-						   optflags[i]);
-			} else {
-				if (commands_v_options[j][i] != 'x')
-					legal = 1;
-				else if (legal == 0)
-					legal = -1;
-			}
-		}
-		if (legal == -1)
-			exit_error(PARAMETER_PROBLEM,
-				   "Illegal option `-%c' with this command\n",
-				   optflags[i]);
-	}
-}
-
-static char
-opt2char(int option)
-{
-	const char *ptr;
-	for (ptr = optflags; option > 1; option >>= 1, ptr++);
-
-	return *ptr;
-}
-
-static char
-cmd2char(int option)
-{
-	const char *ptr;
-	for (ptr = cmdflags; option > 1; option >>= 1, ptr++);
-
-	return *ptr;
-}
-
-static void
-add_command(int *cmd, const int newcmd, const int othercmds, int invert)
-{
-	if (invert)
-		exit_error(PARAMETER_PROBLEM, "unexpected ! flag");
-	if (*cmd & (~othercmds))
-		exit_error(PARAMETER_PROBLEM, "Can't use -%c with -%c\n",
-			   cmd2char(newcmd), cmd2char(*cmd & (~othercmds)));
-	*cmd |= newcmd;
-}
-
-int
-check_inverse(const char option[], int *invert, int *optind, int argc)
-{
-	if (option && strcmp(option, "!") == 0) {
-		if (*invert)
-			exit_error(PARAMETER_PROBLEM,
-				   "Multiple `!' flags not allowed");
-		*invert = TRUE;
-		if (optind) {
-			*optind = *optind+1;
-			if (argc && *optind > argc)
-				exit_error(PARAMETER_PROBLEM,
-					   "no argument following `!'");
-		}
-
-		return TRUE;
-	}
-	return FALSE;
-}
-
-static void *
-fw_calloc(size_t count, size_t size)
-{
-	void *p;
-
-	if ((p = calloc(count, size)) == NULL) {
-		perror("iptables: calloc failed");
-		exit(1);
-	}
-	return p;
-}
-
-static void *
-fw_malloc(size_t size)
-{
-	void *p;
-
-	if ((p = malloc(size)) == NULL) {
-		perror("iptables: malloc failed");
-		exit(1);
-	}
-	return p;
-}
-
-static struct in_addr *
-host_to_addr(const char *name, unsigned int *naddr)
-{
-	struct hostent *host;
-	struct in_addr *addr;
-	unsigned int i;
-
-	*naddr = 0;
-	if ((host = gethostbyname(name)) != NULL) {
-		if (host->h_addrtype != AF_INET ||
-		    host->h_length != sizeof(struct in_addr))
-			return (struct in_addr *) NULL;
-
-		while (host->h_addr_list[*naddr] != (char *) NULL)
-			(*naddr)++;
-		addr = fw_calloc(*naddr, sizeof(struct in_addr));
-		for (i = 0; i < *naddr; i++)
-			inaddrcpy(&(addr[i]),
-				  (struct in_addr *) host->h_addr_list[i]);
-		return addr;
-	}
-
-	return (struct in_addr *) NULL;
-}
-
-static char *
-addr_to_host(const struct in_addr *addr)
-{
-	struct hostent *host;
-
-	if ((host = gethostbyaddr((char *) addr,
-				  sizeof(struct in_addr), AF_INET)) != NULL)
-		return (char *) host->h_name;
-
-	return (char *) NULL;
-}
-
-/*
- *	All functions starting with "parse" should succeed, otherwise
- *	the program fails.
- *	Most routines return pointers to static data that may change
- *	between calls to the same or other routines with a few exceptions:
- *	"host_to_addr", "parse_hostnetwork", and "parse_hostnetworkmask"
- *	return global static data.
-*/
-
-static struct in_addr *
-parse_hostnetwork(const char *name, unsigned int *naddrs)
-{
-	struct in_addr *addrp, *addrptmp;
-
-	if ((addrptmp = dotted_to_addr(name)) != NULL ||
-	    (addrptmp = network_to_addr(name)) != NULL) {
-		addrp = fw_malloc(sizeof(struct in_addr));
-		inaddrcpy(addrp, addrptmp);
-		*naddrs = 1;
-		return addrp;
-	}
-	if ((addrp = host_to_addr(name, naddrs)) != NULL)
-		return addrp;
-
-	exit_error(PARAMETER_PROBLEM, "host/network `%s' not found", name);
-}
-
-static struct in_addr *
-parse_mask(char *mask)
-{
-	static struct in_addr maskaddr;
-	struct in_addr *addrp;
-	unsigned int bits;
-
-	if (mask == NULL) {
-		/* no mask at all defaults to 32 bits */
-		maskaddr.s_addr = 0xFFFFFFFF;
-		return &maskaddr;
-	}
-	if ((addrp = dotted_to_addr(mask)) != NULL)
-		/* dotted_to_addr already returns a network byte order addr */
-		return addrp;
-	if (string_to_number(mask, 0, 32, &bits) == -1)
-		exit_error(PARAMETER_PROBLEM,
-			   "invalid mask `%s' specified", mask);
-	if (bits != 0) {
-		maskaddr.s_addr = htonl(0xFFFFFFFF << (32 - bits));
-		return &maskaddr;
-	}
-
-	maskaddr.s_addr = 0L;
-	return &maskaddr;
-}
-
-void
-parse_hostnetworkmask(const char *name, struct in_addr **addrpp,
-		      struct in_addr *maskp, unsigned int *naddrs)
-{
-	struct in_addr *addrp;
-	char buf[256];
-	char *p;
-	int i, j, k, n;
-
-	strncpy(buf, name, sizeof(buf) - 1);
-	if ((p = strrchr(buf, '/')) != NULL) {
-		*p = '\0';
-		addrp = parse_mask(p + 1);
-	} else
-		addrp = parse_mask(NULL);
-	inaddrcpy(maskp, addrp);
-
-	/* if a null mask is given, the name is ignored, like in "any/0" */
-	if (maskp->s_addr == 0L)
-		strcpy(buf, "0.0.0.0");
-
-	addrp = *addrpp = parse_hostnetwork(buf, naddrs);
-	n = *naddrs;
-	for (i = 0, j = 0; i < n; i++) {
-		addrp[j++].s_addr &= maskp->s_addr;
-		for (k = 0; k < j - 1; k++) {
-			if (addrp[k].s_addr == addrp[j - 1].s_addr) {
-				(*naddrs)--;
-				j--;
-				break;
-			}
-		}
-	}
-}
-
-struct iptables_match *
-find_match(const char *name, enum ipt_tryload tryload)
-{
-	struct iptables_match *ptr;
-
-	for (ptr = iptables_matches; ptr; ptr = ptr->next) {
-		if (strcmp(name, ptr->name) == 0)
-			break;
-	}
-
-#ifndef NO_SHARED_LIBS
-	if (!ptr && tryload != DONT_LOAD) {
-		char path[sizeof(IPT_LIB_DIR) + sizeof("/libipt_.so")
-			 + strlen(name)];
-		sprintf(path, IPT_LIB_DIR "/libipt_%s.so", name);
-		if (dlopen(path, RTLD_NOW)) {
-			/* Found library.  If it didn't register itself,
-			   maybe they specified target as match. */
-			ptr = find_match(name, DONT_LOAD);
-
-			if (!ptr)
-				exit_error(PARAMETER_PROBLEM,
-					   "Couldn't load match `%s'\n",
-					   name);
-		} else if (tryload == LOAD_MUST_SUCCEED)
-			exit_error(PARAMETER_PROBLEM,
-				   "Couldn't load match `%s':%s\n",
-				   name, dlerror());
-	}
-#else
-	if (ptr && !ptr->loaded) {
-		if (tryload != DONT_LOAD)
-			ptr->loaded = 1;
-		else
-			ptr = NULL;
-	}
-	if(!ptr && (tryload == LOAD_MUST_SUCCEED)) {
-		exit_error(PARAMETER_PROBLEM,
-			   "Couldn't find match `%s'\n", name);
-	}
-#endif
-
-	if (ptr)
-		ptr->used = 1;
-
-	return ptr;
-}
-
-/* Christophe Burki wants `-p 6' to imply `-m tcp'.  */
-static struct iptables_match *
-find_proto(const char *pname, enum ipt_tryload tryload, int nolookup)
-{
-	unsigned int proto;
-
-	if (string_to_number(pname, 0, 255, &proto) != -1) {
-		char *protoname = proto_to_name(proto, nolookup);
-
-		if (protoname)
-			return find_match(protoname, tryload);
-	} else
-		return find_match(pname, tryload);
-
-	return NULL;
-}
-
-u_int16_t
-parse_protocol(const char *s)
-{
-	unsigned int proto;
-
-	if (string_to_number(s, 0, 255, &proto) == -1) {
-		struct protoent *pent;
-
-		if ((pent = getprotobyname(s)))
-			proto = pent->p_proto;
-		else {
-			unsigned int i;
-			for (i = 0;
-			     i < sizeof(chain_protos)/sizeof(struct pprot);
-			     i++) {
-				if (strcmp(s, chain_protos[i].name) == 0) {
-					proto = chain_protos[i].num;
-					break;
-				}
-			}
-			if (i == sizeof(chain_protos)/sizeof(struct pprot))
-				exit_error(PARAMETER_PROBLEM,
-					   "unknown protocol `%s' specified",
-					   s);
-		}
-	}
-
-	return (u_int16_t)proto;
-}
-
-static void
-parse_interface(const char *arg, char *vianame, unsigned char *mask)
-{
-	int vialen = strlen(arg);
-	unsigned int i;
-
-	memset(mask, 0, IFNAMSIZ);
-	memset(vianame, 0, IFNAMSIZ);
-
-	if (vialen + 1 > IFNAMSIZ)
-		exit_error(PARAMETER_PROBLEM,
-			   "interface name `%s' must be shorter than IFNAMSIZ"
-			   " (%i)", arg, IFNAMSIZ-1);
-
-	strcpy(vianame, arg);
-	if (vialen == 0)
-		memset(mask, 0, IFNAMSIZ);
-	else if (vianame[vialen - 1] == '+') {
-		memset(mask, 0xFF, vialen - 1);
-		memset(mask + vialen - 1, 0, IFNAMSIZ - vialen + 1);
-		/* Don't remove `+' here! -HW */
-	} else {
-		/* Include nul-terminator in match */
-		memset(mask, 0xFF, vialen + 1);
-		memset(mask + vialen + 1, 0, IFNAMSIZ - vialen - 1);
-		for (i = 0; vianame[i]; i++) {
-			if (!isalnum(vianame[i]) 
-			    && vianame[i] != '_' 
-			    && vianame[i] != '.') {
-				printf("Warning: wierd character in interface"
-				       " `%s' (No aliases, :, ! or *).\n",
-				       vianame);
-				break;
-			}
-		}
-	}
-}
-
-/* Can't be zero. */
-static int
-parse_rulenumber(const char *rule)
-{
-	unsigned int rulenum;
-
-	if (string_to_number(rule, 1, INT_MAX, &rulenum) == -1)
-		exit_error(PARAMETER_PROBLEM,
-			   "Invalid rule number `%s'", rule);
-
-	return rulenum;
-}
-
-static const char *
-parse_target(const char *targetname)
-{
-	const char *ptr;
-
-	if (strlen(targetname) < 1)
-		exit_error(PARAMETER_PROBLEM,
-			   "Invalid target name (too short)");
-
-	if (strlen(targetname)+1 > sizeof(ipt_chainlabel))
-		exit_error(PARAMETER_PROBLEM,
-			   "Invalid target name `%s' (%i chars max)",
-			   targetname, sizeof(ipt_chainlabel)-1);
-
-	for (ptr = targetname; *ptr; ptr++)
-		if (isspace(*ptr))
-			exit_error(PARAMETER_PROBLEM,
-				   "Invalid target name `%s'", targetname);
-	return targetname;
-}
-
-static char *
-addr_to_network(const struct in_addr *addr)
-{
-	struct netent *net;
-
-	if ((net = getnetbyaddr((long) ntohl(addr->s_addr), AF_INET)) != NULL)
-		return (char *) net->n_name;
-
-	return (char *) NULL;
-}
-
-char *
-addr_to_dotted(const struct in_addr *addrp)
-{
-	static char buf[20];
-	const unsigned char *bytep;
-
-	bytep = (const unsigned char *) &(addrp->s_addr);
-	sprintf(buf, "%d.%d.%d.%d", bytep[0], bytep[1], bytep[2], bytep[3]);
-	return buf;
-}
-
-char *
-addr_to_anyname(const struct in_addr *addr)
-{
-	char *name;
-
-	if ((name = addr_to_host(addr)) != NULL ||
-	    (name = addr_to_network(addr)) != NULL)
-		return name;
-
-	return addr_to_dotted(addr);
-}
-
-char *
-mask_to_dotted(const struct in_addr *mask)
-{
-	int i;
-	static char buf[20];
-	u_int32_t maskaddr, bits;
-
-	maskaddr = ntohl(mask->s_addr);
-
-	if (maskaddr == 0xFFFFFFFFL)
-		/* we don't want to see "/32" */
-		return "";
-
-	i = 32;
-	bits = 0xFFFFFFFEL;
-	while (--i >= 0 && maskaddr != bits)
-		bits <<= 1;
-	if (i >= 0)
-		sprintf(buf, "/%d", i);
-	else
-		/* mask was not a decent combination of 1's and 0's */
-		sprintf(buf, "/%s", addr_to_dotted(mask));
-
-	return buf;
-}
-
-int
-string_to_number(const char *s, unsigned int min, unsigned int max,
-		 unsigned int *ret)
-{
-	long number;
-	char *end;
-
-	/* Handle hex, octal, etc. */
-	errno = 0;
-	number = strtol(s, &end, 0);
-	if (*end == '\0' && end != s) {
-		/* we parsed a number, let's see if we want this */
-		if (errno != ERANGE && min <= number && number <= max) {
-			*ret = number;
-			return 0;
-		}
-	}
-	return -1;
-}
-
-static void
-set_option(unsigned int *options, unsigned int option, u_int8_t *invflg,
-	   int invert)
-{
-	if (*options & option)
-		exit_error(PARAMETER_PROBLEM, "multiple -%c flags not allowed",
-			   opt2char(option));
-	*options |= option;
-
-	if (invert) {
-		unsigned int i;
-		for (i = 0; 1 << i != option; i++);
-
-		if (!inverse_for_options[i])
-			exit_error(PARAMETER_PROBLEM,
-				   "cannot have ! before -%c",
-				   opt2char(option));
-		*invflg |= inverse_for_options[i];
-	}
-}
-
-struct iptables_target *
-find_target(const char *name, enum ipt_tryload tryload)
-{
-	struct iptables_target *ptr;
-
-	/* Standard target? */
-	if (strcmp(name, "") == 0
-	    || strcmp(name, IPTC_LABEL_ACCEPT) == 0
-	    || strcmp(name, IPTC_LABEL_DROP) == 0
-	    || strcmp(name, IPTC_LABEL_QUEUE) == 0
-	    || strcmp(name, IPTC_LABEL_RETURN) == 0)
-		name = "standard";
-
-	for (ptr = iptables_targets; ptr; ptr = ptr->next) {
-		if (strcmp(name, ptr->name) == 0)
-			break;
-	}
-
-#ifndef NO_SHARED_LIBS
-	if (!ptr && tryload != DONT_LOAD) {
-		char path[sizeof(IPT_LIB_DIR) + sizeof("/libipt_.so")
-			 + strlen(name)];
-		sprintf(path, IPT_LIB_DIR "/libipt_%s.so", name);
-		if (dlopen(path, RTLD_NOW)) {
-			/* Found library.  If it didn't register itself,
-			   maybe they specified match as a target. */
-			ptr = find_target(name, DONT_LOAD);
-			if (!ptr)
-				exit_error(PARAMETER_PROBLEM,
-					   "Couldn't load target `%s'\n",
-					   name);
-		} else if (tryload == LOAD_MUST_SUCCEED)
-			exit_error(PARAMETER_PROBLEM,
-				   "Couldn't load target `%s':%s\n",
-				   name, dlerror());
-	}
-#else
-	if (ptr && !ptr->loaded) {
-		if (tryload != DONT_LOAD)
-			ptr->loaded = 1;
-		else
-			ptr = NULL;
-	}
-	if(!ptr && (tryload == LOAD_MUST_SUCCEED)) {
-		exit_error(PARAMETER_PROBLEM,
-			   "Couldn't find target `%s'\n", name);
-	}
-#endif
-
-	if (ptr)
-		ptr->used = 1;
-
-	return ptr;
-}
-
-static struct option *
-merge_options(struct option *oldopts, const struct option *newopts,
-	      unsigned int *option_offset)
-{
-	unsigned int num_old, num_new, i;
-	struct option *merge;
-
-	for (num_old = 0; oldopts[num_old].name; num_old++);
-	for (num_new = 0; newopts[num_new].name; num_new++);
-
-	global_option_offset += OPTION_OFFSET;
-	*option_offset = global_option_offset;
-
-	merge = malloc(sizeof(struct option) * (num_new + num_old + 1));
-	memcpy(merge, oldopts, num_old * sizeof(struct option));
-	for (i = 0; i < num_new; i++) {
-		merge[num_old + i] = newopts[i];
-		merge[num_old + i].val += *option_offset;
-	}
-	memset(merge + num_old + num_new, 0, sizeof(struct option));
-
-	return merge;
-}
-
-void
-register_match(struct iptables_match *me)
-{
-	struct iptables_match **i;
-
-	if (strcmp(me->version, program_version) != 0) {
-		fprintf(stderr, "%s: match `%s' v%s (I'm v%s).\n",
-			program_name, me->name, me->version, program_version);
-		exit(1);
-	}
-
-	if (find_match(me->name, DONT_LOAD)) {
-		fprintf(stderr, "%s: match `%s' already registered.\n",
-			program_name, me->name);
-		exit(1);
-	}
-
-	if (me->size != IPT_ALIGN(me->size)) {
-		fprintf(stderr, "%s: match `%s' has invalid size %u.\n",
-			program_name, me->name, me->size);
-		exit(1);
-	}
-
-	/* Append to list. */
-	for (i = &iptables_matches; *i; i = &(*i)->next);
-	me->next = NULL;
-	*i = me;
-
-	me->m = NULL;
-	me->mflags = 0;
-}
-
-void
-register_target(struct iptables_target *me)
-{
-	if (strcmp(me->version, program_version) != 0) {
-		fprintf(stderr, "%s: target `%s' v%s (I'm v%s).\n",
-			program_name, me->name, me->version, program_version);
-		exit(1);
-	}
-
-	if (find_target(me->name, DONT_LOAD)) {
-		fprintf(stderr, "%s: target `%s' already registered.\n",
-			program_name, me->name);
-		exit(1);
-	}
-
-	if (me->size != IPT_ALIGN(me->size)) {
-		fprintf(stderr, "%s: target `%s' has invalid size %u.\n",
-			program_name, me->name, me->size);
-		exit(1);
-	}
-
-	/* Prepend to list. */
-	me->next = iptables_targets;
-	iptables_targets = me;
-	me->t = NULL;
-	me->tflags = 0;
-}
-
-static void
-print_num(u_int64_t number, unsigned int format)
-{
-	if (format & FMT_KILOMEGAGIGA) {
-		if (number > 99999) {
-			number = (number + 500) / 1000;
-			if (number > 9999) {
-				number = (number + 500) / 1000;
-				if (number > 9999) {
-					number = (number + 500) / 1000;
-					if (number > 9999) {
-						number = (number + 500) / 1000;
-						printf(FMT("%4lluT ","%lluT "), number);
-					}
-					else printf(FMT("%4lluG ","%lluG "), number);
-				}
-				else printf(FMT("%4lluM ","%lluM "), number);
-			} else
-				printf(FMT("%4lluK ","%lluK "), number);
-		} else
-			printf(FMT("%5llu ","%llu "), number);
-	} else
-		printf(FMT("%8llu ","%llu "), number);
-}
-
-
-static void
-print_header(unsigned int format, const char *chain, iptc_handle_t *handle)
-{
-	struct ipt_counters counters;
-	const char *pol = iptc_get_policy(chain, &counters, handle);
-	printf("Chain %s", chain);
-	if (pol) {
-		printf(" (policy %s", pol);
-		if (!(format & FMT_NOCOUNTS)) {
-			fputc(' ', stdout);
-			print_num(counters.pcnt, (format|FMT_NOTABLE));
-			fputs("packets, ", stdout);
-			print_num(counters.bcnt, (format|FMT_NOTABLE));
-			fputs("bytes", stdout);
-		}
-		printf(")\n");
-	} else {
-		unsigned int refs;
-		if (!iptc_get_references(&refs, chain, handle))
-			printf(" (ERROR obtaining refs)\n");
-		else
-			printf(" (%u references)\n", refs);
-	}
-
-	if (format & FMT_LINENUMBERS)
-		printf(FMT("%-4s ", "%s "), "num");
-	if (!(format & FMT_NOCOUNTS)) {
-		if (format & FMT_KILOMEGAGIGA) {
-			printf(FMT("%5s ","%s "), "pkts");
-			printf(FMT("%5s ","%s "), "bytes");
-		} else {
-			printf(FMT("%8s ","%s "), "pkts");
-			printf(FMT("%10s ","%s "), "bytes");
-		}
-	}
-	if (!(format & FMT_NOTARGET))
-		printf(FMT("%-9s ","%s "), "target");
-	fputs(" prot ", stdout);
-	if (format & FMT_OPTIONS)
-		fputs("opt", stdout);
-	if (format & FMT_VIA) {
-		printf(FMT(" %-6s ","%s "), "in");
-		printf(FMT("%-6s ","%s "), "out");
-	}
-	printf(FMT(" %-19s ","%s "), "source");
-	printf(FMT(" %-19s "," %s "), "destination");
-	printf("\n");
-}
-
-
-static int
-print_match(const struct ipt_entry_match *m,
-	    const struct ipt_ip *ip,
-	    int numeric)
-{
-	struct iptables_match *match = find_match(m->u.user.name, TRY_LOAD);
-
-	if (match) {
-		if (match->print)
-			match->print(ip, m, numeric);
-		else
-			printf("%s ", match->name);
-	} else {
-		if (m->u.user.name[0])
-			printf("UNKNOWN match `%s' ", m->u.user.name);
-	}
-	/* Don't stop iterating. */
-	return 0;
-}
-
-/* e is called `fw' here for hysterical raisins */
-static void
-print_firewall(const struct ipt_entry *fw,
-	       const char *targname,
-	       unsigned int num,
-	       unsigned int format,
-	       const iptc_handle_t handle)
-{
-	struct iptables_target *target = NULL;
-	const struct ipt_entry_target *t;
-	u_int8_t flags;
-	char buf[BUFSIZ];
-
-	if (!iptc_is_chain(targname, handle))
-		target = find_target(targname, TRY_LOAD);
-	else
-		target = find_target(IPT_STANDARD_TARGET, LOAD_MUST_SUCCEED);
-
-	t = ipt_get_target((struct ipt_entry *)fw);
-	flags = fw->ip.flags;
-
-	if (format & FMT_LINENUMBERS)
-		printf(FMT("%-4u ", "%u "), num+1);
-
-	if (!(format & FMT_NOCOUNTS)) {
-		print_num(fw->counters.pcnt, format);
-		print_num(fw->counters.bcnt, format);
-	}
-
-	if (!(format & FMT_NOTARGET))
-		printf(FMT("%-9s ", "%s "), targname);
-
-	fputc(fw->ip.invflags & IPT_INV_PROTO ? '!' : ' ', stdout);
-	{
-		char *pname = proto_to_name(fw->ip.proto, format&FMT_NUMERIC);
-		if (pname)
-			printf(FMT("%-5s", "%s "), pname);
-		else
-			printf(FMT("%-5hu", "%hu "), fw->ip.proto);
-	}
-
-	if (format & FMT_OPTIONS) {
-		if (format & FMT_NOTABLE)
-			fputs("opt ", stdout);
-		fputc(fw->ip.invflags & IPT_INV_FRAG ? '!' : '-', stdout);
-		fputc(flags & IPT_F_FRAG ? 'f' : '-', stdout);
-		fputc(' ', stdout);
-	}
-
-	if (format & FMT_VIA) {
-		char iface[IFNAMSIZ+2];
-
-		if (fw->ip.invflags & IPT_INV_VIA_IN) {
-			iface[0] = '!';
-			iface[1] = '\0';
-		}
-		else iface[0] = '\0';
-
-		if (fw->ip.iniface[0] != '\0') {
-			strcat(iface, fw->ip.iniface);
-		}
-		else if (format & FMT_NUMERIC) strcat(iface, "*");
-		else strcat(iface, "any");
-		printf(FMT(" %-6s ","in %s "), iface);
-
-		if (fw->ip.invflags & IPT_INV_VIA_OUT) {
-			iface[0] = '!';
-			iface[1] = '\0';
-		}
-		else iface[0] = '\0';
-
-		if (fw->ip.outiface[0] != '\0') {
-			strcat(iface, fw->ip.outiface);
-		}
-		else if (format & FMT_NUMERIC) strcat(iface, "*");
-		else strcat(iface, "any");
-		printf(FMT("%-6s ","out %s "), iface);
-	}
-
-	fputc(fw->ip.invflags & IPT_INV_SRCIP ? '!' : ' ', stdout);
-	if (fw->ip.smsk.s_addr == 0L && !(format & FMT_NUMERIC))
-		printf(FMT("%-19s ","%s "), "anywhere");
-	else {
-		if (format & FMT_NUMERIC)
-			sprintf(buf, "%s", addr_to_dotted(&(fw->ip.src)));
-		else
-			sprintf(buf, "%s", addr_to_anyname(&(fw->ip.src)));
-		strcat(buf, mask_to_dotted(&(fw->ip.smsk)));
-		printf(FMT("%-19s ","%s "), buf);
-	}
-
-	fputc(fw->ip.invflags & IPT_INV_DSTIP ? '!' : ' ', stdout);
-	if (fw->ip.dmsk.s_addr == 0L && !(format & FMT_NUMERIC))
-		printf(FMT("%-19s","-> %s"), "anywhere");
-	else {
-		if (format & FMT_NUMERIC)
-			sprintf(buf, "%s", addr_to_dotted(&(fw->ip.dst)));
-		else
-			sprintf(buf, "%s", addr_to_anyname(&(fw->ip.dst)));
-		strcat(buf, mask_to_dotted(&(fw->ip.dmsk)));
-		printf(FMT("%-19s","-> %s"), buf);
-	}
-
-	if (format & FMT_NOTABLE)
-		fputs("  ", stdout);
-
-	IPT_MATCH_ITERATE(fw, print_match, &fw->ip, format & FMT_NUMERIC);
-
-	if (target) {
-		if (target->print)
-			/* Print the target information. */
-			target->print(&fw->ip, t, format & FMT_NUMERIC);
-	} else if (t->u.target_size != sizeof(*t))
-		printf("[%u bytes of unknown target data] ",
-		       t->u.target_size - sizeof(*t));
-
-	if (!(format & FMT_NONEWLINE))
-		fputc('\n', stdout);
-}
-
-static void
-print_firewall_line(const struct ipt_entry *fw,
-		    const iptc_handle_t h)
-{
-	struct ipt_entry_target *t;
-
-	t = ipt_get_target((struct ipt_entry *)fw);
-	print_firewall(fw, t->u.user.name, 0, FMT_PRINT_RULE, h);
-}
-
-static int
-append_entry(const ipt_chainlabel chain,
-	     struct ipt_entry *fw,
-	     unsigned int nsaddrs,
-	     const struct in_addr saddrs[],
-	     unsigned int ndaddrs,
-	     const struct in_addr daddrs[],
-	     int verbose,
-	     iptc_handle_t *handle)
-{
-	unsigned int i, j;
-	int ret = 1;
-
-	for (i = 0; i < nsaddrs; i++) {
-		fw->ip.src.s_addr = saddrs[i].s_addr;
-		for (j = 0; j < ndaddrs; j++) {
-			fw->ip.dst.s_addr = daddrs[j].s_addr;
-			if (verbose)
-				print_firewall_line(fw, *handle);
-			ret &= iptc_append_entry(chain, fw, handle);
-		}
-	}
-
-	return ret;
-}
-
-static int
-replace_entry(const ipt_chainlabel chain,
-	      struct ipt_entry *fw,
-	      unsigned int rulenum,
-	      const struct in_addr *saddr,
-	      const struct in_addr *daddr,
-	      int verbose,
-	      iptc_handle_t *handle)
-{
-	fw->ip.src.s_addr = saddr->s_addr;
-	fw->ip.dst.s_addr = daddr->s_addr;
-
-	if (verbose)
-		print_firewall_line(fw, *handle);
-	return iptc_replace_entry(chain, fw, rulenum, handle);
-}
-
-static int
-insert_entry(const ipt_chainlabel chain,
-	     struct ipt_entry *fw,
-	     unsigned int rulenum,
-	     unsigned int nsaddrs,
-	     const struct in_addr saddrs[],
-	     unsigned int ndaddrs,
-	     const struct in_addr daddrs[],
-	     int verbose,
-	     iptc_handle_t *handle)
-{
-	unsigned int i, j;
-	int ret = 1;
-
-	for (i = 0; i < nsaddrs; i++) {
-		fw->ip.src.s_addr = saddrs[i].s_addr;
-		for (j = 0; j < ndaddrs; j++) {
-			fw->ip.dst.s_addr = daddrs[j].s_addr;
-			if (verbose)
-				print_firewall_line(fw, *handle);
-			ret &= iptc_insert_entry(chain, fw, rulenum, handle);
-		}
-	}
-
-	return ret;
-}
-
-static unsigned char *
-make_delete_mask(struct ipt_entry *fw)
-{
-	/* Establish mask for comparison */
-	unsigned int size;
-	struct iptables_match *m;
-	unsigned char *mask, *mptr;
-
-	size = sizeof(struct ipt_entry);
-	for (m = iptables_matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		size += IPT_ALIGN(sizeof(struct ipt_entry_match)) + m->size;
-	}
-
-	mask = fw_calloc(1, size
-			 + IPT_ALIGN(sizeof(struct ipt_entry_target))
-			 + iptables_targets->size);
-
-	memset(mask, 0xFF, sizeof(struct ipt_entry));
-	mptr = mask + sizeof(struct ipt_entry);
-
-	for (m = iptables_matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		memset(mptr, 0xFF,
-		       IPT_ALIGN(sizeof(struct ipt_entry_match))
-		       + m->userspacesize);
-		mptr += IPT_ALIGN(sizeof(struct ipt_entry_match)) + m->size;
-	}
-
-	memset(mptr, 0xFF,
-	       IPT_ALIGN(sizeof(struct ipt_entry_target))
-	       + iptables_targets->userspacesize);
-
-	return mask;
-}
-
-static int
-delete_entry(const ipt_chainlabel chain,
-	     struct ipt_entry *fw,
-	     unsigned int nsaddrs,
-	     const struct in_addr saddrs[],
-	     unsigned int ndaddrs,
-	     const struct in_addr daddrs[],
-	     int verbose,
-	     iptc_handle_t *handle)
-{
-	unsigned int i, j;
-	int ret = 1;
-	unsigned char *mask;
-
-	mask = make_delete_mask(fw);
-	for (i = 0; i < nsaddrs; i++) {
-		fw->ip.src.s_addr = saddrs[i].s_addr;
-		for (j = 0; j < ndaddrs; j++) {
-			fw->ip.dst.s_addr = daddrs[j].s_addr;
-			if (verbose)
-				print_firewall_line(fw, *handle);
-			ret &= iptc_delete_entry(chain, fw, mask, handle);
-		}
-	}
-	return ret;
-}
-
-int
-for_each_chain(int (*fn)(const ipt_chainlabel, int, iptc_handle_t *),
-	       int verbose, int builtinstoo, iptc_handle_t *handle)
-{
-        int ret = 1;
-	const char *chain;
-	char *chains;
-	unsigned int i, chaincount = 0;
-
-	chain = iptc_first_chain(handle);
-	while (chain) {
-		chaincount++;
-		chain = iptc_next_chain(handle);
-        }
-
-	chains = fw_malloc(sizeof(ipt_chainlabel) * chaincount);
-	i = 0;
-	chain = iptc_first_chain(handle);
-	while (chain) {
-		strcpy(chains + i*sizeof(ipt_chainlabel), chain);
-		i++;
-		chain = iptc_next_chain(handle);
-        }
-
-	for (i = 0; i < chaincount; i++) {
-		if (!builtinstoo
-		    && iptc_builtin(chains + i*sizeof(ipt_chainlabel),
-				    *handle))
-			continue;
-	        ret &= fn(chains + i*sizeof(ipt_chainlabel), verbose, handle);
-	}
-
-	free(chains);
-        return ret;
-}
-
-int
-flush_entries(const ipt_chainlabel chain, int verbose,
-	      iptc_handle_t *handle)
-{
-	if (!chain)
-		return for_each_chain(flush_entries, verbose, 1, handle);
-
-	if (verbose)
-		fprintf(stdout, "Flushing chain `%s'\n", chain);
-	return iptc_flush_entries(chain, handle);
-}
-
-static int
-zero_entries(const ipt_chainlabel chain, int verbose,
-	     iptc_handle_t *handle)
-{
-	if (!chain)
-		return for_each_chain(zero_entries, verbose, 1, handle);
-
-	if (verbose)
-		fprintf(stdout, "Zeroing chain `%s'\n", chain);
-	return iptc_zero_entries(chain, handle);
-}
-
-int
-delete_chain(const ipt_chainlabel chain, int verbose,
-	     iptc_handle_t *handle)
-{
-	if (!chain)
-		return for_each_chain(delete_chain, verbose, 0, handle);
-
-	if (verbose)
-	        fprintf(stdout, "Deleting chain `%s'\n", chain);
-	return iptc_delete_chain(chain, handle);
-}
-
-static int
-list_entries(const ipt_chainlabel chain, int verbose, int numeric,
-	     int expanded, int linenumbers, iptc_handle_t *handle)
-{
-	int found = 0;
-	unsigned int format;
-	const char *this;
-
-	format = FMT_OPTIONS;
-	if (!verbose)
-		format |= FMT_NOCOUNTS;
-	else
-		format |= FMT_VIA;
-
-	if (numeric)
-		format |= FMT_NUMERIC;
-
-	if (!expanded)
-		format |= FMT_KILOMEGAGIGA;
-
-	if (linenumbers)
-		format |= FMT_LINENUMBERS;
-
-	for (this = iptc_first_chain(handle);
-	     this;
-	     this = iptc_next_chain(handle)) {
-		const struct ipt_entry *i;
-		unsigned int num;
-
-		if (chain && strcmp(chain, this) != 0)
-			continue;
-
-		if (found) printf("\n");
-
-		print_header(format, this, handle);
-		i = iptc_first_rule(this, handle);
-
-		num = 0;
-		while (i) {
-			print_firewall(i,
-				       iptc_get_target(i, handle),
-				       num++,
-				       format,
-				       *handle);
-			i = iptc_next_rule(i, handle);
-		}
-		found = 1;
-	}
-
-	errno = ENOENT;
-	return found;
-}
-
-static char *get_modprobe(void)
-{
-	int procfile;
-	char *ret;
-
-	procfile = open(PROC_SYS_MODPROBE, O_RDONLY);
-	if (procfile < 0)
-		return NULL;
-
-	ret = malloc(1024);
-	if (ret) {
-		switch (read(procfile, ret, 1024)) {
-		case -1: goto fail;
-		case 1024: goto fail; /* Partial read.  Wierd */
-		}
-		if (ret[strlen(ret)-1]=='\n') 
-			ret[strlen(ret)-1]=0;
-		close(procfile);
-		return ret;
-	}
- fail:
-	free(ret);
-	close(procfile);
-	return NULL;
-}
-
-int iptables_insmod(const char *modname, const char *modprobe)
-{
-	char *buf = NULL;
-	char *argv[3];
-
-	/* If they don't explicitly set it, read out of kernel */
-	if (!modprobe) {
-		buf = get_modprobe();
-		if (!buf)
-			return -1;
-		modprobe = buf;
-	}
-
-	switch (fork()) {
-	case 0:
-		argv[0] = (char *)modprobe;
-		argv[1] = (char *)modname;
-		argv[2] = NULL;
-		execv(argv[0], argv);
-
-		/* not usually reached */
-		exit(0);
-	case -1:
-		return -1;
-
-	default: /* parent */
-		wait(NULL);
-	}
-
-	free(buf);
-	return 0;
-}
-
-static struct ipt_entry *
-generate_entry(const struct ipt_entry *fw,
-	       struct iptables_match *matches,
-	       struct ipt_entry_target *target)
-{
-	unsigned int size;
-	struct iptables_match *m;
-	struct ipt_entry *e;
-
-	size = sizeof(struct ipt_entry);
-	for (m = matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		size += m->m->u.match_size;
-	}
-
-	e = fw_malloc(size + target->u.target_size);
-	*e = *fw;
-	e->target_offset = size;
-	e->next_offset = size + target->u.target_size;
-
-	size = 0;
-	for (m = matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		memcpy(e->elems + size, m->m, m->m->u.match_size);
-		size += m->m->u.match_size;
-	}
-	memcpy(e->elems + size, target, target->u.target_size);
-
-	return e;
-}
-
-int do_command(int argc, char *argv[], char **table, iptc_handle_t *handle)
-{
-	struct ipt_entry fw, *e = NULL;
-	int invert = 0;
-	unsigned int nsaddrs = 0, ndaddrs = 0;
-	struct in_addr *saddrs = NULL, *daddrs = NULL;
-
-	int c, verbose = 0;
-	const char *chain = NULL;
-	const char *shostnetworkmask = NULL, *dhostnetworkmask = NULL;
-	const char *policy = NULL, *newname = NULL;
-	unsigned int rulenum = 0, options = 0, command = 0;
-	const char *pcnt = NULL, *bcnt = NULL;
-	int ret = 1;
-	struct iptables_match *m;
-	struct iptables_target *target = NULL;
-	struct iptables_target *t;
-	const char *jumpto = "";
-	char *protocol = NULL;
-	const char *modprobe = NULL;
-	int proto_used = 0;
-
-	memset(&fw, 0, sizeof(fw));
-
-	opts = original_opts;
-	global_option_offset = 0;
-
-	/* re-set optind to 0 in case do_command gets called
-	 * a second time */
-	optind = 0;
-
-	/* clear mflags in case do_command gets called a second time
-	 * (we clear the global list of all matches for security)*/
-	for (m = iptables_matches; m; m = m->next) {
-		m->mflags = 0;
-		m->used = 0;
-	}
-
-	for (t = iptables_targets; t; t = t->next) {
-		t->tflags = 0;
-		t->used = 0;
-	}
-
-	/* Suppress error messages: we may add new options if we
-           demand-load a protocol. */
-	opterr = 0;
-
-	while ((c = getopt_long(argc, argv,
-	   "-A:D:R:I:L::M:F::Z::N:X::E:P:Vh::o:p:s:d:j:i:fbvnt:m:xc:",
-					   opts, NULL)) != -1) {
-		switch (c) {
-			/*
-			 * Command selection
-			 */
-		case 'A':
-			add_command(&command, CMD_APPEND, CMD_NONE,
-				    invert);
-			chain = optarg;
-			break;
-
-		case 'D':
-			add_command(&command, CMD_DELETE, CMD_NONE,
-				    invert);
-			chain = optarg;
-			if (optind < argc && argv[optind][0] != '-'
-			    && argv[optind][0] != '!') {
-				rulenum = parse_rulenumber(argv[optind++]);
-				command = CMD_DELETE_NUM;
-			}
-			break;
-
-		case 'R':
-			add_command(&command, CMD_REPLACE, CMD_NONE,
-				    invert);
-			chain = optarg;
-			if (optind < argc && argv[optind][0] != '-'
-			    && argv[optind][0] != '!')
-				rulenum = parse_rulenumber(argv[optind++]);
-			else
-				exit_error(PARAMETER_PROBLEM,
-					   "-%c requires a rule number",
-					   cmd2char(CMD_REPLACE));
-			break;
-
-		case 'I':
-			add_command(&command, CMD_INSERT, CMD_NONE,
-				    invert);
-			chain = optarg;
-			if (optind < argc && argv[optind][0] != '-'
-			    && argv[optind][0] != '!')
-				rulenum = parse_rulenumber(argv[optind++]);
-			else rulenum = 1;
-			break;
-
-		case 'L':
-			add_command(&command, CMD_LIST, CMD_ZERO,
-				    invert);
-			if (optarg) chain = optarg;
-			else if (optind < argc && argv[optind][0] != '-'
-				 && argv[optind][0] != '!')
-				chain = argv[optind++];
-			break;
-
-		case 'F':
-			add_command(&command, CMD_FLUSH, CMD_NONE,
-				    invert);
-			if (optarg) chain = optarg;
-			else if (optind < argc && argv[optind][0] != '-'
-				 && argv[optind][0] != '!')
-				chain = argv[optind++];
-			break;
-
-		case 'Z':
-			add_command(&command, CMD_ZERO, CMD_LIST,
-				    invert);
-			if (optarg) chain = optarg;
-			else if (optind < argc && argv[optind][0] != '-'
-				&& argv[optind][0] != '!')
-				chain = argv[optind++];
-			break;
-
-		case 'N':
-			if (optarg && *optarg == '-')
-				exit_error(PARAMETER_PROBLEM,
-					   "chain name not allowed to start "
-					   "with `-'\n");
-			if (find_target(optarg, TRY_LOAD))
-				exit_error(PARAMETER_PROBLEM,
-					   "chain name may not clash "
-					   "with target name\n");
-			add_command(&command, CMD_NEW_CHAIN, CMD_NONE,
-				    invert);
-			chain = optarg;
-			break;
-
-		case 'X':
-			add_command(&command, CMD_DELETE_CHAIN, CMD_NONE,
-				    invert);
-			if (optarg) chain = optarg;
-			else if (optind < argc && argv[optind][0] != '-'
-				 && argv[optind][0] != '!')
-				chain = argv[optind++];
-			break;
-
-		case 'E':
-			add_command(&command, CMD_RENAME_CHAIN, CMD_NONE,
-				    invert);
-			chain = optarg;
-			if (optind < argc && argv[optind][0] != '-'
-			    && argv[optind][0] != '!')
-				newname = argv[optind++];
-			else
-				exit_error(PARAMETER_PROBLEM,
-				           "-%c requires old-chain-name and "
-					   "new-chain-name",
-					    cmd2char(CMD_RENAME_CHAIN));
-			break;
-
-		case 'P':
-			add_command(&command, CMD_SET_POLICY, CMD_NONE,
-				    invert);
-			chain = optarg;
-			if (optind < argc && argv[optind][0] != '-'
-			    && argv[optind][0] != '!')
-				policy = argv[optind++];
-			else
-				exit_error(PARAMETER_PROBLEM,
-					   "-%c requires a chain and a policy",
-					   cmd2char(CMD_SET_POLICY));
-			break;
-
-		case 'h':
-			if (!optarg)
-				optarg = argv[optind];
-
-			/* iptables -p icmp -h */
-			if (!iptables_matches && protocol)
-				find_match(protocol, TRY_LOAD);
-
-			exit_printhelp();
-
-			/*
-			 * Option selection
-			 */
-		case 'p':
-			check_inverse(optarg, &invert, &optind, argc);
-			set_option(&options, OPT_PROTOCOL, &fw.ip.invflags,
-				   invert);
-
-			/* Canonicalize into lower case */
-			for (protocol = argv[optind-1]; *protocol; protocol++)
-				*protocol = tolower(*protocol);
-
-			protocol = argv[optind-1];
-			fw.ip.proto = parse_protocol(protocol);
-
-			if (fw.ip.proto == 0
-			    && (fw.ip.invflags & IPT_INV_PROTO))
-				exit_error(PARAMETER_PROBLEM,
-					   "rule would never match protocol");
-			fw.nfcache |= NFC_IP_PROTO;
-			break;
-
-		case 's':
-			check_inverse(optarg, &invert, &optind, argc);
-			set_option(&options, OPT_SOURCE, &fw.ip.invflags,
-				   invert);
-			shostnetworkmask = argv[optind-1];
-			fw.nfcache |= NFC_IP_SRC;
-			break;
-
-		case 'd':
-			check_inverse(optarg, &invert, &optind, argc);
-			set_option(&options, OPT_DESTINATION, &fw.ip.invflags,
-				   invert);
-			dhostnetworkmask = argv[optind-1];
-			fw.nfcache |= NFC_IP_DST;
-			break;
-
-		case 'j':
-			set_option(&options, OPT_JUMP, &fw.ip.invflags,
-				   invert);
-			jumpto = parse_target(optarg);
-			/* TRY_LOAD (may be chain name) */
-			target = find_target(jumpto, TRY_LOAD);
-
-			if (target) {
-				size_t size;
-
-				size = IPT_ALIGN(sizeof(struct ipt_entry_target))
-					+ target->size;
-
-				target->t = fw_calloc(1, size);
-				target->t->u.target_size = size;
-				strcpy(target->t->u.user.name, jumpto);
-				target->init(target->t, &fw.nfcache);
-				opts = merge_options(opts, target->extra_opts, &target->option_offset);
-			}
-			break;
-
-
-		case 'i':
-			check_inverse(optarg, &invert, &optind, argc);
-			set_option(&options, OPT_VIANAMEIN, &fw.ip.invflags,
-				   invert);
-			parse_interface(argv[optind-1],
-					fw.ip.iniface,
-					fw.ip.iniface_mask);
-			fw.nfcache |= NFC_IP_IF_IN;
-			break;
-
-		case 'o':
-			check_inverse(optarg, &invert, &optind, argc);
-			set_option(&options, OPT_VIANAMEOUT, &fw.ip.invflags,
-				   invert);
-			parse_interface(argv[optind-1],
-					fw.ip.outiface,
-					fw.ip.outiface_mask);
-			fw.nfcache |= NFC_IP_IF_OUT;
-			break;
-
-		case 'f':
-			set_option(&options, OPT_FRAGMENT, &fw.ip.invflags,
-				   invert);
-			fw.ip.flags |= IPT_F_FRAG;
-			fw.nfcache |= NFC_IP_FRAG;
-			break;
-
-		case 'v':
-			if (!verbose)
-				set_option(&options, OPT_VERBOSE,
-					   &fw.ip.invflags, invert);
-			verbose++;
-			break;
-
-		case 'm': {
-			size_t size;
-
-			if (invert)
-				exit_error(PARAMETER_PROBLEM,
-					   "unexpected ! flag before --match");
-
-			m = find_match(optarg, LOAD_MUST_SUCCEED);
-			size = IPT_ALIGN(sizeof(struct ipt_entry_match))
-					 + m->size;
-			m->m = fw_calloc(1, size);
-			m->m->u.match_size = size;
-			strcpy(m->m->u.user.name, m->name);
-			m->init(m->m, &fw.nfcache);
-			opts = merge_options(opts, m->extra_opts, &m->option_offset);
-		}
-		break;
-
-		case 'n':
-			set_option(&options, OPT_NUMERIC, &fw.ip.invflags,
-				   invert);
-			break;
-
-		case 't':
-			if (invert)
-				exit_error(PARAMETER_PROBLEM,
-					   "unexpected ! flag before --table");
-			*table = argv[optind-1];
-			break;
-
-		case 'x':
-			set_option(&options, OPT_EXPANDED, &fw.ip.invflags,
-				   invert);
-			break;
-
-		case 'V':
-			if (invert)
-				printf("Not %s ;-)\n", program_version);
-			else
-				printf("%s v%s\n",
-				       program_name, program_version);
-			exit(0);
-
-		case '0':
-			set_option(&options, OPT_LINENUMBERS, &fw.ip.invflags,
-				   invert);
-			break;
-
-		case 'M':
-			modprobe = optarg;
-			break;
-
-		case 'c':
-
-			set_option(&options, OPT_COUNTERS, &fw.ip.invflags,
-				   invert);
-			pcnt = optarg;
-			if (optind < argc && argv[optind][0] != '-'
-			    && argv[optind][0] != '!')
-				bcnt = argv[optind++];
-			else
-				exit_error(PARAMETER_PROBLEM,
-					"-%c requires packet and byte counter",
-					opt2char(OPT_COUNTERS));
-
-			if (sscanf(pcnt, "%llu", &fw.counters.pcnt) != 1)
-				exit_error(PARAMETER_PROBLEM,
-					"-%c packet counter not numeric",
-					opt2char(OPT_COUNTERS));
-
-			if (sscanf(bcnt, "%llu", &fw.counters.bcnt) != 1)
-				exit_error(PARAMETER_PROBLEM,
-					"-%c byte counter not numeric",
-					opt2char(OPT_COUNTERS));
-			
-			break;
-
-
-		case 1: /* non option */
-			if (optarg[0] == '!' && optarg[1] == '\0') {
-				if (invert)
-					exit_error(PARAMETER_PROBLEM,
-						   "multiple consecutive ! not"
-						   " allowed");
-				invert = TRUE;
-				optarg[0] = '\0';
-				continue;
-			}
-			printf("Bad argument `%s'\n", optarg);
-			exit_tryhelp(2);
-
-		default:
-			/* FIXME: This scheme doesn't allow two of the same
-			   matches --RR */
-			if (!target
-			    || !(target->parse(c - target->option_offset,
-					       argv, invert,
-					       &target->tflags,
-					       &fw, &target->t))) {
-				for (m = iptables_matches; m; m = m->next) {
-					if (!m->used)
-						continue;
-
-					if (m->parse(c - m->option_offset,
-						     argv, invert,
-						     &m->mflags,
-						     &fw,
-						     &fw.nfcache,
-						     &m->m))
-						break;
-				}
-
-				/* If you listen carefully, you can
-				   actually hear this code suck. */
-
-				/* some explanations (after four different bugs
-				 * in 3 different releases): If we encountere a
-				 * parameter, that has not been parsed yet,
-				 * it's not an option of an explicitly loaded
-				 * match or a target.  However, we support
-				 * implicit loading of the protocol match
-				 * extension.  '-p tcp' means 'l4 proto 6' and
-				 * at the same time 'load tcp protocol match on
-				 * demand if we specify --dport'.
-				 *
-				 * To make this work, we need to make sure:
-				 * - the parameter has not been parsed by
-				 *   a match (m above)
-				 * - a protocol has been specified
-				 * - the protocol extension has not been
-				 *   loaded yet, or is loaded and unused
-				 *   [think of iptables-restore!]
-				 * - the protocol extension can be successively
-				 *   loaded
-				 */
-				if (m == NULL
-				    && protocol
-				    && (!find_proto(protocol, DONT_LOAD,
-						   options&OPT_NUMERIC) 
-					|| (find_proto(protocol, DONT_LOAD,
-							options&OPT_NUMERIC)
-					    && (proto_used == 0))
-				       )
-				    && (m = find_proto(protocol, TRY_LOAD,
-						       options&OPT_NUMERIC))) {
-					/* Try loading protocol */
-					size_t size;
-					
-					proto_used = 1;
-
-					size = IPT_ALIGN(sizeof(struct ipt_entry_match))
-							 + m->size;
-
-					m->m = fw_calloc(1, size);
-					m->m->u.match_size = size;
-					strcpy(m->m->u.user.name, m->name);
-					m->init(m->m, &fw.nfcache);
-
-					opts = merge_options(opts,
-					    m->extra_opts, &m->option_offset);
-
-					optind--;
-					continue;
-				}
-				if (!m)
-					exit_error(PARAMETER_PROBLEM,
-						   "Unknown arg `%s'",
-						   argv[optind-1]);
-			}
-		}
-		invert = FALSE;
-	}
-
-	for (m = iptables_matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		m->final_check(m->mflags);
-	}
-
-	if (target)
-		target->final_check(target->tflags);
-
-	/* Fix me: must put inverse options checking here --MN */
-
-	if (optind < argc)
-		exit_error(PARAMETER_PROBLEM,
-			   "unknown arguments found on commandline");
-	if (!command)
-		exit_error(PARAMETER_PROBLEM, "no command specified");
-	if (invert)
-		exit_error(PARAMETER_PROBLEM,
-			   "nothing appropriate following !");
-
-	if (command & (CMD_REPLACE | CMD_INSERT | CMD_DELETE | CMD_APPEND)) {
-		if (!(options & OPT_DESTINATION))
-			dhostnetworkmask = "0.0.0.0/0";
-		if (!(options & OPT_SOURCE))
-			shostnetworkmask = "0.0.0.0/0";
-	}
-
-	if (shostnetworkmask)
-		parse_hostnetworkmask(shostnetworkmask, &saddrs,
-				      &(fw.ip.smsk), &nsaddrs);
-
-	if (dhostnetworkmask)
-		parse_hostnetworkmask(dhostnetworkmask, &daddrs,
-				      &(fw.ip.dmsk), &ndaddrs);
-
-	if ((nsaddrs > 1 || ndaddrs > 1) &&
-	    (fw.ip.invflags & (IPT_INV_SRCIP | IPT_INV_DSTIP)))
-		exit_error(PARAMETER_PROBLEM, "! not allowed with multiple"
-			   " source or destination IP addresses");
-
-	if (command == CMD_REPLACE && (nsaddrs != 1 || ndaddrs != 1))
-		exit_error(PARAMETER_PROBLEM, "Replacement rule does not "
-			   "specify a unique address");
-
-	generic_opt_check(command, options);
-
-	if (chain && strlen(chain) > IPT_FUNCTION_MAXNAMELEN)
-		exit_error(PARAMETER_PROBLEM,
-			   "chain name `%s' too long (must be under %i chars)",
-			   chain, IPT_FUNCTION_MAXNAMELEN);
-
-	/* only allocate handle if we weren't called with a handle */
-	if (!*handle)
-		*handle = iptc_init(*table);
-
-	if (!*handle) {
-		/* try to insmod the module if iptc_init failed */
-		iptables_insmod("ip_tables", modprobe);
-		*handle = iptc_init(*table);
-	}
-
-	if (!*handle)
-		exit_error(VERSION_PROBLEM,
-			   "can't initialize iptables table `%s': %s",
-			   *table, iptc_strerror(errno));
-
-	if (command == CMD_APPEND
-	    || command == CMD_DELETE
-	    || command == CMD_INSERT
-	    || command == CMD_REPLACE) {
-		if (strcmp(chain, "PREROUTING") == 0
-		    || strcmp(chain, "INPUT") == 0) {
-			/* -o not valid with incoming packets. */
-			if (options & OPT_VIANAMEOUT)
-				exit_error(PARAMETER_PROBLEM,
-					   "Can't use -%c with %s\n",
-					   opt2char(OPT_VIANAMEOUT),
-					   chain);
-		}
-
-		if (strcmp(chain, "POSTROUTING") == 0
-		    || strcmp(chain, "OUTPUT") == 0) {
-			/* -i not valid with outgoing packets */
-			if (options & OPT_VIANAMEIN)
-				exit_error(PARAMETER_PROBLEM,
-					   "Can't use -%c with %s\n",
-					   opt2char(OPT_VIANAMEIN),
-					   chain);
-		}
-
-		if (target && iptc_is_chain(jumpto, *handle)) {
-			printf("Warning: using chain %s, not extension\n",
-			       jumpto);
-
-			target = NULL;
-		}
-
-		/* If they didn't specify a target, or it's a chain
-		   name, use standard. */
-		if (!target
-		    && (strlen(jumpto) == 0
-			|| iptc_is_chain(jumpto, *handle))) {
-			size_t size;
-
-			target = find_target(IPT_STANDARD_TARGET,
-					     LOAD_MUST_SUCCEED);
-
-			size = sizeof(struct ipt_entry_target)
-				+ target->size;
-			target->t = fw_calloc(1, size);
-			target->t->u.target_size = size;
-			strcpy(target->t->u.user.name, jumpto);
-			target->init(target->t, &fw.nfcache);
-		}
-
-		if (!target) {
-			/* it is no chain, and we can't load a plugin.
-			 * We cannot know if the plugin is corrupt, non
-			 * existant OR if the user just misspelled a
-			 * chain. */
-			find_target(jumpto, LOAD_MUST_SUCCEED);
-		} else {
-			e = generate_entry(&fw, iptables_matches, target->t);
-		}
-	}
-
-	switch (command) {
-	case CMD_APPEND:
-		ret = append_entry(chain, e,
-				   nsaddrs, saddrs, ndaddrs, daddrs,
-				   options&OPT_VERBOSE,
-				   handle);
-		break;
-	case CMD_DELETE:
-		ret = delete_entry(chain, e,
-				   nsaddrs, saddrs, ndaddrs, daddrs,
-				   options&OPT_VERBOSE,
-				   handle);
-		break;
-	case CMD_DELETE_NUM:
-		ret = iptc_delete_num_entry(chain, rulenum - 1, handle);
-		break;
-	case CMD_REPLACE:
-		ret = replace_entry(chain, e, rulenum - 1,
-				    saddrs, daddrs, options&OPT_VERBOSE,
-				    handle);
-		break;
-	case CMD_INSERT:
-		ret = insert_entry(chain, e, rulenum - 1,
-				   nsaddrs, saddrs, ndaddrs, daddrs,
-				   options&OPT_VERBOSE,
-				   handle);
-		break;
-	case CMD_LIST:
-		ret = list_entries(chain,
-				   options&OPT_VERBOSE,
-				   options&OPT_NUMERIC,
-				   options&OPT_EXPANDED,
-				   options&OPT_LINENUMBERS,
-				   handle);
-		break;
-	case CMD_FLUSH:
-		ret = flush_entries(chain, options&OPT_VERBOSE, handle);
-		break;
-	case CMD_ZERO:
-		ret = zero_entries(chain, options&OPT_VERBOSE, handle);
-		break;
-	case CMD_LIST|CMD_ZERO:
-		ret = list_entries(chain,
-				   options&OPT_VERBOSE,
-				   options&OPT_NUMERIC,
-				   options&OPT_EXPANDED,
-				   options&OPT_LINENUMBERS,
-				   handle);
-		if (ret)
-			ret = zero_entries(chain,
-					   options&OPT_VERBOSE, handle);
-		break;
-	case CMD_NEW_CHAIN:
-		ret = iptc_create_chain(chain, handle);
-		break;
-	case CMD_DELETE_CHAIN:
-		ret = delete_chain(chain, options&OPT_VERBOSE, handle);
-		break;
-	case CMD_RENAME_CHAIN:
-		ret = iptc_rename_chain(chain, newname,	handle);
-		break;
-	case CMD_SET_POLICY:
-		ret = iptc_set_policy(chain, policy, NULL, handle);
-		break;
-	default:
-		/* We should never reach this... */
-		exit_tryhelp(2);
-	}
-
-	if (verbose > 1)
-		dump_entries(*handle);
-
-	return ret;
-}
diff -urN iptables-1.2.9/.#iptables.c.1.55 iptables-1.2.10/.#iptables.c.1.55
--- iptables-1.2.9/.#iptables.c.1.55	2003-04-04 23:46:05.000000000 +0200
+++ iptables-1.2.10/.#iptables.c.1.55	1970-01-01 01:00:00.000000000 +0100
@@ -1,2303 +0,0 @@
-/* Code to take an iptables-style command line and do it. */
-
-/*
- * Author: Paul.Russell@rustcorp.com.au and mneuling@radlogic.com.au
- *
- * (C) 2000-2002 by the netfilter coreteam <coreteam@netfilter.org>:
- * 		    Paul 'Rusty' Russell <rusty@rustcorp.com.au>
- * 		    Marc Boucher <marc+nf@mbsi.ca>
- * 		    James Morris <jmorris@intercode.com.au>
- * 		    Harald Welte <laforge@gnumonks.org>
- * 		    Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
- *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
- *
- *	This program is distributed in the hope that it will be useful,
- *	but WITHOUT ANY WARRANTY; without even the implied warranty of
- *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *	GNU General Public License for more details.
- *
- *	You should have received a copy of the GNU General Public License
- *	along with this program; if not, write to the Free Software
- *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include <getopt.h>
-#include <string.h>
-#include <netdb.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <dlfcn.h>
-#include <ctype.h>
-#include <stdarg.h>
-#include <limits.h>
-#include <unistd.h>
-#include <iptables.h>
-#include <fcntl.h>
-#include <sys/wait.h>
-
-#ifndef TRUE
-#define TRUE 1
-#endif
-#ifndef FALSE
-#define FALSE 0
-#endif
-
-#ifndef IPT_LIB_DIR
-#define IPT_LIB_DIR "/usr/local/lib/iptables"
-#endif
-
-#ifndef PROC_SYS_MODPROBE
-#define PROC_SYS_MODPROBE "/proc/sys/kernel/modprobe"
-#endif
-
-#define FMT_NUMERIC	0x0001
-#define FMT_NOCOUNTS	0x0002
-#define FMT_KILOMEGAGIGA 0x0004
-#define FMT_OPTIONS	0x0008
-#define FMT_NOTABLE	0x0010
-#define FMT_NOTARGET	0x0020
-#define FMT_VIA		0x0040
-#define FMT_NONEWLINE	0x0080
-#define FMT_LINENUMBERS 0x0100
-
-#define FMT_PRINT_RULE (FMT_NOCOUNTS | FMT_OPTIONS | FMT_VIA \
-			| FMT_NUMERIC | FMT_NOTABLE)
-#define FMT(tab,notab) ((format) & FMT_NOTABLE ? (notab) : (tab))
-
-
-#define CMD_NONE		0x0000U
-#define CMD_INSERT		0x0001U
-#define CMD_DELETE		0x0002U
-#define CMD_DELETE_NUM		0x0004U
-#define CMD_REPLACE		0x0008U
-#define CMD_APPEND		0x0010U
-#define CMD_LIST		0x0020U
-#define CMD_FLUSH		0x0040U
-#define CMD_ZERO		0x0080U
-#define CMD_NEW_CHAIN		0x0100U
-#define CMD_DELETE_CHAIN	0x0200U
-#define CMD_SET_POLICY		0x0400U
-#define CMD_CHECK		0x0800U
-#define CMD_RENAME_CHAIN	0x1000U
-#define NUMBER_OF_CMD	13
-static const char cmdflags[] = { 'I', 'D', 'D', 'R', 'A', 'L', 'F', 'Z',
-				 'N', 'X', 'P', 'E' };
-
-#define OPTION_OFFSET 256
-
-#define OPT_NONE	0x00000U
-#define OPT_NUMERIC	0x00001U
-#define OPT_SOURCE	0x00002U
-#define OPT_DESTINATION	0x00004U
-#define OPT_PROTOCOL	0x00008U
-#define OPT_JUMP	0x00010U
-#define OPT_VERBOSE	0x00020U
-#define OPT_EXPANDED	0x00040U
-#define OPT_VIANAMEIN	0x00080U
-#define OPT_VIANAMEOUT	0x00100U
-#define OPT_FRAGMENT    0x00200U
-#define OPT_LINENUMBERS 0x00400U
-#define OPT_COUNTERS	0x00800U
-#define NUMBER_OF_OPT	12
-static const char optflags[NUMBER_OF_OPT]
-= { 'n', 's', 'd', 'p', 'j', 'v', 'x', 'i', 'o', 'f', '3', 'c'};
-
-static struct option original_opts[] = {
-	{ "append", 1, 0, 'A' },
-	{ "delete", 1, 0,  'D' },
-	{ "insert", 1, 0,  'I' },
-	{ "replace", 1, 0,  'R' },
-	{ "list", 2, 0,  'L' },
-	{ "flush", 2, 0,  'F' },
-	{ "zero", 2, 0,  'Z' },
-	{ "new-chain", 1, 0,  'N' },
-	{ "delete-chain", 2, 0,  'X' },
-	{ "rename-chain", 1, 0,  'E' },
-	{ "policy", 1, 0,  'P' },
-	{ "source", 1, 0, 's' },
-	{ "destination", 1, 0,  'd' },
-	{ "src", 1, 0,  's' }, /* synonym */
-	{ "dst", 1, 0,  'd' }, /* synonym */
-	{ "protocol", 1, 0,  'p' },
-	{ "in-interface", 1, 0, 'i' },
-	{ "jump", 1, 0, 'j' },
-	{ "table", 1, 0, 't' },
-	{ "match", 1, 0, 'm' },
-	{ "numeric", 0, 0, 'n' },
-	{ "out-interface", 1, 0, 'o' },
-	{ "verbose", 0, 0, 'v' },
-	{ "exact", 0, 0, 'x' },
-	{ "fragments", 0, 0, 'f' },
-	{ "version", 0, 0, 'V' },
-	{ "help", 2, 0, 'h' },
-	{ "line-numbers", 0, 0, '0' },
-	{ "modprobe", 1, 0, 'M' },
-	{ "set-counters", 1, 0, 'c' },
-	{ 0 }
-};
-
-/* we need this for iptables-restore.  iptables-restore.c sets line to the
- * current line of the input file, in order  to give a more precise error
- * message.  iptables itself doesn't need this, so it is initialized to the
- * magic number of -1 */
-int line = -1;
-
-#ifndef __OPTIMIZE__
-struct ipt_entry_target *
-ipt_get_target(struct ipt_entry *e)
-{
-	return (void *)e + e->target_offset;
-}
-#endif
-
-static struct option *opts = original_opts;
-static unsigned int global_option_offset = 0;
-
-/* Table of legal combinations of commands and options.  If any of the
- * given commands make an option legal, that option is legal (applies to
- * CMD_LIST and CMD_ZERO only).
- * Key:
- *  +  compulsory
- *  x  illegal
- *     optional
- */
-
-static char commands_v_options[NUMBER_OF_CMD][NUMBER_OF_OPT] =
-/* Well, it's better than "Re: Linux vs FreeBSD" */
-{
-	/*     -n  -s  -d  -p  -j  -v  -x  -i  -o  -f  --line */
-/*INSERT*/    {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
-/*DELETE*/    {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
-/*DELETE_NUM*/{'x','x','x','x','x',' ','x','x','x','x','x'},
-/*REPLACE*/   {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
-/*APPEND*/    {'x',' ',' ',' ',' ',' ','x',' ',' ',' ','x'},
-/*LIST*/      {' ','x','x','x','x',' ',' ','x','x','x',' '},
-/*FLUSH*/     {'x','x','x','x','x',' ','x','x','x','x','x'},
-/*ZERO*/      {'x','x','x','x','x',' ','x','x','x','x','x'},
-/*NEW_CHAIN*/ {'x','x','x','x','x',' ','x','x','x','x','x'},
-/*DEL_CHAIN*/ {'x','x','x','x','x',' ','x','x','x','x','x'},
-/*SET_POLICY*/{'x','x','x','x','x',' ','x','x','x','x','x'},
-/*CHECK*/     {'x','+','+','+','x',' ','x',' ',' ',' ','x'},
-/*RENAME*/    {'x','x','x','x','x',' ','x','x','x','x','x'}
-};
-
-static int inverse_for_options[NUMBER_OF_OPT] =
-{
-/* -n */ 0,
-/* -s */ IPT_INV_SRCIP,
-/* -d */ IPT_INV_DSTIP,
-/* -p */ IPT_INV_PROTO,
-/* -j */ 0,
-/* -v */ 0,
-/* -x */ 0,
-/* -i */ IPT_INV_VIA_IN,
-/* -o */ IPT_INV_VIA_OUT,
-/* -f */ IPT_INV_FRAG,
-/*--line*/ 0
-};
-
-const char *program_version;
-const char *program_name;
-
-/* Keeping track of external matches and targets: linked lists.  */
-struct iptables_match *iptables_matches = NULL;
-struct iptables_target *iptables_targets = NULL;
-
-/* Extra debugging from libiptc */
-extern void dump_entries(const iptc_handle_t handle);
-
-/* A few hardcoded protocols for 'all' and in case the user has no
-   /etc/protocols */
-struct pprot {
-	char *name;
-	u_int8_t num;
-};
-
-/* Primitive headers... */
-/* defined in netinet/in.h */
-#if 0
-#ifndef IPPROTO_ESP
-#define IPPROTO_ESP 50
-#endif
-#ifndef IPPROTO_AH
-#define IPPROTO_AH 51
-#endif
-#endif
-
-static const struct pprot chain_protos[] = {
-	{ "tcp", IPPROTO_TCP },
-	{ "udp", IPPROTO_UDP },
-	{ "icmp", IPPROTO_ICMP },
-	{ "esp", IPPROTO_ESP },
-	{ "ah", IPPROTO_AH },
-	{ "all", 0 },
-};
-
-static char *
-proto_to_name(u_int8_t proto, int nolookup)
-{
-	unsigned int i;
-
-	if (proto && !nolookup) {
-		struct protoent *pent = getprotobynumber(proto);
-		if (pent)
-			return pent->p_name;
-	}
-
-	for (i = 0; i < sizeof(chain_protos)/sizeof(struct pprot); i++)
-		if (chain_protos[i].num == proto)
-			return chain_protos[i].name;
-
-	return NULL;
-}
-
-struct in_addr *
-dotted_to_addr(const char *dotted)
-{
-	static struct in_addr addr;
-	unsigned char *addrp;
-	char *p, *q;
-	unsigned int onebyte;
-	int i;
-	char buf[20];
-
-	/* copy dotted string, because we need to modify it */
-	strncpy(buf, dotted, sizeof(buf) - 1);
-	addrp = (unsigned char *) &(addr.s_addr);
-
-	p = buf;
-	for (i = 0; i < 3; i++) {
-		if ((q = strchr(p, '.')) == NULL)
-			return (struct in_addr *) NULL;
-
-		*q = '\0';
-		if (string_to_number(p, 0, 255, &onebyte) == -1)
-			return (struct in_addr *) NULL;
-
-		addrp[i] = (unsigned char) onebyte;
-		p = q + 1;
-	}
-
-	/* we've checked 3 bytes, now we check the last one */
-	if (string_to_number(p, 0, 255, &onebyte) == -1)
-		return (struct in_addr *) NULL;
-
-	addrp[3] = (unsigned char) onebyte;
-
-	return &addr;
-}
-
-static struct in_addr *
-network_to_addr(const char *name)
-{
-	struct netent *net;
-	static struct in_addr addr;
-
-	if ((net = getnetbyname(name)) != NULL) {
-		if (net->n_addrtype != AF_INET)
-			return (struct in_addr *) NULL;
-		addr.s_addr = htonl((unsigned long) net->n_net);
-		return &addr;
-	}
-
-	return (struct in_addr *) NULL;
-}
-
-static void
-inaddrcpy(struct in_addr *dst, struct in_addr *src)
-{
-	/* memcpy(dst, src, sizeof(struct in_addr)); */
-	dst->s_addr = src->s_addr;
-}
-
-void
-exit_error(enum exittype status, char *msg, ...)
-{
-	va_list args;
-
-	va_start(args, msg);
-	fprintf(stderr, "%s v%s: ", program_name, program_version);
-	vfprintf(stderr, msg, args);
-	va_end(args);
-	fprintf(stderr, "\n");
-	if (status == PARAMETER_PROBLEM)
-		exit_tryhelp(status);
-	if (status == VERSION_PROBLEM)
-		fprintf(stderr,
-			"Perhaps iptables or your kernel needs to be upgraded.\n");
-	exit(status);
-}
-
-void
-exit_tryhelp(int status)
-{
-<<<<<<< iptables.c
-	if (line != -1)
-		fprintf(stderr, "Error occurred at line: %d\n", line);
-=======
-	if (line != -1)
-		fprintf(stderr, "Error occured at line: %d\n", line);
->>>>>>> 1.55
-	fprintf(stderr, "Try `%s -h' or '%s --help' for more information.\n",
-			program_name, program_name );
-	exit(status);
-}
-
-void
-exit_printhelp(void)
-{
-	struct iptables_match *m = NULL;
-	struct iptables_target *t = NULL;
-
-	printf("%s v%s\n\n"
-"Usage: %s -[AD] chain rule-specification [options]\n"
-"       %s -[RI] chain rulenum rule-specification [options]\n"
-"       %s -D chain rulenum [options]\n"
-"       %s -[LFZ] [chain] [options]\n"
-"       %s -[NX] chain\n"
-"       %s -E old-chain-name new-chain-name\n"
-"       %s -P chain target [options]\n"
-"       %s -h (print this help information)\n\n",
-	       program_name, program_version, program_name, program_name,
-	       program_name, program_name, program_name, program_name,
-	       program_name, program_name);
-
-	printf(
-"Commands:\n"
-"Either long or short options are allowed.\n"
-"  --append  -A chain		Append to chain\n"
-"  --delete  -D chain		Delete matching rule from chain\n"
-"  --delete  -D chain rulenum\n"
-"				Delete rule rulenum (1 = first) from chain\n"
-"  --insert  -I chain [rulenum]\n"
-"				Insert in chain as rulenum (default 1=first)\n"
-"  --replace -R chain rulenum\n"
-"				Replace rule rulenum (1 = first) in chain\n"
-"  --list    -L [chain]		List the rules in a chain or all chains\n"
-"  --flush   -F [chain]		Delete all rules in  chain or all chains\n"
-"  --zero    -Z [chain]		Zero counters in chain or all chains\n"
-"  --new     -N chain		Create a new user-defined chain\n"
-"  --delete-chain\n"
-"            -X [chain]		Delete a user-defined chain\n"
-"  --policy  -P chain target\n"
-"				Change policy on chain to target\n"
-"  --rename-chain\n"
-"            -E old-chain new-chain\n"
-"				Change chain name, (moving any references)\n"
-
-"Options:\n"
-"  --proto	-p [!] proto	protocol: by number or name, eg. `tcp'\n"
-"  --source	-s [!] address[/mask]\n"
-"				source specification\n"
-"  --destination -d [!] address[/mask]\n"
-"				destination specification\n"
-"  --in-interface -i [!] input name[+]\n"
-"				network interface name ([+] for wildcard)\n"
-"  --jump	-j target\n"
-"				target for rule (may load target extension)\n"
-"  --match	-m match\n"
-"				extended match (may load extension)\n"
-"  --numeric	-n		numeric output of addresses and ports\n"
-"  --out-interface -o [!] output name[+]\n"
-"				network interface name ([+] for wildcard)\n"
-"  --table	-t table	table to manipulate (default: `filter')\n"
-"  --verbose	-v		verbose mode\n"
-"  --line-numbers		print line numbers when listing\n"
-"  --exact	-x		expand numbers (display exact values)\n"
-"[!] --fragment	-f		match second or further fragments only\n"
-"  --modprobe=<command>		try to insert modules using this command\n"
-"  --set-counters PKTS BYTES	set the counter during insert/append\n"
-"[!] --version	-V		print package version.\n");
-
-	/* Print out any special helps. A user might like to be able
-	   to add a --help to the commandline, and see expected
-	   results. So we call help for all matches & targets */
-	for (t=iptables_targets;t;t=t->next) {
-		printf("\n");
-		t->help();
-	}
-	for (m=iptables_matches;m;m=m->next) {
-		printf("\n");
-		m->help();
-	}
-	exit(0);
-}
-
-static void
-generic_opt_check(int command, int options)
-{
-	int i, j, legal = 0;
-
-	/* Check that commands are valid with options.  Complicated by the
-	 * fact that if an option is legal with *any* command given, it is
-	 * legal overall (ie. -z and -l).
-	 */
-	for (i = 0; i < NUMBER_OF_OPT; i++) {
-		legal = 0; /* -1 => illegal, 1 => legal, 0 => undecided. */
-
-		for (j = 0; j < NUMBER_OF_CMD; j++) {
-			if (!(command & (1<<j)))
-				continue;
-
-			if (!(options & (1<<i))) {
-				if (commands_v_options[j][i] == '+')
-					exit_error(PARAMETER_PROBLEM,
-						   "You need to supply the `-%c' "
-						   "option for this command\n",
-						   optflags[i]);
-			} else {
-				if (commands_v_options[j][i] != 'x')
-					legal = 1;
-				else if (legal == 0)
-					legal = -1;
-			}
-		}
-		if (legal == -1)
-			exit_error(PARAMETER_PROBLEM,
-				   "Illegal option `-%c' with this command\n",
-				   optflags[i]);
-	}
-}
-
-static char
-opt2char(int option)
-{
-	const char *ptr;
-	for (ptr = optflags; option > 1; option >>= 1, ptr++);
-
-	return *ptr;
-}
-
-static char
-cmd2char(int option)
-{
-	const char *ptr;
-	for (ptr = cmdflags; option > 1; option >>= 1, ptr++);
-
-	return *ptr;
-}
-
-static void
-add_command(int *cmd, const int newcmd, const int othercmds, int invert)
-{
-	if (invert)
-		exit_error(PARAMETER_PROBLEM, "unexpected ! flag");
-	if (*cmd & (~othercmds))
-		exit_error(PARAMETER_PROBLEM, "Can't use -%c with -%c\n",
-			   cmd2char(newcmd), cmd2char(*cmd & (~othercmds)));
-	*cmd |= newcmd;
-}
-
-int
-check_inverse(const char option[], int *invert, int *optind, int argc)
-{
-	if (option && strcmp(option, "!") == 0) {
-		if (*invert)
-			exit_error(PARAMETER_PROBLEM,
-				   "Multiple `!' flags not allowed");
-		*invert = TRUE;
-		if (optind) {
-			*optind = *optind+1;
-			if (argc && *optind > argc)
-				exit_error(PARAMETER_PROBLEM,
-					   "no argument following `!'");
-		}
-
-		return TRUE;
-	}
-	return FALSE;
-}
-
-static void *
-fw_calloc(size_t count, size_t size)
-{
-	void *p;
-
-	if ((p = calloc(count, size)) == NULL) {
-		perror("iptables: calloc failed");
-		exit(1);
-	}
-	return p;
-}
-
-static void *
-fw_malloc(size_t size)
-{
-	void *p;
-
-	if ((p = malloc(size)) == NULL) {
-		perror("iptables: malloc failed");
-		exit(1);
-	}
-	return p;
-}
-
-static struct in_addr *
-host_to_addr(const char *name, unsigned int *naddr)
-{
-	struct hostent *host;
-	struct in_addr *addr;
-	unsigned int i;
-
-	*naddr = 0;
-	if ((host = gethostbyname(name)) != NULL) {
-		if (host->h_addrtype != AF_INET ||
-		    host->h_length != sizeof(struct in_addr))
-			return (struct in_addr *) NULL;
-
-		while (host->h_addr_list[*naddr] != (char *) NULL)
-			(*naddr)++;
-		addr = fw_calloc(*naddr, sizeof(struct in_addr));
-		for (i = 0; i < *naddr; i++)
-			inaddrcpy(&(addr[i]),
-				  (struct in_addr *) host->h_addr_list[i]);
-		return addr;
-	}
-
-	return (struct in_addr *) NULL;
-}
-
-static char *
-addr_to_host(const struct in_addr *addr)
-{
-	struct hostent *host;
-
-	if ((host = gethostbyaddr((char *) addr,
-				  sizeof(struct in_addr), AF_INET)) != NULL)
-		return (char *) host->h_name;
-
-	return (char *) NULL;
-}
-
-/*
- *	All functions starting with "parse" should succeed, otherwise
- *	the program fails.
- *	Most routines return pointers to static data that may change
- *	between calls to the same or other routines with a few exceptions:
- *	"host_to_addr", "parse_hostnetwork", and "parse_hostnetworkmask"
- *	return global static data.
-*/
-
-static struct in_addr *
-parse_hostnetwork(const char *name, unsigned int *naddrs)
-{
-	struct in_addr *addrp, *addrptmp;
-
-	if ((addrptmp = dotted_to_addr(name)) != NULL ||
-	    (addrptmp = network_to_addr(name)) != NULL) {
-		addrp = fw_malloc(sizeof(struct in_addr));
-		inaddrcpy(addrp, addrptmp);
-		*naddrs = 1;
-		return addrp;
-	}
-	if ((addrp = host_to_addr(name, naddrs)) != NULL)
-		return addrp;
-
-	exit_error(PARAMETER_PROBLEM, "host/network `%s' not found", name);
-}
-
-static struct in_addr *
-parse_mask(char *mask)
-{
-	static struct in_addr maskaddr;
-	struct in_addr *addrp;
-	unsigned int bits;
-
-	if (mask == NULL) {
-		/* no mask at all defaults to 32 bits */
-		maskaddr.s_addr = 0xFFFFFFFF;
-		return &maskaddr;
-	}
-	if ((addrp = dotted_to_addr(mask)) != NULL)
-		/* dotted_to_addr already returns a network byte order addr */
-		return addrp;
-	if (string_to_number(mask, 0, 32, &bits) == -1)
-		exit_error(PARAMETER_PROBLEM,
-			   "invalid mask `%s' specified", mask);
-	if (bits != 0) {
-		maskaddr.s_addr = htonl(0xFFFFFFFF << (32 - bits));
-		return &maskaddr;
-	}
-
-	maskaddr.s_addr = 0L;
-	return &maskaddr;
-}
-
-void
-parse_hostnetworkmask(const char *name, struct in_addr **addrpp,
-		      struct in_addr *maskp, unsigned int *naddrs)
-{
-	struct in_addr *addrp;
-	char buf[256];
-	char *p;
-	int i, j, k, n;
-
-	strncpy(buf, name, sizeof(buf) - 1);
-	if ((p = strrchr(buf, '/')) != NULL) {
-		*p = '\0';
-		addrp = parse_mask(p + 1);
-	} else
-		addrp = parse_mask(NULL);
-	inaddrcpy(maskp, addrp);
-
-	/* if a null mask is given, the name is ignored, like in "any/0" */
-	if (maskp->s_addr == 0L)
-		strcpy(buf, "0.0.0.0");
-
-	addrp = *addrpp = parse_hostnetwork(buf, naddrs);
-	n = *naddrs;
-	for (i = 0, j = 0; i < n; i++) {
-		addrp[j++].s_addr &= maskp->s_addr;
-		for (k = 0; k < j - 1; k++) {
-			if (addrp[k].s_addr == addrp[j - 1].s_addr) {
-				(*naddrs)--;
-				j--;
-				break;
-			}
-		}
-	}
-}
-
-struct iptables_match *
-find_match(const char *name, enum ipt_tryload tryload)
-{
-	struct iptables_match *ptr;
-
-	for (ptr = iptables_matches; ptr; ptr = ptr->next) {
-		if (strcmp(name, ptr->name) == 0)
-			break;
-	}
-
-#ifndef NO_SHARED_LIBS
-	if (!ptr && tryload != DONT_LOAD) {
-		char path[sizeof(IPT_LIB_DIR) + sizeof("/libipt_.so")
-			 + strlen(name)];
-		sprintf(path, IPT_LIB_DIR "/libipt_%s.so", name);
-		if (dlopen(path, RTLD_NOW)) {
-			/* Found library.  If it didn't register itself,
-			   maybe they specified target as match. */
-			ptr = find_match(name, DONT_LOAD);
-
-			if (!ptr)
-				exit_error(PARAMETER_PROBLEM,
-					   "Couldn't load match `%s'\n",
-					   name);
-		} else if (tryload == LOAD_MUST_SUCCEED)
-			exit_error(PARAMETER_PROBLEM,
-				   "Couldn't load match `%s':%s\n",
-				   name, dlerror());
-	}
-#else
-	if (ptr && !ptr->loaded) {
-		if (tryload != DONT_LOAD)
-			ptr->loaded = 1;
-		else
-			ptr = NULL;
-	}
-	if(!ptr && (tryload == LOAD_MUST_SUCCEED)) {
-		exit_error(PARAMETER_PROBLEM,
-			   "Couldn't find match `%s'\n", name);
-	}
-#endif
-
-	if (ptr)
-		ptr->used = 1;
-
-	return ptr;
-}
-
-/* Christophe Burki wants `-p 6' to imply `-m tcp'.  */
-static struct iptables_match *
-find_proto(const char *pname, enum ipt_tryload tryload, int nolookup)
-{
-	unsigned int proto;
-
-	if (string_to_number(pname, 0, 255, &proto) != -1) {
-		char *protoname = proto_to_name(proto, nolookup);
-
-		if (protoname)
-			return find_match(protoname, tryload);
-	} else
-		return find_match(pname, tryload);
-
-	return NULL;
-}
-
-u_int16_t
-parse_protocol(const char *s)
-{
-	unsigned int proto;
-
-	if (string_to_number(s, 0, 255, &proto) == -1) {
-		struct protoent *pent;
-
-		if ((pent = getprotobyname(s)))
-			proto = pent->p_proto;
-		else {
-			unsigned int i;
-			for (i = 0;
-			     i < sizeof(chain_protos)/sizeof(struct pprot);
-			     i++) {
-				if (strcmp(s, chain_protos[i].name) == 0) {
-					proto = chain_protos[i].num;
-					break;
-				}
-			}
-			if (i == sizeof(chain_protos)/sizeof(struct pprot))
-				exit_error(PARAMETER_PROBLEM,
-					   "unknown protocol `%s' specified",
-					   s);
-		}
-	}
-
-	return (u_int16_t)proto;
-}
-
-static void
-parse_interface(const char *arg, char *vianame, unsigned char *mask)
-{
-	int vialen = strlen(arg);
-	unsigned int i;
-
-	memset(mask, 0, IFNAMSIZ);
-	memset(vianame, 0, IFNAMSIZ);
-
-	if (vialen + 1 > IFNAMSIZ)
-		exit_error(PARAMETER_PROBLEM,
-			   "interface name `%s' must be shorter than IFNAMSIZ"
-			   " (%i)", arg, IFNAMSIZ-1);
-
-	strcpy(vianame, arg);
-	if (vialen == 0)
-		memset(mask, 0, IFNAMSIZ);
-	else if (vianame[vialen - 1] == '+') {
-		memset(mask, 0xFF, vialen - 1);
-		memset(mask + vialen - 1, 0, IFNAMSIZ - vialen + 1);
-		/* Don't remove `+' here! -HW */
-	} else {
-		/* Include nul-terminator in match */
-		memset(mask, 0xFF, vialen + 1);
-		memset(mask + vialen + 1, 0, IFNAMSIZ - vialen - 1);
-		for (i = 0; vianame[i]; i++) {
-			if (!isalnum(vianame[i]) 
-			    && vianame[i] != '_' 
-			    && vianame[i] != '.') {
-				printf("Warning: wierd character in interface"
-				       " `%s' (No aliases, :, ! or *).\n",
-				       vianame);
-				break;
-			}
-		}
-	}
-}
-
-/* Can't be zero. */
-static int
-parse_rulenumber(const char *rule)
-{
-	unsigned int rulenum;
-
-	if (string_to_number(rule, 1, INT_MAX, &rulenum) == -1)
-		exit_error(PARAMETER_PROBLEM,
-			   "Invalid rule number `%s'", rule);
-
-	return rulenum;
-}
-
-static const char *
-parse_target(const char *targetname)
-{
-	const char *ptr;
-
-	if (strlen(targetname) < 1)
-		exit_error(PARAMETER_PROBLEM,
-			   "Invalid target name (too short)");
-
-	if (strlen(targetname)+1 > sizeof(ipt_chainlabel))
-		exit_error(PARAMETER_PROBLEM,
-			   "Invalid target name `%s' (%i chars max)",
-			   targetname, sizeof(ipt_chainlabel)-1);
-
-	for (ptr = targetname; *ptr; ptr++)
-		if (isspace(*ptr))
-			exit_error(PARAMETER_PROBLEM,
-				   "Invalid target name `%s'", targetname);
-	return targetname;
-}
-
-static char *
-addr_to_network(const struct in_addr *addr)
-{
-	struct netent *net;
-
-	if ((net = getnetbyaddr((long) ntohl(addr->s_addr), AF_INET)) != NULL)
-		return (char *) net->n_name;
-
-	return (char *) NULL;
-}
-
-char *
-addr_to_dotted(const struct in_addr *addrp)
-{
-	static char buf[20];
-	const unsigned char *bytep;
-
-	bytep = (const unsigned char *) &(addrp->s_addr);
-	sprintf(buf, "%d.%d.%d.%d", bytep[0], bytep[1], bytep[2], bytep[3]);
-	return buf;
-}
-
-char *
-addr_to_anyname(const struct in_addr *addr)
-{
-	char *name;
-
-	if ((name = addr_to_host(addr)) != NULL ||
-	    (name = addr_to_network(addr)) != NULL)
-		return name;
-
-	return addr_to_dotted(addr);
-}
-
-char *
-mask_to_dotted(const struct in_addr *mask)
-{
-	int i;
-	static char buf[20];
-	u_int32_t maskaddr, bits;
-
-	maskaddr = ntohl(mask->s_addr);
-
-	if (maskaddr == 0xFFFFFFFFL)
-		/* we don't want to see "/32" */
-		return "";
-
-	i = 32;
-	bits = 0xFFFFFFFEL;
-	while (--i >= 0 && maskaddr != bits)
-		bits <<= 1;
-	if (i >= 0)
-		sprintf(buf, "/%d", i);
-	else
-		/* mask was not a decent combination of 1's and 0's */
-		sprintf(buf, "/%s", addr_to_dotted(mask));
-
-	return buf;
-}
-
-int
-string_to_number(const char *s, unsigned int min, unsigned int max,
-		 unsigned int *ret)
-{
-	long number;
-	char *end;
-
-	/* Handle hex, octal, etc. */
-	errno = 0;
-	number = strtol(s, &end, 0);
-	if (*end == '\0' && end != s) {
-		/* we parsed a number, let's see if we want this */
-		if (errno != ERANGE && min <= number && number <= max) {
-			*ret = number;
-			return 0;
-		}
-	}
-	return -1;
-}
-
-static void
-set_option(unsigned int *options, unsigned int option, u_int8_t *invflg,
-	   int invert)
-{
-	if (*options & option)
-		exit_error(PARAMETER_PROBLEM, "multiple -%c flags not allowed",
-			   opt2char(option));
-	*options |= option;
-
-	if (invert) {
-		unsigned int i;
-		for (i = 0; 1 << i != option; i++);
-
-		if (!inverse_for_options[i])
-			exit_error(PARAMETER_PROBLEM,
-				   "cannot have ! before -%c",
-				   opt2char(option));
-		*invflg |= inverse_for_options[i];
-	}
-}
-
-struct iptables_target *
-find_target(const char *name, enum ipt_tryload tryload)
-{
-	struct iptables_target *ptr;
-
-	/* Standard target? */
-	if (strcmp(name, "") == 0
-	    || strcmp(name, IPTC_LABEL_ACCEPT) == 0
-	    || strcmp(name, IPTC_LABEL_DROP) == 0
-	    || strcmp(name, IPTC_LABEL_QUEUE) == 0
-	    || strcmp(name, IPTC_LABEL_RETURN) == 0)
-		name = "standard";
-
-	for (ptr = iptables_targets; ptr; ptr = ptr->next) {
-		if (strcmp(name, ptr->name) == 0)
-			break;
-	}
-
-#ifndef NO_SHARED_LIBS
-	if (!ptr && tryload != DONT_LOAD) {
-		char path[sizeof(IPT_LIB_DIR) + sizeof("/libipt_.so")
-			 + strlen(name)];
-		sprintf(path, IPT_LIB_DIR "/libipt_%s.so", name);
-		if (dlopen(path, RTLD_NOW)) {
-			/* Found library.  If it didn't register itself,
-			   maybe they specified match as a target. */
-			ptr = find_target(name, DONT_LOAD);
-			if (!ptr)
-				exit_error(PARAMETER_PROBLEM,
-					   "Couldn't load target `%s'\n",
-					   name);
-		} else if (tryload == LOAD_MUST_SUCCEED)
-			exit_error(PARAMETER_PROBLEM,
-				   "Couldn't load target `%s':%s\n",
-				   name, dlerror());
-	}
-#else
-	if (ptr && !ptr->loaded) {
-		if (tryload != DONT_LOAD)
-			ptr->loaded = 1;
-		else
-			ptr = NULL;
-	}
-	if(!ptr && (tryload == LOAD_MUST_SUCCEED)) {
-		exit_error(PARAMETER_PROBLEM,
-			   "Couldn't find target `%s'\n", name);
-	}
-#endif
-
-	if (ptr)
-		ptr->used = 1;
-
-	return ptr;
-}
-
-static struct option *
-merge_options(struct option *oldopts, const struct option *newopts,
-	      unsigned int *option_offset)
-{
-	unsigned int num_old, num_new, i;
-	struct option *merge;
-
-	for (num_old = 0; oldopts[num_old].name; num_old++);
-	for (num_new = 0; newopts[num_new].name; num_new++);
-
-	global_option_offset += OPTION_OFFSET;
-	*option_offset = global_option_offset;
-
-	merge = malloc(sizeof(struct option) * (num_new + num_old + 1));
-	memcpy(merge, oldopts, num_old * sizeof(struct option));
-	for (i = 0; i < num_new; i++) {
-		merge[num_old + i] = newopts[i];
-		merge[num_old + i].val += *option_offset;
-	}
-	memset(merge + num_old + num_new, 0, sizeof(struct option));
-
-	return merge;
-}
-
-void
-register_match(struct iptables_match *me)
-{
-	struct iptables_match **i;
-
-	if (strcmp(me->version, program_version) != 0) {
-		fprintf(stderr, "%s: match `%s' v%s (I'm v%s).\n",
-			program_name, me->name, me->version, program_version);
-		exit(1);
-	}
-
-	if (find_match(me->name, DONT_LOAD)) {
-		fprintf(stderr, "%s: match `%s' already registered.\n",
-			program_name, me->name);
-		exit(1);
-	}
-
-	if (me->size != IPT_ALIGN(me->size)) {
-		fprintf(stderr, "%s: match `%s' has invalid size %u.\n",
-			program_name, me->name, me->size);
-		exit(1);
-	}
-
-	/* Append to list. */
-	for (i = &iptables_matches; *i; i = &(*i)->next);
-	me->next = NULL;
-	*i = me;
-
-	me->m = NULL;
-	me->mflags = 0;
-}
-
-void
-register_target(struct iptables_target *me)
-{
-	if (strcmp(me->version, program_version) != 0) {
-		fprintf(stderr, "%s: target `%s' v%s (I'm v%s).\n",
-			program_name, me->name, me->version, program_version);
-		exit(1);
-	}
-
-	if (find_target(me->name, DONT_LOAD)) {
-		fprintf(stderr, "%s: target `%s' already registered.\n",
-			program_name, me->name);
-		exit(1);
-	}
-
-	if (me->size != IPT_ALIGN(me->size)) {
-		fprintf(stderr, "%s: target `%s' has invalid size %u.\n",
-			program_name, me->name, me->size);
-		exit(1);
-	}
-
-	/* Prepend to list. */
-	me->next = iptables_targets;
-	iptables_targets = me;
-	me->t = NULL;
-	me->tflags = 0;
-}
-
-static void
-print_num(u_int64_t number, unsigned int format)
-{
-	if (format & FMT_KILOMEGAGIGA) {
-		if (number > 99999) {
-			number = (number + 500) / 1000;
-			if (number > 9999) {
-				number = (number + 500) / 1000;
-				if (number > 9999) {
-					number = (number + 500) / 1000;
-					if (number > 9999) {
-						number = (number + 500) / 1000;
-						printf(FMT("%4lluT ","%lluT "), number);
-					}
-					else printf(FMT("%4lluG ","%lluG "), number);
-				}
-				else printf(FMT("%4lluM ","%lluM "), number);
-			} else
-				printf(FMT("%4lluK ","%lluK "), number);
-		} else
-			printf(FMT("%5llu ","%llu "), number);
-	} else
-		printf(FMT("%8llu ","%llu "), number);
-}
-
-
-static void
-print_header(unsigned int format, const char *chain, iptc_handle_t *handle)
-{
-	struct ipt_counters counters;
-	const char *pol = iptc_get_policy(chain, &counters, handle);
-	printf("Chain %s", chain);
-	if (pol) {
-		printf(" (policy %s", pol);
-		if (!(format & FMT_NOCOUNTS)) {
-			fputc(' ', stdout);
-			print_num(counters.pcnt, (format|FMT_NOTABLE));
-			fputs("packets, ", stdout);
-			print_num(counters.bcnt, (format|FMT_NOTABLE));
-			fputs("bytes", stdout);
-		}
-		printf(")\n");
-	} else {
-		unsigned int refs;
-		if (!iptc_get_references(&refs, chain, handle))
-			printf(" (ERROR obtaining refs)\n");
-		else
-			printf(" (%u references)\n", refs);
-	}
-
-	if (format & FMT_LINENUMBERS)
-		printf(FMT("%-4s ", "%s "), "num");
-	if (!(format & FMT_NOCOUNTS)) {
-		if (format & FMT_KILOMEGAGIGA) {
-			printf(FMT("%5s ","%s "), "pkts");
-			printf(FMT("%5s ","%s "), "bytes");
-		} else {
-			printf(FMT("%8s ","%s "), "pkts");
-			printf(FMT("%10s ","%s "), "bytes");
-		}
-	}
-	if (!(format & FMT_NOTARGET))
-		printf(FMT("%-9s ","%s "), "target");
-	fputs(" prot ", stdout);
-	if (format & FMT_OPTIONS)
-		fputs("opt", stdout);
-	if (format & FMT_VIA) {
-		printf(FMT(" %-6s ","%s "), "in");
-		printf(FMT("%-6s ","%s "), "out");
-	}
-	printf(FMT(" %-19s ","%s "), "source");
-	printf(FMT(" %-19s "," %s "), "destination");
-	printf("\n");
-}
-
-
-static int
-print_match(const struct ipt_entry_match *m,
-	    const struct ipt_ip *ip,
-	    int numeric)
-{
-	struct iptables_match *match = find_match(m->u.user.name, TRY_LOAD);
-
-	if (match) {
-		if (match->print)
-			match->print(ip, m, numeric);
-		else
-			printf("%s ", match->name);
-	} else {
-		if (m->u.user.name[0])
-			printf("UNKNOWN match `%s' ", m->u.user.name);
-	}
-	/* Don't stop iterating. */
-	return 0;
-}
-
-/* e is called `fw' here for hysterical raisins */
-static void
-print_firewall(const struct ipt_entry *fw,
-	       const char *targname,
-	       unsigned int num,
-	       unsigned int format,
-	       const iptc_handle_t handle)
-{
-	struct iptables_target *target = NULL;
-	const struct ipt_entry_target *t;
-	u_int8_t flags;
-	char buf[BUFSIZ];
-
-	if (!iptc_is_chain(targname, handle))
-		target = find_target(targname, TRY_LOAD);
-	else
-		target = find_target(IPT_STANDARD_TARGET, LOAD_MUST_SUCCEED);
-
-	t = ipt_get_target((struct ipt_entry *)fw);
-	flags = fw->ip.flags;
-
-	if (format & FMT_LINENUMBERS)
-		printf(FMT("%-4u ", "%u "), num+1);
-
-	if (!(format & FMT_NOCOUNTS)) {
-		print_num(fw->counters.pcnt, format);
-		print_num(fw->counters.bcnt, format);
-	}
-
-	if (!(format & FMT_NOTARGET))
-		printf(FMT("%-9s ", "%s "), targname);
-
-	fputc(fw->ip.invflags & IPT_INV_PROTO ? '!' : ' ', stdout);
-	{
-		char *pname = proto_to_name(fw->ip.proto, format&FMT_NUMERIC);
-		if (pname)
-			printf(FMT("%-5s", "%s "), pname);
-		else
-			printf(FMT("%-5hu", "%hu "), fw->ip.proto);
-	}
-
-	if (format & FMT_OPTIONS) {
-		if (format & FMT_NOTABLE)
-			fputs("opt ", stdout);
-		fputc(fw->ip.invflags & IPT_INV_FRAG ? '!' : '-', stdout);
-		fputc(flags & IPT_F_FRAG ? 'f' : '-', stdout);
-		fputc(' ', stdout);
-	}
-
-	if (format & FMT_VIA) {
-		char iface[IFNAMSIZ+2];
-
-		if (fw->ip.invflags & IPT_INV_VIA_IN) {
-			iface[0] = '!';
-			iface[1] = '\0';
-		}
-		else iface[0] = '\0';
-
-		if (fw->ip.iniface[0] != '\0') {
-			strcat(iface, fw->ip.iniface);
-		}
-		else if (format & FMT_NUMERIC) strcat(iface, "*");
-		else strcat(iface, "any");
-		printf(FMT(" %-6s ","in %s "), iface);
-
-		if (fw->ip.invflags & IPT_INV_VIA_OUT) {
-			iface[0] = '!';
-			iface[1] = '\0';
-		}
-		else iface[0] = '\0';
-
-		if (fw->ip.outiface[0] != '\0') {
-			strcat(iface, fw->ip.outiface);
-		}
-		else if (format & FMT_NUMERIC) strcat(iface, "*");
-		else strcat(iface, "any");
-		printf(FMT("%-6s ","out %s "), iface);
-	}
-
-	fputc(fw->ip.invflags & IPT_INV_SRCIP ? '!' : ' ', stdout);
-	if (fw->ip.smsk.s_addr == 0L && !(format & FMT_NUMERIC))
-		printf(FMT("%-19s ","%s "), "anywhere");
-	else {
-		if (format & FMT_NUMERIC)
-			sprintf(buf, "%s", addr_to_dotted(&(fw->ip.src)));
-		else
-			sprintf(buf, "%s", addr_to_anyname(&(fw->ip.src)));
-		strcat(buf, mask_to_dotted(&(fw->ip.smsk)));
-		printf(FMT("%-19s ","%s "), buf);
-	}
-
-	fputc(fw->ip.invflags & IPT_INV_DSTIP ? '!' : ' ', stdout);
-	if (fw->ip.dmsk.s_addr == 0L && !(format & FMT_NUMERIC))
-		printf(FMT("%-19s","-> %s"), "anywhere");
-	else {
-		if (format & FMT_NUMERIC)
-			sprintf(buf, "%s", addr_to_dotted(&(fw->ip.dst)));
-		else
-			sprintf(buf, "%s", addr_to_anyname(&(fw->ip.dst)));
-		strcat(buf, mask_to_dotted(&(fw->ip.dmsk)));
-		printf(FMT("%-19s","-> %s"), buf);
-	}
-
-	if (format & FMT_NOTABLE)
-		fputs("  ", stdout);
-
-	IPT_MATCH_ITERATE(fw, print_match, &fw->ip, format & FMT_NUMERIC);
-
-	if (target) {
-		if (target->print)
-			/* Print the target information. */
-			target->print(&fw->ip, t, format & FMT_NUMERIC);
-	} else if (t->u.target_size != sizeof(*t))
-		printf("[%u bytes of unknown target data] ",
-		       t->u.target_size - sizeof(*t));
-
-	if (!(format & FMT_NONEWLINE))
-		fputc('\n', stdout);
-}
-
-static void
-print_firewall_line(const struct ipt_entry *fw,
-		    const iptc_handle_t h)
-{
-	struct ipt_entry_target *t;
-
-	t = ipt_get_target((struct ipt_entry *)fw);
-	print_firewall(fw, t->u.user.name, 0, FMT_PRINT_RULE, h);
-}
-
-static int
-append_entry(const ipt_chainlabel chain,
-	     struct ipt_entry *fw,
-	     unsigned int nsaddrs,
-	     const struct in_addr saddrs[],
-	     unsigned int ndaddrs,
-	     const struct in_addr daddrs[],
-	     int verbose,
-	     iptc_handle_t *handle)
-{
-	unsigned int i, j;
-	int ret = 1;
-
-	for (i = 0; i < nsaddrs; i++) {
-		fw->ip.src.s_addr = saddrs[i].s_addr;
-		for (j = 0; j < ndaddrs; j++) {
-			fw->ip.dst.s_addr = daddrs[j].s_addr;
-			if (verbose)
-				print_firewall_line(fw, *handle);
-			ret &= iptc_append_entry(chain, fw, handle);
-		}
-	}
-
-	return ret;
-}
-
-static int
-replace_entry(const ipt_chainlabel chain,
-	      struct ipt_entry *fw,
-	      unsigned int rulenum,
-	      const struct in_addr *saddr,
-	      const struct in_addr *daddr,
-	      int verbose,
-	      iptc_handle_t *handle)
-{
-	fw->ip.src.s_addr = saddr->s_addr;
-	fw->ip.dst.s_addr = daddr->s_addr;
-
-	if (verbose)
-		print_firewall_line(fw, *handle);
-	return iptc_replace_entry(chain, fw, rulenum, handle);
-}
-
-static int
-insert_entry(const ipt_chainlabel chain,
-	     struct ipt_entry *fw,
-	     unsigned int rulenum,
-	     unsigned int nsaddrs,
-	     const struct in_addr saddrs[],
-	     unsigned int ndaddrs,
-	     const struct in_addr daddrs[],
-	     int verbose,
-	     iptc_handle_t *handle)
-{
-	unsigned int i, j;
-	int ret = 1;
-
-	for (i = 0; i < nsaddrs; i++) {
-		fw->ip.src.s_addr = saddrs[i].s_addr;
-		for (j = 0; j < ndaddrs; j++) {
-			fw->ip.dst.s_addr = daddrs[j].s_addr;
-			if (verbose)
-				print_firewall_line(fw, *handle);
-			ret &= iptc_insert_entry(chain, fw, rulenum, handle);
-		}
-	}
-
-	return ret;
-}
-
-static unsigned char *
-make_delete_mask(struct ipt_entry *fw)
-{
-	/* Establish mask for comparison */
-	unsigned int size;
-	struct iptables_match *m;
-	unsigned char *mask, *mptr;
-
-	size = sizeof(struct ipt_entry);
-	for (m = iptables_matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		size += IPT_ALIGN(sizeof(struct ipt_entry_match)) + m->size;
-	}
-
-	mask = fw_calloc(1, size
-			 + IPT_ALIGN(sizeof(struct ipt_entry_target))
-			 + iptables_targets->size);
-
-	memset(mask, 0xFF, sizeof(struct ipt_entry));
-	mptr = mask + sizeof(struct ipt_entry);
-
-	for (m = iptables_matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		memset(mptr, 0xFF,
-		       IPT_ALIGN(sizeof(struct ipt_entry_match))
-		       + m->userspacesize);
-		mptr += IPT_ALIGN(sizeof(struct ipt_entry_match)) + m->size;
-	}
-
-	memset(mptr, 0xFF,
-	       IPT_ALIGN(sizeof(struct ipt_entry_target))
-	       + iptables_targets->userspacesize);
-
-	return mask;
-}
-
-static int
-delete_entry(const ipt_chainlabel chain,
-	     struct ipt_entry *fw,
-	     unsigned int nsaddrs,
-	     const struct in_addr saddrs[],
-	     unsigned int ndaddrs,
-	     const struct in_addr daddrs[],
-	     int verbose,
-	     iptc_handle_t *handle)
-{
-	unsigned int i, j;
-	int ret = 1;
-	unsigned char *mask;
-
-	mask = make_delete_mask(fw);
-	for (i = 0; i < nsaddrs; i++) {
-		fw->ip.src.s_addr = saddrs[i].s_addr;
-		for (j = 0; j < ndaddrs; j++) {
-			fw->ip.dst.s_addr = daddrs[j].s_addr;
-			if (verbose)
-				print_firewall_line(fw, *handle);
-			ret &= iptc_delete_entry(chain, fw, mask, handle);
-		}
-	}
-	return ret;
-}
-
-int
-for_each_chain(int (*fn)(const ipt_chainlabel, int, iptc_handle_t *),
-	       int verbose, int builtinstoo, iptc_handle_t *handle)
-{
-        int ret = 1;
-	const char *chain;
-	char *chains;
-	unsigned int i, chaincount = 0;
-
-	chain = iptc_first_chain(handle);
-	while (chain) {
-		chaincount++;
-		chain = iptc_next_chain(handle);
-        }
-
-	chains = fw_malloc(sizeof(ipt_chainlabel) * chaincount);
-	i = 0;
-	chain = iptc_first_chain(handle);
-	while (chain) {
-		strcpy(chains + i*sizeof(ipt_chainlabel), chain);
-		i++;
-		chain = iptc_next_chain(handle);
-        }
-
-	for (i = 0; i < chaincount; i++) {
-		if (!builtinstoo
-		    && iptc_builtin(chains + i*sizeof(ipt_chainlabel),
-				    *handle))
-			continue;
-	        ret &= fn(chains + i*sizeof(ipt_chainlabel), verbose, handle);
-	}
-
-	free(chains);
-        return ret;
-}
-
-int
-flush_entries(const ipt_chainlabel chain, int verbose,
-	      iptc_handle_t *handle)
-{
-	if (!chain)
-		return for_each_chain(flush_entries, verbose, 1, handle);
-
-	if (verbose)
-		fprintf(stdout, "Flushing chain `%s'\n", chain);
-	return iptc_flush_entries(chain, handle);
-}
-
-static int
-zero_entries(const ipt_chainlabel chain, int verbose,
-	     iptc_handle_t *handle)
-{
-	if (!chain)
-		return for_each_chain(zero_entries, verbose, 1, handle);
-
-	if (verbose)
-		fprintf(stdout, "Zeroing chain `%s'\n", chain);
-	return iptc_zero_entries(chain, handle);
-}
-
-int
-delete_chain(const ipt_chainlabel chain, int verbose,
-	     iptc_handle_t *handle)
-{
-	if (!chain)
-		return for_each_chain(delete_chain, verbose, 0, handle);
-
-	if (verbose)
-	        fprintf(stdout, "Deleting chain `%s'\n", chain);
-	return iptc_delete_chain(chain, handle);
-}
-
-static int
-list_entries(const ipt_chainlabel chain, int verbose, int numeric,
-	     int expanded, int linenumbers, iptc_handle_t *handle)
-{
-	int found = 0;
-	unsigned int format;
-	const char *this;
-
-	format = FMT_OPTIONS;
-	if (!verbose)
-		format |= FMT_NOCOUNTS;
-	else
-		format |= FMT_VIA;
-
-	if (numeric)
-		format |= FMT_NUMERIC;
-
-	if (!expanded)
-		format |= FMT_KILOMEGAGIGA;
-
-	if (linenumbers)
-		format |= FMT_LINENUMBERS;
-
-	for (this = iptc_first_chain(handle);
-	     this;
-	     this = iptc_next_chain(handle)) {
-		const struct ipt_entry *i;
-		unsigned int num;
-
-		if (chain && strcmp(chain, this) != 0)
-			continue;
-
-		if (found) printf("\n");
-
-		print_header(format, this, handle);
-		i = iptc_first_rule(this, handle);
-
-		num = 0;
-		while (i) {
-			print_firewall(i,
-				       iptc_get_target(i, handle),
-				       num++,
-				       format,
-				       *handle);
-			i = iptc_next_rule(i, handle);
-		}
-		found = 1;
-	}
-
-	errno = ENOENT;
-	return found;
-}
-
-static char *get_modprobe(void)
-{
-	int procfile;
-	char *ret;
-
-	procfile = open(PROC_SYS_MODPROBE, O_RDONLY);
-	if (procfile < 0)
-		return NULL;
-
-	ret = malloc(1024);
-	if (ret) {
-		switch (read(procfile, ret, 1024)) {
-		case -1: goto fail;
-		case 1024: goto fail; /* Partial read.  Wierd */
-		}
-		if (ret[strlen(ret)-1]=='\n') 
-			ret[strlen(ret)-1]=0;
-		close(procfile);
-		return ret;
-	}
- fail:
-	free(ret);
-	close(procfile);
-	return NULL;
-}
-
-int iptables_insmod(const char *modname, const char *modprobe)
-{
-	char *buf = NULL;
-	char *argv[3];
-
-	/* If they don't explicitly set it, read out of kernel */
-	if (!modprobe) {
-		buf = get_modprobe();
-		if (!buf)
-			return -1;
-		modprobe = buf;
-	}
-
-	switch (fork()) {
-	case 0:
-		argv[0] = (char *)modprobe;
-		argv[1] = (char *)modname;
-		argv[2] = NULL;
-		execv(argv[0], argv);
-
-		/* not usually reached */
-		exit(0);
-	case -1:
-		return -1;
-
-	default: /* parent */
-		wait(NULL);
-	}
-
-	free(buf);
-	return 0;
-}
-
-static struct ipt_entry *
-generate_entry(const struct ipt_entry *fw,
-	       struct iptables_match *matches,
-	       struct ipt_entry_target *target)
-{
-	unsigned int size;
-	struct iptables_match *m;
-	struct ipt_entry *e;
-
-	size = sizeof(struct ipt_entry);
-	for (m = matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		size += m->m->u.match_size;
-	}
-
-	e = fw_malloc(size + target->u.target_size);
-	*e = *fw;
-	e->target_offset = size;
-	e->next_offset = size + target->u.target_size;
-
-	size = 0;
-	for (m = matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		memcpy(e->elems + size, m->m, m->m->u.match_size);
-		size += m->m->u.match_size;
-	}
-	memcpy(e->elems + size, target, target->u.target_size);
-
-	return e;
-}
-
-int do_command(int argc, char *argv[], char **table, iptc_handle_t *handle)
-{
-	struct ipt_entry fw, *e = NULL;
-	int invert = 0;
-	unsigned int nsaddrs = 0, ndaddrs = 0;
-	struct in_addr *saddrs = NULL, *daddrs = NULL;
-
-	int c, verbose = 0;
-	const char *chain = NULL;
-	const char *shostnetworkmask = NULL, *dhostnetworkmask = NULL;
-	const char *policy = NULL, *newname = NULL;
-	unsigned int rulenum = 0, options = 0, command = 0;
-	const char *pcnt = NULL, *bcnt = NULL;
-	int ret = 1;
-	struct iptables_match *m;
-	struct iptables_target *target = NULL;
-	struct iptables_target *t;
-	const char *jumpto = "";
-	char *protocol = NULL;
-	const char *modprobe = NULL;
-	int proto_used = 0;
-
-	memset(&fw, 0, sizeof(fw));
-
-	opts = original_opts;
-	global_option_offset = 0;
-
-	/* re-set optind to 0 in case do_command gets called
-	 * a second time */
-	optind = 0;
-
-	/* clear mflags in case do_command gets called a second time
-	 * (we clear the global list of all matches for security)*/
-	for (m = iptables_matches; m; m = m->next) {
-		m->mflags = 0;
-		m->used = 0;
-	}
-
-	for (t = iptables_targets; t; t = t->next) {
-		t->tflags = 0;
-		t->used = 0;
-	}
-
-	/* Suppress error messages: we may add new options if we
-           demand-load a protocol. */
-	opterr = 0;
-
-	while ((c = getopt_long(argc, argv,
-	   "-A:D:R:I:L::M:F::Z::N:X::E:P:Vh::o:p:s:d:j:i:fbvnt:m:xc:",
-					   opts, NULL)) != -1) {
-		switch (c) {
-			/*
-			 * Command selection
-			 */
-		case 'A':
-			add_command(&command, CMD_APPEND, CMD_NONE,
-				    invert);
-			chain = optarg;
-			break;
-
-		case 'D':
-			add_command(&command, CMD_DELETE, CMD_NONE,
-				    invert);
-			chain = optarg;
-			if (optind < argc && argv[optind][0] != '-'
-			    && argv[optind][0] != '!') {
-				rulenum = parse_rulenumber(argv[optind++]);
-				command = CMD_DELETE_NUM;
-			}
-			break;
-
-		case 'R':
-			add_command(&command, CMD_REPLACE, CMD_NONE,
-				    invert);
-			chain = optarg;
-			if (optind < argc && argv[optind][0] != '-'
-			    && argv[optind][0] != '!')
-				rulenum = parse_rulenumber(argv[optind++]);
-			else
-				exit_error(PARAMETER_PROBLEM,
-					   "-%c requires a rule number",
-					   cmd2char(CMD_REPLACE));
-			break;
-
-		case 'I':
-			add_command(&command, CMD_INSERT, CMD_NONE,
-				    invert);
-			chain = optarg;
-			if (optind < argc && argv[optind][0] != '-'
-			    && argv[optind][0] != '!')
-				rulenum = parse_rulenumber(argv[optind++]);
-			else rulenum = 1;
-			break;
-
-		case 'L':
-			add_command(&command, CMD_LIST, CMD_ZERO,
-				    invert);
-			if (optarg) chain = optarg;
-			else if (optind < argc && argv[optind][0] != '-'
-				 && argv[optind][0] != '!')
-				chain = argv[optind++];
-			break;
-
-		case 'F':
-			add_command(&command, CMD_FLUSH, CMD_NONE,
-				    invert);
-			if (optarg) chain = optarg;
-			else if (optind < argc && argv[optind][0] != '-'
-				 && argv[optind][0] != '!')
-				chain = argv[optind++];
-			break;
-
-		case 'Z':
-			add_command(&command, CMD_ZERO, CMD_LIST,
-				    invert);
-			if (optarg) chain = optarg;
-			else if (optind < argc && argv[optind][0] != '-'
-				&& argv[optind][0] != '!')
-				chain = argv[optind++];
-			break;
-
-		case 'N':
-			if (optarg && *optarg == '-')
-				exit_error(PARAMETER_PROBLEM,
-					   "chain name not allowed to start "
-					   "with `-'\n");
-			if (find_target(optarg, TRY_LOAD))
-				exit_error(PARAMETER_PROBLEM,
-					   "chain name may not clash "
-					   "with target name\n");
-			add_command(&command, CMD_NEW_CHAIN, CMD_NONE,
-				    invert);
-			chain = optarg;
-			break;
-
-		case 'X':
-			add_command(&command, CMD_DELETE_CHAIN, CMD_NONE,
-				    invert);
-			if (optarg) chain = optarg;
-			else if (optind < argc && argv[optind][0] != '-'
-				 && argv[optind][0] != '!')
-				chain = argv[optind++];
-			break;
-
-		case 'E':
-			add_command(&command, CMD_RENAME_CHAIN, CMD_NONE,
-				    invert);
-			chain = optarg;
-			if (optind < argc && argv[optind][0] != '-'
-			    && argv[optind][0] != '!')
-				newname = argv[optind++];
-			else
-				exit_error(PARAMETER_PROBLEM,
-				           "-%c requires old-chain-name and "
-					   "new-chain-name",
-					    cmd2char(CMD_RENAME_CHAIN));
-			break;
-
-		case 'P':
-			add_command(&command, CMD_SET_POLICY, CMD_NONE,
-				    invert);
-			chain = optarg;
-			if (optind < argc && argv[optind][0] != '-'
-			    && argv[optind][0] != '!')
-				policy = argv[optind++];
-			else
-				exit_error(PARAMETER_PROBLEM,
-					   "-%c requires a chain and a policy",
-					   cmd2char(CMD_SET_POLICY));
-			break;
-
-		case 'h':
-			if (!optarg)
-				optarg = argv[optind];
-
-			/* iptables -p icmp -h */
-			if (!iptables_matches && protocol)
-				find_match(protocol, TRY_LOAD);
-
-			exit_printhelp();
-
-			/*
-			 * Option selection
-			 */
-		case 'p':
-			check_inverse(optarg, &invert, &optind, argc);
-			set_option(&options, OPT_PROTOCOL, &fw.ip.invflags,
-				   invert);
-
-			/* Canonicalize into lower case */
-			for (protocol = argv[optind-1]; *protocol; protocol++)
-				*protocol = tolower(*protocol);
-
-			protocol = argv[optind-1];
-			fw.ip.proto = parse_protocol(protocol);
-
-			if (fw.ip.proto == 0
-			    && (fw.ip.invflags & IPT_INV_PROTO))
-				exit_error(PARAMETER_PROBLEM,
-					   "rule would never match protocol");
-			fw.nfcache |= NFC_IP_PROTO;
-			break;
-
-		case 's':
-			check_inverse(optarg, &invert, &optind, argc);
-			set_option(&options, OPT_SOURCE, &fw.ip.invflags,
-				   invert);
-			shostnetworkmask = argv[optind-1];
-			fw.nfcache |= NFC_IP_SRC;
-			break;
-
-		case 'd':
-			check_inverse(optarg, &invert, &optind, argc);
-			set_option(&options, OPT_DESTINATION, &fw.ip.invflags,
-				   invert);
-			dhostnetworkmask = argv[optind-1];
-			fw.nfcache |= NFC_IP_DST;
-			break;
-
-		case 'j':
-			set_option(&options, OPT_JUMP, &fw.ip.invflags,
-				   invert);
-			jumpto = parse_target(optarg);
-			/* TRY_LOAD (may be chain name) */
-			target = find_target(jumpto, TRY_LOAD);
-
-			if (target) {
-				size_t size;
-
-				size = IPT_ALIGN(sizeof(struct ipt_entry_target))
-					+ target->size;
-
-				target->t = fw_calloc(1, size);
-				target->t->u.target_size = size;
-				strcpy(target->t->u.user.name, jumpto);
-				target->init(target->t, &fw.nfcache);
-				opts = merge_options(opts, target->extra_opts, &target->option_offset);
-			}
-			break;
-
-
-		case 'i':
-			check_inverse(optarg, &invert, &optind, argc);
-			set_option(&options, OPT_VIANAMEIN, &fw.ip.invflags,
-				   invert);
-			parse_interface(argv[optind-1],
-					fw.ip.iniface,
-					fw.ip.iniface_mask);
-			fw.nfcache |= NFC_IP_IF_IN;
-			break;
-
-		case 'o':
-			check_inverse(optarg, &invert, &optind, argc);
-			set_option(&options, OPT_VIANAMEOUT, &fw.ip.invflags,
-				   invert);
-			parse_interface(argv[optind-1],
-					fw.ip.outiface,
-					fw.ip.outiface_mask);
-			fw.nfcache |= NFC_IP_IF_OUT;
-			break;
-
-		case 'f':
-			set_option(&options, OPT_FRAGMENT, &fw.ip.invflags,
-				   invert);
-			fw.ip.flags |= IPT_F_FRAG;
-			fw.nfcache |= NFC_IP_FRAG;
-			break;
-
-		case 'v':
-			if (!verbose)
-				set_option(&options, OPT_VERBOSE,
-					   &fw.ip.invflags, invert);
-			verbose++;
-			break;
-
-		case 'm': {
-			size_t size;
-
-			if (invert)
-				exit_error(PARAMETER_PROBLEM,
-					   "unexpected ! flag before --match");
-
-			m = find_match(optarg, LOAD_MUST_SUCCEED);
-			size = IPT_ALIGN(sizeof(struct ipt_entry_match))
-					 + m->size;
-			m->m = fw_calloc(1, size);
-			m->m->u.match_size = size;
-			strcpy(m->m->u.user.name, m->name);
-			m->init(m->m, &fw.nfcache);
-			opts = merge_options(opts, m->extra_opts, &m->option_offset);
-		}
-		break;
-
-		case 'n':
-			set_option(&options, OPT_NUMERIC, &fw.ip.invflags,
-				   invert);
-			break;
-
-		case 't':
-			if (invert)
-				exit_error(PARAMETER_PROBLEM,
-					   "unexpected ! flag before --table");
-			*table = argv[optind-1];
-			break;
-
-		case 'x':
-			set_option(&options, OPT_EXPANDED, &fw.ip.invflags,
-				   invert);
-			break;
-
-		case 'V':
-			if (invert)
-				printf("Not %s ;-)\n", program_version);
-			else
-				printf("%s v%s\n",
-				       program_name, program_version);
-			exit(0);
-
-		case '0':
-			set_option(&options, OPT_LINENUMBERS, &fw.ip.invflags,
-				   invert);
-			break;
-
-		case 'M':
-			modprobe = optarg;
-			break;
-
-		case 'c':
-
-			set_option(&options, OPT_COUNTERS, &fw.ip.invflags,
-				   invert);
-			pcnt = optarg;
-			if (optind < argc && argv[optind][0] != '-'
-			    && argv[optind][0] != '!')
-				bcnt = argv[optind++];
-			else
-				exit_error(PARAMETER_PROBLEM,
-					"-%c requires packet and byte counter",
-					opt2char(OPT_COUNTERS));
-
-			if (sscanf(pcnt, "%llu", &fw.counters.pcnt) != 1)
-				exit_error(PARAMETER_PROBLEM,
-					"-%c packet counter not numeric",
-					opt2char(OPT_COUNTERS));
-
-			if (sscanf(bcnt, "%llu", &fw.counters.bcnt) != 1)
-				exit_error(PARAMETER_PROBLEM,
-					"-%c byte counter not numeric",
-					opt2char(OPT_COUNTERS));
-			
-			break;
-
-
-		case 1: /* non option */
-			if (optarg[0] == '!' && optarg[1] == '\0') {
-				if (invert)
-					exit_error(PARAMETER_PROBLEM,
-						   "multiple consecutive ! not"
-						   " allowed");
-				invert = TRUE;
-				optarg[0] = '\0';
-				continue;
-			}
-			printf("Bad argument `%s'\n", optarg);
-			exit_tryhelp(2);
-
-		default:
-			/* FIXME: This scheme doesn't allow two of the same
-			   matches --RR */
-			if (!target
-			    || !(target->parse(c - target->option_offset,
-					       argv, invert,
-					       &target->tflags,
-					       &fw, &target->t))) {
-				for (m = iptables_matches; m; m = m->next) {
-					if (!m->used)
-						continue;
-
-					if (m->parse(c - m->option_offset,
-						     argv, invert,
-						     &m->mflags,
-						     &fw,
-						     &fw.nfcache,
-						     &m->m))
-						break;
-				}
-
-				/* If you listen carefully, you can
-				   actually hear this code suck. */
-
-				/* some explanations (after four different bugs
-				 * in 3 different releases): If we encountere a
-				 * parameter, that has not been parsed yet,
-				 * it's not an option of an explicitly loaded
-				 * match or a target.  However, we support
-				 * implicit loading of the protocol match
-				 * extension.  '-p tcp' means 'l4 proto 6' and
-				 * at the same time 'load tcp protocol match on
-				 * demand if we specify --dport'.
-				 *
-				 * To make this work, we need to make sure:
-				 * - the parameter has not been parsed by
-				 *   a match (m above)
-				 * - a protocol has been specified
-				 * - the protocol extension has not been
-				 *   loaded yet, or is loaded and unused
-				 *   [think of iptables-restore!]
-				 * - the protocol extension can be successively
-				 *   loaded
-				 */
-				if (m == NULL
-				    && protocol
-				    && (!find_proto(protocol, DONT_LOAD,
-						   options&OPT_NUMERIC) 
-					|| (find_proto(protocol, DONT_LOAD,
-							options&OPT_NUMERIC)
-					    && (proto_used == 0))
-				       )
-				    && (m = find_proto(protocol, TRY_LOAD,
-						       options&OPT_NUMERIC))) {
-					/* Try loading protocol */
-					size_t size;
-					
-					proto_used = 1;
-
-					size = IPT_ALIGN(sizeof(struct ipt_entry_match))
-							 + m->size;
-
-					m->m = fw_calloc(1, size);
-					m->m->u.match_size = size;
-					strcpy(m->m->u.user.name, m->name);
-					m->init(m->m, &fw.nfcache);
-
-					opts = merge_options(opts,
-					    m->extra_opts, &m->option_offset);
-
-					optind--;
-					continue;
-				}
-				if (!m)
-					exit_error(PARAMETER_PROBLEM,
-						   "Unknown arg `%s'",
-						   argv[optind-1]);
-			}
-		}
-		invert = FALSE;
-	}
-
-	for (m = iptables_matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		m->final_check(m->mflags);
-	}
-
-	if (target)
-		target->final_check(target->tflags);
-
-	/* Fix me: must put inverse options checking here --MN */
-
-	if (optind < argc)
-		exit_error(PARAMETER_PROBLEM,
-			   "unknown arguments found on commandline");
-	if (!command)
-		exit_error(PARAMETER_PROBLEM, "no command specified");
-	if (invert)
-		exit_error(PARAMETER_PROBLEM,
-			   "nothing appropriate following !");
-
-	if (command & (CMD_REPLACE | CMD_INSERT | CMD_DELETE | CMD_APPEND)) {
-		if (!(options & OPT_DESTINATION))
-			dhostnetworkmask = "0.0.0.0/0";
-		if (!(options & OPT_SOURCE))
-			shostnetworkmask = "0.0.0.0/0";
-	}
-
-	if (shostnetworkmask)
-		parse_hostnetworkmask(shostnetworkmask, &saddrs,
-				      &(fw.ip.smsk), &nsaddrs);
-
-	if (dhostnetworkmask)
-		parse_hostnetworkmask(dhostnetworkmask, &daddrs,
-				      &(fw.ip.dmsk), &ndaddrs);
-
-	if ((nsaddrs > 1 || ndaddrs > 1) &&
-	    (fw.ip.invflags & (IPT_INV_SRCIP | IPT_INV_DSTIP)))
-		exit_error(PARAMETER_PROBLEM, "! not allowed with multiple"
-			   " source or destination IP addresses");
-
-	if (command == CMD_REPLACE && (nsaddrs != 1 || ndaddrs != 1))
-		exit_error(PARAMETER_PROBLEM, "Replacement rule does not "
-			   "specify a unique address");
-
-	generic_opt_check(command, options);
-
-	if (chain && strlen(chain) > IPT_FUNCTION_MAXNAMELEN)
-		exit_error(PARAMETER_PROBLEM,
-			   "chain name `%s' too long (must be under %i chars)",
-			   chain, IPT_FUNCTION_MAXNAMELEN);
-
-	/* only allocate handle if we weren't called with a handle */
-	if (!*handle)
-		*handle = iptc_init(*table);
-
-	if (!*handle) {
-		/* try to insmod the module if iptc_init failed */
-		iptables_insmod("ip_tables", modprobe);
-		*handle = iptc_init(*table);
-	}
-
-	if (!*handle)
-		exit_error(VERSION_PROBLEM,
-			   "can't initialize iptables table `%s': %s",
-			   *table, iptc_strerror(errno));
-
-	if (command == CMD_APPEND
-	    || command == CMD_DELETE
-	    || command == CMD_INSERT
-	    || command == CMD_REPLACE) {
-		if (strcmp(chain, "PREROUTING") == 0
-		    || strcmp(chain, "INPUT") == 0) {
-			/* -o not valid with incoming packets. */
-			if (options & OPT_VIANAMEOUT)
-				exit_error(PARAMETER_PROBLEM,
-					   "Can't use -%c with %s\n",
-					   opt2char(OPT_VIANAMEOUT),
-					   chain);
-		}
-
-		if (strcmp(chain, "POSTROUTING") == 0
-		    || strcmp(chain, "OUTPUT") == 0) {
-			/* -i not valid with outgoing packets */
-			if (options & OPT_VIANAMEIN)
-				exit_error(PARAMETER_PROBLEM,
-					   "Can't use -%c with %s\n",
-					   opt2char(OPT_VIANAMEIN),
-					   chain);
-		}
-
-		if (target && iptc_is_chain(jumpto, *handle)) {
-			printf("Warning: using chain %s, not extension\n",
-			       jumpto);
-
-			target = NULL;
-		}
-
-		/* If they didn't specify a target, or it's a chain
-		   name, use standard. */
-		if (!target
-		    && (strlen(jumpto) == 0
-			|| iptc_is_chain(jumpto, *handle))) {
-			size_t size;
-
-			target = find_target(IPT_STANDARD_TARGET,
-					     LOAD_MUST_SUCCEED);
-
-			size = sizeof(struct ipt_entry_target)
-				+ target->size;
-			target->t = fw_calloc(1, size);
-			target->t->u.target_size = size;
-			strcpy(target->t->u.user.name, jumpto);
-			target->init(target->t, &fw.nfcache);
-		}
-
-		if (!target) {
-			/* it is no chain, and we can't load a plugin.
-			 * We cannot know if the plugin is corrupt, non
-			 * existant OR if the user just misspelled a
-			 * chain. */
-			find_target(jumpto, LOAD_MUST_SUCCEED);
-		} else {
-			e = generate_entry(&fw, iptables_matches, target->t);
-		}
-	}
-
-	switch (command) {
-	case CMD_APPEND:
-		ret = append_entry(chain, e,
-				   nsaddrs, saddrs, ndaddrs, daddrs,
-				   options&OPT_VERBOSE,
-				   handle);
-		break;
-	case CMD_DELETE:
-		ret = delete_entry(chain, e,
-				   nsaddrs, saddrs, ndaddrs, daddrs,
-				   options&OPT_VERBOSE,
-				   handle);
-		break;
-	case CMD_DELETE_NUM:
-		ret = iptc_delete_num_entry(chain, rulenum - 1, handle);
-		break;
-	case CMD_REPLACE:
-		ret = replace_entry(chain, e, rulenum - 1,
-				    saddrs, daddrs, options&OPT_VERBOSE,
-				    handle);
-		break;
-	case CMD_INSERT:
-		ret = insert_entry(chain, e, rulenum - 1,
-				   nsaddrs, saddrs, ndaddrs, daddrs,
-				   options&OPT_VERBOSE,
-				   handle);
-		break;
-	case CMD_LIST:
-		ret = list_entries(chain,
-				   options&OPT_VERBOSE,
-				   options&OPT_NUMERIC,
-				   options&OPT_EXPANDED,
-				   options&OPT_LINENUMBERS,
-				   handle);
-		break;
-	case CMD_FLUSH:
-		ret = flush_entries(chain, options&OPT_VERBOSE, handle);
-		break;
-	case CMD_ZERO:
-		ret = zero_entries(chain, options&OPT_VERBOSE, handle);
-		break;
-	case CMD_LIST|CMD_ZERO:
-		ret = list_entries(chain,
-				   options&OPT_VERBOSE,
-				   options&OPT_NUMERIC,
-				   options&OPT_EXPANDED,
-				   options&OPT_LINENUMBERS,
-				   handle);
-		if (ret)
-			ret = zero_entries(chain,
-					   options&OPT_VERBOSE, handle);
-		break;
-	case CMD_NEW_CHAIN:
-		ret = iptc_create_chain(chain, handle);
-		break;
-	case CMD_DELETE_CHAIN:
-		ret = delete_chain(chain, options&OPT_VERBOSE, handle);
-		break;
-	case CMD_RENAME_CHAIN:
-		ret = iptc_rename_chain(chain, newname,	handle);
-		break;
-	case CMD_SET_POLICY:
-		ret = iptc_set_policy(chain, policy, NULL, handle);
-		break;
-	default:
-		/* We should never reach this... */
-		exit_tryhelp(2);
-	}
-
-	if (verbose > 1)
-		dump_entries(*handle);
-
-	return ret;
-}
diff -urN iptables-1.2.9/COMMIT_NOTES iptables-1.2.10/COMMIT_NOTES
--- iptables-1.2.9/COMMIT_NOTES	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/COMMIT_NOTES	2003-04-13 13:29:28.000000000 +0200
@@ -0,0 +1,24 @@
+A quick list of rules for committing stuff into netfilter cvs:
+
+- Always include the Name of the Author/Contributor in the CVS comment
+  like 'fix for foo (Au Thor)'
+
+- make sure that you have set the executable bits on an 'extensions/.*-test'
+  script before adding/committing it to CVS
+
+- If the commit fixes a bugzilla bug, please include '(Closes: #bugnr)' in
+  the commit message
+
+- Make sure you don't commit to CVS while a feature freeze is announced
+
+- For new extensions, there are two possible cases:
+	1) header files are just in patch-o-matic patch, you need an
+	   'extensions/.*-test' script to have a conditional build
+	2) header files are in patch-o-matic patch, and copied to
+	   'netfilter/include/linux/netfilter_xxx'.  This way the extension
+	   can be built _unconditionally_, and thus be included in
+	   'extensions/Makefile'.  Make sure to keep the headers in sync!
+
+  Usually '1)' is used, but in case something is expected to show up in the
+  kernel soon, we should already make userspace support unconditionally.
+
diff -urN iptables-1.2.9/CURRENT_ISSUES iptables-1.2.10/CURRENT_ISSUES
--- iptables-1.2.9/CURRENT_ISSUES	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/CURRENT_ISSUES	2004-02-19 19:13:48.000000000 +0100
@@ -0,0 +1,30 @@
+save/restore problem of owner match
+	- userspace
+u32 match
+	- can wait
+XDMCP conntrack/nat
+	- can wait
+nf_debug stuff
+	- can wait
+ipt_ACCOUNT
+	- can wait
+UDP stream timeout (180s) doens't apply for first reply packet
+	- fix by Martin Josefsson, needs review/testing
+SLOG target
+	- no further work expected
+	- needs to be integrated with recent nfnetlink/ctnetlink
+loop detection / nf_hipac (mail from dec 15
+	- need time
+IPv6 REJECT target fix
+	- important, it's a pity that it's still broken
+bi-directional ftp state tracking
+	- do we want this?
+final ACK of a SYN - SYN/ACK - ACK tcp handshake establishes ASSURED
+	- patch is on list, needs testing + comments from kadlec
+expectations allegedly don't work on sparc64
+	- see <771F217D7A4AF84494632457889470A412D77A@bcmsg011.corp.ads>
+	- is this in bugzilla yet?
+new bytelimit match
+	- unify it with 'limit' for 2.5.x
+boolean MARK operations
+	- patch by Anders Fugmann, needs 64bit testing
diff -urN iptables-1.2.9/Makefile iptables-1.2.10/Makefile
--- iptables-1.2.9/Makefile	2003-11-02 18:00:08.000000000 +0100
+++ iptables-1.2.10/Makefile	2004-06-15 00:02:15.000000000 +0200
@@ -14,8 +14,8 @@
 ifndef KERNEL_DIR
 KERNEL_DIR=/usr/src/linux
 endif
-IPTABLES_VERSION:=1.2.9
-OLD_IPTABLES_VERSION:=1.2.8
+IPTABLES_VERSION:=1.2.10
+OLD_IPTABLES_VERSION:=1.2.9
 
 PREFIX:=/usr/local
 LIBDIR:=$(PREFIX)/lib
@@ -38,22 +38,7 @@
 CFLAGS += -DNO_SHARED_LIBS=1
 endif
 
-ifndef NO_SHARED_LIBS
-DEPFILES = $(SHARED_LIBS:%.so=%.d)
-SH_CFLAGS:=$(CFLAGS) -fPIC
-STATIC_LIBS  =
-STATIC6_LIBS =
-LDFLAGS      = -rdynamic
-LDLIBS       = -ldl -lnsl
-else
-DEPFILES = $(EXT_OBJS:%.o=%.d)
-STATIC_LIBS  = extensions/libext.a
-STATIC6_LIBS = extensions/libext6.a
-LDFLAGS      = -static
-LDLIBS       =
-endif
-
-EXTRAS+=iptables iptables.o
+EXTRAS+=iptables iptables.o iptables.8
 EXTRA_INSTALLS+=$(DESTDIR)$(BINDIR)/iptables $(DESTDIR)$(MANDIR)/man8/iptables.8
 
 # No longer experimental.
@@ -61,7 +46,7 @@
 EXTRA_INSTALLS+=$(DESTDIR)$(BINDIR)/iptables-save $(DESTDIR)$(BINDIR)/iptables-restore $(DESTDIR)$(MANDIR)/man8/iptables-restore.8 $(DESTDIR)$(MANDIR)/man8/iptables-save.8
 
 ifeq ($(DO_IPV6), 1)
-EXTRAS+=ip6tables ip6tables.o
+EXTRAS+=ip6tables ip6tables.o ip6tables.8
 EXTRA_INSTALLS+=$(DESTDIR)$(BINDIR)/ip6tables $(DESTDIR)$(MANDIR)/man8/ip6tables.8
 EXTRAS_EXP+=ip6tables-save ip6tables-restore
 EXTRA_INSTALLS_EXP+=$(DESTDIR)$(BINDIR)/ip6tables-save $(DESTDIR)$(BINDIR)/ip6tables-restore # $(DESTDIR)$(MANDIR)/man8/iptables-restore.8 $(DESTDIR)$(MANDIR)/man8/iptables-save.8 $(DESTDIR)$(MANDIR)/man8/ip6tables-save.8 $(DESTDIR)$(MANDIR)/man8/ip6tables-restore.8
@@ -69,20 +54,56 @@
 
 # Sparc64 hack
 ifeq ($(shell uname -m),sparc64)
-# The kernel is 64-bit, even though userspace is 32.
-CFLAGS+=-DIPT_MIN_ALIGN=8 -DKERNEL_64_USERSPACE_32
-endif
-
-# HPPA hack
-ifeq ($(shell uname -m),parisc64)
-# The kernel is 64-bit, even though userspace is 32.
-CFLAGS+=-DIPT_MIN_ALIGN=8 -DKERNEL_64_USERSPACE_32
+	POINTERTEST:=1
+	32bituser := $(shell echo -e "\#include <stdio.h>\n\#if !defined(__sparcv9) && !defined(__arch64__) && !defined(_LP64)\nuserspace_is_32bit\n\#endif" | $(CC) $(CFLAGS) -E - | grep userspace_is_32bit)
+	ifdef 32bituser
+		# The kernel is 64-bit, even though userspace is 32.
+		CFLAGS+=-DIPT_MIN_ALIGN=8 -DKERNEL_64_USERSPACE_32
+	else
+		EXT_LDFLAGS=-m elf64_sparc
+	endif
+endif
+
+# Alpha only has 64bit userspace and fails the test below
+ifeq ($(shell uname -m), alpha)
+	POINTERTEST:=1
+endif
+
+# Generic test if arch wasn't found above
+ifneq ($(POINTERTEST),1)
+	# Try to determine if kernel is 64bit and we are compiling for 32bit
+	ifeq ($(shell [ -a $(KERNEL_DIR)/include/asm ] && echo YES), YES)
+		64bitkernel := $(shell echo -e "\#include <asm/types.h>\n\#if BITS_PER_LONG == 64\nkernel_is_64bits\n\#endif" | $(CC) $(CFLAGS) -D__KERNEL__ -E - | grep kernel_is_64bits)
+		ifdef 64bitkernel
+			32bituser := $(shell echo -e "\#include <stdio.h>\n\#if !defined(__arch64__) && !defined(_LP64)\nuserspace_is_32bit\n\#endif" | $(CC) $(CFLAGS) -E - | grep userspace_is_32bit)
+			ifdef 32bituser
+				CFLAGS+=-DIPT_MIN_ALIGN=8 -DKERNEL_64_USERSPACE_32
+			endif
+		endif
+	else
+		CFLAGS+=-D_UNKNOWN_KERNEL_POINTER_SIZE
+	endif
 endif
 
 ifndef IPT_LIBDIR
 IPT_LIBDIR:=$(LIBDIR)/iptables
 endif
 
+ifndef NO_SHARED_LIBS
+DEPFILES = $(SHARED_LIBS:%.so=%.d)
+SH_CFLAGS:=$(CFLAGS) -fPIC
+STATIC_LIBS  =
+STATIC6_LIBS =
+LDFLAGS      = -rdynamic
+LDLIBS       = -ldl -lnsl
+else
+DEPFILES = $(EXT_OBJS:%.o=%.d)
+STATIC_LIBS  = extensions/libext.a
+STATIC6_LIBS = extensions/libext6.a
+LDFLAGS      = -static
+LDLIBS       =
+endif
+
 .PHONY: default
 default: print-extensions all
 
@@ -147,6 +168,11 @@
 iptables-standalone.d iptables.d: %.d: %.c
 	@-$(CC) -M -MG $(CFLAGS) $< | sed -e 's@^.*\.o:@$*.d $*.o:@' > $@
 
+iptables.8: iptables.8.in extensions/libipt_matches.man extensions/libipt_targets.man
+	sed -e '/@MATCH@/ r extensions/libipt_matches.man' -e '/@TARGET@/ r extensions/libipt_targets.man' iptables.8.in >iptables.8
+
+ip6tables.8: ip6tables.8.in extensions/libip6t_matches.man extensions/libip6t_targets.man
+	sed -e '/@MATCH@/ r extensions/libip6t_matches.man' -e '/@TARGET@/ r extensions/libiptt_targets.man' ip6tables.8.in >ip6tables.8
 
 # Development Targets
 .PHONY: install-devel-man3
@@ -190,7 +216,7 @@
 	rm -f $(RELEASE_DIR)/iptables-$(IPTABLES_VERSION).tar.bz2
 
 $(RELEASE_DIR)/iptables-$(IPTABLES_VERSION).tar.bz2:
-	cd .. && ln -sf userspace iptables-$(IPTABLES_VERSION) && tar cvf - --exclude CVS iptables-$(IPTABLES_VERSION)/. | bzip2 -9 > $@ && rm iptables-$(IPTABLES_VERSION)
+	cd .. && ln -sf iptables iptables-$(IPTABLES_VERSION) && tar cvf - --exclude CVS iptables-$(IPTABLES_VERSION)/. | bzip2 -9 > $@ && rm iptables-$(IPTABLES_VERSION)
 
 .PHONY: diff
 diff: $(RELEASE_DIR)/iptables-$(IPTABLES_VERSION).tar.bz2
diff -urN iptables-1.2.9/Rules.make iptables-1.2.10/Rules.make
--- iptables-1.2.9/Rules.make	2001-08-06 20:50:21.000000000 +0200
+++ iptables-1.2.10/Rules.make	2004-06-15 00:02:15.000000000 +0200
@@ -31,7 +31,7 @@
 	    sed -e 's@^.*\.o:@$*.d $*_sh.o:@' > $@
 
 $(SHARED_LIBS): %.so : %_sh.o
-	$(LD) -shared -o $@ $<
+	$(LD) -shared $(EXT_LDFLAGS) -o $@ $<
 
 %_sh.o : %.c
 	$(CC) $(SH_CFLAGS) -o $@ -c $<
diff -urN iptables-1.2.9/TODO iptables-1.2.10/TODO
--- iptables-1.2.9/TODO	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/TODO	2003-11-10 19:11:11.000000000 +0100
@@ -0,0 +1,66 @@
+TODO List for netfilter / iptables. 
+Currently maintained by Harald Welte <laforge@gnumonks.org>
+
+Please inform me, if you want to work on any of the TODO items, so I
+can update this list and thus prevent two people doing the same work.
+
+CVS ID: $Id: TODO,v 1.72 2003/11/10 18:11:11 laforge Exp $
+
+IMPORTANT issues:
+- erroneously too-fast dropped conntrack for half-open TCP connections [JK]
+- --mac-source not working in FORWARD (manpage bug?) [BZ]
+- locally bound udp port can still be used for MASQ/SNAT [BZ]
+- unaligned access of nulldevname during string match [BZ]
+- unaligned access in interface match (ip_tables core)
+- update documentation to reflect newnat
+- release iptables-1.3.0-test (with new libiptc for speedup)
+- ipv6 ldp (igmp) and ndisc bypasses LOCAL_OUT hook
+
+TO BE INVESTIGATED:
+- packet counters on sparc64 platform [BZ]
+- conntrack helper not called for first packet (udp!)
+- different behaviour for first packet towards an l2-unresolved ip?
+
+NICE to have:
+- sysctl support for ftp-multi, irc-conntrack/nat, ftp-fxp [BZ]
+- port conntrack to IPv6 (code reuse?) 
+- ip_nat_ident module [BZ]
+- make iptables / ip6tables use the same codebase (as libiptc) [KA]
+- libipq reentrancy [JM]
+- compiling without O2 issue [BZ]
+- libipq runtime version, do before 1.2.5 [JM]
+- l3 independent ip_queue / ULOG (2.6)
+- add support for IRC tracking in opposite direction
+- Find mirrors for www.TLD.netfilter.org domains
+- example section on homepage
+- searchable mailinglist archives
+- faq-o-matic system
+
+FUTURE extensions:
+- dealing with fragmented expectation-causes (i.e. DCC chat split
+  over two packets, etc.)
+- conntrack / nat failover [HW]
+- unified nfnetlink for queue,ulog,conntrack (and more?) (2.5 issue)
+
+Userspace queuing for 2.5:
+- Integration with nfnetlink.
+- Multiple queues per protocol.
+- Netlink broadcast support.
+- Allow multiple reader/writers in userspace.
+- How to handle multiple protocols (e.g. use separate queue handlers
+  or a multiplexer like ipqmpd).
+- Peformance improvements: multipart messages, mmaped socket (possibly).
+- Simplify queuing logic, which is quite ugly at the moment. (BC suggested
+  removing logic from kernel).
+- Allow userspace to set nfmark.
+- Allow userspace to set queue length etc.
+- Possibly pass conntrack/NAT info to userspace with packet.
+
+======================================================================
+[BC]	Brad Chapman <kakadu_croc@yahoo.com>
+[HW]	Harald Welte <laforge@gnumonks.org>
+[JK]	Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+[JM]	James Morris <jmorris@intercode.com.au>
+[KA]	Kiz-Szabo Andras <kisza@sch.bme.hu>
+[RR]	Paul 'Rusty' Russel <rusty@rustcorp.com.au>
+[BZ]	Included in Bugzilla System
diff -urN iptables-1.2.9/extensions/.#libipt_ECN.c.1.7 iptables-1.2.10/extensions/.#libipt_ECN.c.1.7
--- iptables-1.2.9/extensions/.#libipt_ECN.c.1.7	2002-06-27 23:42:52.000000000 +0200
+++ iptables-1.2.10/extensions/.#libipt_ECN.c.1.7	1970-01-01 01:00:00.000000000 +0100
@@ -1,180 +0,0 @@
-/* Shared library add-on to iptables for ECN, $Version$
- *
- * (C) 2002 by Harald Welte <laforge@gnumonks.org>
- *
- * This program is distributed under the terms of GNU GPL v2, 1991
- *
- * libipt_ECN.c borrowed heavily from libipt_DSCP.c
- *
- * $Id: libipt_ECN.c,v 1.7 2002/05/29 15:11:36 laforge Exp $
- */
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <getopt.h>
-
-#include <iptables.h>
-#include <linux/netfilter_ipv4/ip_tables.h>
-#include <linux/netfilter_ipv4/ipt_ECN.h>
-
-static void init(struct ipt_entry_target *t, unsigned int *nfcache) 
-{
-}
-
-static void help(void) 
-{
-	printf(
-"ECN target v%s options\n"
-"  --ecn-tcp-remove		Remove all ECN bits from TCP header\n"
-"ECN target v%s EXPERIMENTAL options (use with extreme care!)\n"
-"  --ecn-ip-ect			Set the IPv4 ECT codepoint (0 to 3)\n"
-"  --ecn-tcp-cwr		Set the IPv4 CWR bit (0 or 1)\n"
-"  --ecn-tcp-ece		Set the IPv4 CWR bit (0 or 1)\n",
-		IPTABLES_VERSION, IPTABLES_VERSION
-);
-}
-
-static struct option opts[] = {
-	{ "ecn-tcp-remove", 0, 0, 'F' },
-	{ "ecn-tcp-cwr", 1, 0, 'G' },
-	{ "ecn-tcp-ece", 1, 0, 'H' },
-	{ "ecn-ip-ect", 1, 0, '9' },
-	{ 0 }
-};
-
-static int
-parse(int c, char **argv, int invert, unsigned int *flags,
-      const struct ipt_entry *entry,
-      struct ipt_entry_target **target)
-{
-	unsigned int result;
-	struct ipt_ECN_info *einfo
-		= (struct ipt_ECN_info *)(*target)->data;
-
-	switch (c) {
-	case 'F':
-		if (*flags)
-			exit_error(PARAMETER_PROBLEM,
-			        "ECN target: Only use --ecn-tcp-remove ONCE!");
-		einfo->operation = IPT_ECN_OP_SET_ECE | IPT_ECN_OP_SET_CWR;
-		einfo->proto.tcp.ece = 0;
-		einfo->proto.tcp.cwr = 0;
-		*flags = 1;
-		break;
-	case 'G':
-		if (*flags & IPT_ECN_OP_SET_CWR)
-			exit_error(PARAMETER_PROBLEM,
-				"ECN target: Only use --ecn-tcp-cwr ONCE!");
-		if (string_to_number(optarg, 0, 1, &result))
-			exit_error(PARAMETER_PROBLEM,
-				   "ECN target: Value out of range");
-		einfo->operation |= IPT_ECN_OP_SET_CWR;
-		einfo->proto.tcp.cwr = result;
-		*flags |= IPT_ECN_OP_SET_CWR;
-		break;
-	case 'H':
-		if (*flags & IPT_ECN_OP_SET_ECE)
-			exit_error(PARAMETER_PROBLEM,
-				"ECN target: Only use --ecn-tcp-ece ONCE!");
-		if (string_to_number(optarg, 0, 1, &result))
-			exit_error(PARAMETER_PROBLEM,
-				   "ECN target: Value out of range");
-		einfo->operation |= IPT_ECN_OP_SET_ECE;
-		einfo->proto.tcp.ece = result;
-		*flags |= IPT_ECN_OP_SET_ECE;
-		break;
-	case '9':
-		if (*flags & IPT_ECN_OP_SET_IP)
-			exit_error(PARAMETER_PROBLEM,
-				"ECN target: Only use --ecn-ip-ect ONCE!");
-		if (string_to_number(optarg, 0, 3, &result))
-			exit_error(PARAMETER_PROBLEM,
-				   "ECN target: Value out of range");
-		einfo->operation |= IPT_ECN_OP_SET_IP;
-		einfo->ip_ect = (result << IPT_ECN_SHIFT);
-	default:
-		return 0;
-	}
-
-	return 1;
-}
-
-static void
-final_check(unsigned int flags)
-{
-	if (!flags)
-		exit_error(PARAMETER_PROBLEM,
-		           "ECN target: Parameter --ecn-remove is required");
-}
-
-/* Prints out the targinfo. */
-static void
-print(const struct ipt_ip *ip,
-      const struct ipt_entry_target *target,
-      int numeric)
-{
-	const struct ipt_ECN_info *einfo =
-		(const struct ipt_ECN_info *)target->data;
-
-	printf("ECN ");
-
-	if (einfo->operation == (IPT_ECN_OP_SET_ECE|IPT_ECN_OP_SET_CWR)
-	    && einfo->proto.tcp.ece == 0
-	    && einfo->proto.tcp.cwr == 0)
-		printf("TCP remove ");
-	else {
-		if (einfo->operation & IPT_ECN_OP_SET_ECE)
-			printf("ECE=%u ", einfo->proto.tcp.ece);
-
-		if (einfo->operation & IPT_ECN_OP_SET_CWR)
-			printf("CWR=%u ", einfo->proto.tcp.cwr);
-
-		if (einfo->operation & IPT_ECN_OP_SET_IP)
-			printf("ECT codepoint=%u ", einfo->ip_ect);
-	}
-}
-
-/* Saves the union ipt_targinfo in parsable form to stdout. */
-static void
-save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
-{
-	const struct ipt_ECN_info *einfo =
-		(const struct ipt_ECN_info *)target->data;
-
-	if (einfo->operation == (IPT_ECN_OP_SET_ECE|IPT_ECN_OP_SET_CWR)
-	    && einfo->proto.tcp.ece == 0
-	    && einfo->proto.tcp.cwr == 0)
-		printf("--ecn-tcp-remove ");
-	else {
-
-		if (einfo->operation & IPT_ECN_OP_SET_ECE)
-			printf("--ecn-tcp-ece %d ", einfo->proto.tcp.ece);
-
-		if (einfo->operation & IPT_ECN_OP_SET_CWR)
-			printf("--ecn-tcp-cwr %d ", einfo->proto.tcp.cwr);
-
-		if (einfo->operation & IPT_ECN_OP_SET_IP)
-			printf("--ecn-ip-ect %d ", einfo->ip_ect);
-	}
-}
-
-static
-struct iptables_target ecn
-= { NULL,
-    "ECN",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_ECN_info)),
-    IPT_ALIGN(sizeof(struct ipt_ECN_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
-};
-
-void _init(void)
-{
-	register_target(&ecn);
-}
diff -urN iptables-1.2.9/extensions/.#libipt_recent.c.1.6 iptables-1.2.10/extensions/.#libipt_recent.c.1.6
--- iptables-1.2.9/extensions/.#libipt_recent.c.1.6	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/.#libipt_recent.c.1.6	1970-01-01 01:00:00.000000000 +0100
@@ -1,229 +0,0 @@
-/* Shared library add-on to iptables to add recent matching support. */
-#include <stdio.h>
-#include <netdb.h>
-#include <string.h>
-#include <stdlib.h>
-#include <getopt.h>
-
-#include <iptables.h>
-#include <linux/netfilter_ipv4/ipt_recent.h>
-
-/* Function which prints out usage message. */
-static void
-help(void)
-{
-	printf(
-"recent v%s options:\n"
-"[!] --set                       Add source address to list, always matches.\n"
-"[!] --rcheck                    Match if source address in list.\n"
-"[!] --update                    Match if source address in list, also update last-seen time.\n"
-"[!] --remove                    Match if source address in list, also removes that address from list.\n"
-"    --seconds seconds           For check and update commands above.\n"
-"                                Specifies that the match will only occur if source address last seen within\n"
-"                                the last 'seconds' seconds.\n"
-"    --hitcount hits             For check and update commands above.\n"
-"                                Specifies that the match will only occur if source address seen hits times.\n"
-"                                May be used in conjunction with the seconds option.\n"
-"    --rttl                      For check and update commands above.\n"
-"                                Specifies that the match will only occur if the source address and the TTL\n"
-"                                match between this packet and the one which was set.\n"
-"                                Useful if you have problems with people spoofing their source address in order\n"
-"                                to DoS you via this module.\n"
-"    --name name                 Name of the recent list to be used.  DEFAULT used if none given.\n"
-"    --rsource                   Save the source address of each packet in the recent list table (default).\n"
-"    --rdest                     Save the destination address of each packet in the recent list table.\n"
-,
-IPTABLES_VERSION);
-
-}
-  
-static struct option opts[] = {
-	{ "set", 0, 0, 201 }, 
-	{ "rcheck", 0, 0, 202 }, 
-	{ "update", 0, 0, 203 },
-	{ "seconds", 1, 0, 204 }, 
-	{ "hitcount", 1, 0, 205 },
-	{ "remove",0, 0, 206 },
-	{ "rttl",0, 0, 207 },
-	{ "name", 1, 0, 208 },
-	{ "rsource", 0, 0, 209 },
-	{ "rdest", 0, 0, 210 },
-	{0}
-};
-
-/* Initialize the match. */
-static void
-init(struct ipt_entry_match *match, unsigned int *nfcache)
-{
-	struct ipt_recent_info *info = (struct ipt_recent_info *)(match)->data;
-
-	*nfcache |= NFC_UNKNOWN;
-
-	strncpy(info->name, "DEFAULT", 200);
-	info->side = IPT_RECENT_SOURCE;
-}
-
-/* Function which parses command options; returns true if it
-   ate an option */
-static int
-parse(int c, char **argv, int invert, unsigned int *flags,
-      const struct ipt_entry *entry,
-      unsigned int *nfcache,
-      struct ipt_entry_match **match)
-{
-	struct ipt_recent_info *info = (struct ipt_recent_info *)(*match)->data;
-	switch (c) {
-		case 201:
-			if (*flags) 
-				exit_error(PARAMETER_PROBLEM,
-					"recent: only one of `--set', `--check' "
-					"`--update' or `--remove' may be set");
-			check_inverse(optarg, &invert, &optind, 0);
-			info->check_set |= IPT_RECENT_SET;
-			if (invert) 
-				info->invert = 1;
-			*flags = 1;
-			break;
-			
-		case 202:
-			if (*flags) 
-				exit_error(PARAMETER_PROBLEM,
-					"recent: only one of `--set', `--check' "
-					"`--update' or `--remove' may be set");
-			check_inverse(optarg, &invert, &optind, 0);
-			info->check_set |= IPT_RECENT_CHECK;
-			if (invert)
-				info->invert = 1;
-			*flags = 1;
-			break;
-
-		case 203:
-			if (*flags)
-				exit_error(PARAMETER_PROBLEM,
-					"recent: only one of `--set', `--check' "
-					"`--update' or `--remove' may be set");
-			check_inverse(optarg, &invert, &optind, 0);
-			info->check_set |= IPT_RECENT_UPDATE;
-			if (invert)
-				info->invert = 1;
-			*flags = 1;
-			break;
-
-		case 206:
-			if (*flags)
-				exit_error(PARAMETER_PROBLEM,
-					"recent: only one of `--set', `--check' "
-					"`--update' or `--remove' may be set");
-			check_inverse(optarg, &invert, &optind, 0);
-			info->check_set |= IPT_RECENT_REMOVE;
-			if (invert)
-				info->invert = 1;
-			*flags = 1;
-			break;
-
-		case 204:
-			info->seconds = atoi(optarg);
-			break;
-
-		case 205:
-			info->hit_count = atoi(optarg);
-			break;
-
-		case 207:
-			info->check_set |= IPT_RECENT_TTL;
-			break;
-
-		case 208:
-			strncpy(info->name, optarg, 200);
-			break;
-
-		case 209:
-			info->side = IPT_RECENT_SOURCE;
-			break;
-
-		case 210:
-			info->side = IPT_RECENT_DEST;
-			break;
-
-		default:
-			return 0;
-	}
-
-	return 1;
-}
-
-/* Final check; must have specified a specific option. */
-static void
-final_check(unsigned int flags)
-{
-
-	if (!flags)
-		exit_error(PARAMETER_PROBLEM,
-			"recent: you must specify one of `--set', `--check' "
-			"`--update' or `--remove'");
-}
-
-/* Prints out the matchinfo. */
-static void
-print(const struct ipt_ip *ip,
-      const struct ipt_entry_match *match,
-      int numeric)
-{
-	struct ipt_recent_info *info = (struct ipt_recent_info *)match->data;
-
-	if (info->invert) fputc('!', stdout);
-
-	printf("recent: ");
-	if(info->check_set & IPT_RECENT_SET) printf("SET ");
-	if(info->check_set & IPT_RECENT_CHECK) printf("CHECK ");
-	if(info->check_set & IPT_RECENT_UPDATE) printf("UPDATE ");
-	if(info->check_set & IPT_RECENT_REMOVE) printf("REMOVE ");
-	if(info->seconds) printf("seconds: %d ", info->seconds);
-	if(info->hit_count) printf("hit_count: %d ", info->hit_count);
-	if(info->check_set & IPT_RECENT_TTL) printf("TTL-Match ");
-	if(info->name) printf("name: %s ", info->name);
-	if(info->side == IPT_RECENT_SOURCE) printf("side: source ");
-	if(info->side == IPT_RECENT_DEST) printf("side: dest");
-}
-
-/* Saves the union ipt_matchinfo in parsable form to stdout. */
-static void
-save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
-{
-	struct ipt_recent_info *info = (struct ipt_recent_info *)match;
-
-	if (info->invert) fputc('!', stdout);
-
-	printf("recent: ");
-	if(info->check_set & IPT_RECENT_SET) printf("SET ");
-	if(info->check_set & IPT_RECENT_CHECK) printf("CHECK ");
-	if(info->check_set & IPT_RECENT_UPDATE) printf("UPDATE ");
-	if(info->check_set & IPT_RECENT_REMOVE) printf("REMOVE ");
-	if(info->seconds) printf("seconds: %d ",info->seconds);
-	if(info->hit_count) printf("hit_count: %d ",info->hit_count);
-	if(info->check_set & IPT_RECENT_TTL) printf("TTL-Match ");
-	if(info->name) printf("name: %s ",info->name);
-	if(info->side == IPT_RECENT_SOURCE) printf("side: source ");
-	if(info->side == IPT_RECENT_DEST) printf("side: dest");
-}
-
-static
-struct iptables_match recent
-= { NULL,
-    "recent",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_recent_info)),
-    IPT_ALIGN(sizeof(struct ipt_recent_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
-};
-
-void _init(void)
-{
-	register_match(&recent);
-}
diff -urN iptables-1.2.9/extensions/.CLUSTERIP-test iptables-1.2.10/extensions/.CLUSTERIP-test
--- iptables-1.2.9/extensions/.CLUSTERIP-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/.CLUSTERIP-test	2003-11-11 19:41:36.000000000 +0100
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_CLUSTERIP.c ] && echo CLUSTERIP
diff -urN iptables-1.2.9/extensions/.account-test iptables-1.2.10/extensions/.account-test
--- iptables-1.2.9/extensions/.account-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/.account-test	2004-03-17 15:27:08.000000000 +0100
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if account match patch is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_account.h ] && echo account
diff -urN iptables-1.2.9/extensions/.childlevel-test iptables-1.2.10/extensions/.childlevel-test
--- iptables-1.2.9/extensions/.childlevel-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/.childlevel-test	2004-02-17 21:56:40.000000000 +0100
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_childlevel.h ] && echo childlevel
diff -urN iptables-1.2.9/extensions/.connrate-test iptables-1.2.10/extensions/.connrate-test
--- iptables-1.2.9/extensions/.connrate-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/.connrate-test	2004-04-18 19:33:26.000000000 +0200
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_connrate.h ] && echo connrate
diff -urN iptables-1.2.9/extensions/.dstlimit-test iptables-1.2.10/extensions/.dstlimit-test
--- iptables-1.2.9/extensions/.dstlimit-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/.dstlimit-test	2003-11-13 19:29:16.000000000 +0100
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_dstlimit.c ] && echo dstlimit
diff -urN iptables-1.2.9/extensions/.set-test iptables-1.2.10/extensions/.set-test
--- iptables-1.2.9/extensions/.set-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/.set-test	2004-02-09 14:47:01.000000000 +0100
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ip_set.h ] && echo set SET
diff -urN iptables-1.2.9/extensions/Makefile iptables-1.2.10/extensions/Makefile
--- iptables-1.2.9/extensions/Makefile	2003-10-16 09:34:36.000000000 +0200
+++ iptables-1.2.10/extensions/Makefile	2004-04-15 11:16:18.000000000 +0200
@@ -5,13 +5,36 @@
 # header files are present in the include/linux directory of this iptables
 # package (HW)
 #
-PF_EXT_SLIB:=ah connlimit connmark conntrack dscp ecn esp helper icmp iprange length limit mac mark multiport owner physdev pkttype realm rpc standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE TTL ULOG
+PF_EXT_SLIB:=ah connlimit connmark conntrack dscp ecn esp helper icmp iprange length limit mac mark multiport owner physdev pkttype realm rpc sctp standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE TTL ULOG
 PF6_EXT_SLIB:=eui64 hl icmpv6 length limit mac mark multiport owner standard tcp udp HL LOG MARK TRACE
 
 # Optionals
 PF_EXT_SLIB_OPTS:=$(foreach T,$(wildcard extensions/.*-test),$(shell KERNEL_DIR=$(KERNEL_DIR) $(T)))
 PF6_EXT_SLIB_OPTS:=$(foreach T,$(wildcard extensions/.*-test6),$(shell KERNEL_DIR=$(KERNEL_DIR) $(T)))
 
+PF_EXT_ALL_SLIB:=$(patsubst extensions/libipt_%.c, %, $(wildcard extensions/libipt_*.c))
+PF6_EXT_ALL_SLIB:=$(patsubst extensions/libip6t_%.c, %, $(wildcard extensions/libip6t_*.c))
+
+PF_EXT_MAN_ALL_MATCHES:=$(foreach T,$(PF_EXT_ALL_SLIB),$(shell test -f extensions/libipt_$(T).man && grep -q register_match extensions/libipt_$(T).c  && echo $(T)))
+PF_EXT_MAN_ALL_TARGETS:=$(foreach T,$(PF_EXT_ALL_SLIB),$(shell test -f extensions/libipt_$(T).man && grep -q register_target extensions/libipt_$(T).c && echo $(T)))
+PF6_EXT_MAN_ALL_MATCHES:=$(foreach T,$(PF6_EXT_ALL_SLIB),$(shell test -f extensions/libip6t_$(T).man && grep -q register_match6 extensions/libip6t_$(T).c  && echo $(T)))
+PF6_EXT_MAN_ALL_TARGETS:=$(foreach T,$(PF6_EXT_ALL_SLIB),$(shell test -f extensions/libip6t_$(T).man && grep -q register_target6 extensions/libip6t_$(T).c && echo $(T)))
+
+PF_EXT_MAN_MATCHES:=$(filter $(PF_EXT_ALL_SLIB), $(PF_EXT_MAN_ALL_MATCHES))
+PF_EXT_MAN_TARGETS:=$(filter $(PF_EXT_ALL_SLIB), $(PF_EXT_MAN_ALL_TARGETS))
+PF_EXT_MAN_EXTRA_MATCHES:=$(filter-out $(PF_EXT_MAN_MATCHES), $(PF_EXT_MAN_ALL_MATCHES))
+PF_EXT_MAN_EXTRA_TARGETS:=$(filter-out $(PF_EXT_MAN_TARGETS), $(PF_EXT_MAN_ALL_TARGETS))
+PF6_EXT_MAN_MATCHES:=$(filter $(PF6_EXT_ALL_SLIB), $(PF6_EXT_MAN_ALL_MATCHES))
+PF6_EXT_MAN_TARGETS:=$(filter $(PF6_EXT_ALL_SLIB), $(PF6_EXT_MAN_ALL_TARGETS))
+PF6_EXT_MAN_EXTRA_MATCHES:=$(filter-out $(PF6_EXT_MAN_MATCHES), $(PF6_EXT_MAN_ALL_MATCHES))
+PF6_EXT_MAN_EXTRA_TARGETS:=$(filter-out $(PF6_EXT_MAN_TARGETS), $(PF6_EXT_MAN_ALL_TARGETS))
+
+
+allman:
+	@echo ALL_SLIB: $(PF_EXT_ALL_SLIB)
+	@echo ALL_MATCH: $(PF_EXT_MAN_ALL_MATCHES)
+	@echo ALL_TARGET: $(PF_EXT_MAN_ALL_TARGETS)
+
 PF_EXT_SLIB+=$(PF_EXT_SLIB_OPTS)
 PF6_EXT_SLIB+=$(PF6_EXT_SLIB_OPTS)
 
@@ -79,6 +102,58 @@
 
 endif
  
+EXTRAS += extensions/libipt_targets.man
+extensions/libipt_targets.man: $(patsubst %,extensions/libipt_%.man,$(PF_EXT_MAN_ALL_TARGETS))
+	@for ext in $(PF_EXT_MAN_TARGETS); do \
+	    echo ".SS $$ext" ;\
+	    cat extensions/libipt_$$ext.man ;\
+	done >extensions/libipt_targets.man
+	@if [ -n "$(PF_EXT_MAN_EXTRA_TARGETS)" ]; then \
+	    for ext in $(PF_EXT_MAN_EXTRA_TARGETS); do \
+		echo ".SS $$ext (not supported, see Patch-O-Matic)" ;\
+		cat extensions/libipt_$$ext.man ;\
+	    done ;\
+       	fi >>extensions/libipt_targets.man
+
+EXTRAS += extensions/libipt_matches.man
+extensions/libipt_matches.man: $(patsubst %,extensions/libipt_%.man,$(PF_EXT_MAN_ALL_MATCHES))
+	@for ext in $(PF_EXT_MAN_MATCHES); do \
+	    echo ".SS $$ext" ;\
+	    cat extensions/libipt_$$ext.man ;\
+	done >extensions/libipt_matches.man
+	@if [ -n "$(PF_EXT_MAN_EXTRA_MATCHES)" ]; then \
+	    for ext in $(PF_EXT_MAN_EXTRA_MATCHES); do \
+		echo ".SS $$ext (not supported, see Patch-O-Matic)" ;\
+		cat extensions/libipt_$$ext.man ;\
+	    done ;\
+       	fi >>extensions/libipt_matches.man
+
+EXTRAS += extensions/libip6t_targets.man
+extensions/libip6t_targets.man: $(patsubst %, extensions/libip6t_%.man, $(PF6_EXT_MAN_ALL_TARGETS))
+	@for ext in $(PF6_EXT_MAN_TARGETS); do \
+	    echo ".SS $$ext" ;\
+	    cat extensions/libip6t_$$ext.man ;\
+	done >extensions/libip6t_targets.man
+	@if [ -n "$(PF6_EXT_MAN_EXTRA_TARGETS)" ]; then \
+	    for ext in $(PF6_EXT_MAN_EXTRA_TARGETS); do \
+		echo ".SS $$ext (not supported, see Patch-O-Matic)" ;\
+		cat extensions/libip6t_$$ext.man ;\
+	    done ;\
+       	fi >>extensions/libip6t_targets.man
+
+EXTRAS += extensions/libip6t_matches.man
+extensions/libip6t_matches.man: $(patsubst %, extensions/libip6t_%.man, $(PF6_EXT_MAN_ALL_MATCHES))
+	@for ext in $(PF6_EXT_MAN_MATCHES); do \
+	    echo ".SS $$ext" ;\
+	    cat extensions/libip6t_$$ext.man ;\
+	done >extensions/libip6t_matches.man
+	@if [ -n "$(PF6_EXT_MAN_EXTRA_MATCHES)" ]; then \
+	    for ext in $(PF6_EXT_MAN_EXTRA_MATCHES); do \
+		echo ".SS $$ext (not supported, see Patch-O-Matic)" ;\
+		cat extensions/libip6t_$$ext.man ;\
+	    done ;\
+       	fi >>extensions/libip6t_matches.man
+
 $(DESTDIR)$(LIBDIR)/iptables/libipt_%.so: extensions/libipt_%.so
 	@[ -d $(DESTDIR)$(LIBDIR)/iptables ] || mkdir -p $(DESTDIR)$(LIBDIR)/iptables
 	cp $< $@
diff -urN iptables-1.2.9/extensions/libip6t_HL.man iptables-1.2.10/extensions/libip6t_HL.man
--- iptables-1.2.9/extensions/libip6t_HL.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_HL.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,17 @@
+This is used to modify the IPv6 HOPLIMIT header field.  The HOPLIMIT field is 
+similar to what is known as TTL value in IPv4.  Setting or incrementing the
+HOPLIMIT field can potentially be very dangerous, so it should be avoided at
+any cost.  
+.TP
+.B Don't ever set or increment the value on packets that leave your local network!
+.B mangle
+table.
+.TP
+.BI "--hl-set " "value"
+Set the HOPLIMIT value to `value'.
+.TP
+.BI "--hl-dec " "value"
+Decrement the HOPLIMIT value `value' times.
+.TP
+.BI "--hl-inc " "value"
+Increment the HOPLIMIT value `value' times.
diff -urN iptables-1.2.9/extensions/libip6t_LOG.c iptables-1.2.10/extensions/libip6t_LOG.c
--- iptables-1.2.9/extensions/libip6t_LOG.c	2003-08-23 13:09:22.000000000 +0200
+++ iptables-1.2.10/extensions/libip6t_LOG.c	2004-06-15 00:02:16.000000000 +0200
@@ -134,7 +134,7 @@
 		if (strlen(optarg) > sizeof(loginfo->prefix) - 1)
 			exit_error(PARAMETER_PROBLEM,
 				   "Maximum prefix length %u for --log-prefix",
-				   sizeof(loginfo->prefix) - 1);
+				   (unsigned int)sizeof(loginfo->prefix) - 1);
 
 		strcpy(loginfo->prefix, optarg);
 		*flags |= IP6T_LOG_OPT_PREFIX;
diff -urN iptables-1.2.9/extensions/libip6t_LOG.man iptables-1.2.10/extensions/libip6t_LOG.man
--- iptables-1.2.9/extensions/libip6t_LOG.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_LOG.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,28 @@
+Turn on kernel logging of matching packets.  When this option is set
+for a rule, the Linux kernel will print some information on all
+matching packets (like most IPv6 IPv6-header fields) via the kernel log
+(where it can be read with
+.I dmesg
+or 
+.IR syslogd (8)).
+This is a "non-terminating target", i.e. rule traversal continues at
+the next rule.  So if you want to LOG the packets you refuse, use two
+separate rules with the same matching criteria, first using target LOG
+then DROP (or REJECT).
+.TP
+.BI "--log-level " "level"
+Level of logging (numeric or see \fIsyslog.conf\fP(5)).
+.TP
+.BI "--log-prefix " "prefix"
+Prefix log messages with the specified prefix; up to 29 letters long,
+and useful for distinguishing messages in the logs.
+.TP
+.B --log-tcp-sequence
+Log TCP sequence numbers. This is a security risk if the log is
+readable by users.
+.TP
+.B --log-tcp-options
+Log options from the TCP packet header.
+.TP
+.B --log-ip-options
+Log options from the IPv6 packet header.
diff -urN iptables-1.2.9/extensions/libip6t_MARK.c iptables-1.2.10/extensions/libip6t_MARK.c
--- iptables-1.2.9/extensions/libip6t_MARK.c	2003-09-05 14:48:08.000000000 +0200
+++ iptables-1.2.10/extensions/libip6t_MARK.c	2004-06-15 00:02:16.000000000 +0200
@@ -6,7 +6,8 @@
 
 #include <ip6tables.h>
 #include <linux/netfilter_ipv6/ip6_tables.h>
-#include <linux/netfilter_ipv6/ip6t_MARK.h>
+/* For 64bit kernel / 32bit userspace */
+#include "../include/linux/netfilter_ipv6/ip6t_MARK.h"
 
 /* Function which prints out usage message. */
 static void
@@ -41,10 +42,14 @@
 		= (struct ip6t_mark_target_info *)(*target)->data;
 
 	switch (c) {
-		char *end;
 	case '1':
-		markinfo->mark = strtoul(optarg, &end, 0);
-		if (*end != '\0' || end == optarg)
+#ifdef KERNEL_64_USERSPACE_32
+		if (string_to_number_ll(optarg, 0, 0, 
+				     &markinfo->mark))
+#else
+		if (string_to_number_l(optarg, 0, 0, 
+				     &markinfo->mark))
+#endif
 			exit_error(PARAMETER_PROBLEM, "Bad MARK value `%s'", optarg);
 		if (*flags)
 			exit_error(PARAMETER_PROBLEM,
@@ -67,6 +72,20 @@
 		           "MARK target: Parameter --set-mark is required");
 }
 
+#ifdef KERNEL_64_USERSPACE_32
+static void
+print_mark(unsigned long long mark)
+{
+	printf("0x%llx ", mark);
+}
+#else
+static void
+print_mark(unsigned long mark)
+{
+	printf("0x%lx ", mark);
+}
+#endif
+
 /* Prints out the targinfo. */
 static void
 print(const struct ip6t_ip6 *ip,
@@ -76,7 +95,8 @@
 	const struct ip6t_mark_target_info *markinfo =
 		(const struct ip6t_mark_target_info *)target->data;
 
-	printf("MARK set 0x%lx ", markinfo->mark);
+	printf("MARK set ");
+	print_mark(markinfo->mark);
 }
 
 /* Saves the union ipt_targinfo in parsable form to stdout. */
@@ -86,7 +106,8 @@
 	const struct ip6t_mark_target_info *markinfo =
 		(const struct ip6t_mark_target_info *)target->data;
 
-	printf("--set-mark 0x%lx ", markinfo->mark);
+	printf("--set-mark ");
+	print_mark(markinfo->mark);
 }
 
 static
diff -urN iptables-1.2.9/extensions/libip6t_MARK.man iptables-1.2.10/extensions/libip6t_MARK.man
--- iptables-1.2.9/extensions/libip6t_MARK.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_MARK.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,6 @@
+This is used to set the netfilter mark value associated with the
+packet.  It is only valid in the
+.B mangle
+table.
+.TP
+.BI "--set-mark " "mark"
diff -urN iptables-1.2.9/extensions/libip6t_REJECT.man iptables-1.2.10/extensions/libip6t_REJECT.man
--- iptables-1.2.9/extensions/libip6t_REJECT.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_REJECT.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,34 @@
+This is used to send back an error packet in response to the matched
+packet: otherwise it is equivalent to 
+.B DROP
+so it is a terminating TARGET, ending rule traversal.
+This target is only valid in the
+.BR INPUT ,
+.B FORWARD
+and
+.B OUTPUT
+chains, and user-defined chains which are only called from those
+chains.  The following option controls the nature of the error packet
+returned:
+.TP
+.BI "--reject-with " "type"
+The type given can be
+.nf
+.B " icmp6-no-route"
+.B " no-route"
+.B " icmp6-adm-prohibited"
+.B " adm-prohibited"
+.B " icmp6-addr-unreachable"
+.B " addr-unreach"
+.B " icmp6-port-unreachable"
+.B " port-unreach"
+.fi
+which return the appropriate IPv6-ICMP error message (\fBport-unreach\fP is
+the default). Finally, the option
+.B tcp-reset
+can be used on rules which only match the TCP protocol: this causes a
+TCP RST packet to be sent back.  This is mainly useful for blocking 
+.I ident
+(113/tcp) probes which frequently occur when sending mail to broken mail
+hosts (which won't accept your mail otherwise).
+
diff -urN iptables-1.2.9/extensions/libip6t_ROUTE.man iptables-1.2.10/extensions/libip6t_ROUTE.man
--- iptables-1.2.9/extensions/libip6t_ROUTE.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_ROUTE.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,12 @@
+This is used to explicitly override the core network stack's routing decision.
+.B mangle
+table.
+.TP
+.BI "--oif " "ifname"
+Route the packet through `ifname' network interface
+.TP
+.BI "--gw " "IPv6_address"
+Route the packet via this gateway
+.TP
+.BI "--continue "
+Behave like a non-terminating target and continue traversing the rules
diff -urN iptables-1.2.9/extensions/libip6t_TRACE.man iptables-1.2.10/extensions/libip6t_TRACE.man
--- iptables-1.2.9/extensions/libip6t_TRACE.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_TRACE.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,3 @@
+This target has no options.  It just turns on 
+.B packet tracing
+for all packets that match this rule.
diff -urN iptables-1.2.9/extensions/libip6t_ah.man iptables-1.2.10/extensions/libip6t_ah.man
--- iptables-1.2.9/extensions/libip6t_ah.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_ah.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,3 @@
+This module matches the SPIs in AH header of IPSec packets.
+.TP
+.BR "--ahspi " "[!] \fIspi\fP[:\fIspi\fP]"
diff -urN iptables-1.2.9/extensions/libip6t_condition.man iptables-1.2.10/extensions/libip6t_condition.man
--- iptables-1.2.9/extensions/libip6t_condition.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_condition.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,4 @@
+This matches if a specific /proc filename is '0' or '1'.
+.TP
+.BI "--condition " "[!] filename"
+Match on boolean value stored in /proc/net/ip6t_condition/filename file
diff -urN iptables-1.2.9/extensions/libip6t_dst.man iptables-1.2.10/extensions/libip6t_dst.man
--- iptables-1.2.9/extensions/libip6t_dst.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_dst.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,7 @@
+This module matches the IPv6 destination header options
+.TP
+.BI "--dst-len" "[!]" "length"
+Total length of this header
+.TP
+.BI "--dst-opts " "TYPE[:LEN],[,TYPE[:LEN]...]"
+Options and it's length (List).
diff -urN iptables-1.2.9/extensions/libip6t_esp.man iptables-1.2.10/extensions/libip6t_esp.man
--- iptables-1.2.9/extensions/libip6t_esp.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_esp.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,3 @@
+This module matches the SPIs in ESP header of IPSec packets.
+.TP
+.BR "--espspi " "[!] \fIspi\fP[:\fIspi\fP]"
diff -urN iptables-1.2.9/extensions/libip6t_eui64.man iptables-1.2.10/extensions/libip6t_eui64.man
--- iptables-1.2.9/extensions/libip6t_eui64.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_eui64.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1 @@
+This module matches the EUI64 part of a stateless autoconfigured IPv6 address.  It compares the source MAC address with the lower 64 bits of the IPv6 address. 
diff -urN iptables-1.2.9/extensions/libip6t_frag.man iptables-1.2.10/extensions/libip6t_frag.man
--- iptables-1.2.9/extensions/libip6t_frag.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_frag.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,19 @@
+This module matches the time IPv6 fragmentathion header
+.TP
+.BI "--fragid " "[!]" "id[:id]"
+Matches the given fragmentation ID (range).
+.TP
+.BI "--fraglen " "[!]" "length"
+Matches the total length of this header.
+.TP
+.BI "--fragres "
+Matches the reserved field, too.
+.TP
+.BI "--fragfirst "
+Matches on the first fragment.
+.TP
+.BI "[--fragmore]"
+Matches if there are more fragments.
+.TP
+.BI "[--fraglast]"
+Matches if this is the last fragement.
diff -urN iptables-1.2.9/extensions/libip6t_fuzzy.man iptables-1.2.10/extensions/libip6t_fuzzy.man
--- iptables-1.2.9/extensions/libip6t_fuzzy.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_fuzzy.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,7 @@
+This module matches a rate limit based on a fuzzy logic controller [FLC]
+.TP
+.BI "--lower-limit  "number"
+Specifies the lower limit (in packets per second).
+.TP
+.BI "--upper-limit " "number"
+Specifies the upper limit (in packets per second).
diff -urN iptables-1.2.9/extensions/libip6t_hbh.man iptables-1.2.10/extensions/libip6t_hbh.man
--- iptables-1.2.9/extensions/libip6t_hbh.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_hbh.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,7 @@
+This module matches the IPv6 hop-by-hop header options
+.TP
+.BI "--hbh-len" "[!]" "length"
+Total length of this header
+.TP
+.BI "--hbh-opts " "TYPE[:LEN],[,TYPE[:LEN]...]"
+Options and it's length (List).
diff -urN iptables-1.2.9/extensions/libip6t_hl.man iptables-1.2.10/extensions/libip6t_hl.man
--- iptables-1.2.9/extensions/libip6t_hl.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_hl.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,10 @@
+This module matches the HOPLIMIT field in the IPv6 header.
+.TP
+.BI "--hl-eq " "value"
+Matches if HOPLIMIT equals the given value.
+.TP
+.BI "--hl-lt " "ttl"
+Matches if HOPLIMIT is less than the given value.
+.TP
+.BI "--hl-gt " "ttl"
+Matches if HOPLIMIT is greater than the given value.
diff -urN iptables-1.2.9/extensions/libip6t_icmpv6.man iptables-1.2.10/extensions/libip6t_icmpv6.man
--- iptables-1.2.9/extensions/libip6t_icmpv6.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_icmpv6.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,9 @@
+This extension is loaded if `--protocol ipv6-icmp' or `--protocol icmpv6' is
+specified. It provides the following option:
+.TP
+.BR "--icmpv6-type " "[!] \fItypename\fP"
+This allows specification of the ICMP type, which can be a numeric
+IPv6-ICMP type, or one of the IPv6-ICMP type names shown by the command
+.nf
+ ip6tables -p ipv6-icmp -h
+.fi
diff -urN iptables-1.2.9/extensions/libip6t_ipv6header.man iptables-1.2.10/extensions/libip6t_ipv6header.man
--- iptables-1.2.9/extensions/libip6t_ipv6header.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_ipv6header.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,10 @@
+This module matches on IPv6 option headers
+.TP
+.BI "--header " "[!]" "headers"
+Matches the given type of headers.  
+Names: hop,dst,route,frag,auth,esp,none,proto
+Long Names: hop-by-hop,ipv6-opts,ipv6-route,ipv6-frag,ah,esp,ipv6-nonxt,protocol
+Numbers: 0,60,43,44,51,50,59
+.TP
+.BI "--soft"
+The header CONTAINS the specified extensions.
diff -urN iptables-1.2.9/extensions/libip6t_length.man iptables-1.2.10/extensions/libip6t_length.man
--- iptables-1.2.9/extensions/libip6t_length.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_length.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,4 @@
+This module matches the length of a packet against a specific value
+or range of values.
+.TP
+.BR "--length " "\fIlength\fP[:\fIlength\fP]"
diff -urN iptables-1.2.9/extensions/libip6t_limit.c iptables-1.2.10/extensions/libip6t_limit.c
--- iptables-1.2.9/extensions/libip6t_limit.c	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_limit.c	2004-06-15 00:02:16.000000000 +0200
@@ -11,7 +11,8 @@
 #include <ip6tables.h>
 #include <stddef.h>
 #include <linux/netfilter_ipv6/ip6_tables.h>
-#include <linux/netfilter_ipv6/ip6t_limit.h>
+/* For 64bit kernel / 32bit userspace */
+#include "../include/linux/netfilter_ipv6/ip6t_limit.h"
 
 #define IP6T_LIMIT_AVG	"3/hour"
 #define IP6T_LIMIT_BURST	5
diff -urN iptables-1.2.9/extensions/libip6t_limit.man iptables-1.2.10/extensions/libip6t_limit.man
--- iptables-1.2.9/extensions/libip6t_limit.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_limit.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,15 @@
+This module matches at a limited rate using a token bucket filter.
+A rule using this extension will match until this limit is reached
+(unless the `!' flag is used).  It can be used in combination with the
+.B LOG
+target to give limited logging, for example.
+.TP
+.BI "--limit " "rate"
+Maximum average matching rate: specified as a number, with an optional
+`/second', `/minute', `/hour', or `/day' suffix; the default is
+3/hour.
+.TP
+.BI "--limit-burst " "number"
+Maximum initial number of packets to match: this number gets
+recharged by one every time the limit specified above is not reached,
+up to this number; the default is 5.
diff -urN iptables-1.2.9/extensions/libip6t_mac.man iptables-1.2.10/extensions/libip6t_mac.man
--- iptables-1.2.9/extensions/libip6t_mac.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_mac.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,10 @@
+.TP
+.BR "--mac-source " "[!] \fIaddress\fP"
+Match source MAC address.  It must be of the form XX:XX:XX:XX:XX:XX.
+Note that this only makes sense for packets coming from an Ethernet device
+and entering the
+.BR PREROUTING ,
+.B FORWARD
+or
+.B INPUT
+chains.
diff -urN iptables-1.2.9/extensions/libip6t_mark.c iptables-1.2.10/extensions/libip6t_mark.c
--- iptables-1.2.9/extensions/libip6t_mark.c	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_mark.c	2004-06-15 00:02:16.000000000 +0200
@@ -6,7 +6,8 @@
 #include <getopt.h>
 
 #include <ip6tables.h>
-#include <linux/netfilter_ipv6/ip6t_mark.h>
+/* For 64bit kernel / 32bit userspace */
+#include "../include/linux/netfilter_ipv6/ip6t_mark.h"
 
 /* Function which prints out usage message. */
 static void
@@ -46,11 +47,19 @@
 		char *end;
 	case '1':
 		check_inverse(optarg, &invert, &optind, 0);
+#ifdef KERNEL_64_USERSPACE_32
+		markinfo->mark = strtoull(optarg, &end, 0);
+		if (*end == '/') {
+			markinfo->mask = strtoull(end+1, &end, 0);
+		} else
+			markinfo->mask = 0xffffffffffffffffULL;
+#else
 		markinfo->mark = strtoul(optarg, &end, 0);
 		if (*end == '/') {
 			markinfo->mask = strtoul(end+1, &end, 0);
 		} else
 			markinfo->mask = 0xffffffff;
+#endif
 		if (*end != '\0' || end == optarg)
 			exit_error(PARAMETER_PROBLEM, "Bad MARK value `%s'", optarg);
 		if (invert)
@@ -64,17 +73,25 @@
 	return 1;
 }
 
+#ifdef KERNEL_64_USERSPACE_32
 static void
-print_mark(unsigned long mark, unsigned long mask, int invert, int numeric)
+print_mark(unsigned long long mark, unsigned long long mask, int numeric)
+{
+	if(mask != 0xffffffffffffffffULL)
+		printf("0x%llx/0x%llx ", mark, mask);
+	else
+		printf("0x%llx ", mark);
+}
+#else
+static void
+print_mark(unsigned long mark, unsigned long mask, int numeric)
 {
-	if (invert)
-		fputc('!', stdout);
-
 	if(mask != 0xffffffff)
 		printf("0x%lx/0x%lx ", mark, mask);
 	else
 		printf("0x%lx ", mark);
 }
+#endif
 
 /* Final check; must have specified --mark. */
 static void
@@ -91,20 +108,27 @@
       const struct ip6t_entry_match *match,
       int numeric)
 {
+	struct ip6t_mark_info *info = (struct ip6t_mark_info *)match->data;
+
 	printf("MARK match ");
-	print_mark(((struct ip6t_mark_info *)match->data)->mark,
-		  ((struct ip6t_mark_info *)match->data)->mask,
-		  ((struct ip6t_mark_info *)match->data)->invert, numeric);
+
+	if (info->invert)
+		printf("!");
+	
+	print_mark(info->mark, info->mask, numeric);
 }
 
 /* Saves the union ip6t_matchinfo in parsable form to stdout. */
 static void
 save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
 {
+	struct ip6t_mark_info *info = (struct ip6t_mark_info *)match->data;
+
+	if (info->invert)
+		printf("! ");
+	
 	printf("--mark ");
-	print_mark(((struct ip6t_mark_info *)match->data)->mark,
-		  ((struct ip6t_mark_info *)match->data)->mask,
-		  ((struct ip6t_mark_info *)match->data)->invert, 0);
+	print_mark(info->mark, info->mask, 0);
 }
 
 static
diff -urN iptables-1.2.9/extensions/libip6t_mark.man iptables-1.2.10/extensions/libip6t_mark.man
--- iptables-1.2.9/extensions/libip6t_mark.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_mark.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,9 @@
+This module matches the netfilter mark field associated with a packet
+(which can be set using the
+.B MARK
+target below).
+.TP
+.BR "--mark " "\fIvalue\fP[/\fImask\fP]"
+Matches packets with the given unsigned mark value (if a mask is
+specified, this is logically ANDed with the mask before the
+comparison).
diff -urN iptables-1.2.9/extensions/libip6t_multiport.man iptables-1.2.10/extensions/libip6t_multiport.man
--- iptables-1.2.9/extensions/libip6t_multiport.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_multiport.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,19 @@
+This module matches a set of source or destination ports.  Up to 15
+ports can be specified.  It can only be used in conjunction with
+.B "-p tcp"
+or
+.BR "-p udp" .
+.TP
+.BR "--source-ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
+Match if the source port is one of the given ports.  The flag
+.B --sports
+is a convenient alias for this option.
+.TP
+.BR "--destination-ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
+Match if the destination port is one of the given ports.  The flag
+.B --dports
+is a convenient alias for this option.
+.TP
+.BR "--ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
+Match if the both the source and destination ports are equal to each
+other and to one of the given ports.
diff -urN iptables-1.2.9/extensions/libip6t_nth.man iptables-1.2.10/extensions/libip6t_nth.man
--- iptables-1.2.9/extensions/libip6t_nth.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_nth.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,14 @@
+This module matches every `n'th packet
+.TP
+.BI "--every " "value"
+Match every `value' packet
+.TP
+.BI "[" "--counter " "num" "]"
+Use internal counter number `num'.  Default is `0'.
+.TP
+.BI "[" "--start " "num" "]"
+Initialize the counter at the number `num' insetad of `0'.  Most between `0'
+and `value'-1.
+.TP
+.BI "[" "--packet " "num" "]"
+Match on `num' packet.  Most be between `0' and `value'-1.
diff -urN iptables-1.2.9/extensions/libip6t_owner.c iptables-1.2.10/extensions/libip6t_owner.c
--- iptables-1.2.9/extensions/libip6t_owner.c	2003-06-30 18:16:54.000000000 +0200
+++ iptables-1.2.10/extensions/libip6t_owner.c	2004-02-19 19:04:14.000000000 +0100
@@ -129,6 +129,7 @@
 			exit_error(PARAMETER_PROBLEM, "OWNER CMD `%s' too long, max %d characters", optarg, sizeof(ownerinfo->comm));
 		
 		strncpy(ownerinfo->comm, optarg, sizeof(ownerinfo->comm));
+		ownerinfo->comm[sizeof(ownerinfo->comm)-1] = '\0';
 
 		if (invert)
 			ownerinfo->invert |= IP6T_OWNER_COMM;
diff -urN iptables-1.2.9/extensions/libip6t_owner.man iptables-1.2.10/extensions/libip6t_owner.man
--- iptables-1.2.9/extensions/libip6t_owner.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_owner.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,21 @@
+This module attempts to match various characteristics of the packet
+creator, for locally-generated packets.  It is only valid in the
+.B OUTPUT
+chain, and even this some packets (such as ICMP ping responses) may
+have no owner, and hence never match.  This is regarded as experimental.
+.TP
+.BI "--uid-owner " "userid"
+Matches if the packet was created by a process with the given
+effective user id.
+.TP
+.BI "--gid-owner " "groupid"
+Matches if the packet was created by a process with the given
+effective group id.
+.TP
+.BI "--pid-owner " "processid"
+Matches if the packet was created by a process with the given
+process id.
+.TP
+.BI "--sid-owner " "sessionid"
+Matches if the packet was created by a process in the given session
+group.
diff -urN iptables-1.2.9/extensions/libip6t_random.man iptables-1.2.10/extensions/libip6t_random.man
--- iptables-1.2.9/extensions/libip6t_random.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_random.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,4 @@
+This module randomly matches a certain percentage of all packets.
+.TP
+.BI "--average " "percent"
+Matches the given percentage.  If omitted, a probability of 50% is set. 
diff -urN iptables-1.2.9/extensions/libip6t_rt.man iptables-1.2.10/extensions/libip6t_rt.man
--- iptables-1.2.9/extensions/libip6t_rt.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_rt.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,19 @@
+Match on IPv6 routing header
+.TP
+.BI "--rt-type " "[!]" "type"
+Match the type (numeric).
+.TP
+.BI "--rt-segsleft" "[!]" "num[:num]"
+Match the `segments left' field (range).
+.TP
+.BI "--rt-len" "[!]" "length"
+Match the length of this header
+.TP
+.BI "--rt-0-res"
+Match the reserved field, too (type=0)
+.TP
+.BI "--rt-0-addrs ADDR[,ADDR...]
+Match type=0 addresses (list).
+.TP
+.BI "--rt-0-not-strict"
+List of type=0 addresses is not a strict list.
diff -urN iptables-1.2.9/extensions/libip6t_tcp.man iptables-1.2.10/extensions/libip6t_tcp.man
--- iptables-1.2.9/extensions/libip6t_tcp.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_tcp.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,45 @@
+These extensions are loaded if `--protocol tcp' is specified. It
+provides the following options:
+.TP
+.BR "--source-port " "[!] \fIport\fP[:\fIport\fP]"
+Source port or port range specification. This can either be a service
+name or a port number. An inclusive range can also be specified,
+using the format
+.IR port : port .
+If the first port is omitted, "0" is assumed; if the last is omitted,
+"65535" is assumed.
+If the second port greater then the first they will be swapped.
+The flag
+.B --sport
+is a convenient alias for this option.
+.TP
+.BR "--destination-port " "[!] \fIport\fP[:\fIport\fP]"
+Destination port or port range specification.  The flag
+.B --dport
+is a convenient alias for this option.
+.TP
+.BR "--tcp-flags " "[!] \fImask\fP \fIcomp\fP"
+Match when the TCP flags are as specified.  The first argument is the
+flags which we should examine, written as a comma-separated list, and
+the second argument is a comma-separated list of flags which must be
+set.  Flags are: 
+.BR "SYN ACK FIN RST URG PSH ALL NONE" .
+Hence the command
+.nf
+ ip6tables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN
+.fi
+will only match packets with the SYN flag set, and the ACK, FIN and
+RST flags unset.
+.TP
+.B "[!] --syn"
+Only match TCP packets with the SYN bit set and the ACK and RST bits
+cleared.  Such packets are used to request TCP connection initiation;
+for example, blocking such packets coming in an interface will prevent
+incoming TCP connections, but outgoing TCP connections will be
+unaffected.
+It is equivalent to \fB--tcp-flags SYN,RST,ACK SYN\fP.
+If the "!" flag precedes the "--syn", the sense of the
+option is inverted.
+.TP
+.BR "--tcp-option " "[!] \fInumber\fP"
+Match if TCP option set.
diff -urN iptables-1.2.9/extensions/libip6t_udp.man iptables-1.2.10/extensions/libip6t_udp.man
--- iptables-1.2.9/extensions/libip6t_udp.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libip6t_udp.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,14 @@
+These extensions are loaded if `--protocol udp' is specified.  It
+provides the following options:
+.TP
+.BR "--source-port " "[!] \fIport\fP[:\fIport\fP]"
+Source port or port range specification.
+See the description of the
+.B --source-port
+option of the TCP extension for details.
+.TP
+.BR "--destination-port " "[!] \fIport\fP[:\fIport\fP]"
+Destination port or port range specification.
+See the description of the
+.B --destination-port
+option of the TCP extension for details.
diff -urN iptables-1.2.9/extensions/libipt_BALANCE.man iptables-1.2.10/extensions/libipt_BALANCE.man
--- iptables-1.2.9/extensions/libipt_BALANCE.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_BALANCE.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,4 @@
+This allows you to DNAT connections in a round-robin way over a given range of destination addresses.
+.TP
+.BI "--to-destination " "ipaddr-ipaddr"
+Address range to round-robin over.
diff -urN iptables-1.2.9/extensions/libipt_CLASSIFY.man iptables-1.2.10/extensions/libipt_CLASSIFY.man
--- iptables-1.2.9/extensions/libipt_CLASSIFY.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_CLASSIFY.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,4 @@
+This module allows you to set the skb->priority value (and thus classify the packet into a specific CBQ class).
+.TP
+.BI "--set-class " "MAJOR:MINOR"
+Set the major and minor class value.
diff -urN iptables-1.2.9/extensions/libipt_CLUSTERIP.c iptables-1.2.10/extensions/libipt_CLUSTERIP.c
--- iptables-1.2.9/extensions/libipt_CLUSTERIP.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_CLUSTERIP.c	2003-11-26 13:50:38.000000000 +0100
@@ -0,0 +1,259 @@
+/* Shared library add-on to iptables to add CLUSTERIP target support. 
+ * (C) 2003 by Harald Welte <laforge@gnumonks.org>
+ *
+ * Development of this code was funded by SuSE AG, http://www.suse.com/
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#if defined(__GLIBC__) && __GLIBC__ == 2
+#include <net/ethernet.h>
+#else
+#include <linux/if_ether.h>
+#endif
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_CLUSTERIP.h>
+
+static void
+help(void)
+{
+	printf(
+"CLUSTERIP target v%s options:\n"
+"  --new			 Create a new ClusterIP\n"
+"  --hashmode <mode>		 Specify hashing mode\n"
+"					sourceip\n"
+"					sourceip-sourceport\n"
+"					sourceip-sourceport-destport\n"
+"  --clustermac <mac>		 Set clusterIP MAC address\n"
+"  --total-nodes <num>		 Set number of total nodes in cluster\n"
+"  --local-node <num>		 Set the local node number\n"
+"  --hash-init\n"
+"\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "new", 0, 0, '1' },
+	{ "hashmode", 1, 0, '2' },
+	{ "clustermac", 1, 0, '3' },
+	{ "total-nodes", 1, 0, '4' },
+	{ "local-node", 1, 0, '5' },
+	{ 0 }
+};
+
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+}
+
+static void
+parse_mac(const char *mac, char *macbuf)
+{
+	unsigned int i = 0;
+
+	if (strlen(mac) != ETH_ALEN*3-1)
+		exit_error(PARAMETER_PROBLEM, "Bad mac address `%s'", mac);
+
+	for (i = 0; i < ETH_ALEN; i++) {
+		long number;
+		char *end;
+
+		number = strtol(mac + i*3, &end, 16);
+
+		if (end == mac + i*3 + 2
+		    && number >= 0
+		    && number <= 255)
+			macbuf[i] = number;
+		else
+			exit_error(PARAMETER_PROBLEM,
+				   "Bad mac address `%s'", mac);
+	}
+}
+
+#define	PARAM_NEW	0x0001
+#define PARAM_HMODE	0x0002
+#define PARAM_MAC	0x0004
+#define PARAM_TOTALNODE	0x0008
+#define PARAM_LOCALNODE	0x0010
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	struct ipt_clusterip_tgt_info *cipinfo
+		= (struct ipt_clusterip_tgt_info *)(*target)->data;
+
+	switch (c) {
+		unsigned int num;
+	case '1':
+		cipinfo->flags |= CLUSTERIP_FLAG_NEW;
+		if (*flags & PARAM_NEW)
+			exit_error(PARAMETER_PROBLEM, "Can only specify `--new' once\n");
+		*flags |= PARAM_NEW;
+		break;
+	case '2':
+		if (!(*flags & PARAM_NEW))
+			exit_error(PARAMETER_PROBLEM, "Can only specify hashmode combined with `--new'\n");
+		if (*flags & PARAM_HMODE)
+			exit_error(PARAMETER_PROBLEM, "Can only specify hashmode once\n");
+		if (!strcmp(optarg, "sourceip"))
+			cipinfo->hash_mode = CLUSTERIP_HASHMODE_SIP;
+		else if (!strcmp(optarg, "sourceip-sourceport"))
+			cipinfo->hash_mode = CLUSTERIP_HASHMODE_SIP_SPT;
+		else if (!strcmp(optarg, "sourceip-sourceport-destport"))
+			cipinfo->hash_mode = CLUSTERIP_HASHMODE_SIP_SPT_DPT;
+		else
+			exit_error(PARAMETER_PROBLEM, "Unknown hashmode `%s'\n",
+				   optarg);
+		*flags |= PARAM_HMODE;
+		break;
+	case '3':
+		if (!(*flags & PARAM_NEW))
+			exit_error(PARAMETER_PROBLEM, "Can only specify MAC combined with `--new'\n");
+		if (*flags & PARAM_MAC)
+			exit_error(PARAMETER_PROBLEM, "Can only specify MAC once\n");
+		parse_mac(optarg, cipinfo->clustermac);
+		if (!(cipinfo->clustermac[0] & 0x01))
+			exit_error(PARAMETER_PROBLEM, "MAC has to be a multicast ethernet address\n");
+		*flags |= PARAM_MAC;
+		break;
+	case '4':
+		if (!(*flags & PARAM_NEW))
+			exit_error(PARAMETER_PROBLEM, "Can only specify node number combined with `--new'\n");
+		if (*flags & PARAM_TOTALNODE)
+			exit_error(PARAMETER_PROBLEM, "Can only specify total node number once\n");
+		if (string_to_number(optarg, 1, CLUSTERIP_MAX_NODES, &num) < 0)
+			exit_error(PARAMETER_PROBLEM, "Unable to parse `%s'\n", optarg);
+		cipinfo->num_total_nodes = (u_int16_t)num;
+		*flags |= PARAM_TOTALNODE;
+		break;
+	case '5':
+		if (!(*flags & PARAM_NEW))
+			exit_error(PARAMETER_PROBLEM, "Can only specify node number combined with `--new'\n");
+		if (*flags & PARAM_LOCALNODE)
+			exit_error(PARAMETER_PROBLEM, "Can only specify local node number once\n");
+		if (string_to_number(optarg, 1, CLUSTERIP_MAX_NODES, &num) < 0)
+			exit_error(PARAMETER_PROBLEM, "Unable to parse `%s'\n", optarg);
+		cipinfo->num_local_nodes = 1;
+		cipinfo->local_nodes[0] = (u_int16_t)num;
+		*flags |= PARAM_LOCALNODE;
+		break;
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+	if (flags == 0)
+		return;
+
+	if (flags == (PARAM_NEW|PARAM_HMODE|PARAM_MAC|PARAM_TOTALNODE|PARAM_LOCALNODE))
+		return;
+
+	exit_error(PARAMETER_PROBLEM, "CLUSTERIP target: Invalid parameter combination\n");
+}
+
+static char *hashmode2str(enum clusterip_hashmode mode)
+{
+	char *retstr;
+	switch (mode) {
+		case CLUSTERIP_HASHMODE_SIP:
+			retstr = "sourceip";
+			break;
+		case CLUSTERIP_HASHMODE_SIP_SPT:
+			retstr = "sourceip-sourceport";
+			break;
+		case CLUSTERIP_HASHMODE_SIP_SPT_DPT:
+			retstr = "sourceip-sourceport-destport";
+			break;
+		default:
+			retstr = "unknown-error";
+			break;
+	}
+	return retstr;
+}
+
+static char *mac2str(u_int8_t mac[ETH_ALEN])
+{
+	static char buf[ETH_ALEN*3];
+	sprintf(buf, "%02X:%02X:%02X:%02X:%02X:%02X",
+		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+	return buf;
+}
+			
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	const struct ipt_clusterip_tgt_info *cipinfo =
+		(const struct ipt_clusterip_tgt_info *)target->data;
+	
+	if (!cipinfo->flags & CLUSTERIP_FLAG_NEW) {
+		printf("CLUSTERIP");
+		return;
+	}
+
+	printf("CLUSTERIP hashmode=%s clustermac=%s total_nodes=%u local_node=%u ", 
+		hashmode2str(cipinfo->hash_mode),
+		mac2str(cipinfo->clustermac),
+		cipinfo->num_total_nodes,
+		cipinfo->local_nodes[0]);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	/*
+	const struct ipt_connmark_target_info *markinfo =
+		(const struct ipt_connmark_target_info *)target->data;
+
+	switch (markinfo->mode) {
+	case IPT_CONNMARK_SET:
+	    printf("--set-mark 0x%lx ", markinfo->mark);
+	    break;
+	case IPT_CONNMARK_SAVE:
+	    printf("--save-mark ");
+	    break;
+	case IPT_CONNMARK_RESTORE:
+	    printf("--restore-mark ");
+	    break;
+	default:
+	    printf("ERROR: UNKNOWN CONNMARK MODE ");
+	    break;
+	}
+	*/
+}
+
+static
+struct iptables_target clusterip
+= { NULL,
+    "CLUSTERIP",
+    IPTABLES_VERSION,
+    IPT_ALIGN(sizeof(struct ipt_clusterip_tgt_info)),
+    IPT_ALIGN(sizeof(struct ipt_clusterip_tgt_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_target(&clusterip);
+}
diff -urN iptables-1.2.9/extensions/libipt_CLUSTERIP.man iptables-1.2.10/extensions/libipt_CLUSTERIP.man
--- iptables-1.2.9/extensions/libipt_CLUSTERIP.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_CLUSTERIP.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,24 @@
+This module allows you to configure a simple cluster of nodes that share
+a certain IP and MAC address without an explicit load balancer in front of
+them.  Connections are statically distributed between the nodes in this
+cluster.
+.TP
+.BI "--new "
+Create a new ClusterIP.  You always have to set this on the first rule
+for a given ClusterIP.
+.TP
+.BI "--hashmode " "mode"
+Specify the hashing mode.  Has to be one of
+.B sourceip, sourceip-sourceport, sourceip-sourceport-destport
+.TP
+.BI "--clustermac " "mac"
+Specify the ClusterIP MAC address.  Has to be a link-layer multicast address
+.TP
+.BI "--total-nodes " "num"
+Number of total nodes within this cluster.
+.TP
+.BI "--local-node " "num"
+Local node number within this cluster.
+.TP
+.BI "--hash-init " "rnd"
+Specify the random seed used for hash initialization.
diff -urN iptables-1.2.9/extensions/libipt_CONNMARK.c iptables-1.2.10/extensions/libipt_CONNMARK.c
--- iptables-1.2.9/extensions/libipt_CONNMARK.c	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_CONNMARK.c	2004-02-19 19:04:15.000000000 +0100
@@ -1,4 +1,24 @@
-/* Shared library add-on to iptables to add CONNMARK target support. */
+/* Shared library add-on to iptables to add CONNMARK target support.
+ *
+ * (C) 2002,2004 MARA Systems AB <http://www.marasystems.com>
+ * by Henrik Nordstrom <hno@marasystems.com>
+ *
+ * Version 1.1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
@@ -21,9 +41,9 @@
 {
 	printf(
 "CONNMARK target v%s options:\n"
-"  --set-mark value              Set conntrack mark value\n"
-"  --save-mark                   Save the packet nfmark on the connection\n"
-"  --restore-mark                Restore saved nfmark value\n"
+"  --set-mark value[/mask]       Set conntrack mark value\n"
+"  --save-mark [--mask mask]     Save the packet nfmark in the connection\n"
+"  --restore-mark [--mask mask]  Restore saved nfmark value\n"
 "\n",
 IPTABLES_VERSION);
 }
@@ -32,6 +52,7 @@
 	{ "set-mark", 1, 0, '1' },
 	{ "save-mark", 0, 0, '2' },
 	{ "restore-mark", 0, 0, '3' },
+	{ "mask", 1, 0, '4' },
 	{ 0 }
 };
 
@@ -55,7 +76,10 @@
 		char *end;
 	case '1':
 		markinfo->mode = IPT_CONNMARK_SET;
+		markinfo->mask = ~0;
 		markinfo->mark = strtoul(optarg, &end, 0);
+		if (*end == '/' && end[1] != '\0')
+		    markinfo->mask = strtoul(end+1, &end, 0);
 		if (*end != '\0' || end == optarg)
 			exit_error(PARAMETER_PROBLEM, "Bad MARK value `%s'", optarg);
 		if (*flags)
@@ -65,6 +89,7 @@
 		break;
 	case '2':
 		markinfo->mode = IPT_CONNMARK_SAVE;
+		markinfo->mask = ~0;
 		if (*flags)
 			exit_error(PARAMETER_PROBLEM,
 			           "CONNMARK target: Can't specify --save-mark twice");
@@ -72,11 +97,20 @@
 		break;
 	case '3':
 		markinfo->mode = IPT_CONNMARK_RESTORE;
+		markinfo->mask = ~0;
 		if (*flags)
 			exit_error(PARAMETER_PROBLEM,
 			           "CONNMARK target: Can't specify --restore-mark twice");
 		*flags = 1;
 		break;
+	case '4':
+		if (!*flags)
+			exit_error(PARAMETER_PROBLEM,
+			           "CONNMARK target: Can't specify --mask without a operation");
+		markinfo->mark = strtoul(optarg, &end, 0);
+		if (*end != '\0' || end == optarg)
+			exit_error(PARAMETER_PROBLEM, "Bad MARK value `%s'", optarg);
+		break;
 	default:
 		return 0;
 	}
@@ -89,16 +123,10 @@
 {
 	if (!flags)
 		exit_error(PARAMETER_PROBLEM,
-		           "CONNMARK target: Parameter --set-mark is required");
-}
-
-static void
-print_mark(unsigned long mark, int numeric)
-{
-	printf("0x%lx ", mark);
+		           "CONNMARK target: No operation specified");
 }
 
-/* Prints out the targinfo. */
+/* Prints out the target info. */
 static void
 print(const struct ipt_ip *ip,
       const struct ipt_entry_target *target,
@@ -108,14 +136,21 @@
 		(const struct ipt_connmark_target_info *)target->data;
 	switch (markinfo->mode) {
 	case IPT_CONNMARK_SET:
-	    printf("CONNMARK set ");
-	    print_mark(markinfo->mark, numeric);
+	    printf("CONNMARK set 0x%lx", markinfo->mark);
+	    if (markinfo->mask != ~0)
+		printf("/0x%lx", markinfo->mask);
+	    printf(" ");
 	    break;
 	case IPT_CONNMARK_SAVE:
 	    printf("CONNMARK save ");
+	    if (markinfo->mask != ~0)
+		printf("mask 0x%lx", markinfo->mask);
+	    printf(" ");
 	    break;
 	case IPT_CONNMARK_RESTORE:
 	    printf("CONNMARK restore ");
+	    if (markinfo->mask != ~0)
+		printf("mask 0x%lx", markinfo->mask);
 	    break;
 	default:
 	    printf("ERROR: UNKNOWN CONNMARK MODE ");
@@ -123,7 +158,7 @@
 	}
 }
 
-/* Saves the union ipt_targinfo in parsable form to stdout. */
+/* Saves the target into in parsable form to stdout. */
 static void
 save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
 {
@@ -132,13 +167,20 @@
 
 	switch (markinfo->mode) {
 	case IPT_CONNMARK_SET:
-	    printf("--set-mark 0x%lx ", markinfo->mark);
+	    printf("--set-mark 0x%lx", markinfo->mark);
+	    if (markinfo->mask != ~0)
+		printf("/0x%lx", markinfo->mask);
+	    printf(" ");
 	    break;
 	case IPT_CONNMARK_SAVE:
 	    printf("--save-mark ");
+	    if (markinfo->mask != ~0)
+		printf("--mask 0x%lx", markinfo->mask);
 	    break;
 	case IPT_CONNMARK_RESTORE:
 	    printf("--restore-mark ");
+	    if (markinfo->mask != ~0)
+		printf("--mask 0x%lx", markinfo->mask);
 	    break;
 	default:
 	    printf("ERROR: UNKNOWN CONNMARK MODE ");
@@ -146,23 +188,21 @@
 	}
 }
 
-static
-struct iptables_target mark
-= { NULL,
-    "CONNMARK",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_connmark_target_info)),
-    IPT_ALIGN(sizeof(struct ipt_connmark_target_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_target connmark_target = {
+    .name          = "CONNMARK",
+    .version       = IPTABLES_VERSION,
+    .size          = IPT_ALIGN(sizeof(struct ipt_connmark_target_info)),
+    .userspacesize = IPT_ALIGN(sizeof(struct ipt_connmark_target_info)),
+    .help          = &help,
+    .init          = &init,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
 };
 
 void _init(void)
 {
-	register_target(&mark);
+	register_target(&connmark_target);
 }
diff -urN iptables-1.2.9/extensions/libipt_CONNMARK.man iptables-1.2.10/extensions/libipt_CONNMARK.man
--- iptables-1.2.9/extensions/libipt_CONNMARK.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_CONNMARK.man	2004-02-03 09:19:04.000000000 +0100
@@ -0,0 +1,15 @@
+This module sets the netfilter mark value associated with a connection
+.TP
+.B --set-mark mark[/mask]
+Set connection mark. If a mask is specified then only those bits set in the
+mask is modified.
+.TP
+.B --save-mark [--mask mask]
+Copy the netfilter packet mark value to the connection mark. If a mask
+is specified then only those bits are copied.
+.TP
+.B --restore-mark [--mask mask]
+Copy the connection mark value to the packet. If a mask is specified
+then only those bits are copied. This is only valid in the
+.B mangle
+table.
diff -urN iptables-1.2.9/extensions/libipt_DNAT.man iptables-1.2.10/extensions/libipt_DNAT.man
--- iptables-1.2.9/extensions/libipt_DNAT.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_DNAT.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,27 @@
+This target is only valid in the
+.B nat
+table, in the
+.B PREROUTING
+and
+.B OUTPUT
+chains, and user-defined chains which are only called from those
+chains.  It specifies that the destination address of the packet
+should be modified (and all future packets in this connection will
+also be mangled), and rules should cease being examined.  It takes one
+type of option:
+.TP
+.BR "--to-destination " "\fIipaddr\fP[-\fIipaddr\fP][:\fIport\fP-\fIport\fP]"
+which can specify a single new destination IP address, an inclusive
+range of IP addresses, and optionally, a port range (which is only
+valid if the rule also specifies
+.B "-p tcp"
+or
+.BR "-p udp" ).
+If no port range is specified, then the destination port will never be
+modified.
+.RS
+.PP
+You can add several --to-destination options.  If you specify more
+than one destination address, either via an address range or multiple
+--to-destination options, a simple round-robin (one after another in
+cycle) load balancing takes place between these adresses.
diff -urN iptables-1.2.9/extensions/libipt_DSCP.c iptables-1.2.10/extensions/libipt_DSCP.c
--- iptables-1.2.9/extensions/libipt_DSCP.c	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_DSCP.c	2004-03-04 08:35:30.000000000 +0100
@@ -35,7 +35,7 @@
 "               		or in hex (ex: 0x20)\n"
 "  --set-dscp-class class	Set the DSCP field in packet header to the\n"
 "				value represented by the DiffServ class value.\n"
-"				This class may be EF,BE or any of the CSxx "
+"				This class may be EF,BE or any of the CSxx\n"
 "				or AFxx classes.\n"
 "\n"
 "				These two options are mutually exclusive !\n"
diff -urN iptables-1.2.9/extensions/libipt_DSCP.man iptables-1.2.10/extensions/libipt_DSCP.man
--- iptables-1.2.9/extensions/libipt_DSCP.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_DSCP.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,9 @@
+This target allows to alter the value of the DSCP bits within the TOS
+header of the IPv4 packet.  As this manipulates a packet, it can only
+be used in the mangle table.
+.TP
+.BI "--set-dscp " "value"
+Set the DSCP field to a numerical value (can be decimal or hex)
+.TP
+.BI "--set-dscp-class " "class"
+Set the DSCP field to a DiffServ class.
diff -urN iptables-1.2.9/extensions/libipt_ECN.man iptables-1.2.10/extensions/libipt_ECN.man
--- iptables-1.2.9/extensions/libipt_ECN.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_ECN.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,7 @@
+This target allows to selectively work around known ECN blackholes.
+It can only be used in the mangle table.
+.TP
+.BI "--ecn-tcp-remove"
+Remove all ECN bits from the TCP header.  Of course, it can only be used
+in conjunction with
+.BR "-p tcp" .
diff -urN iptables-1.2.9/extensions/libipt_LOG.c iptables-1.2.10/extensions/libipt_LOG.c
--- iptables-1.2.9/extensions/libipt_LOG.c	2003-08-23 13:09:22.000000000 +0200
+++ iptables-1.2.10/extensions/libipt_LOG.c	2004-06-15 00:02:16.000000000 +0200
@@ -134,7 +134,7 @@
 		if (strlen(optarg) > sizeof(loginfo->prefix) - 1)
 			exit_error(PARAMETER_PROBLEM,
 				   "Maximum prefix length %u for --log-prefix",
-				   sizeof(loginfo->prefix) - 1);
+				   (unsigned int)sizeof(loginfo->prefix) - 1);
 
 		strcpy(loginfo->prefix, optarg);
 		*flags |= IPT_LOG_OPT_PREFIX;
diff -urN iptables-1.2.9/extensions/libipt_LOG.man iptables-1.2.10/extensions/libipt_LOG.man
--- iptables-1.2.9/extensions/libipt_LOG.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_LOG.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,28 @@
+Turn on kernel logging of matching packets.  When this option is set
+for a rule, the Linux kernel will print some information on all
+matching packets (like most IP header fields) via the kernel log
+(where it can be read with
+.I dmesg
+or 
+.IR syslogd (8)).
+This is a "non-terminating target", i.e. rule traversal continues at
+the next rule.  So if you want to LOG the packets you refuse, use two
+separate rules with the same matching criteria, first using target LOG
+then DROP (or REJECT).
+.TP
+.BI "--log-level " "level"
+Level of logging (numeric or see \fIsyslog.conf\fP(5)).
+.TP
+.BI "--log-prefix " "prefix"
+Prefix log messages with the specified prefix; up to 29 letters long,
+and useful for distinguishing messages in the logs.
+.TP
+.B --log-tcp-sequence
+Log TCP sequence numbers. This is a security risk if the log is
+readable by users.
+.TP
+.B --log-tcp-options
+Log options from the TCP packet header.
+.TP
+.B --log-ip-options
+Log options from the IP packet header.
diff -urN iptables-1.2.9/extensions/libipt_MARK.c iptables-1.2.10/extensions/libipt_MARK.c
--- iptables-1.2.9/extensions/libipt_MARK.c	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_MARK.c	2004-06-15 00:02:16.000000000 +0200
@@ -6,12 +6,8 @@
 
 #include <iptables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
-#include <linux/netfilter_ipv4/ipt_MARK.h>
-
-struct markinfo {
-	struct ipt_entry_target t;
-	struct ipt_mark_target_info mark;
-};
+/* For 64bit kernel / 32bit userspace */
+#include "../include/linux/netfilter_ipv4/ipt_MARK.h"
 
 /* Function which prints out usage message. */
 static void
@@ -47,8 +43,13 @@
 
 	switch (c) {
 	case '1':
-		if (string_to_number(optarg, 0, 0xffffffff, 
-				     (unsigned int *)&markinfo->mark))
+#ifdef KERNEL_64_USERSPACE_32
+		if (string_to_number_ll(optarg, 0, 0, 
+				     &markinfo->mark))
+#else
+		if (string_to_number_l(optarg, 0, 0, 
+				     &markinfo->mark))
+#endif
 			exit_error(PARAMETER_PROBLEM, "Bad MARK value `%s'", optarg);
 		if (*flags)
 			exit_error(PARAMETER_PROBLEM,
@@ -71,11 +72,19 @@
 		           "MARK target: Parameter --set-mark is required");
 }
 
+#ifdef KERNEL_64_USERSPACE_32
+static void
+print_mark(unsigned long long mark)
+{
+	printf("0x%llx ", mark);
+}
+#else
 static void
-print_mark(unsigned long mark, int numeric)
+print_mark(unsigned long mark)
 {
 	printf("0x%lx ", mark);
 }
+#endif
 
 /* Prints out the targinfo. */
 static void
@@ -86,7 +95,7 @@
 	const struct ipt_mark_target_info *markinfo =
 		(const struct ipt_mark_target_info *)target->data;
 	printf("MARK set ");
-	print_mark(markinfo->mark, numeric);
+	print_mark(markinfo->mark);
 }
 
 /* Saves the union ipt_targinfo in parsable form to stdout. */
@@ -96,7 +105,8 @@
 	const struct ipt_mark_target_info *markinfo =
 		(const struct ipt_mark_target_info *)target->data;
 
-	printf("--set-mark 0x%lx ", markinfo->mark);
+	printf("--set-mark ");
+	print_mark(markinfo->mark);
 }
 
 static
diff -urN iptables-1.2.9/extensions/libipt_MARK.man iptables-1.2.10/extensions/libipt_MARK.man
--- iptables-1.2.9/extensions/libipt_MARK.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_MARK.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,6 @@
+This is used to set the netfilter mark value associated with the
+packet.  It is only valid in the
+.B mangle
+table.  It can for example be used in conjunction with iproute2.
+.TP
+.BI "--set-mark " "mark"
diff -urN iptables-1.2.9/extensions/libipt_MASQUERADE.man iptables-1.2.10/extensions/libipt_MASQUERADE.man
--- iptables-1.2.9/extensions/libipt_MASQUERADE.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_MASQUERADE.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,22 @@
+This target is only valid in the
+.B nat
+table, in the
+.B POSTROUTING
+chain.  It should only be used with dynamically assigned IP (dialup)
+connections: if you have a static IP address, you should use the SNAT
+target.  Masquerading is equivalent to specifying a mapping to the IP
+address of the interface the packet is going out, but also has the
+effect that connections are
+.I forgotten
+when the interface goes down.  This is the correct behavior when the
+next dialup is unlikely to have the same interface address (and hence
+any established connections are lost anyway).  It takes one option:
+.TP
+.BR "--to-ports " "\fIport\fP[-\fIport\fP]"
+This specifies a range of source ports to use, overriding the default
+.B SNAT
+source port-selection heuristics (see above).  This is only valid
+if the rule also specifies
+.B "-p tcp"
+or
+.BR "-p udp" .
diff -urN iptables-1.2.9/extensions/libipt_MIRROR.man iptables-1.2.10/extensions/libipt_MIRROR.man
--- iptables-1.2.9/extensions/libipt_MIRROR.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_MIRROR.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,12 @@
+This is an experimental demonstration target which inverts the source
+and destination fields in the IP header and retransmits the packet.
+It is only valid in the
+.BR INPUT ,
+.B FORWARD
+and
+.B PREROUTING
+chains, and user-defined chains which are only called from those
+chains.  Note that the outgoing packets are
+.B NOT
+seen by any packet filtering chains, connection tracking or NAT, to
+avoid loops and other problems.
diff -urN iptables-1.2.9/extensions/libipt_NETMAP.man iptables-1.2.10/extensions/libipt_NETMAP.man
--- iptables-1.2.9/extensions/libipt_NETMAP.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_NETMAP.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,9 @@
+This target allows you to statically map a whole network of addresses onto
+another network of addresses.  It can only be used from rules in the
+.B nat
+table.
+.TP
+.BI "--to "  "address[/mask]"
+Network address to map to.  The resulting address will be constructed in the
+following way: All 'one' bits in the mask are filled in from the new `address'.
+All bits that are zero in the mask are filled in from the original address.
diff -urN iptables-1.2.9/extensions/libipt_NOTRACK.man iptables-1.2.10/extensions/libipt_NOTRACK.man
--- iptables-1.2.9/extensions/libipt_NOTRACK.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_NOTRACK.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,5 @@
+This target disables connection tracking for all packets matching that rule.
+.TP
+It can only be used in the
+.B raw
+table.
diff -urN iptables-1.2.9/extensions/libipt_REDIRECT.man iptables-1.2.10/extensions/libipt_REDIRECT.man
--- iptables-1.2.9/extensions/libipt_REDIRECT.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_REDIRECT.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,18 @@
+This target is only valid in the
+.B nat
+table, in the
+.B PREROUTING
+and
+.B OUTPUT
+chains, and user-defined chains which are only called from those
+chains.  It alters the destination IP address to send the packet to
+the machine itself (locally-generated packets are mapped to the
+127.0.0.1 address).  It takes one option:
+.TP
+.BR "--to-ports " "\fIport\fP[-\fIport\fP]"
+This specifies a destination port or range of ports to use: without
+this, the destination port is never altered.  This is only valid
+if the rule also specifies
+.B "-p tcp"
+or
+.BR "-p udp" .
diff -urN iptables-1.2.9/extensions/libipt_REJECT.man iptables-1.2.10/extensions/libipt_REJECT.man
--- iptables-1.2.9/extensions/libipt_REJECT.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_REJECT.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,34 @@
+This is used to send back an error packet in response to the matched
+packet: otherwise it is equivalent to
+.B DROP
+so it is a terminating TARGET, ending rule traversal.
+This target is only valid in the
+.BR INPUT ,
+.B FORWARD
+and
+.B OUTPUT
+chains, and user-defined chains which are only called from those
+chains.  The following option controls the nature of the error packet
+returned:
+.TP
+.BI "--reject-with " "type"
+The type given can be
+.nf
+.B " icmp-net-unreachable"
+.B " icmp-host-unreachable"
+.B " icmp-port-unreachable"
+.B " icmp-proto-unreachable"
+.B " icmp-net-prohibited"
+.B " icmp-host-prohibited or"
+.B " icmp-admin-prohibited (*)"
+.fi
+which return the appropriate ICMP error message (\fBport-unreachable\fP is
+the default).  The option
+.B tcp-reset
+can be used on rules which only match the TCP protocol: this causes a
+TCP RST packet to be sent back.  This is mainly useful for blocking 
+.I ident
+(113/tcp) probes which frequently occur when sending mail to broken mail
+hosts (which won't accept your mail otherwise).
+.TP
+(*) Using icmp-admin-prohibited with kernels that do not support it will result in a plain DROP instead of REJECT
diff -urN iptables-1.2.9/extensions/libipt_ROUTE.man iptables-1.2.10/extensions/libipt_ROUTE.man
--- iptables-1.2.9/extensions/libipt_ROUTE.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_ROUTE.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,15 @@
+This is used to explicitly override the core network stack's routing decision.
+.B mangle
+table.
+.TP
+.BI "--oif " "ifname"
+Route the packet through `ifname' network interface
+.TP
+.BI "--iif " "ifname"
+Change the packet's incoming interface to `ifname'
+.TP
+.BI "--gw " "IP_address"
+Route the packet via this gateway
+.TP
+.BI "--continue "
+Behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--iif'
diff -urN iptables-1.2.9/extensions/libipt_SAME.c iptables-1.2.10/extensions/libipt_SAME.c
--- iptables-1.2.9/extensions/libipt_SAME.c	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_SAME.c	2004-06-15 00:02:16.000000000 +0200
@@ -7,7 +7,8 @@
 #include <iptables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/netfilter_ipv4/ip_nat_rule.h>
-#include <linux/netfilter_ipv4/ipt_SAME.h>
+/* For 64bit kernel / 32bit userspace */
+#include "../include/linux/netfilter_ipv4/ipt_SAME.h"
 
 /* Function which prints out usage message. */
 static void
diff -urN iptables-1.2.9/extensions/libipt_SET.c iptables-1.2.10/extensions/libipt_SET.c
--- iptables-1.2.9/extensions/libipt_SET.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_SET.c	2004-02-09 14:47:01.000000000 +0100
@@ -0,0 +1,174 @@
+/* Shared library add-on to iptables to add IP set mangling target. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_nat_rule.h>
+#include <linux/netfilter_ipv4/ip_set.h>
+#include <linux/netfilter_ipv4/ipt_set.h>
+#include "../ipset/libipt_set.h"
+
+/* Function which prints out usage message. */
+static void help(void)
+{
+	printf("SET v%s options:\n"
+	       " --add-set name[:flags] flags\n"
+	       " --del-set name[:flags] flags\n"
+	       "		add/del src/dst IP/port from/to named sets,\n"
+	       "		where flags are the comma separated list of\n"
+	       "		'src' and 'dst'.\n"
+	       "\n", IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{"add-set",   1, 0, '1'},
+	{"del-set",   1, 0, '2'},
+	{0}
+};
+
+/* Initialize the target. */
+static void init(struct ipt_entry_target *target, unsigned int *nfcache)
+{
+	struct ipt_set_info_target *info =
+	    (struct ipt_set_info_target *) target->data;
+
+	memset(info, 0, sizeof(struct ipt_set_info_target));
+	info->add_set.id = -1;
+	info->del_set.id = -1;
+
+	/* Can't cache this */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry, struct ipt_entry_target **target)
+{
+	struct ipt_set_info_target *myinfo =
+	    (struct ipt_set_info_target *) (*target)->data;
+	struct ipt_set_info *info;
+
+	switch (c) {
+	case '1':		/* --add-set <set>[:<flags>] <flags> */
+		info = &myinfo->add_set;
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --add-set");
+
+		if (!argv[optind]
+		    || argv[optind][0] == '-' || argv[optind][0] == '!')
+			exit_error(PARAMETER_PROBLEM,
+				   "--add-set requires two args.");
+
+		parse_pool(argv[optind - 1], info);
+		parse_ipflags(argv[optind++], info);
+		
+		*flags = 1;
+		break;
+	case '2':		/* --del-set <set>[:<flags>] <flags> */
+		info = &myinfo->del_set;
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --del-set");
+
+		if (!argv[optind]
+		    || argv[optind][0] == '-' || argv[optind][0] == '!')
+			exit_error(PARAMETER_PROBLEM,
+				   "--del-set requires two args.");
+
+		parse_pool(argv[optind - 1], info);
+		if (parse_ipflags(argv[optind++], info))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't use overwrite flag with --del-set.");
+		
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; must specify at least one. */
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+			   "You must specify either `--add-set' or `--del-set'");
+}
+
+static void
+print_target(const char *prefix, const struct ipt_set_info *info)
+{
+	int i;
+	char setname[IP_SET_MAXNAMELEN];
+
+	if (info->id >= 0) {
+		get_set_byid(setname, info->id);
+		printf("%s %s", prefix, setname);
+		for (i = 0; i < info->set_level; i++)
+			printf("%s%s",
+			       i == 0 ? ":" : ",",
+			       info->flags[i] & IPSET_SRC ? "src" : "dst");
+		for (i = info->set_level; i < info->ip_level; i++)
+			printf("%s%s%s",
+			       i == info->set_level ? " " : ",",
+			       info->flags[i] & IPSET_ADD_OVERWRITE ? "+" : "",
+			       info->flags[i] & IPSET_SRC ? "src" : "dst");
+		printf(" ");
+	}
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target, int numeric)
+{
+	struct ipt_set_info_target *info =
+	    (struct ipt_set_info_target *) target->data;
+
+	print_target("add-set", &info->add_set);
+	print_target("del-set", &info->del_set);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	struct ipt_set_info_target *info =
+	    (struct ipt_set_info_target *) target->data;
+
+	print_target("--add-set", &info->add_set);
+	print_target("--del-set", &info->del_set);
+}
+
+static
+struct iptables_target ipt_set_target 
+= {
+	.name		= "SET",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_set_info_target)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_set_info_target)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_target(&ipt_set_target);
+}
diff -urN iptables-1.2.9/extensions/libipt_SNAT.man iptables-1.2.10/extensions/libipt_SNAT.man
--- iptables-1.2.9/extensions/libipt_SNAT.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_SNAT.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,26 @@
+This target is only valid in the
+.B nat
+table, in the
+.B POSTROUTING
+chain.  It specifies that the source address of the packet should be
+modified (and all future packets in this connection will also be
+mangled), and rules should cease being examined.  It takes one type
+of option:
+.TP
+.BR "--to-source  " "\fIipaddr\fP[-\fIipaddr\fP][:\fIport\fP-\fIport\fP]"
+which can specify a single new source IP address, an inclusive range
+of IP addresses, and optionally, a port range (which is only valid if
+the rule also specifies
+.B "-p tcp"
+or
+.BR "-p udp" ).
+If no port range is specified, then source ports below 512 will be
+mapped to other ports below 512: those between 512 and 1023 inclusive
+will be mapped to ports below 1024, and other ports will be mapped to
+1024 or above. Where possible, no port alteration will occur.
+.RS
+.PP
+You can add several --to-source options.  If you specify more
+than one source address, either via an address range or multiple
+--to-source options, a simple round-robin (one after another in
+cycle) takes place between these adresses.
diff -urN iptables-1.2.9/extensions/libipt_TCPMSS.man iptables-1.2.10/extensions/libipt_TCPMSS.man
--- iptables-1.2.9/extensions/libipt_TCPMSS.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_TCPMSS.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,38 @@
+This target allows to alter the MSS value of TCP SYN packets, to control
+the maximum size for that connection (usually limiting it to your
+outgoing interface's MTU minus 40).  Of course, it can only be used
+in conjunction with
+.BR "-p tcp" .
+.br
+This target is used to overcome criminally braindead ISPs or servers
+which block ICMP Fragmentation Needed packets.  The symptoms of this
+problem are that everything works fine from your Linux
+firewall/router, but machines behind it can never exchange large
+packets:
+.PD 0
+.RS 0.1i
+.TP 0.3i
+1)
+Web browsers connect, then hang with no data received.
+.TP
+2)
+Small mail works fine, but large emails hang.
+.TP
+3)
+ssh works fine, but scp hangs after initial handshaking.
+.RE
+.PD
+Workaround: activate this option and add a rule to your firewall
+configuration like:
+.nf
+ iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN \\
+             -j TCPMSS --clamp-mss-to-pmtu
+.fi
+.TP
+.BI "--set-mss " "value"
+Explicitly set MSS option to specified value.
+.TP
+.B "--clamp-mss-to-pmtu"
+Automatically clamp MSS value to (path_MTU - 40).
+.TP
+These options are mutually exclusive.
diff -urN iptables-1.2.9/extensions/libipt_TOS.man iptables-1.2.10/extensions/libipt_TOS.man
--- iptables-1.2.9/extensions/libipt_TOS.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_TOS.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,11 @@
+This is used to set the 8-bit Type of Service field in the IP header.
+It is only valid in the
+.B mangle
+table.
+.TP
+.BI "--set-tos " "tos"
+You can use a numeric TOS values, or use
+.nf
+ iptables -j TOS -h
+.fi
+to see the list of valid TOS names.
diff -urN iptables-1.2.9/extensions/libipt_TRACE.man iptables-1.2.10/extensions/libipt_TRACE.man
--- iptables-1.2.9/extensions/libipt_TRACE.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_TRACE.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,3 @@
+This target has no options.  It just turns on 
+.B packet tracing
+for all packets that match this rule.
diff -urN iptables-1.2.9/extensions/libipt_TTL.man iptables-1.2.10/extensions/libipt_TTL.man
--- iptables-1.2.9/extensions/libipt_TTL.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_TTL.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,19 @@
+This is used to modify the IPv4 TTL header field.  The TTL field determines
+how many hops (routers) a packet can traverse until it's time to live is
+exceeded.
+.TP
+Setting or incrementing the TTL field can potentially be very dangerous,
+so it should be avoided at any cost.  
+.TP
+.B Don't ever set or increment the value on packets that leave your local network!
+.B mangle
+table.
+.TP
+.BI "--ttl-set " "value"
+Set the TTL value to `value'.
+.TP
+.BI "--ttl-dec " "value"
+Decrement the TTL value `value' times.
+.TP
+.BI "--ttl-inc " "value"
+Increment the TTL value `value' times.
diff -urN iptables-1.2.9/extensions/libipt_ULOG.c iptables-1.2.10/extensions/libipt_ULOG.c
--- iptables-1.2.9/extensions/libipt_ULOG.c	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_ULOG.c	2004-06-15 00:02:17.000000000 +0200
@@ -17,10 +17,8 @@
 #include <getopt.h>
 #include <iptables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
-#include <linux/netfilter_ipv4/ipt_ULOG.h>
-
-#define ULOG_DEFAULT_NLGROUP 1
-#define ULOG_DEFAULT_QTHRESHOLD 1
+/* For 64bit kernel / 32bit userspace */
+#include "../include/linux/netfilter_ipv4/ipt_ULOG.h"
 
 
 void print_groups(unsigned int gmask)
@@ -112,7 +110,7 @@
 		if (strlen(optarg) > sizeof(loginfo->prefix) - 1)
 			exit_error(PARAMETER_PROBLEM,
 				   "Maximum prefix length %u for --ulog-prefix",
-				   sizeof(loginfo->prefix) - 1);
+				   (unsigned int)sizeof(loginfo->prefix) - 1);
 
 		strcpy(loginfo->prefix, optarg);
 		*flags |= IPT_LOG_OPT_PREFIX;
@@ -124,7 +122,11 @@
 		if (atoi(optarg) < 0)
 			exit_error(PARAMETER_PROBLEM,
 				   "Negative copy range?");
+#ifdef KERNEL_64_USERSPACE_32
+		loginfo->copy_range = (unsigned long long)atoll(optarg);
+#else
 		loginfo->copy_range = atoi(optarg);
+#endif
 		*flags |= IPT_LOG_OPT_CPRANGE;
 		break;
 	case 'B':
@@ -137,7 +139,11 @@
 		if (atoi(optarg) > ULOG_MAX_QLEN)
 			exit_error(PARAMETER_PROBLEM,
 				   "Maximum queue length exceeded");
+#ifdef KERNEL_64_USERSPACE_32
+		loginfo->qthreshold = (unsigned long long)atoll(optarg);
+#else
 		loginfo->qthreshold = atoi(optarg);
+#endif
 		*flags |= IPT_LOG_OPT_QTHRESHOLD;
 		break;
 	}
@@ -163,11 +169,19 @@
 		printf("--ulog-nlgroup ");
 		print_groups(loginfo->nl_group);
 	}
+#ifdef KERNEL_64_USERSPACE_32
+	if (loginfo->copy_range)
+		printf("--ulog-cprange %llu ", loginfo->copy_range);
+
+	if (loginfo->qthreshold != ULOG_DEFAULT_QTHRESHOLD)
+		printf("--ulog-qthreshold %llu ", loginfo->qthreshold);
+#else
 	if (loginfo->copy_range)
-		printf("--ulog-cprange %d ", loginfo->copy_range);
+		printf("--ulog-cprange %u ", (unsigned int)loginfo->copy_range);
 
 	if (loginfo->qthreshold != ULOG_DEFAULT_QTHRESHOLD)
-		printf("--ulog-qthreshold %d ", loginfo->qthreshold);
+		printf("--ulog-qthreshold %u ", (unsigned int)loginfo->qthreshold);
+#endif
 }
 
 /* Prints out the targinfo. */
@@ -179,11 +193,19 @@
 	    = (const struct ipt_ulog_info *) target->data;
 
 	printf("ULOG ");
-	printf("copy_range %d nlgroup ", loginfo->copy_range);
+#ifdef KERNEL_64_USERSPACE_32
+	printf("copy_range %llu nlgroup ", loginfo->copy_range);
+#else
+	printf("copy_range %u nlgroup ", (unsigned int)loginfo->copy_range);
+#endif
 	print_groups(loginfo->nl_group);
 	if (strcmp(loginfo->prefix, "") != 0)
 		printf("prefix `%s' ", loginfo->prefix);
-	printf("queue_threshold %d ", loginfo->qthreshold);
+#ifdef KERNEL_64_USERSPACE_32
+	printf("queue_threshold %llu ", loginfo->qthreshold);
+#else
+	printf("queue_threshold %u ", (unsigned int)loginfo->qthreshold);
+#endif
 }
 
 static
diff -urN iptables-1.2.9/extensions/libipt_ULOG.man iptables-1.2.10/extensions/libipt_ULOG.man
--- iptables-1.2.9/extensions/libipt_ULOG.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_ULOG.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,27 @@
+This target provides userspace logging of matching packets.  When this
+target is set for a rule, the Linux kernel will multicast this packet
+through a
+.IR netlink 
+socket. One or more userspace processes may then subscribe to various 
+multicast groups and receive the packets.
+Like LOG, this is a "non-terminating target", i.e. rule traversal
+continues at the next rule.
+.TP
+.BI "--ulog-nlgroup " "nlgroup"
+This specifies the netlink group (1-32) to which the packet is sent.
+Default value is 1.
+.TP
+.BI "--ulog-prefix " "prefix"
+Prefix log messages with the specified prefix; up to 32 characters
+long, and useful for distinguishing messages in the logs.
+.TP
+.BI "--ulog-cprange " "size"
+Number of bytes to be copied to userspace.  A value of 0 always copies
+the entire packet, regardless of its size.  Default is 0.
+.TP
+.BI "--ulog-qthreshold " "size"
+Number of packet to queue inside kernel.  Setting this value to, e.g. 10
+accumulates ten packets inside the kernel and transmits them as one
+netlink multipart message to userspace.  Default is 1 (for backwards
+compatibility).
+.br
diff -urN iptables-1.2.9/extensions/libipt_XOR.c iptables-1.2.10/extensions/libipt_XOR.c
--- iptables-1.2.9/extensions/libipt_XOR.c	2003-05-31 19:11:49.000000000 +0200
+++ iptables-1.2.10/extensions/libipt_XOR.c	2004-02-19 19:04:17.000000000 +0100
@@ -47,6 +47,7 @@
 	switch (c) {	
 		case '1':
 			strncpy(info->key, optarg, 30);
+			info->key[29] = '\0';
 			*flags |= IPT_KEY_SET;
 			break;
 		case '2':
diff -urN iptables-1.2.9/extensions/libipt_account.c iptables-1.2.10/extensions/libipt_account.c
--- iptables-1.2.9/extensions/libipt_account.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_account.c	2004-03-17 15:27:08.000000000 +0100
@@ -0,0 +1,244 @@
+/* 
+ * accounting match helper (libipt_account.c)
+ * (C) 2003,2004 by Piotr Gasido (quaker@barbara.eu.org)
+ *
+ * Version: 0.1.5
+ *
+ * This software is distributed under the terms of GNU GPL
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <iptables.h>
+#include <string.h>
+#include <getopt.h>
+
+#include <linux/netfilter_ipv4/ipt_account.h>
+
+#ifndef HIPQUAD
+#define HIPQUAD(addr) \
+	((unsigned char *)&addr)[3], \
+	((unsigned char *)&addr)[2], \
+	((unsigned char *)&addr)[1], \
+	((unsigned char *)&addr)[0]
+#endif
+				
+static void help(void) {
+	printf(
+			"account v%s options:\n"
+			"--aaddr network/netmask\n"
+			"	defines network/netmask for which make statistics.\n"
+			"--aname name\n"
+			"	defines name of list where statistics will be kept. If no is\n"
+			"	specified DEFAULT will be used.\n"
+
+	, 
+	IPTABLES_VERSION);
+};
+
+static struct option opts[] = {
+	{ "aaddr", 1, NULL, 201 },
+	{ "aname", 1, NULL, 202 },
+	{ 0 }
+};
+
+/* Helper functions for parse_network */
+int parseip(const char *parameter, u_int32_t *ip) {
+	
+	char buffer[16], *bufferptr, *dot;
+	unsigned int i, shift, part;
+
+	if (strlen(parameter) > 15)
+		return 0;
+
+	strncpy(buffer, parameter, 15);
+	buffer[15] = 0;
+
+	bufferptr = buffer;
+
+	for (i = 0, shift = 24, *ip = 0; i < 3; i++, shift -= 8) {
+		/* no dot */
+		if ((dot = strchr(bufferptr, '.')) == NULL)
+			return 0;
+		/* not a number */
+		if ((part = strtol(bufferptr, (char**)NULL, 10)) < 0) 
+			return 0;	
+		/* to big number */
+		if (part > 255)
+			return 0;
+		*ip |= part << shift;		
+		bufferptr = dot + 1;
+	}
+	/* not a number */
+	if ((part = strtol(bufferptr, (char**)NULL, 10)) < 0) 
+		return 0;
+	/* to big number */
+	if (part > 255)
+		return 0;
+	*ip |= part;
+	return 1;
+}
+
+static void parsenetwork(const char *parameter, u_int32_t *network) {
+	if (!parseip(parameter, network))
+		exit_error(PARAMETER_PROBLEM, "account: wrong ip in network");
+}
+
+static void parsenetmaskasbits(const char *parameter, u_int32_t *netmask) {
+	
+	u_int32_t bits;
+	
+	if ((bits = strtol(parameter, (char **)NULL, 10)) < 0 || bits > 32)
+		exit_error(PARAMETER_PROBLEM, "account: wrong netmask");
+
+	*netmask = 0xffffffff << (32 - bits);
+}
+
+static void parsenetmaskasip(const char *parameter, u_int32_t *netmask) {
+	if (!parseip(parameter, netmask))
+		exit_error(PARAMETER_PROBLEM, "account: wrong ip in netmask");
+}
+
+static void parsenetmask(const char *parameter, u_int32_t *netmask) 
+{
+	if (strchr(parameter, '.') != NULL)
+		parsenetmaskasip(parameter, netmask);
+	else
+		parsenetmaskasbits(parameter, netmask);
+}
+
+static void parsenetworkandnetmask(const char *parameter, u_int32_t *network, u_int32_t *netmask) 
+{
+	
+	char buffer[32], *slash;
+
+	if (strlen(parameter) > 31)
+		/* text is to long, even for 255.255.255.255/255.255.255.255 */
+		exit_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+
+	strncpy(buffer, parameter, 31);
+	buffer[31] = 0;
+
+	/* check whether netmask is given */
+	if ((slash = strchr(buffer, '/')) != NULL) {
+		parsenetmask(slash + 1, netmask);
+		*slash = 0;
+	} else
+		*netmask = 0xffffffff;
+	parsenetwork(buffer, network);
+
+	if ((*network & *netmask) != *network)
+		exit_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+}
+
+
+/* Function gets network & netmask from argument after --aaddr */
+static void parse_network(const char *parameter, struct t_ipt_account_info *info) {
+
+	parsenetworkandnetmask(parameter, &info->network, &info->netmask);
+	
+}
+
+/* Function initializes match */
+static void init(struct ipt_entry_match *match, 
+		 unsigned int *nfcache) {
+	
+	struct t_ipt_account_info *info = (struct t_ipt_account_info *)(match)->data;
+
+	*nfcache |= NFC_UNKNOWN;
+
+	/* set default table name to DEFAULT */
+	strncpy(info->name, "DEFAULT", IPT_ACCOUNT_NAME_LEN);
+	
+}
+
+/* Function parses match's arguments */
+static int parse(int c, char **argv, 
+		  int invert, 
+		  unsigned int *flags,
+                  const struct ipt_entry *entry,
+                  unsigned int *nfcache,
+                  struct ipt_entry_match **match) {
+	
+	struct t_ipt_account_info *info = (struct t_ipt_account_info *)(*match)->data;
+
+	switch (c) {
+		
+		/* --aaddr */
+		case 201:
+			parse_network(optarg, info);			
+			*flags = 1;
+			break;
+			
+		/* --aname */
+		case 202:
+			if (strlen(optarg) < IPT_ACCOUNT_NAME_LEN)
+				strncpy(info->name, optarg, IPT_ACCOUNT_NAME_LEN);
+			else
+				exit_error(PARAMETER_PROBLEM, "account: Too long list name");			
+			break;	
+		default:
+			return 0;			
+	}
+	return 1;	
+}
+
+/* Final check whether network/netmask was specified */
+static void final_check(unsigned int flags) {
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM, "account: You need specify '--aaddr' parameter");
+}
+
+/* Function used for printing rule with account match for iptables -L */
+static void print(const struct ipt_ip *ip,
+                  const struct ipt_entry_match *match, 
+		  int numeric) {
+	
+	struct t_ipt_account_info *info = (struct t_ipt_account_info *)match->data;
+	
+	printf("account: ");
+	printf("network/netmask: ");
+	printf("%u.%u.%u.%u/%u.%u.%u.%u ",
+			HIPQUAD(info->network),
+			HIPQUAD(info->netmask)
+	      );
+	
+	printf("name: %s ", info->name);
+}
+
+/* Function used for saving rule containing account match */
+static void save(const struct ipt_ip *ip, 
+		 const struct ipt_entry_match *match) {
+
+	struct t_ipt_account_info *info = (struct t_ipt_account_info *)match->data;
+	
+	printf("--aaddr ");
+	printf("%u.%u.%u.%u/%u.%u.%u.%u ",
+			 HIPQUAD(info->network),
+			 HIPQUAD(info->netmask)
+	       );
+	
+	printf("--aname %s ", info->name);
+}
+	
+static struct iptables_match account = {
+	NULL,			/* struct iptables_match *next; */
+	"account",		/* ipt_chainlabel name; */
+	IPTABLES_VERSION,	/* const char *version; */
+	IPT_ALIGN(sizeof(struct t_ipt_account_info)),		/* Size of match data. */
+	IPT_ALIGN(sizeof(struct t_ipt_account_info)),		/* Size of match data relevent for userspace comparison purposes */
+	&help,			/* Function which prints out usage message. */
+	&init,			/* Initialize the match. */
+	&parse,			/* Function which parses command options; returns true if it ate an option */
+	&final_check,		/* Final check; exit if not ok. */
+	&print,			/* Prints out the match iff non-NULL: put space at end */
+	&save,			/* Saves the match info in parsable form to stdout. */
+	opts			/* Pointer to list of extra command-line options */
+};
+
+/* Function which registers match */
+void _init(void)
+{
+	register_match(&account);
+}
+	
diff -urN iptables-1.2.9/extensions/libipt_addrtype.man iptables-1.2.10/extensions/libipt_addrtype.man
--- iptables-1.2.9/extensions/libipt_addrtype.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_addrtype.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,37 @@
+This module matches packets based on their 
+.B address type.
+Address types are used within the kernel networking stack and categorize
+addresses into various groups.  The exact definition of that group depends on the specific layer three protocol.
+.TP
+The following address types are possible:
+.TP
+.BI "UNSPEC"
+an unspecified address (i.e. 0.0.0.0)
+.BI "UNICAST"
+an unicast address
+.BI "LOCAL"
+a local address
+.BI "BROADCAST"
+a broadcast address
+.BI "ANYCAST"
+an anycast packet
+.BI "MULTICAST"
+a multicast address
+.BI "BLACKHOLE"
+a blackhole address
+.BI "UNREACHABLE"
+an unreachable address
+.BI "PROHIBIT"
+a prohibited address
+.BI "THROW"
+FIXME
+.BI "NAT"
+FIXME
+.BI "XRESOLVE"
+FIXME
+.TP
+.BI "--src-type " "type"
+Matches if the source address is of given type
+.TP
+.BI "--dst-type " "type"
+Matches if the destination address is of given type
diff -urN iptables-1.2.9/extensions/libipt_ah.man iptables-1.2.10/extensions/libipt_ah.man
--- iptables-1.2.9/extensions/libipt_ah.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_ah.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,3 @@
+This module matches the SPIs in AH header of IPSec packets.
+.TP
+.BR "--ahspi " "[!] \fIspi\fP[:\fIspi\fP]"
diff -urN iptables-1.2.9/extensions/libipt_childlevel.c iptables-1.2.10/extensions/libipt_childlevel.c
--- iptables-1.2.9/extensions/libipt_childlevel.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_childlevel.c	2004-02-17 21:56:40.000000000 +0100
@@ -0,0 +1,122 @@
+/* 
+   Shared library add-on to iptables to add layer 7 matching support. 
+
+   http://l7-filter.sf.net
+  
+   By Matthew Strait <quadong@users.sf.net>, Dec 2003.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version
+   2 of the License, or (at your option) any later version.
+   http://www.gnu.org/licenses/gpl.txt
+*/
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <dirent.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_childlevel.h>
+
+/* Function which prints out usage message. */
+static void help(void)
+{
+	printf(
+	"CHILDLEVEL match v%s options:\n"
+	"--level <n>  : Match childlevel n (0 == master)\n",
+	IPTABLES_VERSION);
+	fputc('\n', stdout);
+}
+
+static struct option opts[] = {
+	{ .name = "level", .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = 0 }
+};
+
+/* Initialize the match. */
+static void init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Function which parses command options; returns true if it ate an option */
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry, unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_childlevel_info *childlevelinfo = 
+		(struct ipt_childlevel_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		check_inverse(optarg, &invert, &optind, 0);
+		childlevelinfo->childlevel = atoi(argv[optind-1]);
+		if (invert)
+			childlevelinfo->invert = 1;
+		*flags = 1;
+		break;
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; must have specified --level. */
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+			   "CHILDLEVEL match: You must specify `--level'");
+}
+
+static void print_protocol(int n, int invert, int numeric)
+{
+	fputs("childlevel ", stdout);
+	if (invert) fputc('!', stdout);
+	printf("%d ", n);
+}
+
+/* Prints out the matchinfo. */
+static void print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	printf("CHILDLEVEL ");
+
+	print_protocol(((struct ipt_childlevel_info *)match->data)->childlevel,
+		  ((struct ipt_childlevel_info *)match->data)->invert, numeric);
+}
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+        const struct ipt_childlevel_info *info =
+            (const struct ipt_childlevel_info*) match->data;
+
+        printf("--childlevel %s%d ", (info->invert) ? "! ": "", info->childlevel);
+}
+
+static struct iptables_match childlevel = { 
+	.name		= "childlevel",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_childlevel_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_childlevel_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&childlevel);
+}
diff -urN iptables-1.2.9/extensions/libipt_childlevel.man iptables-1.2.10/extensions/libipt_childlevel.man
--- iptables-1.2.9/extensions/libipt_childlevel.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_childlevel.man	2004-02-17 21:56:40.000000000 +0100
@@ -0,0 +1,5 @@
+This is an experimental module.  It matches on whether the 
+packet is part of a master connection or one of its children (or grandchildren,
+etc).  For instance, most packets are level 0.  FTP data transfer is level 1.
+.TP
+.BR "--childlevel " "[!] \fIlevel\fP"
diff -urN iptables-1.2.9/extensions/libipt_condition.man iptables-1.2.10/extensions/libipt_condition.man
--- iptables-1.2.9/extensions/libipt_condition.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_condition.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,4 @@
+This matches if a specific /proc filename is '0' or '1'.
+.TP
+.BI "--condition " "[!] filename"
+Match on boolean value stored in /proc/net/ipt_condition/filename file
diff -urN iptables-1.2.9/extensions/libipt_connbytes.c iptables-1.2.10/extensions/libipt_connbytes.c
--- iptables-1.2.9/extensions/libipt_connbytes.c	2003-06-19 14:23:37.000000000 +0200
+++ iptables-1.2.10/extensions/libipt_connbytes.c	2004-05-16 10:48:03.000000000 +0200
@@ -37,10 +37,10 @@
 {
 	char *colon,*p;
 
-	si->from = strtol(arg,&colon,10);
+	si->from = strtoul(arg,&colon,10);
 	if (*colon != ':') 
 		exit_error(PARAMETER_PROBLEM, "Bad range `%s'", arg);
-	si->to = strtol(colon+1,&p,10);
+	si->to = strtoul(colon+1,&p,10);
 	if (p == colon+1) {
 		/* second number omited */
 		si->to = 0xffffffff;
@@ -58,7 +58,7 @@
       struct ipt_entry_match **match)
 {
 	struct ipt_connbytes_info *sinfo = (struct ipt_connbytes_info *)(*match)->data;
-	int i;
+	unsigned long i;
 
 	switch (c) {
 	case '1':
diff -urN iptables-1.2.9/extensions/libipt_connlimit.c iptables-1.2.10/extensions/libipt_connlimit.c
--- iptables-1.2.9/extensions/libipt_connlimit.c	2003-04-30 18:54:48.000000000 +0200
+++ iptables-1.2.10/extensions/libipt_connlimit.c	2004-02-19 19:04:17.000000000 +0100
@@ -43,6 +43,7 @@
       struct ipt_entry_match **match)
 {
 	struct ipt_connlimit_info *info = (struct ipt_connlimit_info*)(*match)->data;
+	int i;
 
 	if (0 == (*flags & 2)) {
 		/* set default mask unless we've already seen a mask option */
@@ -58,7 +59,15 @@
 		break;
 
 	case '2':
-		info->mask = htonl(0xFFFFFFFF << (32 - atoi(argv[optind-1])));
+		i = atoi(argv[optind-1]);
+		if ((i < 0) || (i > 32))
+			exit_error(PARAMETER_PROBLEM,
+				"--connlimit-mask must be between 0 and 32");
+
+		if (i == 0)
+			info->mask = 0;
+		else
+			info->mask = htonl(0xFFFFFFFF << (32 - i));
 		*flags |= 2;
 		break;
 
diff -urN iptables-1.2.9/extensions/libipt_connmark.c iptables-1.2.10/extensions/libipt_connmark.c
--- iptables-1.2.9/extensions/libipt_connmark.c	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_connmark.c	2004-02-19 19:04:17.000000000 +0100
@@ -1,4 +1,24 @@
-/* Shared library add-on to iptables to add CONNMARK matching support. */
+/* Shared library add-on to iptables to add connmark matching support.
+ *
+ * (C) 2002,2004 MARA Systems AB <http://www.marasystems.com>
+ * by Henrik Nordstrom <hno@marasystems.com>
+ *
+ * Version 1.1
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
 #include <stdio.h>
 #include <netdb.h>
 #include <string.h>
@@ -50,7 +70,7 @@
 		if (*end == '/') {
 			markinfo->mask = strtoul(end+1, &end, 0);
 		} else
-			markinfo->mask = 0xffffffff;
+			markinfo->mask = ~0;
 		if (*end != '\0' || end == optarg)
 			exit_error(PARAMETER_PROBLEM, "Bad MARK value `%s'", optarg);
 		if (invert)
@@ -67,7 +87,7 @@
 static void
 print_mark(unsigned long mark, unsigned long mask, int numeric)
 {
-	if(mask != 0xffffffff)
+	if(mask != ~0)
 		printf("0x%lx/0x%lx ", mark, mask);
 	else
 		printf("0x%lx ", mark);
@@ -96,7 +116,7 @@
 	print_mark(info->mark, info->mask, numeric);
 }
 
-/* Saves the union ipt_matchinfo in parsable form to stdout. */
+/* Saves the matchinfo in parsable form to stdout. */
 static void
 save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
 {
@@ -109,23 +129,21 @@
 	print_mark(info->mark, info->mask, 0);
 }
 
-static
-struct iptables_match mark
-= { NULL,
-    "connmark",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_connmark_info)),
-    IPT_ALIGN(sizeof(struct ipt_connmark_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
+static struct iptables_match connmark_match = {
+    .name          = "connmark",
+    .version       = IPTABLES_VERSION,
+    .size          = IPT_ALIGN(sizeof(struct ipt_connmark_info)),
+    .userspacesize = IPT_ALIGN(sizeof(struct ipt_connmark_info)),
+    .help          = &help,
+    .init          = &init,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
 };
 
 void _init(void)
 {
-	register_match(&mark);
+	register_match(&connmark_match);
 }
diff -urN iptables-1.2.9/extensions/libipt_connmark.man iptables-1.2.10/extensions/libipt_connmark.man
--- iptables-1.2.9/extensions/libipt_connmark.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_connmark.man	2004-02-03 09:19:04.000000000 +0100
@@ -0,0 +1,9 @@
+This module matches the netfilter mark field associated with a connection
+(which can be set using the
+.B CONNMARK
+target below).
+.TP
+.BI "--mark " "value[/mask]"
+Matches packets in connections with the given mark value (if a mask is
+specified, this is logically ANDed with the mark before the
+comparison).
diff -urN iptables-1.2.9/extensions/libipt_connrate.c iptables-1.2.10/extensions/libipt_connrate.c
--- iptables-1.2.9/extensions/libipt_connrate.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_connrate.c	2004-04-18 19:33:26.000000000 +0200
@@ -0,0 +1,189 @@
+/* Shared library add-on to iptables to add connection rate tracking
+ * support.
+ *
+ * Copyright (c) 2004 Nuutti Kotivuori <naked@iki.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ **/
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ipt_connrate.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"connrate v%s options:\n"
+" --connrate [!] [from]:[to]\n"
+"				Match connection transfer rate in bytes\n"
+"				per second. `inf' can be used for maximum\n"
+"				expressible value.\n"
+"\n", IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "connrate", 1, 0, '1' },
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	/* caching not yet implemented */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static u_int32_t
+parse_value(const char *arg, u_int32_t def)
+{
+	char *end;
+	size_t len;
+	u_int32_t value;
+
+	len = strlen(arg);
+	if(len == 0)
+		return def;
+	if(strcmp(arg, "inf") == 0)
+		return 0xFFFFFFFF;
+	value = strtoul(arg, &end, 0);
+	if(*end != '\0')
+		exit_error(PARAMETER_PROBLEM,
+			   "Bad value in range `%s'", arg);
+	return value;
+}
+
+static void
+parse_range(const char *arg, struct ipt_connrate_info *si)
+{
+	char *buffer;
+	char *colon;
+
+	buffer = strdup(arg);
+	if ((colon = strchr(buffer, ':')) == NULL)
+		exit_error(PARAMETER_PROBLEM, "Bad range `%s'", arg);
+	*colon = '\0';
+	si->from = parse_value(buffer, 0);
+	si->to = parse_value(colon+1, 0xFFFFFFFF);
+	if (si->from > si->to)
+		exit_error(PARAMETER_PROBLEM, "%u should be less than %u", si->from,si->to);
+	free(buffer);
+}
+
+#define CONNRATE_OPT 0x01
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_connrate_info *sinfo = (struct ipt_connrate_info *)(*match)->data;
+	u_int32_t tmp;
+
+	switch (c) {
+	case '1':
+		if (*flags & CONNRATE_OPT)
+			exit_error(PARAMETER_PROBLEM,
+				   "Only one `--connrate' allowed");
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_range(argv[optind-1], sinfo);
+		if (invert) {
+			tmp = sinfo->from;
+			sinfo->from = sinfo->to;
+			sinfo->to = tmp;
+		}
+		*flags |= CONNRATE_OPT;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	if (!(flags & CONNRATE_OPT))
+		exit_error(PARAMETER_PROBLEM,
+			   "connrate match: You must specify `--connrate'");
+}
+
+static void
+print_value(u_int32_t value)
+{
+	if(value == 0xFFFFFFFF)
+		printf("inf");
+	else
+		printf("%u", value);
+}
+
+static void
+print_range(struct ipt_connrate_info *sinfo)
+{
+	if (sinfo->from > sinfo->to) {
+		printf("! ");
+		print_value(sinfo->to);
+		printf(":");
+		print_value(sinfo->from);
+	} else {
+		print_value(sinfo->from);
+		printf(":");
+		print_value(sinfo->to);
+	}
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_connrate_info *sinfo = (struct ipt_connrate_info *)match->data;
+
+	printf("connrate ");
+	print_range(sinfo);
+	printf(" ");
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_connrate_info *sinfo = (struct ipt_connrate_info *)match->data;
+
+	printf("--connrate ");
+	print_range(sinfo);
+	printf(" ");
+}
+
+static
+struct iptables_match state
+= { NULL,
+    "connrate",
+    IPTABLES_VERSION,
+    IPT_ALIGN(sizeof(struct ipt_connrate_info)),
+    IPT_ALIGN(sizeof(struct ipt_connrate_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_match(&state);
+}
diff -urN iptables-1.2.9/extensions/libipt_connrate.man iptables-1.2.10/extensions/libipt_connrate.man
--- iptables-1.2.9/extensions/libipt_connrate.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_connrate.man	2004-04-18 19:33:26.000000000 +0200
@@ -0,0 +1,6 @@
+This module matches the current transfer rate in a connection.
+.TP
+.BI "--connrate " "[!] [\fIfrom\fP]:[\fIto\fP]"
+Match against the current connection transfer rate being within 'from'
+and 'to' bytes per second. When the "!" argument is used before the
+range, the sense of the match is inverted.
diff -urN iptables-1.2.9/extensions/libipt_conntrack.c iptables-1.2.10/extensions/libipt_conntrack.c
--- iptables-1.2.9/extensions/libipt_conntrack.c	2003-10-07 20:54:30.000000000 +0200
+++ iptables-1.2.10/extensions/libipt_conntrack.c	2004-06-15 00:02:17.000000000 +0200
@@ -11,7 +11,8 @@
 #include <iptables.h>
 #include <linux/netfilter_ipv4/ip_conntrack.h>
 #include <linux/netfilter_ipv4/ip_conntrack_tuple.h>
-#include <linux/netfilter_ipv4/ipt_conntrack.h>
+/* For 64bit kernel / 32bit userspace */
+#include "../include/linux/netfilter_ipv4/ipt_conntrack.h"
 
 #ifndef IPT_CONNTRACK_STATE_UNTRACKED
 #define IPT_CONNTRACK_STATE_UNTRACKED (1 << (IP_CT_NUMBER + 3))
@@ -135,17 +136,29 @@
 		exit_error(PARAMETER_PROBLEM, "Bad ctstatus `%s'", arg);
 }
 
-
+#ifdef KERNEL_64_USERSPACE_32
+static unsigned long long
+parse_expire(const char *s)
+{
+	unsigned long long len;
+	
+	if (string_to_number_ll(s, 0, 0, &len) == -1)
+		exit_error(PARAMETER_PROBLEM, "expire value invalid: `%s'\n", s);
+	else
+		return len;
+}
+#else
 static unsigned long
 parse_expire(const char *s)
 {
 	unsigned int len;
 	
-	if (string_to_number(s, 0, 0xFFFFFFFF, &len) == -1)
+	if (string_to_number(s, 0, 0, &len) == -1)
 		exit_error(PARAMETER_PROBLEM, "expire value invalid: `%s'\n", s);
 	else
 		return len;
 }
+#endif
 
 /* If a single value is provided, min and max are both set to the value */
 static void
@@ -162,15 +175,19 @@
 		cp++;
 
 		sinfo->expires_min = buffer[0] ? parse_expire(buffer) : 0;
-		sinfo->expires_max = cp[0] ? parse_expire(cp) : 0xFFFFFFFF;
+		sinfo->expires_max = cp[0] ? parse_expire(cp) : -1;
 	}
 	free(buffer);
 	
 	if (sinfo->expires_min > sinfo->expires_max)
 		exit_error(PARAMETER_PROBLEM,
+#ifdef KERNEL_64_USERSPACE_32
+		           "expire min. range value `%llu' greater than max. "
+		           "range value `%llu'", sinfo->expires_min, sinfo->expires_max);
+#else
 		           "expire min. range value `%lu' greater than max. "
 		           "range value `%lu'", sinfo->expires_min, sinfo->expires_max);
-	
+#endif
 }
 
 /* Function which parses command options; returns true if it
@@ -485,10 +502,17 @@
         	if (sinfo->invflags & IPT_CONNTRACK_EXPIRES)
                 	printf("! ");
 
+#ifdef KERNEL_64_USERSPACE_32
+        	if (sinfo->expires_max == sinfo->expires_min)
+                	printf("%llu ", sinfo->expires_min);
+        	else
+                	printf("%llu:%llu ", sinfo->expires_min, sinfo->expires_max);
+#else
         	if (sinfo->expires_max == sinfo->expires_min)
                 	printf("%lu ", sinfo->expires_min);
         	else
                 	printf("%lu:%lu ", sinfo->expires_min, sinfo->expires_max);
+#endif
 	}
 }
 
@@ -504,7 +528,7 @@
 /* Saves the matchinfo in parsable form to stdout. */
 static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
 {
-	matchinfo_print(ip, match, 0, "--");
+	matchinfo_print(ip, match, 1, "--");
 }
 
 static
diff -urN iptables-1.2.9/extensions/libipt_conntrack.man iptables-1.2.10/extensions/libipt_conntrack.man
--- iptables-1.2.9/extensions/libipt_conntrack.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_conntrack.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,49 @@
+This module, when combined with connection tracking, allows access to
+more connection tracking information than the "state" match.
+(this module is present only if iptables was compiled under a kernel
+supporting this feature)
+.TP
+.BI "--ctstate " "state"
+Where state is a comma separated list of the connection states to
+match.  Possible states are
+.B INVALID
+meaning that the packet is associated with no known connection,
+.B ESTABLISHED
+meaning that the packet is associated with a connection which has seen
+packets in both directions,
+.B NEW
+meaning that the packet has started a new connection, or otherwise
+associated with a connection which has not seen packets in both
+directions, and
+.B RELATED
+meaning that the packet is starting a new connection, but is
+associated with an existing connection, such as an FTP data transfer,
+or an ICMP error.
+.B SNAT
+A virtual state, matching if the original source address differs from
+the reply destination.
+.B DNAT
+A virtual state, matching if the original destination differs from the
+reply source.
+.TP
+.BI "--ctproto " "proto"
+Protocol to match (by number or name)
+.TP
+.BI "--ctorigsrc " "[!] \fIaddress\fP[/\fImask\fP]"
+Match against original source address
+.TP
+.BI "--ctorigdst " "[!] \fIaddress\fP[/\fImask\fP]"
+Match against original destination address
+.TP
+.BI "--ctreplsrc " "[!] \fIaddress\fP[/\fImask\fP]"
+Match against reply source address
+.TP
+.BI "--ctrepldst " "[!] \fIaddress\fB[/\fImask\fP]"
+Match against reply destination address
+.TP
+.BI "--ctstatus " "[\fINONE|EXPECTED|SEEN_REPLY|ASSURED\fP][,...]"
+Match against internal conntrack states
+.TP
+.BI "--ctexpire " "\fItime\fP[\fI:time\fP]"
+Match remaining lifetime in seconds against given value
+or range of values (inclusive)
diff -urN iptables-1.2.9/extensions/libipt_dscp.man iptables-1.2.10/extensions/libipt_dscp.man
--- iptables-1.2.9/extensions/libipt_dscp.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_dscp.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,10 @@
+This module matches the 6 bit DSCP field within the TOS field in the
+IP header.  DSCP has superseded TOS within the IETF.
+.TP
+.BI "--dscp " "value"
+Match against a numeric (decimal or hex) value [0-32].
+.TP
+.BI "--dscp-class " "\fIDiffServ Class\fP"
+Match the DiffServ class. This value may be any of the
+BE, EF, AFxx or CSx classes.  It will then be converted
+into it's according numeric value.
diff -urN iptables-1.2.9/extensions/libipt_dstlimit.c iptables-1.2.10/extensions/libipt_dstlimit.c
--- iptables-1.2.9/extensions/libipt_dstlimit.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_dstlimit.c	2004-02-23 12:10:55.000000000 +0100
@@ -0,0 +1,357 @@
+/* iptables match extension for limiting packets per destination
+ *
+ * (C) 2003 by Harald Welte <laforge@netfilter.org>
+ *
+ * Development of this code was funded by Astaro AG, http://www.astaro.com/
+ *
+ * Based on ipt_limit.c by
+ * Jrme de Vivie   <devivie@info.enserb.u-bordeaux.fr>
+ * Herv Eychenne    <rv@wallfire.org>
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <stddef.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_dstlimit.h>
+
+#define IPT_DSTLIMIT_BURST	5
+
+/* miliseconds */
+#define IPT_DSTLIMIT_GCINTERVAL	1000
+#define IPT_DSTLIMIT_EXPIRE	10000
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"dstlimit v%s options:\n"
+"--dstlimit <avg>		max average match rate\n"
+"                                [Packets per second unless followed by \n"
+"                                /sec /minute /hour /day postfixes]\n"
+"--dstlimit-mode <mode>		mode\n"
+"					dstip\n"
+"					dstip-dstport\n"
+"					srcip-dstip\n"
+"					srcip-dstip-dstport\n"
+"--dstlimit-name <name>		name for /proc/net/ipt_dstlimit/\n"
+"[--dstlimit-burst <num>]	number to match in a burst, default %u\n"
+"[--dstlimit-htable-size <num>]	number of hashtable buckets\n"
+"[--dstlimit-htable-max <num>]	number of hashtable entries\n"
+"[--dstlimit-htable-gcinterval]	interval between garbage collection runs\n"
+"[--dstlimit-htable-expire]	after which time are idle entries expired?\n"
+"\n", IPTABLES_VERSION, IPT_DSTLIMIT_BURST);
+}
+
+static struct option opts[] = {
+	{ "dstlimit", 1, 0, '%' },
+	{ "dstlimit-burst", 1, 0, '$' },
+	{ "dstlimit-htable-size", 1, 0, '&' },
+	{ "dstlimit-htable-max", 1, 0, '*' },
+	{ "dstlimit-htable-gcinterval", 1, 0, '(' },
+	{ "dstlimit-htable-expire", 1, 0, ')' },
+	{ "dstlimit-mode", 1, 0, '_' },
+	{ "dstlimit-name", 1, 0, '"' },
+	{ 0 }
+};
+
+static
+int parse_rate(const char *rate, u_int32_t *val)
+{
+	const char *delim;
+	u_int32_t r;
+	u_int32_t mult = 1;  /* Seconds by default. */
+
+	delim = strchr(rate, '/');
+	if (delim) {
+		if (strlen(delim+1) == 0)
+			return 0;
+
+		if (strncasecmp(delim+1, "second", strlen(delim+1)) == 0)
+			mult = 1;
+		else if (strncasecmp(delim+1, "minute", strlen(delim+1)) == 0)
+			mult = 60;
+		else if (strncasecmp(delim+1, "hour", strlen(delim+1)) == 0)
+			mult = 60*60;
+		else if (strncasecmp(delim+1, "day", strlen(delim+1)) == 0)
+			mult = 24*60*60;
+		else
+			return 0;
+	}
+	r = atoi(rate);
+	if (!r)
+		return 0;
+
+	/* This would get mapped to infinite (1/day is minimum they
+           can specify, so we're ok at that end). */
+	if (r / mult > IPT_DSTLIMIT_SCALE)
+		exit_error(PARAMETER_PROBLEM, "Rate too fast `%s'\n", rate);
+
+	*val = IPT_DSTLIMIT_SCALE * mult / r;
+	return 1;
+}
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_dstlimit_info *r = (struct ipt_dstlimit_info *)m->data;
+
+	r->cfg.burst = IPT_DSTLIMIT_BURST;
+	r->cfg.gc_interval = IPT_DSTLIMIT_GCINTERVAL;
+	r->cfg.expire = IPT_DSTLIMIT_EXPIRE;
+
+	/* Can't cache this */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+#define PARAM_LIMIT		0x00000001
+#define PARAM_BURST		0x00000002
+#define PARAM_MODE		0x00000004
+#define PARAM_NAME		0x00000008
+#define PARAM_SIZE		0x00000010
+#define PARAM_MAX		0x00000020
+#define PARAM_GCINTERVAL	0x00000040
+#define PARAM_EXPIRE		0x00000080
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_dstlimit_info *r = 
+			(struct ipt_dstlimit_info *)(*match)->data;
+	unsigned int num;
+
+	switch(c) {
+	case '%':
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --dstlimit");
+		if (!parse_rate(optarg, &r->cfg.avg))
+			exit_error(PARAMETER_PROBLEM,
+				   "bad rate `%s'", optarg);
+		*flags |= PARAM_LIMIT;
+		break;
+
+	case '$':
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --dstlimit-burst");
+
+		if (string_to_number(optarg, 0, 10000, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				   "bad --dstlimit-burst `%s'", optarg);
+		r->cfg.burst = num;
+		*flags |= PARAM_BURST;
+		break;
+	case '&':
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				"Unexpected `!' after --dstlimit-htable-size");
+
+		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				"bad --dstlimit-htable-size: `%s'", optarg);
+		r->cfg.size = num;
+		*flags |= PARAM_SIZE;
+		break;
+	case '*':
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				"Unexpected `!' after --dstlimit-htable-max");
+		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				"bad --dstlimit-htable-max: `%s'", optarg);
+		r->cfg.max = num;
+		*flags |= PARAM_MAX;
+		break;
+	case '(':
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM, "Unexpected `!' after "
+					"--dstlimit-htable-gcinterval");
+		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				"bad --dstlimit-htable-gcinterval: `%s'", 
+				optarg);
+		/* FIXME: not HZ dependent!! */
+		r->cfg.gc_interval = num;
+		*flags |= PARAM_GCINTERVAL;
+		break;
+	case ')':
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM, "Unexpected `!' after " 
+					"--dstlimit-htable-expire");
+		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				"bad --dstlimit-htable-expire: `%s'", optarg);
+		/* FIXME: not HZ dependent */
+		r->cfg.expire = num;
+		*flags |= PARAM_EXPIRE;
+		break;
+	case '_':
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM, "Unexpected `!' after "
+					"--dstlimit-mode");
+		if (!strcmp(optarg, "dstip"))
+			r->cfg.mode = IPT_DSTLIMIT_HASH_DIP;
+		else if (!strcmp(optarg, "dstip-destport") ||
+			 !strcmp(optarg, "dstip-dstport"))
+			r->cfg.mode = IPT_DSTLIMIT_HASH_DIP|IPT_DSTLIMIT_HASH_DPT;
+		else if (!strcmp(optarg, "srcip-dstip"))
+			r->cfg.mode = IPT_DSTLIMIT_HASH_SIP|IPT_DSTLIMIT_HASH_DIP;
+		else if (!strcmp(optarg, "srcip-dstip-destport") ||
+			 !strcmp(optarg, "srcip-dstip-dstport"))
+			r->cfg.mode = IPT_DSTLIMIT_HASH_SIP|IPT_DSTLIMIT_HASH_DIP|IPT_DSTLIMIT_HASH_DPT;
+		else
+			exit_error(PARAMETER_PROBLEM, 
+				"bad --dstlimit-mode: `%s'\n", optarg);
+		*flags |= PARAM_MODE;
+		break;
+	case '"':
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM, "Unexpected `!' after "
+					"--dstlimit-name");
+		if (strlen(optarg) == 0)
+			exit_error(PARAMETER_PROBLEM, "Zero-length name?");
+		strncpy(r->name, optarg, sizeof(r->name));
+		*flags |= PARAM_NAME;
+		break;
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+	if (!(flags & PARAM_LIMIT))
+		exit_error(PARAMETER_PROBLEM,
+				"You have to specify --dstlimit");
+	if (!(flags & PARAM_MODE))
+		exit_error(PARAMETER_PROBLEM,
+				"You have to specify --dstlimit-mode");
+	if (!(flags & PARAM_NAME))
+		exit_error(PARAMETER_PROBLEM,
+				"You have to specify --dstlimit-name");
+}
+
+static struct rates
+{
+	const char *name;
+	u_int32_t mult;
+} rates[] = { { "day", IPT_DSTLIMIT_SCALE*24*60*60 },
+	      { "hour", IPT_DSTLIMIT_SCALE*60*60 },
+	      { "min", IPT_DSTLIMIT_SCALE*60 },
+	      { "sec", IPT_DSTLIMIT_SCALE } };
+
+static void print_rate(u_int32_t period)
+{
+	unsigned int i;
+
+	for (i = 1; i < sizeof(rates)/sizeof(struct rates); i++) {
+		if (period > rates[i].mult
+            || rates[i].mult/period < rates[i].mult%period)
+			break;
+	}
+
+	printf("%u/%s ", rates[i-1].mult / period, rates[i-1].name);
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_dstlimit_info *r = 
+		(struct ipt_dstlimit_info *)match->data;
+	printf("limit: avg "); print_rate(r->cfg.avg);
+	printf("burst %u ", r->cfg.burst);
+	switch (r->cfg.mode) {
+		case (IPT_DSTLIMIT_HASH_DIP):
+			printf("mode dstip ");
+			break;
+		case (IPT_DSTLIMIT_HASH_DIP|IPT_DSTLIMIT_HASH_DPT):
+			printf("mode dstip-dstport ");
+			break;
+		case (IPT_DSTLIMIT_HASH_SIP|IPT_DSTLIMIT_HASH_DIP):
+			printf("mode srcip-dstip ");
+			break;
+		case (IPT_DSTLIMIT_HASH_SIP|IPT_DSTLIMIT_HASH_DIP|IPT_DSTLIMIT_HASH_DPT):
+			printf("mode srcip-dstip-dstport ");
+			break;
+	}
+	if (r->cfg.size)
+		printf("htable-size %u ", r->cfg.size);
+	if (r->cfg.max)
+		printf("htable-max %u ", r->cfg.max);
+	if (r->cfg.gc_interval != IPT_DSTLIMIT_GCINTERVAL)
+		printf("htable-gcinterval %u ", r->cfg.gc_interval);
+	if (r->cfg.expire != IPT_DSTLIMIT_EXPIRE)
+		printf("htable-expire %u ", r->cfg.expire);
+}
+
+/* FIXME: Make minimalist: only print rate if not default --RR */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_dstlimit_info *r = 
+		(struct ipt_dstlimit_info *)match->data;
+
+	printf("--dstlimit "); print_rate(r->cfg.avg);
+	if (r->cfg.burst != IPT_DSTLIMIT_BURST)
+		printf("--dstlimit-burst %u ", r->cfg.burst);
+	switch (r->cfg.mode) {
+		case (IPT_DSTLIMIT_HASH_DIP):
+			printf("--mode dstip ");
+			break;
+		case (IPT_DSTLIMIT_HASH_DIP|IPT_DSTLIMIT_HASH_DPT):
+			printf("--mode dstip-dstport ");
+			break;
+		case (IPT_DSTLIMIT_HASH_SIP|IPT_DSTLIMIT_HASH_DIP):
+			printf("--mode srcip-dstip ");
+			break;
+		case (IPT_DSTLIMIT_HASH_SIP|IPT_DSTLIMIT_HASH_DIP|IPT_DSTLIMIT_HASH_DPT):
+			printf("--mode srcip-dstip-dstport ");
+			break;
+	}
+	if (r->cfg.size)
+		printf("--dstlimit-htable-size %u ", r->cfg.size);
+	if (r->cfg.max)
+		printf("--dstlimit-htable-max %u ", r->cfg.max);
+	if (r->cfg.gc_interval != IPT_DSTLIMIT_GCINTERVAL)
+		printf("--dstlimit-htable-gcinterval %u", r->cfg.gc_interval);
+	if (r->cfg.expire != IPT_DSTLIMIT_EXPIRE)
+		printf("--dstlimit-htable-expire %u ", r->cfg.expire);
+}
+
+static
+struct iptables_match dstlimit
+= { NULL,
+    "dstlimit",
+    IPTABLES_VERSION,
+    IPT_ALIGN(sizeof(struct ipt_dstlimit_info)),
+    IPT_ALIGN(sizeof(struct ipt_dstlimit_info)),
+    //offsetof(struct ipt_dstlimit_info, prev),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_match(&dstlimit);
+}
diff -urN iptables-1.2.9/extensions/libipt_dstlimit.man iptables-1.2.10/extensions/libipt_dstlimit.man
--- iptables-1.2.9/extensions/libipt_dstlimit.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_dstlimit.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,35 @@
+This module allows you to limit the packet per second (pps) rate on a per
+destination IP or per destination port base.  As opposed to the `limit' match,
+every destination ip / destination port has it's own limit.
+.TP
+.BI "--dstlimit " "avg"
+Maximum average match rate (packets per second unless followed by /sec /minute /hour /day postfixes).
+.TP
+.BI "--dstlimit-mode " "mode"
+The limiting hashmode.  Is the specified limit per
+.B dstip, dstip-dstport
+tuple, 
+.B srcip-dstip
+tuple, or per
+.B srcipdstip-dstport
+tuple.
+.TP
+.BI "--dstlimit-name " "name"
+Name for /proc/net/ipt_dstlimit/* file entry
+.TP
+.BI "[" "--dstlimit-burst " "burst" "]"
+Number of packets to match in a burst.  Default: 5
+.TP
+.BI "[" "--dstlimit-htable-size " "size" "]"
+Number of buckets in the hashtable
+.TP
+.BI "[" "--dstlimit-htable-max " "max" "]"
+Maximum number of entries in the hashtable
+.TP
+.BI "[" "--dstlimit-htable-gcinterval " "interval" "]"
+Interval between garbage collection runs of the hashtable (in miliseconds).
+Default is 1000 (1 second).
+.TP
+.BI "[" "--dstlimit-htable-expire " "time"
+After which time are idle entries expired from hashtable (in miliseconds)?
+Default is 10000 (10 seconds).
diff -urN iptables-1.2.9/extensions/libipt_ecn.man iptables-1.2.10/extensions/libipt_ecn.man
--- iptables-1.2.9/extensions/libipt_ecn.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_ecn.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,11 @@
+This allows you to match the ECN bits of the IPv4 and TCP header.  ECN is the Explicit Congestion Notification mechanism as specified in RFC3168
+.TP
+.BI "--ecn-tcp-cwr"
+This matches if the TCP ECN CWR (Congestion Window Received) bit is set.
+.TP
+.BI "--ecn-tcp-ece"
+This matches if the TCP ECN ECE (ECN Echo) bit is set.
+.TP
+.BI "--ecn-ip-ect " "num"
+This matches a particular IPv4 ECT (ECN-Capable Transport). You have to specify
+a number between `0' and `3'.
diff -urN iptables-1.2.9/extensions/libipt_esp.man iptables-1.2.10/extensions/libipt_esp.man
--- iptables-1.2.9/extensions/libipt_esp.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_esp.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,3 @@
+This module matches the SPIs in ESP header of IPSec packets.
+.TP
+.BR "--espspi " "[!] \fIspi\fP[:\fIspi\fP]"
diff -urN iptables-1.2.9/extensions/libipt_fuzzy.man iptables-1.2.10/extensions/libipt_fuzzy.man
--- iptables-1.2.9/extensions/libipt_fuzzy.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_fuzzy.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,7 @@
+This module matches a rate limit based on a fuzzy logic controller [FLC]
+.TP
+.BI "--lower-limit  "number"
+Specifies the lower limit (in packets per second).
+.TP
+.BI "--upper-limit " "number"
+Specifies the upper limit (in packets per second).
diff -urN iptables-1.2.9/extensions/libipt_helper.c iptables-1.2.10/extensions/libipt_helper.c
--- iptables-1.2.9/extensions/libipt_helper.c	2003-03-05 08:26:13.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_helper.c	2004-02-19 19:04:18.000000000 +0100
@@ -46,6 +46,7 @@
 	case '1':
 		check_inverse(optarg, &invert, &invert, 0);
 		strncpy(info->name, optarg, 29);
+		info->name[29] = '\0';
 		if (invert)
 			info->invert = 1;
 		*flags = 1;
diff -urN iptables-1.2.9/extensions/libipt_helper.man iptables-1.2.10/extensions/libipt_helper.man
--- iptables-1.2.9/extensions/libipt_helper.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_helper.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,11 @@
+This module matches packets related to a specific conntrack-helper.
+.TP
+.BI "--helper " "string"
+Matches packets related to the specified conntrack-helper.
+.RS
+.PP
+string can be "ftp" for packets related to a ftp-session on default port.
+For other ports append -portnr to the value, ie. "ftp-2121".
+.PP
+Same rules apply for other conntrack-helpers.
+.RE
diff -urN iptables-1.2.9/extensions/libipt_icmp.c iptables-1.2.10/extensions/libipt_icmp.c
--- iptables-1.2.9/extensions/libipt_icmp.c	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_icmp.c	2004-02-19 19:04:18.000000000 +0100
@@ -273,8 +273,7 @@
 
 	/* special hack for 'any' case */
 	if (icmp->type == 0xFF) {
-		print_icmptype(icmp->type, icmp->code[0], icmp->code[1],
-				icmp->invflags & IPT_ICMP_INV, 0);
+		printf("--icmp-type any ");
 	} else {
 		printf("--icmp-type %u", icmp->type);
 		if (icmp->code[0] != 0 || icmp->code[1] != 0xFF)
diff -urN iptables-1.2.9/extensions/libipt_icmp.man iptables-1.2.10/extensions/libipt_icmp.man
--- iptables-1.2.9/extensions/libipt_icmp.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_icmp.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,9 @@
+This extension is loaded if `--protocol icmp' is specified.  It
+provides the following option:
+.TP
+.BR "--icmp-type " "[!] \fItypename\fP"
+This allows specification of the ICMP type, which can be a numeric
+ICMP type, or one of the ICMP type names shown by the command
+.nf
+ iptables -p icmp -h
+.fi
diff -urN iptables-1.2.9/extensions/libipt_iprange.man iptables-1.2.10/extensions/libipt_iprange.man
--- iptables-1.2.9/extensions/libipt_iprange.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_iprange.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,7 @@
+This matches on a given arbitrary range of IPv4 addresses
+.TP
+.BI "[!]" "--src-range " "ip-ip"
+Match source IP in the specified range.
+.TP
+.BI "[!]" "--dst-range " "ip-ip"
+Match destination IP in the specified range.
diff -urN iptables-1.2.9/extensions/libipt_length.man iptables-1.2.10/extensions/libipt_length.man
--- iptables-1.2.9/extensions/libipt_length.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_length.man	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,4 @@
+This module matches the length of a packet against a specific value
+or range of values.
+.TP
+.BR "--length " "\fIlength\fP[:\fIlength\fP]"
diff -urN iptables-1.2.9/extensions/libipt_limit.c iptables-1.2.10/extensions/libipt_limit.c
--- iptables-1.2.9/extensions/libipt_limit.c	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_limit.c	2004-06-15 00:02:17.000000000 +0200
@@ -11,7 +11,8 @@
 #include <iptables.h>
 #include <stddef.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
-#include <linux/netfilter_ipv4/ipt_limit.h>
+/* For 64bit kernel / 32bit userspace */
+#include "../include/linux/netfilter_ipv4/ipt_limit.h"
 
 #define IPT_LIMIT_AVG	"3/hour"
 #define IPT_LIMIT_BURST	5
diff -urN iptables-1.2.9/extensions/libipt_limit.man iptables-1.2.10/extensions/libipt_limit.man
--- iptables-1.2.9/extensions/libipt_limit.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_limit.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,15 @@
+This module matches at a limited rate using a token bucket filter.
+A rule using this extension will match until this limit is reached
+(unless the `!' flag is used).  It can be used in combination with the
+.B LOG
+target to give limited logging, for example.
+.TP
+.BI "--limit " "rate"
+Maximum average matching rate: specified as a number, with an optional
+`/second', `/minute', `/hour', or `/day' suffix; the default is
+3/hour.
+.TP
+.BI "--limit-burst " "number"
+Maximum initial number of packets to match: this number gets
+recharged by one every time the limit specified above is not reached,
+up to this number; the default is 5.
diff -urN iptables-1.2.9/extensions/libipt_mac.man iptables-1.2.10/extensions/libipt_mac.man
--- iptables-1.2.9/extensions/libipt_mac.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_mac.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,10 @@
+.TP
+.BR "--mac-source " "[!] \fIaddress\fP"
+Match source MAC address.  It must be of the form XX:XX:XX:XX:XX:XX.
+Note that this only makes sense for packets coming from an Ethernet device
+and entering the
+.BR PREROUTING ,
+.B FORWARD
+or
+.B INPUT
+chains.
diff -urN iptables-1.2.9/extensions/libipt_mark.c iptables-1.2.10/extensions/libipt_mark.c
--- iptables-1.2.9/extensions/libipt_mark.c	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_mark.c	2004-06-15 00:02:17.000000000 +0200
@@ -6,7 +6,8 @@
 #include <getopt.h>
 
 #include <iptables.h>
-#include <linux/netfilter_ipv4/ipt_mark.h>
+/* For 64bit kernel / 32bit userspace */
+#include "../include/linux/netfilter_ipv4/ipt_mark.h"
 
 /* Function which prints out usage message. */
 static void
@@ -46,11 +47,19 @@
 		char *end;
 	case '1':
 		check_inverse(optarg, &invert, &optind, 0);
+#ifdef KERNEL_64_USERSPACE_32
+		markinfo->mark = strtoull(optarg, &end, 0);
+		if (*end == '/') {
+			markinfo->mask = strtoull(end+1, &end, 0);
+		} else
+			markinfo->mask = 0xffffffffffffffffULL;
+#else
 		markinfo->mark = strtoul(optarg, &end, 0);
 		if (*end == '/') {
 			markinfo->mask = strtoul(end+1, &end, 0);
 		} else
 			markinfo->mask = 0xffffffff;
+#endif
 		if (*end != '\0' || end == optarg)
 			exit_error(PARAMETER_PROBLEM, "Bad MARK value `%s'", optarg);
 		if (invert)
@@ -64,6 +73,16 @@
 	return 1;
 }
 
+#ifdef KERNEL_64_USERSPACE_32
+static void
+print_mark(unsigned long long mark, unsigned long long mask, int numeric)
+{
+	if(mask != 0xffffffffffffffffULL)
+		printf("0x%llx/0x%llx ", mark, mask);
+	else
+		printf("0x%llx ", mark);
+}
+#else
 static void
 print_mark(unsigned long mark, unsigned long mask, int numeric)
 {
@@ -72,6 +91,7 @@
 	else
 		printf("0x%lx ", mark);
 }
+#endif
 
 /* Final check; must have specified --mark. */
 static void
diff -urN iptables-1.2.9/extensions/libipt_mark.man iptables-1.2.10/extensions/libipt_mark.man
--- iptables-1.2.9/extensions/libipt_mark.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_mark.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,9 @@
+This module matches the netfilter mark field associated with a packet
+(which can be set using the
+.B MARK
+target below).
+.TP
+.BR "--mark " "\fIvalue\fP[/\fImask\fP]"
+Matches packets with the given unsigned mark value (if a mask is
+specified, this is logically ANDed with the mask before the
+comparison).
diff -urN iptables-1.2.9/extensions/libipt_mport.man iptables-1.2.10/extensions/libipt_mport.man
--- iptables-1.2.9/extensions/libipt_mport.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_mport.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,19 @@
+This module matches a set of source or destination ports.  Up to 15
+ports can be specified.  It can only be used in conjunction with
+.B "-p tcp"
+or
+.BR "-p udp" .
+.TP
+.BR "--source-ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
+Match if the source port is one of the given ports.  The flag
+.B --sports
+is a convenient alias for this option.
+.TP
+.BR "--destination-ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
+Match if the destination port is one of the given ports.  The flag
+.B --dports
+is a convenient alias for this option.
+.TP
+.BR "--ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
+Match if the both the source and destination ports are equal to each
+other and to one of the given ports.
diff -urN iptables-1.2.9/extensions/libipt_multiport.man iptables-1.2.10/extensions/libipt_multiport.man
--- iptables-1.2.9/extensions/libipt_multiport.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_multiport.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,19 @@
+This module matches a set of source or destination ports.  Up to 15
+ports can be specified.  It can only be used in conjunction with
+.B "-p tcp"
+or
+.BR "-p udp" .
+.TP
+.BR "--source-ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
+Match if the source port is one of the given ports.  The flag
+.B --sports
+is a convenient alias for this option.
+.TP
+.BR "--destination-ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
+Match if the destination port is one of the given ports.  The flag
+.B --dports
+is a convenient alias for this option.
+.TP
+.BR "--ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
+Match if the both the source and destination ports are equal to each
+other and to one of the given ports.
diff -urN iptables-1.2.9/extensions/libipt_nth.man iptables-1.2.10/extensions/libipt_nth.man
--- iptables-1.2.9/extensions/libipt_nth.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_nth.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,14 @@
+This module matches every `n'th packet
+.TP
+.BI "--every " "value"
+Match every `value' packet
+.TP
+.BI "[" "--counter " "num" "]"
+Use internal counter number `num'.  Default is `0'.
+.TP
+.BI "[" "--start " "num" "]"
+Initialize the counter at the number `num' insetad of `0'.  Most between `0'
+and `value'-1.
+.TP
+.BI "[" "--packet " "num" "]"
+Match on `num' packet.  Most be between `0' and `value'-1.
diff -urN iptables-1.2.9/extensions/libipt_osf.c iptables-1.2.10/extensions/libipt_osf.c
--- iptables-1.2.9/extensions/libipt_osf.c	2003-09-29 12:49:15.000000000 +0200
+++ iptables-1.2.10/extensions/libipt_osf.c	2004-02-29 22:10:18.000000000 +0100
@@ -36,13 +36,21 @@
 static void help(void)
 {
 	printf("OS fingerprint match v%s options:\n"
-		"  --genre [!] string          Match a OS genre bypassive fingerprinting.\n",
+		"--genre [!] string	Match a OS genre by passive fingerprinting.\n"
+		"--smart		Use some smart extensions to determine OS (do not use TTL).\n"
+		"--log level		Log all(or only first) determined genres even if "
+					"they do not match desired one. "
+					"Level may be 0(all) or 1(only first entry).\n"
+		"--netlink		Log through netlink(NETLINK_NFLOG).\n",
 		IPTABLES_VERSION);
 }
 
 
 static struct option opts[] = {
-	{ .name = "genre",     .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = "genre",	.has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = "smart",	.has_arg = 0, .flag = 0, .val = '2' },
+	{ .name = "log",	.has_arg = 1, .flag = 0, .val = '3' },
+	{ .name = "netlink",	.has_arg = 0, .flag = 0, .val = '4' },
 	{ .name = 0 }
 };
 
@@ -71,15 +79,34 @@
 	
 	switch(c) 
 	{
-		case '1':
-			if (*flags)
-				exit_error(PARAMETER_PROBLEM, "Can't specify multiple strings");
+		case '1': /* --genre */
+			if (*flags & IPT_OSF_GENRE)
+				exit_error(PARAMETER_PROBLEM, "Can't specify multiple genre parameter");
 			check_inverse(optarg, &invert, &optind, 0);
 			parse_string(argv[optind-1], info);
 			if (invert)
 				info->invert = 1;
 			info->len=strlen((char *)info->genre);
-			*flags = 1;
+			*flags |= IPT_OSF_GENRE;
+			break;
+		case '2': /* --smart */
+			if (*flags & IPT_OSF_SMART)
+				exit_error(PARAMETER_PROBLEM, "Can't specify multiple smart parameter");
+			*flags |= IPT_OSF_SMART;
+			info->flags |= IPT_OSF_SMART;
+			break;
+		case '3': /* --log */
+			if (*flags & IPT_OSF_LOG)
+				exit_error(PARAMETER_PROBLEM, "Can't specify multiple log parameter");
+			*flags |= IPT_OSF_LOG;
+			info->loglevel = atoi(argv[optind-1]);
+			info->flags |= IPT_OSF_LOG;
+			break;
+		case '4': /* --netlink */
+			if (*flags & IPT_OSF_NETLINK)
+				exit_error(PARAMETER_PROBLEM, "Can't specify multiple smart parameter");
+			*flags |= IPT_OSF_NETLINK;
+			info->flags |= IPT_OSF_NETLINK;
 			break;
 		default:
 			return 0;
diff -urN iptables-1.2.9/extensions/libipt_owner.c iptables-1.2.10/extensions/libipt_owner.c
--- iptables-1.2.9/extensions/libipt_owner.c	2003-05-03 20:52:15.000000000 +0200
+++ iptables-1.2.10/extensions/libipt_owner.c	2004-06-15 00:02:17.000000000 +0200
@@ -125,9 +125,10 @@
 	case '5':
 		check_inverse(optarg, &invert, &optind, 0);
 		if(strlen(optarg) > sizeof(ownerinfo->comm))
-			exit_error(PARAMETER_PROBLEM, "OWNER CMD `%s' too long, max %d characters", optarg, sizeof(ownerinfo->comm));
+			exit_error(PARAMETER_PROBLEM, "OWNER CMD `%s' too long, max %u characters", optarg, (unsigned int)sizeof(ownerinfo->comm));
 
 		strncpy(ownerinfo->comm, optarg, sizeof(ownerinfo->comm));
+		ownerinfo->comm[sizeof(ownerinfo->comm)-1] = '\0';
 
 		if (invert)
 			ownerinfo->invert |= IPT_OWNER_COMM;
diff -urN iptables-1.2.9/extensions/libipt_owner.man iptables-1.2.10/extensions/libipt_owner.man
--- iptables-1.2.9/extensions/libipt_owner.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_owner.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,26 @@
+This module attempts to match various characteristics of the packet
+creator, for locally-generated packets.  It is only valid in the
+.B OUTPUT
+chain, and even this some packets (such as ICMP ping responses) may
+have no owner, and hence never match.
+.TP
+.BI "--uid-owner " "userid"
+Matches if the packet was created by a process with the given
+effective user id.
+.TP
+.BI "--gid-owner " "groupid"
+Matches if the packet was created by a process with the given
+effective group id.
+.TP
+.BI "--pid-owner " "processid"
+Matches if the packet was created by a process with the given
+process id.
+.TP
+.BI "--sid-owner " "sessionid"
+Matches if the packet was created by a process in the given session
+group.
+.TP
+.BI "--cmd-owner " "name"
+Matches if the packet was created by a process with the given command name.
+(this option is present only if iptables was compiled under a kernel
+supporting this feature)
diff -urN iptables-1.2.9/extensions/libipt_physdev.man iptables-1.2.10/extensions/libipt_physdev.man
--- iptables-1.2.9/extensions/libipt_physdev.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_physdev.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,42 @@
+This module matches on the bridge port input and output devices enslaved
+to a bridge device. This module is a part of the infrastructure that enables
+a transparent bridging IP firewall and is only useful for kernel versions
+above version 2.5.44.
+.TP
+.B --physdev-in name
+Name of a bridge port via which a packet is received (only for
+packets entering the
+.BR INPUT ,
+.B FORWARD
+and
+.B PREROUTING
+chains). If the interface name ends in a "+", then any
+interface which begins with this name will match. If the packet didn't arrive
+through a bridge device, this packet won't match this option, unless '!' is used.
+.TP
+.B --physdev-out name
+Name of a bridge port via which a packet is going to be sent (for packets
+entering the
+.BR FORWARD ,
+.B OUTPUT
+and
+.B POSTROUTING
+chains).  If the interface name ends in a "+", then any
+interface which begins with this name will match. Note that in the
+.BR nat " and " mangle
+.B OUTPUT
+chains one cannot match on the bridge output port, however one can in the
+.B "filter OUTPUT"
+chain. If the packet won't leave by a bridge device or it is yet unknown what
+the output device will be, then the packet won't match this option, unless
+'!' is used.
+.TP
+.B --physdev-is-in
+Matches if the packet has entered through a bridge interface.
+.TP
+.B --physdev-is-out
+Matches if the packet will leave through a bridge interface.
+.TP
+.B --physdev-is-bridged
+Matches if the packet is being bridged and therefore is not being routed.
+This is only useful in the FORWARD and POSTROUTING chains.
diff -urN iptables-1.2.9/extensions/libipt_pkttype.man iptables-1.2.10/extensions/libipt_pkttype.man
--- iptables-1.2.9/extensions/libipt_pkttype.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_pkttype.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,3 @@
+This module matches the link-layer packet type.
+.TP
+.BI "--pkt-type " "[\fIunicast\fP|\fIbroadcast\fP|\fImulticast\fP]"
diff -urN iptables-1.2.9/extensions/libipt_pool.c.orig iptables-1.2.10/extensions/libipt_pool.c.orig
--- iptables-1.2.9/extensions/libipt_pool.c.orig	2002-06-04 09:57:31.000000000 +0200
+++ iptables-1.2.10/extensions/libipt_pool.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,144 +0,0 @@
-/* Shared library add-on to iptables to add IP address pool matching. */
-#include <stdio.h>
-#include <netdb.h>
-#include <string.h>
-#include <stdlib.h>
-#include <getopt.h>
-#include <ctype.h>
-
-#include <iptables.h>
-#include <linux/netfilter_ipv4/ip_conntrack.h>
-#include <linux/netfilter_ipv4/ipt_pool.h>
-
-#include <libippool/ip_pool_support.h>
-
-/* FIXME --RR */
-#include "../ippool/libippool.c"
-
-/* Function which prints out usage message. */
-static void
-help(void)
-{
-	printf(
-"pool v%s options:\n"
-" [!] --srcpool NAME|INDEX\n"
-" [!] --dstpool NAME|INDEX\n"
-"			Pool index (or name from %s) to match\n"
-"\n", IPTABLES_VERSION, IPPOOL_CONF);
-}
-
-static struct option opts[] = {
-	{ "srcpool", 1, 0, '1' },
-	{ "dstpool", 1, 0, '2' },
-	{0}
-};
-
-/* Initialize the match. */
-static void
-init(struct ipt_entry_match *match, unsigned int *nfcache)
-{
-	struct ipt_pool_info *info =
-		(struct ipt_pool_info *)match->data;
-
-	info->src = IP_POOL_NONE;
-	info->dst = IP_POOL_NONE;
-	info->flags = 0;
-	/* Can't cache this - XXX */
-	*nfcache |= NFC_UNKNOWN;
-}
-
-/* Function which parses command options; returns true if it ate an option */
-static int
-parse(int c, char **argv, int invert, unsigned int *flags,
-      const struct ipt_entry *entry,
-      unsigned int *nfcache,
-      struct ipt_entry_match **match)
-{
-	struct ipt_pool_info *info =
-		(struct ipt_pool_info *)(*match)->data;
-
-	switch (c) {
-	case '1':
-		check_inverse(optarg, &invert, &optind, 0);
-		info->src = ip_pool_get_index(argv[optind-1]);
-		if (invert) info->flags |= IPT_POOL_INV_SRC;
-		*flags = 1;
-		break;
-	case '2':
-		check_inverse(optarg, &invert, &optind, 0);
-		info->dst = ip_pool_get_index(argv[optind-1]);
-		if (invert) info->flags |= IPT_POOL_INV_DST;
-		*flags = 1;
-		break;
-
-	default:
-		return 0;
-	}
-
-	return 1;
-}
-
-/* Final check; must have specified --srcpool or --dstpool. */
-static void final_check(unsigned int flags)
-{
-	if (!flags)
-		exit_error(PARAMETER_PROBLEM, "You must specify either `--srcpool or --dstpool'");
-}
-
-/* Prints out the matchinfo. */
-static void
-print(const struct ipt_ip *ip,
-      const struct ipt_entry_match *match,
-      int numeric)
-{
-	char buf[256];
-	struct ipt_pool_info *info =
-		(struct ipt_pool_info *)match->data;
-
-	if (info->src != IP_POOL_NONE)
-		printf("%ssrcpool %s ",
-			(info->flags & IPT_POOL_INV_SRC) ? "!" : "",
-			ip_pool_get_name(buf, sizeof(buf), info->src, 0));
-	if (info->dst != IP_POOL_NONE)
-		printf("%sdstpool %s ",
-			(info->flags & IPT_POOL_INV_DST) ? "!" : "",
-			ip_pool_get_name(buf, sizeof(buf), info->dst, 0));
-}
-
-/* Saves the matchinfo in parsable form to stdout. */
-static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
-{
-	char buf[256];
-	struct ipt_pool_info *info =
-		(struct ipt_pool_info *)match->data;
-
-	if (info->src != IP_POOL_NONE)
-		printf("%s--srcpool %s",
-			(info->flags & IPT_POOL_INV_SRC) ? "! " : "",
-			ip_pool_get_name(buf, sizeof(buf), info->src, 0));
-	if (info->dst != IP_POOL_NONE)
-		printf("%s--dstpool %s",
-			(info->flags & IPT_POOL_INV_DST) ? "! " : "",
-			ip_pool_get_name(buf, sizeof(buf), info->dst, 0));
-}
-
-static
-struct iptables_match pool
-= { NULL,
-    "pool",
-    IPTABLES_VERSION,
-    IPT_ALIGN(sizeof(struct ipt_pool_info)),
-    IPT_ALIGN(sizeof(struct ipt_pool_info)),
-    &help,
-    &init,
-    &parse,
-    &final_check,
-    &print,
-    &save,
-    opts
-};
-
-void _init(void)
-{
-	register_match(&pool);
-}
diff -urN iptables-1.2.9/extensions/libipt_random.man iptables-1.2.10/extensions/libipt_random.man
--- iptables-1.2.9/extensions/libipt_random.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_random.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,4 @@
+This module randomly matches a certain percentage of all packets.
+.TP
+.BI "--average " "percent"
+Matches the given percentage.  If omitted, a probability of 50% is set. 
diff -urN iptables-1.2.9/extensions/libipt_realm.man iptables-1.2.10/extensions/libipt_realm.man
--- iptables-1.2.9/extensions/libipt_realm.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_realm.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,5 @@
+This matches the routing realm.  Routing realms are used in complex routing
+setups involving dynamic routing protocols like BGP.
+.TP
+.BI "--realm " "[!]" "value[/mask]"
+Matches a given realm number (and optionally mask).
diff -urN iptables-1.2.9/extensions/libipt_recent.c iptables-1.2.10/extensions/libipt_recent.c
--- iptables-1.2.9/extensions/libipt_recent.c	2003-06-15 00:39:35.000000000 +0200
+++ iptables-1.2.10/extensions/libipt_recent.c	2004-02-19 19:04:19.000000000 +0100
@@ -75,6 +75,9 @@
 	*nfcache |= NFC_UNKNOWN;
 
 	strncpy(info->name,"DEFAULT",IPT_RECENT_NAME_LEN);
+	/* eventhough IPT_RECENT_NAME_LEN is currently defined as 200,
+	 * better be safe, than sorry */
+	info->name[IPT_RECENT_NAME_LEN-1] = '\0';
 	info->side = IPT_RECENT_SOURCE;
 }
 
@@ -142,6 +145,7 @@
 
 		case 208:
 			strncpy(info->name,optarg,IPT_RECENT_NAME_LEN);
+			info->name[IPT_RECENT_NAME_LEN-1] = '\0';
 			break;
 
 		case 209:
diff -urN iptables-1.2.9/extensions/libipt_sctp.c iptables-1.2.10/extensions/libipt_sctp.c
--- iptables-1.2.9/extensions/libipt_sctp.c	2003-05-03 20:05:58.000000000 +0200
+++ iptables-1.2.10/extensions/libipt_sctp.c	2004-03-02 19:28:17.000000000 +0100
@@ -12,30 +12,48 @@
 #include <stdlib.h>
 #include <getopt.h>
 #include <netdb.h>
+#include <ctype.h>
 
 #include <iptables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/netfilter_ipv4/ipt_sctp.h>
 
+#if 0
+#define DEBUGP(format, first...) printf(format, ##first)
+#define static
+#else
+#define DEBUGP(format, fist...) 
+#endif
+
+static void
+print_chunk(u_int32_t chunknum, int numeric);
+
 /* Initialize the match. */
 static void
-init(struct ipt_entry_match *m, unsigned int *nfcache)
+init(struct ipt_entry_match *m, 
+     unsigned int *nfcache)
 {
+	int i;
 	struct ipt_sctp_info *einfo = (struct ipt_sctp_info *)m->data;
 
-	einfo->spts[1] = einfo->dpts[1] = 0xFFFF;
+	memset(einfo, 0, sizeof(struct ipt_sctp_info));
+
+	for (i = 0; i < IPT_NUM_SCTP_FLAGS; i++) {
+		einfo->flag_info[i].chunktype = -1;
+	}
 }
 
-static void help(void) 
+static void help(void)
 {
 	printf(
 "SCTP match v%s options\n"
-" --sctp-chunks [!] mask comp	match when SCTP chunks & mask == comp\n"
-" --source-port [!] port[:port]\n"
+" --source-port [!] port[:port]                          match source port(s)\n"
 " --sport ...\n"
-"                               match source port(s)"
-" --destination-port [!] port[:port]\n"
-" --dport ...\n\n",
+" --destination-port [!] port[:port]                     match destination port(s)\n"
+" --dport ...\n" 
+" --chunk-types [!] (all|any|none) (chunktype[:flags])+	match if all, any or none of\n"
+"						        chunktypes are present\n"
+"chunktypes - DATA INIT INIT_ACK SACK HEARTBEAT HEARTBEAT_ACK ABORT SHUTDOWN SHUTDOWN_ACK ERROR COOKIE_ECHO COOKIE_ACK ECN_ECNE ECN_CWR SHUTDOWN_COMPLETE ASCONF ASCONF_ACK ALL NONE\n",
 	IPTABLES_VERSION);
 }
 
@@ -44,7 +62,7 @@
 	{ .name = "sport", .has_arg = 1, .flag = 0, .val = '1' },
 	{ .name = "destination-port", .has_arg = 1, .flag = 0, .val = '2' },
 	{ .name = "dport", .has_arg = 1, .flag = 0, .val = '2' },
-	{ .name = "sctp-chunks", .has_arg = 1, .flag = 0, .val = '3' },
+	{ .name = "chunk-types", .has_arg = 1, .flag = 0, .val = '3' },
 	{ .name = 0 }
 };
 
@@ -64,24 +82,27 @@
 {
 	unsigned int portnum;
 
+	DEBUGP("%s\n", port);
 	if (string_to_number(port, 0, 65535, &portnum) != -1 ||
 	    (portnum = service_to_port(port)) != -1)
 		return (u_int16_t)portnum;
 
 	exit_error(PARAMETER_PROBLEM,
-		   "invalid TCP port/service `%s' specified", port);
+		   "invalid SCTP port/service `%s' specified", port);
 }
 
-
 static void
-parse_sctp_ports(const char *portstring, u_int16_t *ports)
+parse_sctp_ports(const char *portstring, 
+		 u_int16_t *ports)
 {
 	char *buffer;
 	char *cp;
 
 	buffer = strdup(portstring);
-	if ((cp = strchr(buffer, ':')) == NULL)
+	DEBUGP("%s\n", portstring);
+	if ((cp = strchr(buffer, ':')) == NULL) {
 		ports[0] = ports[1] = parse_sctp_port(buffer);
+	}
 	else {
 		*cp = '\0';
 		cp++;
@@ -98,51 +119,106 @@
 
 struct sctp_chunk_names {
 	const char *name;
-	unsigned int flag;
+	unsigned int chunk_type;
+	const char *valid_flags;
 };
 
-/* FIXME: */
-#define ALL_CHUNKS	0xabcdef
+/*'ALL' and 'NONE' will be treated specially. */
 static struct sctp_chunk_names sctp_chunk_names[]
-= { { .name = "DATA", 		.flag = (1 << 0) },
-    { .name = "INIT", 		.flag = (1 << 1) },
-    { .name = "INIT_ACK", 	.flag = (1 << 2) },
-    { .name = "SACK",		.flag = (1 << 3) },
-    { .name = "HEARTBEAT",	.flag = (1 << 4) },
-    { .name = "HEARTBEAT_ACK",	.flag = (1 << 5) },
-    { .name = "ABORT",		.flag = (1 << 6) },
-    { .name = "SHUTDOWN",	.flag = (1 << 7) },
-    { .name = "SHUTDOWN_ACK",	.flag = (1 << 8) },
-    { .name = "ERROR",		.flag = (1 << 9) },
-    { .name = "COOKIE_ECHO",	.flag = (1 << 10) },
-    { .name = "COOKIE_ACK",	.flag = (1 << 11) },
-    { .name = "ECN_ECNE",	.flag = (1 << 12) },
-    { .name = "ECN_CWR",	.flag = (1 << 13) },
-    { .name = "SHUTDOWN_COMPLETE", .flag = (1 << 14) },
-    { .name = "ASCONF",		.flag = (1 << 31) },
-    { .name = "ASCONF_ACK",	.flag = (1 << 30) },
-    { .name = "ALL", 		.flag = ALL_CHUNKS },
-    { .name = "NONE",		.flag = 0 },
+= { { .name = "DATA", 		.chunk_type = 0,   .valid_flags = "-----UBE"},
+    { .name = "INIT", 		.chunk_type = 1,   .valid_flags = "--------"},
+    { .name = "INIT_ACK", 	.chunk_type = 2,   .valid_flags = "--------"},
+    { .name = "SACK",		.chunk_type = 3,   .valid_flags = "--------"},
+    { .name = "HEARTBEAT",	.chunk_type = 4,   .valid_flags = "--------"},
+    { .name = "HEARTBEAT_ACK",	.chunk_type = 5,   .valid_flags = "--------"},
+    { .name = "ABORT",		.chunk_type = 6,   .valid_flags = "-------T"},
+    { .name = "SHUTDOWN",	.chunk_type = 7,   .valid_flags = "--------"},
+    { .name = "SHUTDOWN_ACK",	.chunk_type = 8,   .valid_flags = "--------"},
+    { .name = "ERROR",		.chunk_type = 9,   .valid_flags = "--------"},
+    { .name = "COOKIE_ECHO",	.chunk_type = 10,  .valid_flags = "--------"},
+    { .name = "COOKIE_ACK",	.chunk_type = 11,  .valid_flags = "--------"},
+    { .name = "ECN_ECNE",	.chunk_type = 12,  .valid_flags = "--------"},
+    { .name = "ECN_CWR",	.chunk_type = 13,  .valid_flags = "--------"},
+    { .name = "SHUTDOWN_COMPLETE", .chunk_type = 14,  .valid_flags = "-------T"},
+    { .name = "ASCONF",		.chunk_type = 31,  .valid_flags = "--------"},
+    { .name = "ASCONF_ACK",	.chunk_type = 30,  .valid_flags = "--------"},
 };
 
+static void
+save_chunk_flag_info(struct ipt_sctp_flag_info *flag_info,
+		     int *flag_count,
+		     int chunktype, 
+		     int bit, 
+		     int set)
+{
+	int i;
+
+	for (i = 0; i < *flag_count; i++) {
+		if (flag_info[i].chunktype == chunktype) {
+			DEBUGP("Previous match found\n");
+			flag_info[i].chunktype = chunktype;
+			flag_info[i].flag_mask |= (1 << bit);
+			if (set) {
+				flag_info[i].flag |= (1 << bit);
+			}
+
+			return;
+		}
+	}
+	
+	if (*flag_count == IPT_NUM_SCTP_FLAGS) {
+		exit_error (PARAMETER_PROBLEM,
+			"Number of chunk types with flags exceeds currently allowed limit."
+			"Increasing this limit involves changing IPT_NUM_SCTP_FLAGS and"
+			"recompiling both the kernel space and user space modules\n");
+	}
+
+	flag_info[*flag_count].chunktype = chunktype;
+	flag_info[*flag_count].flag_mask |= (1 << bit);
+	if (set) {
+		flag_info[*flag_count].flag |= (1 << bit);
+	}
+	(*flag_count)++;
+}
 
-static unsigned int
-parse_sctp_chunk(const char *flags)
+static void
+parse_sctp_chunk(struct ipt_sctp_info *einfo, 
+		 const char *chunks)
 {
-	unsigned int ret = 0;
 	char *ptr;
 	char *buffer;
-
-	buffer = strdup(flags);
+	unsigned int i, j;
+	int found = 0;
+	char *chunk_flags;
+
+	buffer = strdup(chunks);
+	DEBUGP("Buffer: %s\n", buffer);
+
+	SCTP_CHUNKMAP_RESET(einfo->chunkmap);
+
+	if (!strcasecmp(buffer, "ALL")) {
+		SCTP_CHUNKMAP_SET_ALL(einfo->chunkmap);
+		goto out;
+	}
+	
+	if (!strcasecmp(buffer, "NONE")) {
+		SCTP_CHUNKMAP_RESET(einfo->chunkmap);
+		goto out;
+	}
 
 	for (ptr = strtok(buffer, ","); ptr; ptr = strtok(NULL, ",")) {
-		unsigned int i;
-		int found = 0;
-		for (i = 0;
-		     i < sizeof(sctp_chunk_names)/sizeof(struct sctp_chunk_names);
-		     i++) {
+		found = 0;
+		DEBUGP("Next Chunk type %s\n", ptr);
+		
+		if ((chunk_flags = strchr(ptr, ':')) != NULL) {
+			*chunk_flags++ = 0;
+		}
+		
+		for (i = 0; i < ELEMCOUNT(sctp_chunk_names); i++) {
 			if (strcasecmp(sctp_chunk_names[i].name, ptr) == 0) {
-				ret |= sctp_chunk_names[i].flag;
+				DEBUGP("Chunk num %d\n", sctp_chunk_names[i].chunk_type);
+				SCTP_CHUNKMAP_SET(einfo->chunkmap, 
+					sctp_chunk_names[i].chunk_type);
 				found = 1;
 				break;
 			}
@@ -150,29 +226,53 @@
 		if (!found)
 			exit_error(PARAMETER_PROBLEM,
 				   "Unknown sctp chunk `%s'", ptr);
-	}
 
+		if (chunk_flags) {
+			DEBUGP("Chunk flags %s\n", chunk_flags);
+			for (j = 0; j < strlen(chunk_flags); j++) {
+				char *p;
+				int bit;
+
+				if ((p = strchr(sctp_chunk_names[i].valid_flags, 
+						toupper(chunk_flags[j]))) != NULL) {
+					bit = p - sctp_chunk_names[i].valid_flags;
+					bit = 7 - bit;
+
+					save_chunk_flag_info(einfo->flag_info, 
+						&(einfo->flag_count), i, bit, 
+						isupper(chunk_flags[j]));
+				} else {
+					exit_error(PARAMETER_PROBLEM, 
+						"Invalid flags for chunk type %d\n", i);
+				}
+			}
+		}
+	}
+out:
 	free(buffer);
-	return ret;
 }
 
 static void
 parse_sctp_chunks(struct ipt_sctp_info *einfo,
-		const char *mask,
-		const char *cmp,
-		int invert)
+		  const char *match_type,
+		  const char *chunks)
 {
-	einfo->chunks = parse_sctp_chunk(mask);
-	einfo->chunk_mask = parse_sctp_chunk(cmp);
+	DEBUGP("Match type: %s Chunks: %s\n", match_type, chunks);
+	if (!strcasecmp(match_type, "ANY")) {
+		einfo->chunk_match_type = SCTP_CHUNK_MATCH_ANY;
+	} else 	if (!strcasecmp(match_type, "ALL")) {
+		einfo->chunk_match_type = SCTP_CHUNK_MATCH_ALL;
+	} else 	if (!strcasecmp(match_type, "ONLY")) {
+		einfo->chunk_match_type = SCTP_CHUNK_MATCH_ONLY;
+	} else {
+		exit_error (PARAMETER_PROBLEM, 
+			"Match type has to be one of \"ALL\", \"ANY\" or \"ONLY\"");
+	}
 
-	if (invert)
-		einfo->invflags |= IPT_SCTP_INV_CHUNKS;
+	SCTP_CHUNKMAP_RESET(einfo->chunkmap);
+	parse_sctp_chunk(einfo, chunks);
 }
 
-#define SCTP_SRC_PORTS	0x01
-#define SCTP_DST_PORTS	0x02
-#define SCTP_CHUNKS	0x03
-
 static int
 parse(int c, char **argv, int invert, unsigned int *flags,
       const struct ipt_entry *entry,
@@ -184,48 +284,53 @@
 
 	switch (c) {
 	case '1':
-		if (*flags & SCTP_SRC_PORTS)
+		if (*flags & IPT_SCTP_SRC_PORTS)
 			exit_error(PARAMETER_PROBLEM,
 			           "Only one `--source-port' allowed");
+		einfo->flags |= IPT_SCTP_SRC_PORTS;
 		check_inverse(optarg, &invert, &optind, 0);
 		parse_sctp_ports(argv[optind-1], einfo->spts);
 		if (invert)
-			einfo->invflags |= IPT_SCTP_INV_SRCPT;
-		*flags |= SCTP_SRC_PORTS;
+			einfo->invflags |= IPT_SCTP_SRC_PORTS;
+		*flags |= IPT_SCTP_SRC_PORTS;
 		*nfcache |= NFC_IP_SRC_PT;
 		break;
 
 	case '2':
-		if (*flags & SCTP_DST_PORTS)
+		if (*flags & IPT_SCTP_DEST_PORTS)
 			exit_error(PARAMETER_PROBLEM,
 				   "Only one `--destination-port' allowed");
+		einfo->flags |= IPT_SCTP_DEST_PORTS;
 		check_inverse(optarg, &invert, &optind, 0);
 		parse_sctp_ports(argv[optind-1], einfo->dpts);
 		if (invert)
-			einfo->invflags |= IPT_SCTP_INV_DSTPT;
-		*flags |= SCTP_DST_PORTS;
+			einfo->invflags |= IPT_SCTP_DEST_PORTS;
+		*flags |= IPT_SCTP_DEST_PORTS;
 		*nfcache |= NFC_IP_DST_PT;
 		break;
 
 	case '3':
-		if (*flags & SCTP_CHUNKS)
+		if (*flags & IPT_SCTP_CHUNK_TYPES)
 			exit_error(PARAMETER_PROBLEM,
-				   "Only one `--sctp-chunks' allowed");
+				   "Only one `--chunk-types' allowed");
 		check_inverse(optarg, &invert, &optind, 0);
 
 		if (!argv[optind] 
 		    || argv[optind][0] == '-' || argv[optind][0] == '!')
 			exit_error(PARAMETER_PROBLEM,
-				   "--sctp-chunks requires two args");
+				   "--chunk-types requires two args");
 
-		parse_sctp_chunks(einfo, argv[optind-1], argv[optind], invert);
+		einfo->flags |= IPT_SCTP_CHUNK_TYPES;
+		parse_sctp_chunks(einfo, argv[optind-1], argv[optind]);
+		if (invert)
+			einfo->invflags |= IPT_SCTP_CHUNK_TYPES;
 		optind++;
-		*flags |= SCTP_CHUNKS;
+		*flags |= IPT_SCTP_CHUNK_TYPES;
 		break;
+
 	default:
 		return 0;
 	}
-
 	return 1;
 }
 
@@ -278,41 +383,89 @@
 }
 
 static void
-print_chunk(u_int32_t chunks)
+print_chunk_flags(u_int32_t chunknum, u_int8_t chunk_flags, u_int8_t chunk_flags_mask)
 {
-	unsigned int have_flag = 0;
+	int i;
 
-	while (chunks) {
-		unsigned int i;
+	DEBUGP("type: %d\tflags: %x\tflag mask: %x\n", chunknum, chunk_flags, 
+			chunk_flags_mask);
 
-		for (i = 0; (chunks & sctp_chunk_names[i].flag) == 0; i++);
+	if (chunk_flags_mask) {
+		printf(":");
+	}
 
-		if (have_flag)
-			printf(",");
-		printf("%s", sctp_chunk_names[i].name);
-		have_flag = 1;
+	for (i = 7; i >= 0; i--) {
+		if (chunk_flags_mask & (1 << i)) {
+			if (chunk_flags & (1 << i)) {
+				printf("%c", sctp_chunk_names[chunknum].valid_flags[7-i]);
+			} else {
+				printf("%c", tolower(sctp_chunk_names[chunknum].valid_flags[7-i]));
+			}
+		}
+	}
+}
 
-		chunks &= ~sctp_chunk_names[i].flag;
+static void
+print_chunk(u_int32_t chunknum, int numeric)
+{
+	if (numeric) {
+		printf("0x%04X", chunknum);
 	}
+	else {
+		int i;
 
-	if (!have_flag)
-		printf("NONE");
+		for (i = 0; i < ELEMCOUNT(sctp_chunk_names); i++) {
+			if (sctp_chunk_names[i].chunk_type == chunknum)
+				printf("%s", sctp_chunk_names[chunknum].name);
+		}
+	}
 }
 
 static void
-print_chunks(u_int32_t mask, u_int32_t cmp, int invert, int numeric)
-{
-	if (mask || invert) {
-		printf("flags:%s", invert ? "!" : "");
-		if (numeric)
-			printf("0x%04X/0x%04X ", mask, cmp);
-		else {
-			print_chunk(mask);
-			printf("/");
-			print_chunk(cmp);
-			printf(" ");
+print_chunks(u_int32_t chunk_match_type, 
+	     const u_int32_t *chunkmap, 
+	     const struct ipt_sctp_flag_info *flag_info,
+	     int flag_count,
+	     int numeric)
+{
+	int i, j;
+	int flag;
+
+	switch (chunk_match_type) {
+		case SCTP_CHUNK_MATCH_ANY:	printf("any "); break;
+		case SCTP_CHUNK_MATCH_ALL:	printf("all "); break;
+		case SCTP_CHUNK_MATCH_ONLY:	printf("only "); break;
+		default:	printf("Never reach herer\n"); break;
+	}
+
+	if (SCTP_CHUNKMAP_IS_CLEAR(chunkmap)) {
+		printf("NONE ");
+		goto out;
+	}
+	
+	if (SCTP_CHUNKMAP_IS_ALL_SET(chunkmap)) {
+		printf("ALL ");
+		goto out;
+	}
+	
+	flag = 0;
+	for (i = 0; i < 256; i++) {
+		if (SCTP_CHUNKMAP_IS_SET(chunkmap, i)) {
+			flag && printf(",");
+			flag = 1;
+			print_chunk(i, numeric);
+			for (j = 0; j < flag_count; j++) {
+				if (flag_info[j].chunktype == i) {
+					print_chunk_flags(i, flag_info[j].flag,
+						flag_info[j].flag_mask);
+				}
+			}
 		}
 	}
+
+	flag && printf(" ");
+out:
+	return;
 }
 
 /* Prints out the matchinfo. */
@@ -326,28 +479,39 @@
 
 	printf("sctp ");
 
-	print_ports("spt", einfo->spts[0], einfo->spts[1],
-		    einfo->invflags & IPT_SCTP_INV_SRCPT,
-		    numeric);
-	print_ports("dpt", einfo->dpts[0], einfo->dpts[1],
-		    einfo->invflags & IPT_SCTP_INV_DSTPT,
-		    numeric);
-
-	print_chunks(einfo->chunks, einfo->chunk_mask,
-		     einfo->invflags & ~IPT_SCTP_INV_MASK,
-		     numeric);
+	if (einfo->flags & IPT_SCTP_SRC_PORTS) {
+		print_ports("spt", einfo->spts[0], einfo->spts[1],
+			einfo->invflags & IPT_SCTP_SRC_PORTS,
+			numeric);
+	}
+
+	if (einfo->flags & IPT_SCTP_DEST_PORTS) {
+		print_ports("dpt", einfo->dpts[0], einfo->dpts[1],
+			einfo->invflags & IPT_SCTP_DEST_PORTS,
+			numeric);
+	}
+
+	if (einfo->flags & IPT_SCTP_CHUNK_TYPES) {
+		/* FIXME: print_chunks() is used in save() where the printing of '!'
+		s taken care of, so we need to do that here as well */
+		if (einfo->invflags & IPT_SCTP_CHUNK_TYPES) {
+			printf("! ");
+		}
+		print_chunks(einfo->chunk_match_type, einfo->chunkmap,
+			einfo->flag_info, einfo->flag_count, numeric);
+	}
 }
 
 /* Saves the union ipt_matchinfo in parsable form to stdout. */
 static void
-save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+save(const struct ipt_ip *ip, 
+     const struct ipt_entry_match *match)
 {
 	const struct ipt_sctp_info *einfo =
 		(const struct ipt_sctp_info *)match->data;
 
-	if (einfo->spts[0] != 0
-	    || einfo->spts[1] != 0xFFFF) {
-		if (einfo->invflags & IPT_SCTP_INV_SRCPT)
+	if (einfo->flags & IPT_SCTP_SRC_PORTS) {
+		if (einfo->invflags & IPT_SCTP_SRC_PORTS)
 			printf("! ");
 		if (einfo->spts[0] != einfo->spts[1])
 			printf("--sport %u:%u ", 
@@ -356,9 +520,8 @@
 			printf("--sport %u ", einfo->spts[0]);
 	}
 
-	if (einfo->dpts[0] != 0
-	    || einfo->dpts[1] != 0xFFFF) {
-		if (einfo->invflags & IPT_SCTP_INV_DSTPT)
+	if (einfo->flags & IPT_SCTP_DEST_PORTS) {
+		if (einfo->invflags & IPT_SCTP_DEST_PORTS)
 			printf("! ");
 		if (einfo->dpts[0] != einfo->dpts[1])
 			printf("--dport %u:%u ",
@@ -367,17 +530,13 @@
 			printf("--dport %u ", einfo->dpts[0]);
 	}
 
-	if (einfo->chunks
-	    || (einfo->invflags & IPT_SCTP_INV_CHUNKS)) {
-		if (einfo->invflags & IPT_SCTP_INV_CHUNKS)
+	if (einfo->flags & IPT_SCTP_CHUNK_TYPES) {
+		if (einfo->invflags & IPT_SCTP_CHUNK_TYPES)
 			printf("! ");
-		printf("--sctp-chunks ");
-		if (einfo->chunks != ALL_CHUNKS) {
-			print_chunk(einfo->chunks);
-		}
-		printf(" ");
-		print_chunk(einfo->chunk_mask);
-		printf(" ");
+		printf("--chunk-types ");
+
+		print_chunks(einfo->chunk_match_type, einfo->chunkmap, 
+			einfo->flag_info, einfo->flag_count, 0);
 	}
 }
 
@@ -400,3 +559,4 @@
 {
 	register_match(&sctp);
 }
+
diff -urN iptables-1.2.9/extensions/libipt_set.c iptables-1.2.10/extensions/libipt_set.c
--- iptables-1.2.9/extensions/libipt_set.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_set.c	2004-02-09 14:47:01.000000000 +0100
@@ -0,0 +1,152 @@
+/* Shared library add-on to iptables to add IP address set matching. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ipt_set.h>
+#include "../ipset/libipt_set.h"
+
+/* Function which prints out usage message. */
+static void help(void)
+{
+	printf("set v%s options:\n"
+	       " [!] --set     name[:flags] flags\n"
+	       "		'name' is the set name from to match.\n" 
+	       "		'flags' are the comma separated list of\n"
+	       "		'src' and 'dst'.\n"
+	       "\n", IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{"set", 1, 0, '1'},
+	{0}
+};
+
+/* Initialize the match. */
+static void init(struct ipt_entry_match *match, unsigned int *nfcache)
+{
+	struct ipt_set_info_match *info = 
+		(struct ipt_set_info_match *) match->data;
+	
+
+	memset(info, 0, sizeof(struct ipt_set_info_match));
+	info->match.id = -1;
+
+	/* Can't cache this - XXX */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Function which parses command options; returns true if it ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache, struct ipt_entry_match **match)
+{
+	struct ipt_set_info_match *myinfo = 
+		(struct ipt_set_info_match *) (*match)->data;
+	struct ipt_set_info *info = &myinfo->match;
+
+	switch (c) {
+	case '1':		/* --set <set>[:<flags>] <flags> */
+		check_inverse(optarg, &invert, &optind, 0);
+		if (invert)
+			info->flags[0] |= IPSET_MATCH_INV;
+
+		if (!argv[optind]
+		    || argv[optind][0] == '-' || argv[optind][0] == '!')
+			exit_error(PARAMETER_PROBLEM,
+				   "--set requires two args.");
+
+		parse_pool(argv[optind - 1], info);
+		if (parse_ipflags(argv[optind++], info))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't use overwrite flag with --set.");
+		
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; must have specified --set. */
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+			   "You must specify either `--set'");
+}
+
+static void
+print_match(const char *prefix, const struct ipt_set_info *info)
+{
+	int i;
+	char setname[IP_SET_MAXNAMELEN];
+
+	if (info->id >= 0) {
+		get_set_byid(setname, info->id);
+		printf("%s%s %s", 
+		       (info->flags[0] & IPSET_MATCH_INV) ? "!" : "",
+		       prefix,
+		       setname); 
+		for (i = 0; i < info->set_level; i++)
+			printf("%s%s",
+			       i == 0 ? ":" : ",",
+			       info->flags[i] & IPSET_SRC ? "src" : "dst");
+		for (i = info->set_level; i < info->ip_level; i++)
+			printf("%s%s",
+			       i == info->set_level ? " " : ",",
+			       info->flags[i] & IPSET_SRC ? "src" : "dst");
+		printf(" ");
+	}
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match, int numeric)
+{
+	struct ipt_set_info_match *info = 
+		(struct ipt_set_info_match *) match->data;
+
+	print_match("set", &info->match);
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip,
+		 const struct ipt_entry_match *match)
+{
+	struct ipt_set_info_match *info = 
+		(struct ipt_set_info_match *) match->data;
+
+	print_match("--set", &info->match);
+}
+
+static
+struct iptables_match set = { NULL,
+	.name		= "set",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_set_info_match)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_set_info_match)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&set);
+}
diff -urN iptables-1.2.9/extensions/libipt_state.man iptables-1.2.10/extensions/libipt_state.man
--- iptables-1.2.9/extensions/libipt_state.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_state.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,21 @@
+This module, when combined with connection tracking, allows access to
+the connection tracking state for this packet.
+.TP
+.BI "--state " "state"
+Where state is a comma separated list of the connection states to
+match.  Possible states are
+.B INVALID
+meaning that the packet could not be identified for some reason which
+includes running out of memory and ICMP errors which don't correspond to any
+known connection,
+.B ESTABLISHED
+meaning that the packet is associated with a connection which has seen
+packets in both directions,
+.B NEW
+meaning that the packet has started a new connection, or otherwise
+associated with a connection which has not seen packets in both
+directions, and
+.B RELATED
+meaning that the packet is starting a new connection, but is
+associated with an existing connection, such as an FTP data transfer,
+or an ICMP error.
diff -urN iptables-1.2.9/extensions/libipt_string.c iptables-1.2.10/extensions/libipt_string.c
--- iptables-1.2.9/extensions/libipt_string.c	2003-05-03 20:52:15.000000000 +0200
+++ iptables-1.2.10/extensions/libipt_string.c	2004-01-05 10:50:12.000000000 +0100
@@ -3,6 +3,13 @@
  * Copyright (C) 2000 Emmanuel Roger  <winfield@freegates.be>
  *
  * ChangeLog
+ *     29.12.2003: Michael Rash <mbr@cipherdyne.org>
+ *             Fixed iptables save/restore for ascii strings
+ *             that contain space chars, and hex strings that
+ *             contain embedded NULL chars.  Updated to print
+ *             strings in hex mode if any non-printable char
+ *             is contained within the string.
+ *
  *     27.01.2001: Gianni Tedesco <gianni@ecsc.co.uk>
  *             Changed --tos to --string in save(). Also
  *             updated to work with slightly modified
@@ -77,8 +84,12 @@
 		} else if (s[i] == '|') {
 			if (hex_f)
 				hex_f = 0;
-			else
+			else {
 				hex_f = 1;
+				/* get past any initial whitespace just after the '|' */
+				while (s[i+1] == ' ')
+					i++;
+			}
 			if (i+1 >= slen)
 				break;
 			else
@@ -178,9 +189,53 @@
 {
 	if (!flags)
 		exit_error(PARAMETER_PROBLEM,
-			   "STRING match: You must specify `--string'");
+			   "STRING match: You must specify `--string' or `--hex-string'");
 }
 
+/* Test to see if the string contains non-printable chars or quotes */
+static unsigned short int
+is_hex_string(const char *str, const unsigned short int len)
+{
+	unsigned int i;
+	for (i=0; i < len; i++)
+		if (! isprint(str[i]))
+			return 1;  /* string contains at least one non-printable char */
+	/* use hex output if the last char is a "\" */
+	if ((unsigned char) str[len-1] == 0x5c)
+		return 1;
+	return 0;
+}
+
+/* Print string with "|" chars included as one would pass to --hex-string */
+static void
+print_hex_string(const char *str, const unsigned short int len)
+{
+	unsigned int i;
+	/* start hex block */
+	printf("\"|");
+	for (i=0; i < len; i++) {
+		/* see if we need to prepend a zero */
+		if ((unsigned char) str[i] <= 0x0F)
+			printf("0%x", (unsigned char) str[i]);
+		else
+			printf("%x", (unsigned char) str[i]);
+	}
+	/* close hex block */
+	printf("|\" ");
+}
+
+static void
+print_string(const char *str, const unsigned short int len)
+{
+	unsigned int i;
+	printf("\"");
+	for (i=0; i < len; i++) {
+		if ((unsigned char) str[i] == 0x22)  /* escape any embedded quotes */
+			printf("%c", 0x5c);
+		printf("%c", (unsigned char) str[i]);
+	}
+	printf("\" ");  /* closing space and quote */
+}
 
 /* Prints out the matchinfo. */
 static void
@@ -191,7 +246,13 @@
 	const struct ipt_string_info *info =
 	    (const struct ipt_string_info*) match->data;
 
-	printf("STRING match %s%s ", (info->invert) ? "!" : "", info->string);
+	if (is_hex_string(info->string, info->len)) {
+		printf("STRING match %s", (info->invert) ? "!" : "");
+		print_hex_string(info->string, info->len);
+	} else {
+		printf("STRING match %s", (info->invert) ? "!" : "");
+		print_string(info->string, info->len);
+	}
 }
 
 
@@ -202,7 +263,13 @@
 	const struct ipt_string_info *info =
 	    (const struct ipt_string_info*) match->data;
 
-	printf("--string %s%s ", (info->invert) ? "! ": "", info->string);
+	if (is_hex_string(info->string, info->len)) {
+		printf("--hex-string %s", (info->invert) ? "! ": "");
+		print_hex_string(info->string, info->len);
+	} else {
+		printf("--string %s", (info->invert) ? "! ": "");
+		print_string(info->string, info->len);
+	}
 }
 
 
diff -urN iptables-1.2.9/extensions/libipt_tcp.man iptables-1.2.10/extensions/libipt_tcp.man
--- iptables-1.2.9/extensions/libipt_tcp.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_tcp.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,49 @@
+These extensions are loaded if `--protocol tcp' is specified. It
+provides the following options:
+.TP
+.BR "--source-port " "[!] \fIport\fP[:\fIport\fP]"
+Source port or port range specification. This can either be a service
+name or a port number. An inclusive range can also be specified,
+using the format
+.IR port : port .
+If the first port is omitted, "0" is assumed; if the last is omitted,
+"65535" is assumed.
+If the second port greater then the first they will be swapped.
+The flag
+.B --sport
+is a convenient alias for this option.
+.TP
+.BR "--destination-port " "[!] \fIport\fP[:\fIport\fP]"
+Destination port or port range specification.  The flag
+.B --dport
+is a convenient alias for this option.
+.TP
+.BR "--tcp-flags " "[!] \fImask\fP \fIcomp\fP"
+Match when the TCP flags are as specified.  The first argument is the
+flags which we should examine, written as a comma-separated list, and
+the second argument is a comma-separated list of flags which must be
+set.  Flags are:
+.BR "SYN ACK FIN RST URG PSH ALL NONE" .
+Hence the command
+.nf
+ iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN
+.fi
+will only match packets with the SYN flag set, and the ACK, FIN and
+RST flags unset.
+.TP
+.B "[!] --syn"
+Only match TCP packets with the SYN bit set and the ACK and RST bits
+cleared.  Such packets are used to request TCP connection initiation;
+for example, blocking such packets coming in an interface will prevent
+incoming TCP connections, but outgoing TCP connections will be
+unaffected.
+It is equivalent to \fB--tcp-flags SYN,RST,ACK SYN\fP.
+If the "!" flag precedes the "--syn", the sense of the
+option is inverted.
+.TP
+.BR "--tcp-option " "[!] \fInumber\fP"
+Match if TCP option set.
+.TP
+.BR "--mss " "\fIvalue\fP[:\fIvalue\fP]"
+Match TCP SYN or SYN/ACK packets with the specified MSS value (or range),
+which control the maximum packet size for that connection.
diff -urN iptables-1.2.9/extensions/libipt_tcpmss.man iptables-1.2.10/extensions/libipt_tcpmss.man
--- iptables-1.2.9/extensions/libipt_tcpmss.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_tcpmss.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,4 @@
+This matches the TCP MSS (maximum segment size) field of the TCP header.  You can only use this on TCP SYN or SYN/ACK packets, since the MSS is only negotiated during the TCP handshake at connection startup time.
+.TP
+.BI "[!] "--mss " "value[:value]"
+Match a given TCP MSS value or range.
diff -urN iptables-1.2.9/extensions/libipt_time.c iptables-1.2.10/extensions/libipt_time.c
--- iptables-1.2.9/extensions/libipt_time.c	2003-03-02 17:16:45.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_time.c	2004-05-16 10:48:04.000000000 +0200
@@ -3,6 +3,7 @@
 #include <netdb.h>
 #include <string.h>
 #include <stdlib.h>
+#include <stddef.h> /* for 'offsetof' */
 #include <getopt.h>
 
 #include <iptables.h>
@@ -17,10 +18,26 @@
 {
 	printf(
 "TIME v%s options:\n"
-" --timestart value --timestop value --days listofdays\n"
-"          timestart value : HH:MM\n"
-"          timestop  value : HH:MM\n"
-"          listofdays value: a list of days to apply -> ie. Mon,Tue,Wed,Thu,Fri. Case sensitive\n",
+" [ --timestart value ] [ --timestop value] [ --days listofdays ] [ --datestart value ] [ --datestop value ]\n"
+"          timestart value : HH:MM (default 00:00)\n"
+"          timestop  value : HH:MM (default 23:59)\n"
+"          listofdays value: a list of days to apply\n"
+"                            from Mon,Tue,Wed,Thu,Fri,Sat,Sun\n"
+"                            Coma speparated, no space, case sensitive.\n"
+"                            Defaults to all days.\n"
+"          datestart value : YYYY[:MM[:DD[:hh[:mm[:ss]]]]]\n"
+"                            If any of month, day, hour, minute or second is\n"
+"                            not specified, then defaults to their smallest\n"
+"                            1900 <= YYYY < 2037\n"
+"                               1 <= MM <= 12\n"
+"                               1 <= DD <= 31\n"
+"                               0 <= hh <= 23\n"
+"                               0 <= mm <= 59\n"
+"                               0 <= ss <= 59\n"
+"          datestop  value : YYYY[:MM[:DD[:hh[:mm[:ss]]]]]\n"
+"                            If the whole option is ommited, default to never stop\n"
+"                            If any of month, day, hour, minute or second is\n"
+"                            not specified, then default to their smallest\n",
 IPTABLES_VERSION);
 }
 
@@ -28,6 +45,8 @@
 	{ "timestart", 1, 0, '1' },
 	{ "timestop", 1, 0, '2' },
 	{ "days", 1, 0, '3'},
+	{ "datestart", 1, 0, '4' },
+	{ "datestop", 1, 0, '5' },
 	{0}
 };
 
@@ -35,9 +54,18 @@
 static void
 init(struct ipt_entry_match *m, unsigned int *nfcache)
 {
+	struct ipt_time_info *info = (struct ipt_time_info *)m->data;
+	globaldays = 0;
 	/* caching not yet implemented */
         *nfcache |= NFC_UNKNOWN;
-	globaldays = 0;
+        /* By default, we match on everyday */
+	info->days_match = 127;
+	/* By default, we match on every hour:min of the day */
+	info->time_start = 0;
+	info->time_stop  = 1439;  /* (23*60+59 = 1439 */
+	/* By default, we don't have any date-begin or date-end boundaries */
+	info->date_start = 0;
+	info->date_stop  = LONG_MAX;
 }
 
 /**
@@ -77,36 +105,45 @@
 	return 1;
 }
 
+static int
+parse_number(char *str, int num_min, int num_max, int *number)
+{
+	/* if the number starts with 0, replace it with a space else
+	string_to_number() will interpret it as octal !! */
+	if (strlen(str) == 0)
+		return 0;
+
+	if ((str[0] == '0') && (str[1] != '\0'))
+		str[0] = ' ';
+
+	return string_to_number(str, num_min, num_max, number);
+}
+
 static void
-parse_time_string(unsigned int *hour, unsigned int *minute, const char *time)
+parse_time_string(int *hour, int *minute, const char *time)
 {
 	char *hours;
 	char *minutes;
-
 	hours = (char *)malloc(3);
 	minutes = (char *)malloc(3);
-	bzero((void *)hours, 3);
-	bzero((void *)minutes, 3);
+	memset(hours, 0, 3);
+	memset(minutes, 0, 3);
 
-	if (split_time(&hours, &minutes, time) == 1)
+	if (split_time((char **)&hours, (char **)&minutes, time) == 1)
 	{
-                /* if the number starts with 0, replace it with a space else
-                   this string_to_number will interpret it as octal !! */
-                if ((hours[0] == '0') && (hours[1] != '\0'))
-			hours[0] = ' ';
-		if ((minutes[0] == '0') && (minutes[1] != '\0'))
-			minutes[0] = ' ';
-
-		if((string_to_number(hours, 0, 23, hour) == -1) ||
-			(string_to_number(minutes, 0, 59, minute) == -1)) {
-			*hour = *minute = (-1);
+		*hour = 0;
+		*minute = 0;
+		if ((parse_number((char *)hours, 0, 23, hour) != -1) &&
+		    (parse_number((char *)minutes, 0, 59, minute) != -1))
+		{
+			free(hours);
+			free(minutes);
+			return;
 		}
 	}
-	if ((*hour != (-1)) && (*minute != (-1))) {
-		free(hours);
-		free(minutes);
-		return;
-	}
+
+	free(hours);
+	free(minutes);
 
 	/* If we are here, there was a problem ..*/
 	exit_error(PARAMETER_PROBLEM,
@@ -160,10 +197,139 @@
 	}
 }
 
+static int
+parse_date_field(const char *str_to_parse, int str_to_parse_s, int start_pos,
+                 char *dest, int *next_pos)
+{
+	unsigned char found_value = 0;
+	unsigned char found_column = 0;
+	int i;
+
+	for (i=0; i<2; i++)
+	{
+		if ((i+start_pos) >= str_to_parse_s) /* don't exit boundaries of the string..  */
+			break;
+		if (str_to_parse[i+start_pos] == ':')
+			found_column = 1;
+		else
+		{
+			found_value = 1;
+			dest[i] = str_to_parse[i+start_pos];
+		}
+	}
+	if (found_value == 0)
+		return 0;
+	*next_pos = i + start_pos;
+	if (found_column == 0)
+		++(*next_pos);
+	return 1;
+}
+
+static int
+split_date(char *year, char *month,  char *day,
+           char *hour, char *minute, char *second,
+           const char *str_to_parse)
+{
+        int i;
+        unsigned char found_column = 0;
+	int str_to_parse_s = strlen(str_to_parse);
+
+        /* Check the length of the string */
+        if ((str_to_parse_s > 19) ||  /* YYYY:MM:DD:HH:MM:SS */
+            (str_to_parse_s < 4))     /* YYYY*/
+                return 0;
+
+	/* Clear the buffers */
+        memset(year, 0, 4);
+	memset(month, 0, 2);
+	memset(day, 0, 2);
+	memset(hour, 0, 2);
+	memset(minute, 0, 2);
+	memset(second, 0, 2);
+
+	/* parse the year YYYY */
+	found_column = 0;
+	for (i=0; i<5; i++)
+	{
+		if (i >= str_to_parse_s)
+			break;
+		if (str_to_parse[i] == ':')
+		{
+			found_column = 1;
+			break;
+		}
+		else
+			year[i] = str_to_parse[i];
+	}
+	if (found_column == 1)
+		++i;
+
+	/* parse the month if it exists */
+	if (! parse_date_field(str_to_parse, str_to_parse_s, i, month, &i))
+		return 1;
+
+	if (! parse_date_field(str_to_parse, str_to_parse_s, i, day, &i))
+		return 1;
+
+	if (! parse_date_field(str_to_parse, str_to_parse_s, i, hour, &i))
+		return 1;
+
+	if (! parse_date_field(str_to_parse, str_to_parse_s, i, minute, &i))
+		return 1;
+
+	parse_date_field(str_to_parse, str_to_parse_s, i, second, &i);
+
+        /* if we are here, format should be ok. */
+        return 1;
+}
+
+static time_t
+parse_date_string(const char *str_to_parse)
+{
+	char year[5];
+	char month[3];
+	char day[3];
+	char hour[3];
+	char minute[3];
+	char second[3];
+	struct tm t;
+	time_t temp_time;
+
+	memset(year, 0, 5);
+	memset(month, 0, 3);
+	memset(day, 0, 3);
+	memset(hour, 0, 3);
+	memset(minute, 0, 3);
+	memset(second, 0, 3);
+
+        if (split_date(year, month, day, hour, minute, second, str_to_parse) == 1)
+        {
+		memset((void *)&t, 0, sizeof(struct tm));
+		t.tm_isdst = -1;
+		t.tm_mday = 1;
+		if (!((parse_number(year, 1900, 2037, &(t.tm_year)) == -1) ||
+		      (parse_number(month, 1, 12, &(t.tm_mon)) == -1) ||
+		      (parse_number(day, 1, 31, &(t.tm_mday)) == -1) ||
+		      (parse_number(hour, 0, 9999, &(t.tm_hour)) == -1) ||
+		      (parse_number(minute, 0, 59, &(t.tm_min)) == -1) ||
+		      (parse_number(second, 0, 59, &(t.tm_sec)) == -1)))
+		{
+			t.tm_year -= 1900;
+			--(t.tm_mon);
+			temp_time = mktime(&t);
+			if (temp_time != -1)
+				return temp_time;
+		}
+	}
+	exit_error(PARAMETER_PROBLEM,
+		   "invalid date `%s' specified, should be YYYY[:MM[:DD[:hh[:mm[:ss]]]]] format", str_to_parse);
+}
+
 #define IPT_TIME_START 0x01
 #define IPT_TIME_STOP  0x02
 #define IPT_TIME_DAYS  0x04
-
+#define IPT_DATE_START 0x08
+#define IPT_DATE_STOP  0x10
 
 /* Function which parses command options; returns true if it
    ate an option */
@@ -175,6 +341,7 @@
 {
 	struct ipt_time_info *timeinfo = (struct ipt_time_info *)(*match)->data;
 	int hours, minutes;
+	time_t temp_date;
 
 	switch (c)
 	{
@@ -215,19 +382,43 @@
 		timeinfo->days_match = globaldays;
 		*flags |= IPT_TIME_DAYS;
 		break;
+
+		/* datestart */
+	case '4':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --datestart");
+		if (*flags & IPT_DATE_START)
+			exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --datestart twice");
+		temp_date = parse_date_string(optarg);
+		timeinfo->date_start = temp_date;
+		*flags |= IPT_DATE_START;
+		break;
+
+		/* datestop*/
+	case '5':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --datestop");
+		if (*flags & IPT_DATE_STOP)
+			exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --datestop twice");
+		temp_date = parse_date_string(optarg);
+		timeinfo->date_stop = temp_date;
+		*flags |= IPT_DATE_STOP;
+		break;
 	default:
 		return 0;
 	}
 	return 1;
 }
 
-/* Final check; must have specified --timestart --timestop --days. */
+/* Final check */
 static void
 final_check(unsigned int flags)
 {
-	if (flags != (IPT_TIME_START | IPT_TIME_STOP | IPT_TIME_DAYS))
-		exit_error(PARAMETER_PROBLEM,
-			   "TIME match: You must specify `--timestart --timestop and --days'");
+	/* Nothing to do */
 }
 
 
@@ -248,6 +439,7 @@
 			++nbdays;
 		}
 	}
+	printf(" ");
 }
 
 static void
@@ -257,6 +449,22 @@
 	*minutes = fulltime % 60;
 }
 
+static void
+print_date(time_t date, char *command)
+{
+	/* If it's default value, don't print..*/
+	if (((date == 0) || (date == LONG_MAX)) && (command != NULL))
+		return;
+	struct tm *t;
+	t = localtime(&date);
+	if (command != NULL)
+		printf("%s %d:%d:%d:%d:%d:%d ", command, (t->tm_year + 1900), (t->tm_mon + 1),
+			t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
+        else
+        	printf("%d-%d-%d %d:%d:%d ", (t->tm_year + 1900), (t->tm_mon + 1),
+			t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
+}
+
 /* Prints out the matchinfo. */
 static void
 print(const struct ipt_ip *ip,
@@ -268,11 +476,26 @@
 
 	divide_time(time->time_start, &hour_start, &minute_start);
 	divide_time(time->time_stop, &hour_stop, &minute_stop);
-	printf(" TIME from %d:%d to %d:%d on ",
-	       hour_start, minute_start,
-	       hour_stop, minute_stop);
-	print_days(time->days_match);
-	printf(" ");
+	printf("TIME ");
+	if (time->time_start != 0)
+		printf("from %d:%d ", hour_start, minute_start);
+	if (time->time_stop != 1439) /* 23*60+59 = 1439 */
+		printf("to %d:%d ", hour_stop, minute_stop);
+	printf("on ");
+	if (time->days_match == 127)
+		printf("all days ");
+	else
+		print_days(time->days_match);
+	if (time->date_start != 0)
+	{
+		printf("starting from ");
+		print_date(time->date_start, NULL);
+	}
+	if (time->date_stop != LONG_MAX)
+	{
+		printf("until date ");
+		print_date(time->date_stop, NULL);
+	}
 }
 
 /* Saves the data in parsable form to stdout. */
@@ -284,20 +507,33 @@
 
 	divide_time(time->time_start, &hour_start, &minute_start);
 	divide_time(time->time_stop, &hour_stop, &minute_stop);
-	printf(" --timestart %.2d:%.2d --timestop %.2d:%.2d --days ",
-	       hour_start, minute_start,
-	       hour_stop, minute_stop);
-	print_days(time->days_match);
-	printf(" ");
+	if (time->time_start != 0)
+		printf("--timestart %.2d:%.2d ",
+		        hour_start, minute_start);
+	
+	if (time->time_stop != 1439) /* 23*60+59 = 1439 */
+		printf("--timestop %.2d:%.2d ",
+		        hour_stop, minute_stop);
+	
+	if (time->days_match != 127)
+	{
+		printf("--days ");
+		print_days(time->days_match);
+		printf(" ");
+	}
+	print_date(time->date_start, "--datestart");
+	print_date(time->date_stop, "--datestop");
 }
 
+/* have to use offsetof() instead of IPT_ALIGN(), since kerneltime must not
+ * be compared when user deletes rule with '-D' */
 static
 struct iptables_match timestruct
 = { NULL,
     "time",
     IPTABLES_VERSION,
     IPT_ALIGN(sizeof(struct ipt_time_info)),
-    IPT_ALIGN(sizeof(struct ipt_time_info)),
+    offsetof(struct ipt_time_info, kerneltime),
     &help,
     &init,
     &parse,
diff -urN iptables-1.2.9/extensions/libipt_time.man iptables-1.2.10/extensions/libipt_time.man
--- iptables-1.2.9/extensions/libipt_time.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_time.man	2004-05-16 10:48:04.000000000 +0200
@@ -0,0 +1,16 @@
+This matches if the packet arrival time/date is within a given range. All options are facultative.
+.TP
+.BI " --timestart " "value"
+Match only if it is after `value' (Inclusive, format: HH:MM ; default 00:00).
+.TP
+.BI "--timestop  " "value"
+Match only if it is before `value' (Inclusive, format: HH:MM ; default 23:59).
+.TP
+.BI "--days " "listofdays"
+Match only if today is one of the given days. (format: Mon,Tue,Wed,Thu,Fri,Sat,Sun ; default everyday)
+.TP
+.BI "--datestart " "date"
+Match only if it is after `date' (Inclusive, format: YYYY[:MM[:DD[:hh[:mm[:ss]]]]] ; h,m,s start from 0 ; default to 1970)
+.TP
+.BI "--datestop " "date"
+Match only if it is before `date' (Inclusive, format: YYYY[:MM[:DD[:hh[:mm[:ss]]]]] ; h,m,s start from 0 ; default to 2037)
diff -urN iptables-1.2.9/extensions/libipt_tos.man iptables-1.2.10/extensions/libipt_tos.man
--- iptables-1.2.9/extensions/libipt_tos.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_tos.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,9 @@
+This module matches the 8 bits of Type of Service field in the IP
+header (ie. including the precedence bits).
+.TP
+.BI "--tos " "tos"
+The argument is either a standard name, (use
+.br
+ iptables -m tos -h
+.br
+to see the list), or a numeric value to match.
diff -urN iptables-1.2.9/extensions/libipt_ttl.man iptables-1.2.10/extensions/libipt_ttl.man
--- iptables-1.2.9/extensions/libipt_ttl.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_ttl.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,10 @@
+This module matches the time to live field in the IP header.
+.TP
+.BI "--ttl-eq " "ttl"
+Matches the given TTL value.
+.TP
+.BI "--ttl-gt " "ttl"
+Matches if TTL is greater than the given TTL value.
+.TP
+.BI "--ttl-lt " "ttl"
+Matches if TTL is less than the given TTL value.
diff -urN iptables-1.2.9/extensions/libipt_udp.man iptables-1.2.10/extensions/libipt_udp.man
--- iptables-1.2.9/extensions/libipt_udp.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_udp.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,14 @@
+These extensions are loaded if `--protocol udp' is specified.  It
+provides the following options:
+.TP
+.BR "--source-port " "[!] \fIport\fP[:\fIport\fP]"
+Source port or port range specification.
+See the description of the
+.B --source-port
+option of the TCP extension for details.
+.TP
+.BR "--destination-port " "[!] \fIport\fP[:\fIport\fP]"
+Destination port or port range specification.
+See the description of the
+.B --destination-port
+option of the TCP extension for details.
diff -urN iptables-1.2.9/extensions/libipt_unclean.man iptables-1.2.10/extensions/libipt_unclean.man
--- iptables-1.2.9/extensions/libipt_unclean.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/extensions/libipt_unclean.man	2004-01-22 16:04:25.000000000 +0100
@@ -0,0 +1,2 @@
+This module takes no options, but attempts to match packets which seem
+malformed or unusual.  This is regarded as experimental.
diff -urN iptables-1.2.9/include/ip6tables.h iptables-1.2.10/include/ip6tables.h
--- iptables-1.2.9/include/ip6tables.h	2003-03-05 08:44:18.000000000 +0100
+++ iptables-1.2.10/include/ip6tables.h	2004-02-19 19:04:20.000000000 +0100
@@ -4,6 +4,13 @@
 #include "iptables_common.h"
 #include "libiptc/libip6tc.h"
 
+struct ip6tables_rule_match
+{
+	struct ip6tables_rule_match *next;
+
+	struct ip6tables_match *match;
+};
+
 /* Include file for additions: new matches and targets. */
 struct ip6tables_match
 {
@@ -50,7 +57,6 @@
 	unsigned int option_offset;
 	struct ip6t_entry_match *m;
 	unsigned int mflags;
-	unsigned int used;
 #ifdef NO_SHARED_LIBS
 	unsigned int loaded; /* simulate loading so options are merged properly */
 #endif
@@ -125,7 +131,7 @@
 };
 
 extern struct ip6tables_target *find_target(const char *name, enum ip6t_tryload);
-extern struct ip6tables_match *find_match(const char *name, enum ip6t_tryload);
+extern struct ip6tables_match *find_match(const char *name, enum ip6t_tryload, struct ip6tables_rule_match **match);
 
 extern int for_each_chain(int (*fn)(const ip6t_chainlabel, int, ip6tc_handle_t *), int verbose, int builtinstoo, ip6tc_handle_t *handle);
 extern int flush_entries(const ip6t_chainlabel chain, int verbose, ip6tc_handle_t *handle);
diff -urN iptables-1.2.9/include/iptables.h iptables-1.2.10/include/iptables.h
--- iptables-1.2.9/include/iptables.h	2003-03-05 08:26:13.000000000 +0100
+++ iptables-1.2.10/include/iptables.h	2004-03-04 08:36:18.000000000 +0100
@@ -4,6 +4,17 @@
 #include "iptables_common.h"
 #include "libiptc/libiptc.h"
 
+#ifndef IPPROTO_SCTP
+#define IPPROTO_SCTP 132
+#endif
+
+struct iptables_rule_match
+{
+	struct iptables_rule_match *next;
+
+	struct iptables_match *match;
+};
+
 /* Include file for additions: new matches and targets. */
 struct iptables_match
 {
@@ -50,7 +61,6 @@
 	unsigned int option_offset;
 	struct ipt_entry_match *m;
 	unsigned int mflags;
-	unsigned int used;
 #ifdef NO_SHARED_LIBS
 	unsigned int loaded; /* simulate loading so options are merged properly */
 #endif
@@ -134,7 +144,7 @@
 };
 
 extern struct iptables_target *find_target(const char *name, enum ipt_tryload);
-extern struct iptables_match *find_match(const char *name, enum ipt_tryload);
+extern struct iptables_match *find_match(const char *name, enum ipt_tryload, struct iptables_rule_match **match);
 
 extern int delete_chain(const ipt_chainlabel chain, int verbose,
 			iptc_handle_t *handle);
diff -urN iptables-1.2.9/include/iptables_common.h iptables-1.2.10/include/iptables_common.h
--- iptables-1.2.9/include/iptables_common.h	2003-03-02 17:15:17.000000000 +0100
+++ iptables-1.2.10/include/iptables_common.h	2004-06-15 00:02:17.000000000 +0200
@@ -14,6 +14,14 @@
 			    unsigned int, 
 			    unsigned int,
 			    unsigned int *);
+extern int string_to_number_l(const char *, 
+			    unsigned long int, 
+			    unsigned long int,
+			    unsigned long *);
+extern int string_to_number_ll(const char *, 
+			    unsigned long long int, 
+			    unsigned long long int,
+			    unsigned long long *);
 extern int iptables_insmod(const char *modname, const char *modprobe);
 void exit_error(enum exittype, char *, ...)__attribute__((noreturn,
 							  format(printf,2,3)));
diff -urN iptables-1.2.9/include/linux/netfilter_ipv4/ipt_CONNMARK.h iptables-1.2.10/include/linux/netfilter_ipv4/ipt_CONNMARK.h
--- iptables-1.2.9/include/linux/netfilter_ipv4/ipt_CONNMARK.h	2003-08-24 00:09:24.000000000 +0200
+++ iptables-1.2.10/include/linux/netfilter_ipv4/ipt_CONNMARK.h	2004-02-19 19:04:21.000000000 +0100
@@ -1,6 +1,15 @@
 #ifndef _IPT_CONNMARK_H_target
 #define _IPT_CONNMARK_H_target
 
+/* Copyright (C) 2002,2004 MARA Systems AB <http://www.marasystems.com>
+ * by Henrik Nordstrom <hno@marasystems.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
 enum {
 	IPT_CONNMARK_SET = 0,
 	IPT_CONNMARK_SAVE,
@@ -9,6 +18,7 @@
 
 struct ipt_connmark_target_info {
 	unsigned long mark;
+	unsigned long mask;
 	u_int8_t mode;
 };
 
diff -urN iptables-1.2.9/include/linux/netfilter_ipv4/ipt_MARK.h iptables-1.2.10/include/linux/netfilter_ipv4/ipt_MARK.h
--- iptables-1.2.9/include/linux/netfilter_ipv4/ipt_MARK.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/include/linux/netfilter_ipv4/ipt_MARK.h	2004-05-26 23:56:26.000000000 +0200
@@ -0,0 +1,12 @@
+#ifndef _IPT_MARK_H_target
+#define _IPT_MARK_H_target
+
+struct ipt_mark_target_info {
+#ifdef KERNEL_64_USERSPACE_32
+	unsigned long long mark;
+#else
+	unsigned long mark;
+#endif
+};
+
+#endif /*_IPT_MARK_H_target*/
diff -urN iptables-1.2.9/include/linux/netfilter_ipv4/ipt_SAME.h iptables-1.2.10/include/linux/netfilter_ipv4/ipt_SAME.h
--- iptables-1.2.9/include/linux/netfilter_ipv4/ipt_SAME.h	2001-08-26 10:18:25.000000000 +0200
+++ iptables-1.2.10/include/linux/netfilter_ipv4/ipt_SAME.h	2004-06-15 00:02:17.000000000 +0200
@@ -8,12 +8,13 @@
 struct ipt_same_info
 {
 	unsigned char info;
-
-	unsigned int rangesize;
-
-	unsigned int ipnum;
-
+	u_int32_t rangesize;
+	u_int32_t ipnum;
+#ifdef KERNEL_64_USERSPACE_32
+	u_int64_t placeholder;
+#else
 	u_int32_t *iparray;
+#endif
 
 	/* hangs off end. */
 	struct ip_nat_range range[IPT_SAME_MAX_RANGE];
diff -urN iptables-1.2.9/include/linux/netfilter_ipv4/ipt_ULOG.h iptables-1.2.10/include/linux/netfilter_ipv4/ipt_ULOG.h
--- iptables-1.2.9/include/linux/netfilter_ipv4/ipt_ULOG.h	2002-02-07 10:18:28.000000000 +0100
+++ iptables-1.2.10/include/linux/netfilter_ipv4/ipt_ULOG.h	2004-06-15 00:02:17.000000000 +0200
@@ -1,4 +1,4 @@
-/* Header file for IP tables userspace logging, Version 1.8 
+/* Header file for IP tables userspace logging, Version 1.8
  *
  * (C) 2000-2002 by Harald Welte <laforge@gnumonks.org>
  * 
@@ -11,6 +11,9 @@
 #define NETLINK_NFLOG 	5
 #endif
 
+#define ULOG_DEFAULT_NLGROUP	1
+#define ULOG_DEFAULT_QTHRESHOLD	1
+
 #define ULOG_MAC_LEN	80
 #define ULOG_PREFIX_LEN	32
 
@@ -23,8 +26,13 @@
 /* private data structure for each rule with a ULOG target */
 struct ipt_ulog_info {
 	unsigned int nl_group;
+#ifdef KERNEL_64_USERSPACE_32
+	unsigned long long copy_range;
+	unsigned long long qthreshold;
+#else
 	size_t copy_range;
 	size_t qthreshold;
+#endif
 	char prefix[ULOG_PREFIX_LEN];
 };
 
diff -urN iptables-1.2.9/include/linux/netfilter_ipv4/ipt_connmark.h iptables-1.2.10/include/linux/netfilter_ipv4/ipt_connmark.h
--- iptables-1.2.9/include/linux/netfilter_ipv4/ipt_connmark.h	2003-08-24 00:07:10.000000000 +0200
+++ iptables-1.2.10/include/linux/netfilter_ipv4/ipt_connmark.h	2004-02-19 19:04:21.000000000 +0100
@@ -1,6 +1,15 @@
 #ifndef _IPT_CONNMARK_H
 #define _IPT_CONNMARK_H
 
+/* Copyright (C) 2002,2004 MARA Systems AB <http://www.marasystems.com>
+ * by Henrik Nordstrom <hno@marasystems.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
 struct ipt_connmark_info {
 	unsigned long mark, mask;
 	u_int8_t invert;
diff -urN iptables-1.2.9/include/linux/netfilter_ipv4/ipt_conntrack.h iptables-1.2.10/include/linux/netfilter_ipv4/ipt_conntrack.h
--- iptables-1.2.9/include/linux/netfilter_ipv4/ipt_conntrack.h	2002-03-18 13:46:23.000000000 +0100
+++ iptables-1.2.10/include/linux/netfilter_ipv4/ipt_conntrack.h	2004-06-15 00:02:17.000000000 +0200
@@ -10,6 +10,7 @@
 
 #define IPT_CONNTRACK_STATE_SNAT (1 << (IP_CT_NUMBER + 1))
 #define IPT_CONNTRACK_STATE_DNAT (1 << (IP_CT_NUMBER + 2))
+#define IPT_CONNTRACK_STATE_UNTRACKED (1 << (IP_CT_NUMBER + 3))
 
 /* flags, invflags: */
 #define IPT_CONNTRACK_STATE	0x01
@@ -28,7 +29,11 @@
 	struct ip_conntrack_tuple tuple[IP_CT_DIR_MAX];
 	struct in_addr sipmsk[IP_CT_DIR_MAX], dipmsk[IP_CT_DIR_MAX];
 
+#ifdef KERNEL_64_USERSPACE_32
+	unsigned long long expires_min, expires_max;
+#else
 	unsigned long expires_min, expires_max;
+#endif
 
 	/* Flags word */
 	u_int8_t flags;
@@ -36,4 +41,3 @@
 	u_int8_t invflags;
 };
 #endif /*_IPT_CONNTRACK_H*/
-
diff -urN iptables-1.2.9/include/linux/netfilter_ipv4/ipt_dstlimit.h iptables-1.2.10/include/linux/netfilter_ipv4/ipt_dstlimit.h
--- iptables-1.2.9/include/linux/netfilter_ipv4/ipt_dstlimit.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/include/linux/netfilter_ipv4/ipt_dstlimit.h	2004-04-16 10:13:24.000000000 +0200
@@ -0,0 +1,39 @@
+#ifndef _IPT_DSTLIMIT_H
+#define _IPT_DSTLIMIT_H
+
+/* timings are in milliseconds. */
+#define IPT_DSTLIMIT_SCALE 10000
+/* 1/10,000 sec period => max of 10,000/sec.  Min rate is then 429490
+   seconds, or one every 59 hours. */
+
+/* details of this structure hidden by the implementation */
+struct ipt_dstlimit_htable;
+
+#define IPT_DSTLIMIT_HASH_DIP	0x0001
+#define IPT_DSTLIMIT_HASH_DPT	0x0002
+#define IPT_DSTLIMIT_HASH_SIP	0x0004
+
+struct dstlimit_cfg {
+	u_int32_t mode;	  /* bitmask of IPT_DSTLIMIT_HASH_* */
+	u_int32_t avg;    /* Average secs between packets * scale */
+	u_int32_t burst;  /* Period multiplier for upper limit. */
+
+	/* user specified */
+	u_int32_t size;		/* how many buckets */
+	u_int32_t max;		/* max number of entries */
+	u_int32_t gc_interval;	/* gc interval */
+	u_int32_t expire;	/* when do entries expire? */
+};
+
+struct ipt_dstlimit_info {
+	char name [IFNAMSIZ];		/* name */
+	struct dstlimit_cfg cfg;
+	struct ipt_dstlimit_htable *hinfo;
+
+	/* Used internally by the kernel */
+	union {
+		void *ptr;
+		struct ipt_dstlimit_info *master;
+	} u;
+};
+#endif /*_IPT_DSTLIMIT_H*/
diff -urN iptables-1.2.9/include/linux/netfilter_ipv4/ipt_limit.h iptables-1.2.10/include/linux/netfilter_ipv4/ipt_limit.h
--- iptables-1.2.9/include/linux/netfilter_ipv4/ipt_limit.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/include/linux/netfilter_ipv4/ipt_limit.h	2004-05-26 17:50:57.000000000 +0200
@@ -0,0 +1,26 @@
+#ifndef _IPT_RATE_H
+#define _IPT_RATE_H
+
+/* timings are in milliseconds. */
+#define IPT_LIMIT_SCALE 10000
+
+/* 1/10,000 sec period => max of 10,000/sec.  Min rate is then 429490
+   seconds, or one every 59 hours. */
+struct ipt_rateinfo {
+	u_int32_t avg;    /* Average secs between packets * scale */
+	u_int32_t burst;  /* Period multiplier for upper limit. */
+
+#ifdef KERNEL_64_USERSPACE_32
+	u_int64_t prev;
+	u_int64_t placeholder;
+#else
+	/* Used internally by the kernel */
+	unsigned long prev;
+	/* Ugly, ugly fucker. */
+	struct ipt_rateinfo *master;
+#endif
+
+	u_int32_t credit;
+	u_int32_t credit_cap, cost;
+};
+#endif /*_IPT_RATE_H*/
diff -urN iptables-1.2.9/include/linux/netfilter_ipv4/ipt_mark.h iptables-1.2.10/include/linux/netfilter_ipv4/ipt_mark.h
--- iptables-1.2.9/include/linux/netfilter_ipv4/ipt_mark.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/include/linux/netfilter_ipv4/ipt_mark.h	2004-05-26 23:56:26.000000000 +0200
@@ -0,0 +1,13 @@
+#ifndef _IPT_MARK_H
+#define _IPT_MARK_H
+
+struct ipt_mark_info {
+#ifdef KERNEL_64_USERSPACE_32
+    unsigned long long mark, mask;
+#else
+    unsigned long mark, mask;
+#endif
+    u_int8_t invert;
+};
+
+#endif /*_IPT_MARK_H*/
diff -urN iptables-1.2.9/include/linux/netfilter_ipv4/ipt_sctp.h iptables-1.2.10/include/linux/netfilter_ipv4/ipt_sctp.h
--- iptables-1.2.9/include/linux/netfilter_ipv4/ipt_sctp.h	2003-05-03 20:05:58.000000000 +0200
+++ iptables-1.2.10/include/linux/netfilter_ipv4/ipt_sctp.h	2004-03-02 19:28:17.000000000 +0100
@@ -1,25 +1,107 @@
-/* iptables module for matching the SCTP header
- *
- * (C) 2003 Harald Welte <laforge@gnumonks.org>
- *
- * This software is distributed under GNU GPL v2, 1991
- *
- * $Id: ipt_sctp.h,v 1.1 2003/05/03 18:05:58 laforge Exp $
- */
-#ifndef _IPT_SCTP_H
-#define _IPT_SCTP_H
+#ifndef _IPT_SCTP_H_
+#define _IPT_SCTP_H_
+
+#define IPT_SCTP_SRC_PORTS	        0x01
+#define IPT_SCTP_DEST_PORTS	        0x02
+#define IPT_SCTP_CHUNK_TYPES		0x04
+
+#define IPT_SCTP_VALID_FLAGS		0x07
+
+#define ELEMCOUNT(x) (sizeof(x)/sizeof(x[0]))
+
+
+struct ipt_sctp_flag_info {
+	u_int8_t chunktype;
+	u_int8_t flag;
+	u_int8_t flag_mask;
+};
+
+#define IPT_NUM_SCTP_FLAGS	4
 
 struct ipt_sctp_info {
-	u_int16_t spts[2];			/* Souce port range */
-	u_int16_t dpts[2];			/* Destination port range */
-	u_int32_t chunks;			/* chunks to be matched */
-	u_int32_t chunk_mask;			/* chunk mask to be matched */
-	u_int8_t invflags;			/* Inverse flags */
+	u_int16_t dpts[2];  /* Min, Max */
+	u_int16_t spts[2];  /* Min, Max */
+
+	u_int32_t chunkmap[256 / sizeof (u_int32_t)];  /* Bit mask of chunks to be matched according to RFC 2960 */
+
+#define SCTP_CHUNK_MATCH_ANY   0x01  /* Match if any of the chunk types are present */
+#define SCTP_CHUNK_MATCH_ALL   0x02  /* Match if all of the chunk types are present */
+#define SCTP_CHUNK_MATCH_ONLY  0x04  /* Match if these are the only chunk types present */
+
+	u_int32_t chunk_match_type;
+	struct ipt_sctp_flag_info flag_info[IPT_NUM_SCTP_FLAGS];
+	int flag_count;
+
+	u_int32_t flags;
+	u_int32_t invflags;
 };
 
-#define IPT_SCTP_INV_SRCPT	0x01	/* Invert the sense of source ports */
-#define IPT_SCTP_INV_DSTPT	0x02	/* Invert the sense of dest ports */
-#define IPT_SCTP_INV_CHUNKS	0x03	/* Invert the sense of chunks */
-#define IPT_SCTP_INV_MASK	0x03	/* All possible flags */
+#define bytes(type) (sizeof(type) * 8)
+
+#define SCTP_CHUNKMAP_SET(chunkmap, type) 		\
+	do { 						\
+		chunkmap[type / bytes(u_int32_t)] |= 	\
+			1 << (type % bytes(u_int32_t));	\
+	} while (0)
+
+#define SCTP_CHUNKMAP_CLEAR(chunkmap, type)		 	\
+	do {							\
+		chunkmap[type / bytes(u_int32_t)] &= 		\
+			~(1 << (type % bytes(u_int32_t)));	\
+	} while (0)
+
+#define SCTP_CHUNKMAP_IS_SET(chunkmap, type) 			\
+({								\
+	(chunkmap[type / bytes (u_int32_t)] & 			\
+		(1 << (type % bytes (u_int32_t)))) ? 1: 0;	\
+})
+
+#define SCTP_CHUNKMAP_RESET(chunkmap) 				\
+	do {							\
+		int i; 						\
+		for (i = 0; i < ELEMCOUNT(chunkmap); i++)	\
+			chunkmap[i] = 0;			\
+	} while (0)
+
+#define SCTP_CHUNKMAP_SET_ALL(chunkmap) 			\
+	do {							\
+		int i; 						\
+		for (i = 0; i < ELEMCOUNT(chunkmap); i++) 	\
+			chunkmap[i] = ~0;			\
+	} while (0)
+
+#define SCTP_CHUNKMAP_COPY(destmap, srcmap) 			\
+	do {							\
+		int i; 						\
+		for (i = 0; i < ELEMCOUNT(chunkmap); i++) 	\
+			destmap[i] = srcmap[i];			\
+	} while (0)
+
+#define SCTP_CHUNKMAP_IS_CLEAR(chunkmap) 		\
+({							\
+	int i; 						\
+	int flag = 1;					\
+	for (i = 0; i < ELEMCOUNT(chunkmap); i++) {	\
+		if (chunkmap[i]) {			\
+			flag = 0;			\
+			break;				\
+		}					\
+	}						\
+        flag;						\
+})
+
+#define SCTP_CHUNKMAP_IS_ALL_SET(chunkmap) 		\
+({							\
+	int i; 						\
+	int flag = 1;					\
+	for (i = 0; i < ELEMCOUNT(chunkmap); i++) {	\
+		if (chunkmap[i] != ~0) {		\
+			flag = 0;			\
+				break;			\
+		}					\
+	}						\
+        flag;						\
+})
+
+#endif /* _IPT_SCTP_H_ */
 
-#endif /* _IPT_SCTP_H */
diff -urN iptables-1.2.9/include/linux/netfilter_ipv6/ip6t_MARK.h iptables-1.2.10/include/linux/netfilter_ipv6/ip6t_MARK.h
--- iptables-1.2.9/include/linux/netfilter_ipv6/ip6t_MARK.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/include/linux/netfilter_ipv6/ip6t_MARK.h	2004-05-26 23:56:26.000000000 +0200
@@ -0,0 +1,12 @@
+#ifndef _IP6T_MARK_H_target
+#define _IP6T_MARK_H_target
+
+struct ip6t_mark_target_info {
+#ifdef KERNEL_64_USERSPACE_32
+	unsigned long long mark;
+#else
+	unsigned long mark;
+#endif
+};
+
+#endif /*_IPT_MARK_H_target*/
diff -urN iptables-1.2.9/include/linux/netfilter_ipv6/ip6t_limit.h iptables-1.2.10/include/linux/netfilter_ipv6/ip6t_limit.h
--- iptables-1.2.9/include/linux/netfilter_ipv6/ip6t_limit.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/include/linux/netfilter_ipv6/ip6t_limit.h	2004-05-26 18:00:43.000000000 +0200
@@ -0,0 +1,25 @@
+#ifndef _IP6T_RATE_H
+#define _IP6T_RATE_H
+
+/* timings are in milliseconds. */
+#define IP6T_LIMIT_SCALE 10000
+
+/* 1/10,000 sec period => max of 10,000/sec.  Min rate is then 429490
+   seconds, or one every 59 hours. */
+struct ip6t_rateinfo {
+	u_int32_t avg;    /* Average secs between packets * scale */
+	u_int32_t burst;  /* Period multiplier for upper limit. */
+
+#ifdef KERNEL_64_USERSPACE_32
+	u_int64_t prev;
+	u_int64_t placeholder;
+#else
+	/* Used internally by the kernel */
+	unsigned long prev;
+	/* Ugly, ugly fucker. */
+	struct ip6t_rateinfo *master;
+#endif
+	u_int32_t credit;
+	u_int32_t credit_cap, cost;
+};
+#endif /*_IPT_RATE_H*/
diff -urN iptables-1.2.9/include/linux/netfilter_ipv6/ip6t_mark.h iptables-1.2.10/include/linux/netfilter_ipv6/ip6t_mark.h
--- iptables-1.2.9/include/linux/netfilter_ipv6/ip6t_mark.h	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/include/linux/netfilter_ipv6/ip6t_mark.h	2004-05-26 23:56:26.000000000 +0200
@@ -0,0 +1,13 @@
+#ifndef _IP6T_MARK_H
+#define _IP6T_MARK_H
+
+struct ip6t_mark_info {
+#ifdef KERNEL_64_USERSPACE_32
+    unsigned long long mark, mask;
+#else
+    unsigned long mark, mask;
+#endif
+    u_int8_t invert;
+};
+
+#endif /*_IPT_MARK_H*/
diff -urN iptables-1.2.9/ip6tables-restore.c iptables-1.2.10/ip6tables-restore.c
--- iptables-1.2.9/ip6tables-restore.c	2003-05-03 20:52:13.000000000 +0200
+++ iptables-1.2.10/ip6tables-restore.c	2004-06-15 00:02:16.000000000 +0200
@@ -7,7 +7,7 @@
  * 	Rusty Russell <rusty@linuxcare.com.au>
  * This code is distributed under the terms of GNU GPL v2
  *
- * $Id: ip6tables-restore.c,v 1.12 2003/05/02 15:30:11 laforge Exp $
+ * $Id: ip6tables-restore.c,v 1.22 2004/05/26 16:04:48 gandalf Exp $
  */
 
 #include <getopt.h>
@@ -30,7 +30,8 @@
 static struct option options[] = {
 	{ "binary", 0, 0, 'b' },
 	{ "counters", 0, 0, 'c' },
-	{ "verbose", 1, 0, 'v' },
+	{ "verbose", 0, 0, 'v' },
+	{ "test", 0, 0, 't' },
 	{ "help", 0, 0, 'h' },
 	{ "noflush", 0, 0, 'n'},
 	{ "modprobe", 1, 0, 'M'},
@@ -41,10 +42,11 @@
 
 static void print_usage(const char *name, const char *version)
 {
-	fprintf(stderr, "Usage: %s [-b] [-c] [-v] [-h]\n"
+	fprintf(stderr, "Usage: %s [-b] [-c] [-v] [-t] [-h]\n"
 			"	   [ --binary ]\n"
 			"	   [ --counters ]\n"
 			"	   [ --verbose ]\n"
+			"	   [ --test ]\n"
 			"	   [ --help ]\n"
 			"	   [ --noflush ]\n"
 		        "          [ --modprobe=<command>]\n", name);
@@ -74,7 +76,7 @@
 
 int parse_counters(char *string, struct ip6t_counters *ctr)
 {
-	return (sscanf(string, "[%llu:%llu]", &ctr->pcnt, &ctr->bcnt) == 2);
+	return (sscanf(string, "[%llu:%llu]", (unsigned long long *)&ctr->pcnt, (unsigned long long *)&ctr->bcnt) == 2);
 }
 
 /* global new argv and argc */
@@ -108,7 +110,7 @@
 	char curtable[IP6T_TABLE_MAXNAMELEN + 1];
 	FILE *in;
 	const char *modprobe = 0;
-	int in_table = 0;
+	int in_table = 0, testing = 0;
 
 	program_name = "ip6tables-restore";
 	program_version = IPTABLES_VERSION;
@@ -118,7 +120,7 @@
 	init_extensions();
 #endif
 
-	while ((c = getopt_long(argc, argv, "bcvhnM:", options, NULL)) != -1) {
+	while ((c = getopt_long(argc, argv, "bcvthnM:", options, NULL)) != -1) {
 		switch (c) {
 			case 'b':
 				binary = 1;
@@ -129,6 +131,9 @@
 			case 'v':
 				verbose = 1;
 				break;
+			case 't':
+				testing = 1;
+				break;
 			case 'h':
 				print_usage("ip6tables-restore",
 					    IPTABLES_VERSION);
@@ -158,16 +163,23 @@
 	
 	/* Grab standard input. */
 	while (fgets(buffer, sizeof(buffer), in)) {
-		int ret;
+		int ret = 0;
 
 		line++;
-		if (buffer[0] == '\n') continue;
+		if (buffer[0] == '\n')
+			continue;
 		else if (buffer[0] == '#') {
-			if (verbose) fputs(buffer, stdout);
+			if (verbose)
+				fputs(buffer, stdout);
 			continue;
 		} else if ((strcmp(buffer, "COMMIT\n") == 0) && (in_table)) {
-			DEBUGP("Calling commit\n");
-			ret = ip6tc_commit(&handle);
+			if (!testing) {
+				DEBUGP("Calling commit\n");
+				ret = ip6tc_commit(&handle);
+			} else {
+				DEBUGP("Not calling commit, testing\n");
+				ret = 1;
+			}
 			in_table = 0;
 		} else if ((buffer[0] == '*') && (!in_table)) {
 			/* New table */
@@ -182,6 +194,7 @@
 				exit(1);
 			}
 			strncpy(curtable, table, IP6T_TABLE_MAXNAMELEN);
+			curtable[IP6T_TABLE_MAXNAMELEN] = '\0';
 
 			if (handle)
 				ip6tc_free(&handle);
@@ -321,7 +334,11 @@
 			
 			for (curchar = parsestart; *curchar; curchar++) {
 				if (*curchar == '"') {
-					if (quote_open) {
+					/* quote_open cannot be true if there
+					 * was no previous character.  Thus, 
+					 * curchar-1 has to be within bounds */
+					if (quote_open && 
+					    *(curchar-1) != '\\') {
 						quote_open = 0;
 						*curchar = ' ';
 					} else {
@@ -382,6 +399,11 @@
 			exit(1);
 		}
 	}
+	if (in_table) {
+		fprintf(stderr, "%s: COMMIT expected at line %u\n",
+				program_name, line + 1);
+		exit(1);
+	}
 
 	return 0;
 }
diff -urN iptables-1.2.9/ip6tables-save.c iptables-1.2.10/ip6tables-save.c
--- iptables-1.2.9/ip6tables-save.c	2003-05-03 20:52:13.000000000 +0200
+++ iptables-1.2.10/ip6tables-save.c	2004-06-15 00:02:16.000000000 +0200
@@ -100,7 +100,7 @@
 			const struct ip6t_ip6 *ip)
 {
 	struct ip6tables_match *match
-		= find_match(e->u.user.name, TRY_LOAD);
+		= find_match(e->u.user.name, TRY_LOAD, NULL);
 
 	if (match) {
 		printf("-m %s ", e->u.user.name);
@@ -149,7 +149,7 @@
 
 	/* print counters */
 	if (counters)
-		printf("[%llu:%llu] ", e->counters.pcnt, e->counters.bcnt);
+		printf("[%llu:%llu] ", (unsigned long long)e->counters.pcnt, (unsigned long long)e->counters.bcnt);
 
 	/* print chain name */
 	printf("-A %s ", chain);
@@ -277,7 +277,7 @@
 				struct ip6t_counters count;
 				printf("%s ",
 				       ip6tc_get_policy(chain, &count, &h));
-				printf("[%llu:%llu]\n", count.pcnt, count.bcnt);
+				printf("[%llu:%llu]\n", (unsigned long long)count.pcnt, (unsigned long long)count.bcnt);
 			} else {
 				printf("- [0:0]\n");
 			}
diff -urN iptables-1.2.9/ip6tables.8 iptables-1.2.10/ip6tables.8
--- iptables-1.2.9/ip6tables.8	2003-06-30 18:16:54.000000000 +0200
+++ iptables-1.2.10/ip6tables.8	1970-01-01 01:00:00.000000000 +0100
@@ -1,821 +0,0 @@
-.TH IP6TABLES 8 "Mar 09, 2002" "" ""
-.\"
-.\" Man page written by Andras Kis-Szabo <kisza@sch.bme.hu>
-.\" It is based on iptables man page.
-.\"
-.\" iptables page by Herve Eychenne <rv@wallfire.org>
-.\" It is based on ipchains man page.
-.\"
-.\" ipchains page by Paul ``Rusty'' Russell March 1997
-.\" Based on the original ipfwadm man page by Jos Vos <jos@xos.nl>
-.\"
-.\"	This program is free software; you can redistribute it and/or modify
-.\"	it under the terms of the GNU General Public License as published by
-.\"	the Free Software Foundation; either version 2 of the License, or
-.\"	(at your option) any later version.
-.\"
-.\"	This program is distributed in the hope that it will be useful,
-.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
-.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-.\"	GNU General Public License for more details.
-.\"
-.\"	You should have received a copy of the GNU General Public License
-.\"	along with this program; if not, write to the Free Software
-.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-.\"
-.\"
-.SH NAME
-ip6tables \- IPv6 packet filter administration
-.SH SYNOPSIS
-.BR "ip6tables [-t table] -[AD] " "chain rule-specification [options]"
-.br
-.BR "ip6tables [-t table] -I " "chain [rulenum] rule-specification [options]"
-.br
-.BR "ip6tables [-t table] -R " "chain rulenum rule-specification [options]"
-.br
-.BR "ip6tables [-t table] -D " "chain rulenum [options]"
-.br
-.BR "ip6tables [-t table] -[LFZ] " "[chain] [options]"
-.br
-.BR "ip6tables [-t table] -N " "chain"
-.br
-.BR "ip6tables [-t table] -X " "[chain]"
-.br
-.BR "ip6tables [-t table] -P " "chain target [options]"
-.br
-.BR "ip6tables [-t table] -E " "old-chain-name new-chain-name"
-.SH DESCRIPTION
-.B Ip6tables
-is used to set up, maintain, and inspect the tables of IPv6 packet
-filter rules in the Linux kernel.  Several different tables
-may be defined.  Each table contains a number of built-in
-chains and may also contain user-defined chains.
-
-Each chain is a list of rules which can match a set of packets.  Each
-rule specifies what to do with a packet that matches.  This is called
-a `target', which may be a jump to a user-defined chain in the same
-table.
-
-.SH TARGETS
-A firewall rule specifies criteria for a packet, and a target.  If the
-packet does not match, the next rule in the chain is the examined; if
-it does match, then the next rule is specified by the value of the
-target, which can be the name of a user-defined chain or one of the
-special values 
-.IR ACCEPT ,
-.IR DROP ,
-.IR QUEUE ,
-or
-.IR RETURN .
-.PP
-.I ACCEPT 
-means to let the packet through.
-.I DROP
-means to drop the packet on the floor.
-.I QUEUE
-means to pass the packet to userspace (if supported by the kernel).
-.I RETURN
-means stop traversing this chain and resume at the next rule in the
-previous (calling) chain.  If the end of a built-in chain is reached
-or a rule in a built-in chain with target
-.I RETURN
-is matched, the target specified by the chain policy determines the
-fate of the packet.
-.SH TABLES
-There are currently two independent tables (which tables are present
-at any time depends on the kernel configuration options and which
-modules are present), as nat table has not been implemented yet.
-.TP
-.BI "-t, --table " "table"
-This option specifies the packet matching table which the command
-should operate on.  If the kernel is configured with automatic module
-loading, an attempt will be made to load the appropriate module for
-that table if it is not already there.
-
-The tables are as follows:
-.RS
-.TP .4i
-.BR "filter" :
-This is the default table (if no -t option is passed).  It contains
-the built-in chains
-.B INPUT
-(for packets coming into the box itself),
-.B FORWARD
-(for packets being routed through the box), and
-.B OUTPUT
-(for locally-generated packets).
-.TP
-.BR "mangle" :
-This table is used for specialized packet alteration.  Until kernel
-2.4.17 it had two built-in chains:
-.B PREROUTING
-(for altering incoming packets before routing) and
-.B OUTPUT
-(for altering locally-generated packets before routing).
-Since kernel 2.4.18, three other built-in chains are also supported:
-.B INPUT
-(for packets coming into the box itself),
-.B FORWARD
-(for altering packets being routed through the box), and
-.B POSTROUTING
-(for altering packets as they are about to go out).
-.RE
-.SH OPTIONS
-The options that are recognized by
-.B ip6tables
-can be divided into several different groups.
-.SS COMMANDS
-These options specify the specific action to perform.  Only one of them
-can be specified on the command line unless otherwise specified
-below.  For all the long versions of the command and option names, you
-need to use only enough letters to ensure that
-.B ip6tables
-can differentiate it from all other options.
-.TP
-.BI "-A, --append " "chain rule-specification"
-Append one or more rules to the end of the selected chain.
-When the source and/or destination names resolve to more than one
-address, a rule will be added for each possible address combination.
-.TP
-.BI "-D, --delete " "chain rule-specification"
-.ns
-.TP
-.BI "-D, --delete " "chain rulenum"
-Delete one or more rules from the selected chain.  There are two
-versions of this command: the rule can be specified as a number in the
-chain (starting at 1 for the first rule) or a rule to match.
-.TP
-.B "-I, --insert"
-Insert one or more rules in the selected chain as the given rule
-number.  So, if the rule number is 1, the rule or rules are inserted
-at the head of the chain.  This is also the default if no rule number
-is specified.
-.TP
-.BI "-R, --replace " "chain rulenum rule-specification"
-Replace a rule in the selected chain.  If the source and/or
-destination names resolve to multiple addresses, the command will
-fail.  Rules are numbered starting at 1.
-.TP
-.BR "-L, --list " "[\fIchain\fP]"
-List all rules in the selected chain.  If no chain is selected, all
-chains are listed.  As every other iptables command, it applies to the
-specified table (filter is the default), so mangle rules get listed by
-.nf
- ip6tables -t mangle -n -L
-.fi
-Please note that it is often used with the
-.B -n
-option, in order to avoid long reverse DNS lookups.
-It is legal to specify the
-.B -Z
-(zero) option as well, in which case the chain(s) will be atomically
-listed and zeroed.  The exact output is affected by the other
-arguments given. The exact rules are suppressed until you use
-.nf
- ip6tables -L -v
-.fi
-.TP
-.BR "-F, --flush " "[\fIchain\fP]"
-Flush the selected chain (all the chains in the table if none is given).
-This is equivalent to deleting all the rules one by one.
-.TP
-.BR "-Z, --zero " "[\fIchain\fP]"
-Zero the packet and byte counters in all chains.  It is legal to
-specify the
-.B "-L, --list"
-(list) option as well, to see the counters immediately before they are
-cleared. (See above.)
-.TP
-.BI "-N, --new-chain " "chain"
-Create a new user-defined chain by the given name.  There must be no
-target of that name already.
-.TP
-.BR "-X, --delete-chain " "[\fIchain\fP]"
-Delete the optional user-defined chain specified.  There must be no references
-to the chain.  If there are, you must delete or replace the referring
-rules before the chain can be deleted.  If no argument is given, it
-will attempt to delete every non-builtin chain in the table.
-.TP
-.BI "-P, --policy " "chain target"
-Set the policy for the chain to the given target.  See the section
-.B TARGETS
-for the legal targets.  Only built-in (non-user-defined) chains can have
-policies, and neither built-in nor user-defined chains can be policy
-targets.
-.TP
-.BI "-E, --rename-chain " "old-chain new-chain"
-Rename the user specified chain to the user supplied name.  This is
-cosmetic, and has no effect on the structure of the table.
-.TP
-.B -h
-Help.
-Give a (currently very brief) description of the command syntax.
-.SS PARAMETERS
-The following parameters make up a rule specification (as used in the
-add, delete, insert, replace and append commands).
-.TP
-.BR "-p, --protocol " "[!] \fIprotocol\fP"
-The protocol of the rule or of the packet to check.
-The specified protocol can be one of
-.IR tcp ,
-.IR udp ,
-.IR ipv6-icmp|icmpv6 ,
-or
-.IR all ,
-or it can be a numeric value, representing one of these protocols or a
-different one.  A protocol name from /etc/protocols is also allowed.
-A "!" argument before the protocol inverts the
-test.  The number zero is equivalent to
-.IR all .
-Protocol
-.I all
-will match with all protocols and is taken as default when this
-option is omitted.
-.TP
-.BR "-s, --source " "[!] \fIaddress\fP[/\fImask\fP]"
-Source specification.
-.I Address
-can be either a hostname (please note that specifying
-any name to be resolved with a remote query such as DNS is a really bad idea),
-a network IPv6 address (with /mask), or a plain IPv6 address.
-(the network name isn't supported now).
-The
-.I mask
-can be either a network mask or a plain number,
-specifying the number of 1's at the left side of the network mask.
-Thus, a mask of
-.I 64
-is equivalent to
-.IR ffff:ffff:ffff:ffff:0000:0000:0000:0000 .
-A "!" argument before the address specification inverts the sense of
-the address. The flag
-.B --src
-is an alias for this option.
-.TP
-.BR "-d, --destination " "[!] \fIaddress\fP[/\fImask\fP]"
-Destination specification. 
-See the description of the
-.B -s
-(source) flag for a detailed description of the syntax.  The flag
-.B --dst
-is an alias for this option.
-.TP
-.BI "-j, --jump " "target"
-This specifies the target of the rule; i.e., what to do if the packet
-matches it.  The target can be a user-defined chain (other than the
-one this rule is in), one of the special builtin targets which decide
-the fate of the packet immediately, or an extension (see
-.B EXTENSIONS
-below).  If this
-option is omitted in a rule, then matching the rule will have no
-effect on the packet's fate, but the counters on the rule will be
-incremented.
-.TP
-.BR "-i, --in-interface " "[!] \fIname\fP"
-Name of an interface via which a packet is going to be received (only for
-packets entering the 
-.BR INPUT ,
-.B FORWARD
-and
-.B PREROUTING
-chains).  When the "!" argument is used before the interface name, the
-sense is inverted.  If the interface name ends in a "+", then any
-interface which begins with this name will match.  If this option is
-omitted, any interface name will match.
-.TP
-.BR "-o, --out-interface " "[!] \fIname\fP"
-Name of an interface via which a packet is going to be sent (for packets
-entering the
-.BR FORWARD 
-and
-.B OUTPUT
-chains).  When the "!" argument is used before the interface name, the
-sense is inverted.  If the interface name ends in a "+", then any
-interface which begins with this name will match.  If this option is
-omitted, any interface name will match.
-.TP
-.\" Currently not supported (header-based)
-.\" 
-.\" .B "[!] " "-f, --fragment"
-.\" This means that the rule only refers to second and further fragments
-.\" of fragmented packets.  Since there is no way to tell the source or
-.\" destination ports of such a packet (or ICMP type), such a packet will
-.\" not match any rules which specify them.  When the "!" argument
-.\" precedes the "-f" flag, the rule will only match head fragments, or
-.\" unfragmented packets.
-.\" .TP
-.B "-c, --set-counters " "PKTS BYTES"
-This enables the administrator to initialize the packet and byte
-counters of a rule (during
-.B INSERT,
-.B APPEND,
-.B REPLACE
-operations).
-.SS "OTHER OPTIONS"
-The following additional options can be specified:
-.TP
-.B "-v, --verbose"
-Verbose output.  This option makes the list command show the interface
-name, the rule options (if any), and the TOS masks.  The packet and
-byte counters are also listed, with the suffix 'K', 'M' or 'G' for
-1000, 1,000,000 and 1,000,000,000 multipliers respectively (but see
-the
-.B -x
-flag to change this).
-For appending, insertion, deletion and replacement, this causes
-detailed information on the rule or rules to be printed.
-.TP
-.B "-n, --numeric"
-Numeric output.
-IP addresses and port numbers will be printed in numeric format.
-By default, the program will try to display them as host names,
-network names, or services (whenever applicable).
-.TP
-.B "-x, --exact"
-Expand numbers.
-Display the exact value of the packet and byte counters,
-instead of only the rounded number in K's (multiples of 1000)
-M's (multiples of 1000K) or G's (multiples of 1000M).  This option is
-only relevant for the 
-.B -L
-command.
-.TP
-.B "--line-numbers"
-When listing rules, add line numbers to the beginning of each rule,
-corresponding to that rule's position in the chain.
-.TP
-.B "--modprobe=command"
-When adding or inserting rules into a chain, use
-.B command
-to load any necessary modules (targets, match extensions, etc).
-.SH MATCH EXTENSIONS
-ip6tables can use extended packet matching modules.  These are loaded
-in two ways: implicitly, when
-.B -p
-or
-.B --protocol
-is specified, or with the
-.B -m
-or
-.B --match
-options, followed by the matching module name; after these, various
-extra command line options become available, depending on the specific
-module.  You can specify multiple extended match modules in one line,
-and you can use the
-.B -h
-or
-.B --help
-options after the module has been specified to receive help specific
-to that module.
-
-The following are included in the base package, and most of these can
-be preceded by a
-.B !
-to invert the sense of the match.
-.SS tcp
-These extensions are loaded if `--protocol tcp' is specified. It
-provides the following options:
-.TP
-.BR "--source-port " "[!] \fIport\fP[:\fIport\fP]"
-Source port or port range specification. This can either be a service
-name or a port number. An inclusive range can also be specified,
-using the format
-.IR port : port .
-If the first port is omitted, "0" is assumed; if the last is omitted,
-"65535" is assumed.
-If the second port greater then the first they will be swapped.
-The flag
-.B --sport
-is a convenient alias for this option.
-.TP
-.BR "--destination-port " "[!] \fIport\fP[:\fIport\fP]"
-Destination port or port range specification.  The flag
-.B --dport
-is a convenient alias for this option.
-.TP
-.BR "--tcp-flags " "[!] \fImask\fP \fIcomp\fP"
-Match when the TCP flags are as specified.  The first argument is the
-flags which we should examine, written as a comma-separated list, and
-the second argument is a comma-separated list of flags which must be
-set.  Flags are: 
-.BR "SYN ACK FIN RST URG PSH ALL NONE" .
-Hence the command
-.nf
- ip6tables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN
-.fi
-will only match packets with the SYN flag set, and the ACK, FIN and
-RST flags unset.
-.TP
-.B "[!] --syn"
-Only match TCP packets with the SYN bit set and the ACK and RST bits
-cleared.  Such packets are used to request TCP connection initiation;
-for example, blocking such packets coming in an interface will prevent
-incoming TCP connections, but outgoing TCP connections will be
-unaffected.
-It is equivalent to \fB--tcp-flags SYN,RST,ACK SYN\fP.
-If the "!" flag precedes the "--syn", the sense of the
-option is inverted.
-.TP
-.BR "--tcp-option " "[!] \fInumber\fP"
-Match if TCP option set.
-.SS udp
-These extensions are loaded if `--protocol udp' is specified.  It
-provides the following options:
-.TP
-.BR "--source-port " "[!] \fIport\fP[:\fIport\fP]"
-Source port or port range specification.
-See the description of the
-.B --source-port
-option of the TCP extension for details.
-.TP
-.BR "--destination-port " "[!] \fIport\fP[:\fIport\fP]"
-Destination port or port range specification.
-See the description of the
-.B --destination-port
-option of the TCP extension for details.
-.SS ipv6-icmp
-This extension is loaded if `--protocol ipv6-icmp' or `--protocol icmpv6' is
-specified. It provides the following option:
-.TP
-.BR "--icmpv6-type " "[!] \fItypename\fP"
-This allows specification of the ICMP type, which can be a numeric
-IPv6-ICMP type, or one of the IPv6-ICMP type names shown by the command
-.nf
- ip6tables -p ipv6-icmp -h
-.fi
-.SS mac
-.TP
-.BR "--mac-source " "[!] \fIaddress\fP"
-Match source MAC address.  It must be of the form XX:XX:XX:XX:XX:XX.
-Note that this only makes sense for packets coming from an Ethernet device
-and entering the
-.BR PREROUTING ,
-.B FORWARD
-or
-.B INPUT
-chains.
-.SS limit
-This module matches at a limited rate using a token bucket filter.
-A rule using this extension will match until this limit is reached
-(unless the `!' flag is used).  It can be used in combination with the
-.B LOG
-target to give limited logging, for example.
-.TP
-.BI "--limit " "rate"
-Maximum average matching rate: specified as a number, with an optional
-`/second', `/minute', `/hour', or `/day' suffix; the default is
-3/hour.
-.TP
-.BI "--limit-burst " "number"
-Maximum initial number of packets to match: this number gets
-recharged by one every time the limit specified above is not reached,
-up to this number; the default is 5.
-.SS multiport
-This module matches a set of source or destination ports.  Up to 15
-ports can be specified.  It can only be used in conjunction with
-.B "-p tcp"
-or
-.BR "-p udp" .
-.TP
-.BR "--source-ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
-Match if the source port is one of the given ports.  The flag
-.B --sports
-is a convenient alias for this option.
-.TP
-.BR "--destination-ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
-Match if the destination port is one of the given ports.  The flag
-.B --dports
-is a convenient alias for this option.
-.TP
-.BR "--ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
-Match if the both the source and destination ports are equal to each
-other and to one of the given ports.
-.SS mark
-This module matches the netfilter mark field associated with a packet
-(which can be set using the
-.B MARK
-target below).
-.TP
-.BR "--mark " "\fIvalue\fP[/\fImask\fP]"
-Matches packets with the given unsigned mark value (if a mask is
-specified, this is logically ANDed with the mask before the
-comparison).
-.SS owner
-This module attempts to match various characteristics of the packet
-creator, for locally-generated packets.  It is only valid in the
-.B OUTPUT
-chain, and even this some packets (such as ICMP ping responses) may
-have no owner, and hence never match.  This is regarded as experimental.
-.TP
-.BI "--uid-owner " "userid"
-Matches if the packet was created by a process with the given
-effective user id.
-.TP
-.BI "--gid-owner " "groupid"
-Matches if the packet was created by a process with the given
-effective group id.
-.TP
-.BI "--pid-owner " "processid"
-Matches if the packet was created by a process with the given
-process id.
-.TP
-.BI "--sid-owner " "sessionid"
-Matches if the packet was created by a process in the given session
-group.
-.\" .SS state
-.\" This module, when combined with connection tracking, allows access to
-.\" the connection tracking state for this packet.
-.\" .TP
-.\" .BI "--state " "state"
-.\" Where state is a comma separated list of the connection states to
-.\" match.  Possible states are 
-.\" .B INVALID
-.\" meaning that the packet is associated with no known connection,
-.\" .B ESTABLISHED
-.\" meaning that the packet is associated with a connection which has seen
-.\" packets in both directions,
-.\" .B NEW
-.\" meaning that the packet has started a new connection, or otherwise
-.\" associated with a connection which has not seen packets in both
-.\" directions, and
-.\" .B RELATED
-.\" meaning that the packet is starting a new connection, but is
-.\" associated with an existing connection, such as an FTP data transfer,
-.\" or an ICMP error.
-.\" .SS unclean
-.\" This module takes no options, but attempts to match packets which seem
-.\" malformed or unusual.  This is regarded as experimental.
-.\" .SS tos
-.\" This module matches the 8 bits of Type of Service field in the IP
-.\" header (ie. including the precedence bits). 
-.\" .TP
-.\" .BI "--tos " "tos"
-.\" The argument is either a standard name, (use
-.\" .br
-.\" iptables -m tos -h
-.\" .br
-.\" to see the list), or a numeric value to match.
-.SH TARGET EXTENSIONS
-ip6tables can use extended target modules: the following are included
-in the standard distribution.
-.SS LOG
-Turn on kernel logging of matching packets.  When this option is set
-for a rule, the Linux kernel will print some information on all
-matching packets (like most IPv6 IPv6-header fields) via the kernel log
-(where it can be read with
-.I dmesg
-or 
-.IR syslogd (8)).
-This is a "non-terminating target", i.e. rule traversal continues at
-the next rule.  So if you want to LOG the packets you refuse, use two
-separate rules with the same matching criteria, first using target LOG
-then DROP (or REJECT).
-.TP
-.BI "--log-level " "level"
-Level of logging (numeric or see \fIsyslog.conf\fP(5)).
-.TP
-.BI "--log-prefix " "prefix"
-Prefix log messages with the specified prefix; up to 29 letters long,
-and useful for distinguishing messages in the logs.
-.TP
-.B --log-tcp-sequence
-Log TCP sequence numbers. This is a security risk if the log is
-readable by users.
-.TP
-.B --log-tcp-options
-Log options from the TCP packet header.
-.TP
-.B --log-ip-options
-Log options from the IPv6 packet header.
-.SS MARK
-This is used to set the netfilter mark value associated with the
-packet.  It is only valid in the
-.B mangle
-table.
-.TP
-.BI "--set-mark " "mark"
-.SS REJECT
-This is used to send back an error packet in response to the matched
-packet: otherwise it is equivalent to 
-.B DROP
-so it is a terminating TARGET, ending rule traversal.
-This target is only valid in the
-.BR INPUT ,
-.B FORWARD
-and
-.B OUTPUT
-chains, and user-defined chains which are only called from those
-chains.  The following option controls the nature of the error packet
-returned:
-.TP
-.BI "--reject-with " "type"
-The type given can be
-.nf
-.B " icmp6-no-route"
-.B " no-route"
-.B " icmp6-adm-prohibited"
-.B " adm-prohibited"
-.B " icmp6-addr-unreachable"
-.B " addr-unreach"
-.B " icmp6-port-unreachable"
-.B " port-unreach"
-.fi
-which return the appropriate IPv6-ICMP error message (\fBport-unreach\fP is
-the default). Finally, the option
-.B tcp-reset
-can be used on rules which only match the TCP protocol: this causes a
-TCP RST packet to be sent back.  This is mainly useful for blocking 
-.I ident
-(113/tcp) probes which frequently occur when sending mail to broken mail
-hosts (which won't accept your mail otherwise).
-.\" .SS TOS
-.\" This is used to set the 8-bit Type of Service field in the IP header.
-.\" It is only valid in the
-.\" .B mangle
-.\" table.
-.\" .TP
-.\" .BI "--set-tos " "tos"
-.\" You can use a numeric TOS values, or use
-.\" .br
-.\" iptables -j TOS -h
-.\" .br
-.\" to see the list of valid TOS names.
-.\" .SS MIRROR
-.\" This is an experimental demonstration target which inverts the source
-.\" and destination fields in the IP header and retransmits the packet.
-.\" It is only valid in the
-.\" .BR INPUT ,
-.\" .B FORWARD
-.\" and 
-.\" .B PREROUTING
-.\" chains, and user-defined chains which are only called from those
-.\" chains.  Note that the outgoing packets are
-.\" .B NOT
-.\" seen by any packet filtering chains, connection tracking or NAT, to
-.\" avoid loops and other problems.
-.\" .SS SNAT
-.\" This target is only valid in the 
-.\" .B nat
-.\" table, in the 
-.\" .B POSTROUTING
-.\" chain.  It specifies that the source address of the packet should be
-.\" modified (and all future packets in this connection will also be
-.\" mangled), and rules should cease being examined.  It takes one option:
-.\" .TP
-.\" .BR "--to-source  " "\fIipaddr\fP[-\fIipaddr\fP][:\fIport\fP-\fIport\fP]"
-.\" which can specify a single new source IP address, an inclusive range
-.\" of IP addresses, and optionally, a port range (which is only valid if
-.\" the rule also specifies
-.\" .B "-p tcp"
-.\" or
-.\" .BR "-p udp" ).
-.\" If no port range is specified, then source ports below 512 will be
-.\" mapped to other ports below 512: those between 512 and 1023 inclusive
-.\" will be mapped to ports below 1024, and other ports will be mapped to
-.\" 1024 or above. Where possible, no port alteration will occur.
-.\" .SS DNAT
-.\" This target is only valid in the 
-.\" .B nat
-.\" table, in the 
-.\" .B PREROUTING
-.\" and
-.\" .B OUTPUT
-.\" chains, and user-defined chains which are only called from those
-.\" chains.  It specifies that the destination address of the packet
-.\" should be modified (and all future packets in this connection will
-.\" also be mangled), and rules should cease being examined.  It takes one
-.\" option:
-.\" .TP
-.\" .BR "--to-destination " "\fIipaddr\fP[-\fIipaddr\fP][:\fIport\fP-\fIport\fP]"
-.\" which can specify a single new destination IP address, an inclusive
-.\" range of IP addresses, and optionally, a port range (which is only
-.\" valid if the rule also specifies
-.\" .B "-p tcp"
-.\" or
-.\" .BR "-p udp" ).
-.\" If no port range is specified, then the destination port will never be
-.\" modified.
-.\" .SS MASQUERADE
-.\" This target is only valid in the 
-.\" .B nat
-.\" table, in the 
-.\" .B POSTROUTING
-.\" chain.  It should only be used with dynamically assigned IP (dialup)
-.\" connections: if you have a static IP address, you should use the SNAT
-.\" target.  Masquerading is equivalent to specifying a mapping to the IP
-.\" address of the interface the packet is going out, but also has the
-.\" effect that connections are 
-.\" .I forgotten
-.\" when the interface goes down.  This is the correct behavior when the
-.\" next dialup is unlikely to have the same interface address (and hence
-.\" any established connections are lost anyway).  It takes one option:
-.\" .TP
-.\" .BR "--to-ports " "\fIport\fP[-\fIport\fP]"
-.\" This specifies a range of source ports to use, overriding the default 
-.\" .B SNAT
-.\" source port-selection heuristics (see above).  This is only valid
-.\" if the rule also specifies
-.\" .B "-p tcp"
-.\" or
-.\" .BR "-p udp" .
-.\" .SS REDIRECT
-.\" This target is only valid in the 
-.\" .B nat
-.\" table, in the 
-.\" .B PREROUTING
-.\" and
-.\" .B OUTPUT
-.\" chains, and user-defined chains which are only called from those
-.\" chains.  It alters the destination IP address to send the packet to
-.\" the machine itself (locally-generated packets are mapped to the
-.\" 127.0.0.1 address).  It takes one option:
-.\" .TP
-.\" .BR "--to-ports " "\fIport\fP[-\fIport\fP]"
-.\" This specifies a destination port or range of ports to use: without
-.\" this, the destination port is never altered.  This is only valid
-.\" if the rule also specifies
-.\" .B "-p tcp"
-.\" or
-.\" .BR "-p udp" .
-.SH DIAGNOSTICS
-Various error messages are printed to standard error.  The exit code
-is 0 for correct functioning.  Errors which appear to be caused by
-invalid or abused command line parameters cause an exit code of 2, and
-other errors cause an exit code of 1.
-.SH BUGS
-Bugs?  What's this? ;-)
-Well... the counters are not reliable on sparc64.
-.SH COMPATIBILITY WITH IPCHAINS
-This 
-.B ip6tables
-is very similar to ipchains by Rusty Russell.  The main difference is
-that the chains 
-.B INPUT
-and
-.B OUTPUT
-are only traversed for packets coming into the local host and
-originating from the local host respectively.  Hence every packet only
-passes through one of the three chains (except loopback traffic, which
-involves both INPUT and OUTPUT chains); previously a forwarded packet
-would pass through all three.
-.PP
-The other main difference is that 
-.B -i
-refers to the input interface;
-.B -o
-refers to the output interface, and both are available for packets
-entering the
-.B FORWARD
-chain.
-.\" .PP The various forms of NAT have been separated out; 
-.\" .B iptables 
-.\" is a pure packet filter when using the default `filter' table, with
-.\" optional extension modules.  This should simplify much of the previous
-.\" confusion over the combination of IP masquerading and packet filtering
-.\" seen previously.  So the following options are handled differently:
-.\" .br
-.\" -j MASQ
-.\" .br
-.\" -M -S
-.\" .br
-.\" -M -L
-.\" .br
-There are several other changes in ip6tables.
-.SH SEE ALSO
-.BR ip6tables-save (8),
-.BR ip6tables-restore(8),
-.BR iptables (8),
-.BR iptables-save (8),
-.BR iptables-restore (8).
-.P
-The packet-filtering-HOWTO details iptables usage for
-packet filtering, the NAT-HOWTO details NAT,
-the netfilter-extensions-HOWTO details the extensions that are
-not in the standard distribution,
-and the netfilter-hacking-HOWTO details the netfilter internals.
-.br
-See
-.BR "http://www.netfilter.org/" .
-.SH AUTHORS
-Rusty Russell wrote iptables, in early consultation with Michael
-Neuling.
-.PP
-Marc Boucher made Rusty abandon ipnatctl by lobbying for a generic packet
-selection framework in iptables, then wrote the mangle table, the owner match,
-the mark stuff, and ran around doing cool stuff everywhere.
-.PP
-James Morris wrote the TOS target, and tos match.
-.PP
-Jozsef Kadlecsik wrote the REJECT target.
-.PP
-Harald Welte wrote the ULOG target, TTL match+target and libipulog.
-.PP
-The Netfilter Core Team is: Marc Boucher, Martin Josefsson, Jozsef Kadlecsik,
-James Morris, Harald Welte and Rusty Russell.
-.PP
-ip6tables man page created by Andras Kis-Szabo, based on
-iptables man page written by Herve Eychenne <rv@wallfire.org>.
-.\" .. and did I mention that we are incredibly cool people?
-.\" .. sexy, too ..
-.\" .. witty, charming, powerful ..
-.\" .. and most of all, modest ..
diff -urN iptables-1.2.9/ip6tables.8.in iptables-1.2.10/ip6tables.8.in
--- iptables-1.2.9/ip6tables.8.in	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/ip6tables.8.in	2004-01-22 16:04:24.000000000 +0100
@@ -0,0 +1,461 @@
+.TH IP6TABLES 8 "Mar 09, 2002" "" ""
+.\"
+.\" Man page written by Andras Kis-Szabo <kisza@sch.bme.hu>
+.\" It is based on iptables man page.
+.\"
+.\" iptables page by Herve Eychenne <rv@wallfire.org>
+.\" It is based on ipchains man page.
+.\"
+.\" ipchains page by Paul ``Rusty'' Russell March 1997
+.\" Based on the original ipfwadm man page by Jos Vos <jos@xos.nl>
+.\"
+.\"	This program is free software; you can redistribute it and/or modify
+.\"	it under the terms of the GNU General Public License as published by
+.\"	the Free Software Foundation; either version 2 of the License, or
+.\"	(at your option) any later version.
+.\"
+.\"	This program is distributed in the hope that it will be useful,
+.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
+.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+.\"	GNU General Public License for more details.
+.\"
+.\"	You should have received a copy of the GNU General Public License
+.\"	along with this program; if not, write to the Free Software
+.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+.\"
+.\"
+.SH NAME
+ip6tables \- IPv6 packet filter administration
+.SH SYNOPSIS
+.BR "ip6tables [-t table] -[AD] " "chain rule-specification [options]"
+.br
+.BR "ip6tables [-t table] -I " "chain [rulenum] rule-specification [options]"
+.br
+.BR "ip6tables [-t table] -R " "chain rulenum rule-specification [options]"
+.br
+.BR "ip6tables [-t table] -D " "chain rulenum [options]"
+.br
+.BR "ip6tables [-t table] -[LFZ] " "[chain] [options]"
+.br
+.BR "ip6tables [-t table] -N " "chain"
+.br
+.BR "ip6tables [-t table] -X " "[chain]"
+.br
+.BR "ip6tables [-t table] -P " "chain target [options]"
+.br
+.BR "ip6tables [-t table] -E " "old-chain-name new-chain-name"
+.SH DESCRIPTION
+.B Ip6tables
+is used to set up, maintain, and inspect the tables of IPv6 packet
+filter rules in the Linux kernel.  Several different tables
+may be defined.  Each table contains a number of built-in
+chains and may also contain user-defined chains.
+
+Each chain is a list of rules which can match a set of packets.  Each
+rule specifies what to do with a packet that matches.  This is called
+a `target', which may be a jump to a user-defined chain in the same
+table.
+
+.SH TARGETS
+A firewall rule specifies criteria for a packet, and a target.  If the
+packet does not match, the next rule in the chain is the examined; if
+it does match, then the next rule is specified by the value of the
+target, which can be the name of a user-defined chain or one of the
+special values 
+.IR ACCEPT ,
+.IR DROP ,
+.IR QUEUE ,
+or
+.IR RETURN .
+.PP
+.I ACCEPT 
+means to let the packet through.
+.I DROP
+means to drop the packet on the floor.
+.I QUEUE
+means to pass the packet to userspace (if supported by the kernel).
+.I RETURN
+means stop traversing this chain and resume at the next rule in the
+previous (calling) chain.  If the end of a built-in chain is reached
+or a rule in a built-in chain with target
+.I RETURN
+is matched, the target specified by the chain policy determines the
+fate of the packet.
+.SH TABLES
+There are currently two independent tables (which tables are present
+at any time depends on the kernel configuration options and which
+modules are present), as nat table has not been implemented yet.
+.TP
+.BI "-t, --table " "table"
+This option specifies the packet matching table which the command
+should operate on.  If the kernel is configured with automatic module
+loading, an attempt will be made to load the appropriate module for
+that table if it is not already there.
+
+The tables are as follows:
+.RS
+.TP .4i
+.BR "filter" :
+This is the default table (if no -t option is passed).  It contains
+the built-in chains
+.B INPUT
+(for packets coming into the box itself),
+.B FORWARD
+(for packets being routed through the box), and
+.B OUTPUT
+(for locally-generated packets).
+.TP
+.BR "mangle" :
+This table is used for specialized packet alteration.  Until kernel
+2.4.17 it had two built-in chains:
+.B PREROUTING
+(for altering incoming packets before routing) and
+.B OUTPUT
+(for altering locally-generated packets before routing).
+Since kernel 2.4.18, three other built-in chains are also supported:
+.B INPUT
+(for packets coming into the box itself),
+.B FORWARD
+(for altering packets being routed through the box), and
+.B POSTROUTING
+(for altering packets as they are about to go out).
+.RE
+.SH OPTIONS
+The options that are recognized by
+.B ip6tables
+can be divided into several different groups.
+.SS COMMANDS
+These options specify the specific action to perform.  Only one of them
+can be specified on the command line unless otherwise specified
+below.  For all the long versions of the command and option names, you
+need to use only enough letters to ensure that
+.B ip6tables
+can differentiate it from all other options.
+.TP
+.BI "-A, --append " "chain rule-specification"
+Append one or more rules to the end of the selected chain.
+When the source and/or destination names resolve to more than one
+address, a rule will be added for each possible address combination.
+.TP
+.BI "-D, --delete " "chain rule-specification"
+.ns
+.TP
+.BI "-D, --delete " "chain rulenum"
+Delete one or more rules from the selected chain.  There are two
+versions of this command: the rule can be specified as a number in the
+chain (starting at 1 for the first rule) or a rule to match.
+.TP
+.B "-I, --insert"
+Insert one or more rules in the selected chain as the given rule
+number.  So, if the rule number is 1, the rule or rules are inserted
+at the head of the chain.  This is also the default if no rule number
+is specified.
+.TP
+.BI "-R, --replace " "chain rulenum rule-specification"
+Replace a rule in the selected chain.  If the source and/or
+destination names resolve to multiple addresses, the command will
+fail.  Rules are numbered starting at 1.
+.TP
+.BR "-L, --list " "[\fIchain\fP]"
+List all rules in the selected chain.  If no chain is selected, all
+chains are listed.  As every other iptables command, it applies to the
+specified table (filter is the default), so mangle rules get listed by
+.nf
+ ip6tables -t mangle -n -L
+.fi
+Please note that it is often used with the
+.B -n
+option, in order to avoid long reverse DNS lookups.
+It is legal to specify the
+.B -Z
+(zero) option as well, in which case the chain(s) will be atomically
+listed and zeroed.  The exact output is affected by the other
+arguments given. The exact rules are suppressed until you use
+.nf
+ ip6tables -L -v
+.fi
+.TP
+.BR "-F, --flush " "[\fIchain\fP]"
+Flush the selected chain (all the chains in the table if none is given).
+This is equivalent to deleting all the rules one by one.
+.TP
+.BR "-Z, --zero " "[\fIchain\fP]"
+Zero the packet and byte counters in all chains.  It is legal to
+specify the
+.B "-L, --list"
+(list) option as well, to see the counters immediately before they are
+cleared. (See above.)
+.TP
+.BI "-N, --new-chain " "chain"
+Create a new user-defined chain by the given name.  There must be no
+target of that name already.
+.TP
+.BR "-X, --delete-chain " "[\fIchain\fP]"
+Delete the optional user-defined chain specified.  There must be no references
+to the chain.  If there are, you must delete or replace the referring
+rules before the chain can be deleted.  If no argument is given, it
+will attempt to delete every non-builtin chain in the table.
+.TP
+.BI "-P, --policy " "chain target"
+Set the policy for the chain to the given target.  See the section
+.B TARGETS
+for the legal targets.  Only built-in (non-user-defined) chains can have
+policies, and neither built-in nor user-defined chains can be policy
+targets.
+.TP
+.BI "-E, --rename-chain " "old-chain new-chain"
+Rename the user specified chain to the user supplied name.  This is
+cosmetic, and has no effect on the structure of the table.
+.TP
+.B -h
+Help.
+Give a (currently very brief) description of the command syntax.
+.SS PARAMETERS
+The following parameters make up a rule specification (as used in the
+add, delete, insert, replace and append commands).
+.TP
+.BR "-p, --protocol " "[!] \fIprotocol\fP"
+The protocol of the rule or of the packet to check.
+The specified protocol can be one of
+.IR tcp ,
+.IR udp ,
+.IR ipv6-icmp|icmpv6 ,
+or
+.IR all ,
+or it can be a numeric value, representing one of these protocols or a
+different one.  A protocol name from /etc/protocols is also allowed.
+A "!" argument before the protocol inverts the
+test.  The number zero is equivalent to
+.IR all .
+Protocol
+.I all
+will match with all protocols and is taken as default when this
+option is omitted.
+.TP
+.BR "-s, --source " "[!] \fIaddress\fP[/\fImask\fP]"
+Source specification.
+.I Address
+can be either a hostname (please note that specifying
+any name to be resolved with a remote query such as DNS is a really bad idea),
+a network IPv6 address (with /mask), or a plain IPv6 address.
+(the network name isn't supported now).
+The
+.I mask
+can be either a network mask or a plain number,
+specifying the number of 1's at the left side of the network mask.
+Thus, a mask of
+.I 64
+is equivalent to
+.IR ffff:ffff:ffff:ffff:0000:0000:0000:0000 .
+A "!" argument before the address specification inverts the sense of
+the address. The flag
+.B --src
+is an alias for this option.
+.TP
+.BR "-d, --destination " "[!] \fIaddress\fP[/\fImask\fP]"
+Destination specification. 
+See the description of the
+.B -s
+(source) flag for a detailed description of the syntax.  The flag
+.B --dst
+is an alias for this option.
+.TP
+.BI "-j, --jump " "target"
+This specifies the target of the rule; i.e., what to do if the packet
+matches it.  The target can be a user-defined chain (other than the
+one this rule is in), one of the special builtin targets which decide
+the fate of the packet immediately, or an extension (see
+.B EXTENSIONS
+below).  If this
+option is omitted in a rule, then matching the rule will have no
+effect on the packet's fate, but the counters on the rule will be
+incremented.
+.TP
+.BR "-i, --in-interface " "[!] \fIname\fP"
+Name of an interface via which a packet is going to be received (only for
+packets entering the 
+.BR INPUT ,
+.B FORWARD
+and
+.B PREROUTING
+chains).  When the "!" argument is used before the interface name, the
+sense is inverted.  If the interface name ends in a "+", then any
+interface which begins with this name will match.  If this option is
+omitted, any interface name will match.
+.TP
+.BR "-o, --out-interface " "[!] \fIname\fP"
+Name of an interface via which a packet is going to be sent (for packets
+entering the
+.BR FORWARD 
+and
+.B OUTPUT
+chains).  When the "!" argument is used before the interface name, the
+sense is inverted.  If the interface name ends in a "+", then any
+interface which begins with this name will match.  If this option is
+omitted, any interface name will match.
+.TP
+.\" Currently not supported (header-based)
+.\" 
+.\" .B "[!] " "-f, --fragment"
+.\" This means that the rule only refers to second and further fragments
+.\" of fragmented packets.  Since there is no way to tell the source or
+.\" destination ports of such a packet (or ICMP type), such a packet will
+.\" not match any rules which specify them.  When the "!" argument
+.\" precedes the "-f" flag, the rule will only match head fragments, or
+.\" unfragmented packets.
+.\" .TP
+.B "-c, --set-counters " "PKTS BYTES"
+This enables the administrator to initialize the packet and byte
+counters of a rule (during
+.B INSERT,
+.B APPEND,
+.B REPLACE
+operations).
+.SS "OTHER OPTIONS"
+The following additional options can be specified:
+.TP
+.B "-v, --verbose"
+Verbose output.  This option makes the list command show the interface
+name, the rule options (if any), and the TOS masks.  The packet and
+byte counters are also listed, with the suffix 'K', 'M' or 'G' for
+1000, 1,000,000 and 1,000,000,000 multipliers respectively (but see
+the
+.B -x
+flag to change this).
+For appending, insertion, deletion and replacement, this causes
+detailed information on the rule or rules to be printed.
+.TP
+.B "-n, --numeric"
+Numeric output.
+IP addresses and port numbers will be printed in numeric format.
+By default, the program will try to display them as host names,
+network names, or services (whenever applicable).
+.TP
+.B "-x, --exact"
+Expand numbers.
+Display the exact value of the packet and byte counters,
+instead of only the rounded number in K's (multiples of 1000)
+M's (multiples of 1000K) or G's (multiples of 1000M).  This option is
+only relevant for the 
+.B -L
+command.
+.TP
+.B "--line-numbers"
+When listing rules, add line numbers to the beginning of each rule,
+corresponding to that rule's position in the chain.
+.TP
+.B "--modprobe=command"
+When adding or inserting rules into a chain, use
+.B command
+to load any necessary modules (targets, match extensions, etc).
+.SH MATCH EXTENSIONS
+ip6tables can use extended packet matching modules.  These are loaded
+in two ways: implicitly, when
+.B -p
+or
+.B --protocol
+is specified, or with the
+.B -m
+or
+.B --match
+options, followed by the matching module name; after these, various
+extra command line options become available, depending on the specific
+module.  You can specify multiple extended match modules in one line,
+and you can use the
+.B -h
+or
+.B --help
+options after the module has been specified to receive help specific
+to that module.
+
+The following are included in the base package, and most of these can
+be preceded by a
+.B !
+to invert the sense of the match.
+.\" @MATCH@
+.SH TARGET EXTENSIONS
+ip6tables can use extended target modules: the following are included
+in the standard distribution.
+.\" @TARGET@
+.SH DIAGNOSTICS
+Various error messages are printed to standard error.  The exit code
+is 0 for correct functioning.  Errors which appear to be caused by
+invalid or abused command line parameters cause an exit code of 2, and
+other errors cause an exit code of 1.
+.SH BUGS
+Bugs?  What's this? ;-)
+Well... the counters are not reliable on sparc64.
+.SH COMPATIBILITY WITH IPCHAINS
+This 
+.B ip6tables
+is very similar to ipchains by Rusty Russell.  The main difference is
+that the chains 
+.B INPUT
+and
+.B OUTPUT
+are only traversed for packets coming into the local host and
+originating from the local host respectively.  Hence every packet only
+passes through one of the three chains (except loopback traffic, which
+involves both INPUT and OUTPUT chains); previously a forwarded packet
+would pass through all three.
+.PP
+The other main difference is that 
+.B -i
+refers to the input interface;
+.B -o
+refers to the output interface, and both are available for packets
+entering the
+.B FORWARD
+chain.
+.\" .PP The various forms of NAT have been separated out; 
+.\" .B iptables 
+.\" is a pure packet filter when using the default `filter' table, with
+.\" optional extension modules.  This should simplify much of the previous
+.\" confusion over the combination of IP masquerading and packet filtering
+.\" seen previously.  So the following options are handled differently:
+.\" .br
+.\" -j MASQ
+.\" .br
+.\" -M -S
+.\" .br
+.\" -M -L
+.\" .br
+There are several other changes in ip6tables.
+.SH SEE ALSO
+.BR ip6tables-save (8),
+.BR ip6tables-restore(8),
+.BR iptables (8),
+.BR iptables-save (8),
+.BR iptables-restore (8).
+.P
+The packet-filtering-HOWTO details iptables usage for
+packet filtering, the NAT-HOWTO details NAT,
+the netfilter-extensions-HOWTO details the extensions that are
+not in the standard distribution,
+and the netfilter-hacking-HOWTO details the netfilter internals.
+.br
+See
+.BR "http://www.netfilter.org/" .
+.SH AUTHORS
+Rusty Russell wrote iptables, in early consultation with Michael
+Neuling.
+.PP
+Marc Boucher made Rusty abandon ipnatctl by lobbying for a generic packet
+selection framework in iptables, then wrote the mangle table, the owner match,
+the mark stuff, and ran around doing cool stuff everywhere.
+.PP
+James Morris wrote the TOS target, and tos match.
+.PP
+Jozsef Kadlecsik wrote the REJECT target.
+.PP
+Harald Welte wrote the ULOG target, TTL match+target and libipulog.
+.PP
+The Netfilter Core Team is: Marc Boucher, Martin Josefsson, Jozsef Kadlecsik,
+James Morris, Harald Welte and Rusty Russell.
+.PP
+ip6tables man page created by Andras Kis-Szabo, based on
+iptables man page written by Herve Eychenne <rv@wallfire.org>.
+.\" .. and did I mention that we are incredibly cool people?
+.\" .. sexy, too ..
+.\" .. witty, charming, powerful ..
+.\" .. and most of all, modest ..
diff -urN iptables-1.2.9/ip6tables.c iptables-1.2.10/ip6tables.c
--- iptables-1.2.9/ip6tables.c	2003-06-30 18:16:54.000000000 +0200
+++ iptables-1.2.10/ip6tables.c	2004-06-15 00:02:16.000000000 +0200
@@ -292,9 +292,9 @@
 }
 
 void
-exit_printhelp(void)
+exit_printhelp(struct ip6tables_rule_match *matches)
 {
-	struct ip6tables_match *m = NULL;
+	struct ip6tables_rule_match *matchp = NULL;
 	struct ip6tables_target *t = NULL;
 
 	printf("%s v%s\n\n"
@@ -359,14 +359,16 @@
 
 	/* Print out any special helps. A user might like to be able to add a --help 
 	   to the commandline, and see expected results. So we call help for all 
-	   matches & targets */
-	for (t=ip6tables_targets;t;t=t->next) {
-		printf("\n");
-		t->help();
+	   specified matches & targets */
+	for (t = ip6tables_targets; t; t = t->next) {
+		if (t->used) {
+			printf("\n");
+			t->help();
+		}
 	}
-	for (m=ip6tables_matches;m;m=m->next) {
+	for (matchp = matches; matchp; matchp = matchp->next) {
 		printf("\n");
-		m->help();
+		matchp->match->help();
 	}
 	exit(0);
 }
@@ -675,6 +677,7 @@
 	int i, j, n;
 
 	strncpy(buf, name, sizeof(buf) - 1);
+	buf[sizeof(buf) - 1] = '\0';
 	if ((p = strrchr(buf, '/')) != NULL) {
 		*p = '\0';
 		addrp = parse_mask(p + 1);
@@ -704,7 +707,7 @@
 }
 
 struct ip6tables_match *
-find_match(const char *name, enum ip6t_tryload tryload)
+find_match(const char *name, enum ip6t_tryload tryload, struct ip6tables_rule_match **matches)
 {
 	struct ip6tables_match *ptr;
  	int icmphack = 0;
@@ -738,7 +741,7 @@
 		if (dlopen(path, RTLD_NOW)) {
 			/* Found library.  If it didn't register itself,
 			   maybe they specified target as match. */
-			ptr = find_match(name, DONT_LOAD);
+			ptr = find_match(name, DONT_LOAD, NULL);
 
 			if (!ptr)
 				exit_error(PARAMETER_PROBLEM,
@@ -762,15 +765,24 @@
 	}
 #endif
 
-	if (ptr)
-		ptr->used = 1;
+	if (ptr && matches) {
+		struct ip6tables_rule_match **i;
+		struct ip6tables_rule_match *newentry;
+
+		newentry = fw_malloc(sizeof(struct ip6tables_rule_match));
+
+		for (i = matches; *i; i = &(*i)->next);
+		newentry->match = ptr;
+		newentry->next = NULL;
+		*i = newentry;
+	}
 
 	return ptr;
 }
 
 /* Christophe Burki wants `-p 6' to imply `-m tcp'.  */
 static struct ip6tables_match *
-find_proto(const char *pname, enum ip6t_tryload tryload, int nolookup)
+find_proto(const char *pname, enum ip6t_tryload tryload, int nolookup, struct ip6tables_rule_match **matches)
 {
 	unsigned int proto;
 
@@ -778,9 +790,9 @@
 		char *protoname = proto_to_name(proto, nolookup);
 
 		if (protoname)
-			return find_match(protoname, tryload);
+			return find_match(protoname, tryload, matches);
 	} else
-		return find_match(pname, tryload);
+		return find_match(pname, tryload, matches);
 
 	return NULL;
 }
@@ -830,7 +842,7 @@
 			   " (%i)", arg, IFNAMSIZ-1);
 
 	strcpy(vianame, arg);
-	if (vialen == 0)
+	if ((vialen == 0) || (vialen == 1 && vianame[0] == '+'))
 		memset(mask, 0, IFNAMSIZ);
 	else if (vianame[vialen - 1] == '+') {
 		memset(mask, 0xFF, vialen - 1);
@@ -877,8 +889,8 @@
 
 	if (strlen(targetname)+1 > sizeof(ip6t_chainlabel))
 		exit_error(PARAMETER_PROBLEM,
-			   "Invalid target name `%s' (%i chars max)",
-			   targetname, sizeof(ip6t_chainlabel)-1);
+			   "Invalid target name `%s' (%u chars max)",
+			   targetname, (unsigned int)sizeof(ip6t_chainlabel)-1);
 
 	for (ptr = targetname; *ptr; ptr++)
 		if (isspace(*ptr))
@@ -888,18 +900,18 @@
 }
 
 int
-string_to_number(const char *s, unsigned int min, unsigned int max,
-		 unsigned int *ret)
+string_to_number_ll(const char *s, unsigned long long min, unsigned long long max,
+		 unsigned long long *ret)
 {
-	long number;
+	unsigned long long number;
 	char *end;
 
 	/* Handle hex, octal, etc. */
 	errno = 0;
-	number = strtol(s, &end, 0);
+	number = strtoull(s, &end, 0);
 	if (*end == '\0' && end != s) {
 		/* we parsed a number, let's see if we want this */
-		if (errno != ERANGE && min <= number && number <= max) {
+		if (errno != ERANGE && min <= number && (!max || number <= max)) {
 			*ret = number;
 			return 0;
 		}
@@ -907,6 +919,31 @@
 	return -1;
 }
 
+int
+string_to_number_l(const char *s, unsigned long min, unsigned long max,
+		 unsigned long *ret)
+{
+	int result;
+	unsigned long long number;
+
+	result = string_to_number_ll(s, min, max, &number);
+	*ret = (unsigned long)number;
+
+	return result;
+}
+
+int string_to_number(const char *s, unsigned int min, unsigned int max,
+		unsigned int *ret)
+{
+	int result;
+	unsigned long number;
+
+	result = string_to_number_l(s, min, max, &number);
+	*ret = (unsigned int)number;
+
+	return result;
+}
+
 static void
 set_option(unsigned int *options, unsigned int option, u_int8_t *invflg,
 	   int invert)
@@ -1018,7 +1055,7 @@
 		exit(1);
 	}
 
-	if (find_match(me->name, DONT_LOAD)) {
+	if (find_match(me->name, DONT_LOAD, NULL)) {
 		fprintf(stderr, "%s: match `%s' already registered.\n",
 			program_name, me->name);
 		exit(1);
@@ -1026,7 +1063,7 @@
 
 	if (me->size != IP6T_ALIGN(me->size)) {
 		fprintf(stderr, "%s: match `%s' has invalid size %u.\n",
-			program_name, me->name, me->size);
+			program_name, me->name, (unsigned int)me->size);
 		exit(1);
 	}
 
@@ -1056,7 +1093,7 @@
 
 	if (me->size != IP6T_ALIGN(me->size)) {
 		fprintf(stderr, "%s: target `%s' has invalid size %u.\n",
-			program_name, me->name, me->size);
+			program_name, me->name, (unsigned int)me->size);
 		exit(1);
 	}
 
@@ -1079,17 +1116,17 @@
 					number = (number + 500) / 1000;
 					if (number > 9999) {
 						number = (number + 500) / 1000;
-						printf(FMT("%4lluT ","%lluT "), number);
+						printf(FMT("%4lluT ","%lluT "), (unsigned long long)number);
 					}
-					else printf(FMT("%4lluG ","%lluG "), number);
+					else printf(FMT("%4lluG ","%lluG "), (unsigned long long)number);
 				}
-				else printf(FMT("%4lluM ","%lluM "), number);
+				else printf(FMT("%4lluM ","%lluM "), (unsigned long long)number);
 			} else
-				printf(FMT("%4lluK ","%lluK "), number);
+				printf(FMT("%4lluK ","%lluK "), (unsigned long long)number);
 		} else
-			printf(FMT("%5llu ","%llu "), number);
+			printf(FMT("%5llu ","%llu "), (unsigned long long)number);
 	} else
-		printf(FMT("%8llu ","%llu "), number);
+		printf(FMT("%8llu ","%llu "), (unsigned long long)number);
 }
 
 
@@ -1148,7 +1185,7 @@
 	    const struct ip6t_ip6 *ip,
 	    int numeric)
 {
-	struct ip6tables_match *match = find_match(m->u.user.name, TRY_LOAD);
+	struct ip6tables_match *match = find_match(m->u.user.name, TRY_LOAD, NULL);
 
 	if (match) {
 		if (match->print)
@@ -1279,7 +1316,7 @@
 			target->print(&fw->ipv6, t, format & FMT_NUMERIC);
 	} else if (t->u.target_size != sizeof(*t))
 		printf("[%u bytes of unknown target data] ",
-		       t->u.target_size - sizeof(*t));
+		       (unsigned int)(t->u.target_size - sizeof(*t)));
 
 	if (!(format & FMT_NONEWLINE))
 		fputc('\n', stdout);
@@ -1366,20 +1403,16 @@
 }
 
 static unsigned char *
-make_delete_mask(struct ip6t_entry *fw)
+make_delete_mask(struct ip6t_entry *fw, struct ip6tables_rule_match *matches)
 {
 	/* Establish mask for comparison */
 	unsigned int size;
-	struct ip6tables_match *m;
+	struct ip6tables_rule_match *matchp;
 	unsigned char *mask, *mptr;
 
 	size = sizeof(struct ip6t_entry);
-	for (m = ip6tables_matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		size += IP6T_ALIGN(sizeof(struct ip6t_entry_match)) + m->size;
-	}
+	for (matchp = matches; matchp; matchp = matchp->next)
+		size += IP6T_ALIGN(sizeof(struct ip6t_entry_match)) + matchp->match->size;
 
 	mask = fw_calloc(1, size
 			 + IP6T_ALIGN(sizeof(struct ip6t_entry_target))
@@ -1388,14 +1421,11 @@
 	memset(mask, 0xFF, sizeof(struct ip6t_entry));
 	mptr = mask + sizeof(struct ip6t_entry);
 
-	for (m = ip6tables_matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
+	for (matchp = matches; matchp; matchp = matchp->next) {
 		memset(mptr, 0xFF,
 		       IP6T_ALIGN(sizeof(struct ip6t_entry_match))
-		       + m->userspacesize);
-		mptr += IP6T_ALIGN(sizeof(struct ip6t_entry_match)) + m->size;
+		       + matchp->match->userspacesize);
+		mptr += IP6T_ALIGN(sizeof(struct ip6t_entry_match)) + matchp->match->size;
 	}
 
 	memset(mptr, 0xFF, 
@@ -1413,13 +1443,14 @@
 	     unsigned int ndaddrs,
 	     const struct in6_addr daddrs[],
 	     int verbose,
-	     ip6tc_handle_t *handle)
+	     ip6tc_handle_t *handle,
+	     struct ip6tables_rule_match *matches)
 {
 	unsigned int i, j;
 	int ret = 1;
 	unsigned char *mask;
 
-	mask = make_delete_mask(fw);
+	mask = make_delete_mask(fw, matches);
 	for (i = 0; i < nsaddrs; i++) {
 		fw->ipv6.src = saddrs[i];
 		for (j = 0; j < ndaddrs; j++) {
@@ -1429,6 +1460,8 @@
 			ret &= ip6tc_delete_entry(chain, fw, mask, handle);
 		}
 	}
+	free(mask);
+
 	return ret;
 }
 
@@ -1618,20 +1651,16 @@
 
 static struct ip6t_entry *
 generate_entry(const struct ip6t_entry *fw,
-	       struct ip6tables_match *matches,
+	       struct ip6tables_rule_match *matches,
 	       struct ip6t_entry_target *target)
 {
 	unsigned int size;
-	struct ip6tables_match *m;
+	struct ip6tables_rule_match *matchp;
 	struct ip6t_entry *e;
 
 	size = sizeof(struct ip6t_entry);
-	for (m = matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		size += m->m->u.match_size;
-	}
+	for (matchp = matches; matchp; matchp = matchp->next)
+		size += matchp->match->m->u.match_size;
 
 	e = fw_malloc(size + target->u.target_size);
 	*e = *fw;
@@ -1639,18 +1668,30 @@
 	e->next_offset = size + target->u.target_size;
 
 	size = 0;
-	for (m = matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		memcpy(e->elems + size, m->m, m->m->u.match_size);
-		size += m->m->u.match_size;
+	for (matchp = matches; matchp; matchp = matchp->next) {
+		memcpy(e->elems + size, matchp->match->m, matchp->match->m->u.match_size);
+		size += matchp->match->m->u.match_size;
 	}
 	memcpy(e->elems + size, target, target->u.target_size);
 
 	return e;
 }
 
+void clear_rule_matches(struct ip6tables_rule_match **matches)
+{
+	struct ip6tables_rule_match *matchp, *tmp;
+
+	for (matchp = *matches; matchp;) {
+		tmp = matchp->next;
+		if (matchp->match->m)
+			free(matchp->match->m);
+		free(matchp);
+		matchp = tmp;
+	}
+
+	*matches = NULL;
+}
+
 int do_command6(int argc, char *argv[], char **table, ip6tc_handle_t *handle)
 {
 	struct ip6t_entry fw, *e = NULL;
@@ -1666,6 +1707,8 @@
 	const char *pcnt = NULL, *bcnt = NULL;
 	int ret = 1;
 	struct ip6tables_match *m;
+	struct ip6tables_rule_match *matches = NULL;
+	struct ip6tables_rule_match *matchp;
 	struct ip6tables_target *target = NULL;
 	struct ip6tables_target *t;
 	const char *jumpto = "";
@@ -1676,19 +1719,14 @@
 
 	memset(&fw, 0, sizeof(fw));
 
-	opts = original_opts;
-	global_option_offset = 0;
-
 	/* re-set optind to 0 in case do_command gets called
 	 * a second time */
 	optind = 0;
 
 	/* clear mflags in case do_command gets called a second time
 	 * (we clear the global list of all matches for security)*/
-	for (m = ip6tables_matches; m; m = m->next) {
+	for (m = ip6tables_matches; m; m = m->next)
 		m->mflags = 0;
-		m->used = 0;
-	}
 
 	for (t = ip6tables_targets; t; t = t->next) {
 		t->tflags = 0;
@@ -1828,10 +1866,10 @@
 				optarg = argv[optind];
 
 			/* iptables -p icmp -h */
-			if (!ip6tables_matches && protocol)
-				find_match(protocol, TRY_LOAD);
+			if (!matches && protocol)
+				find_match(protocol, TRY_LOAD, &matches);
 
-			exit_printhelp();
+			exit_printhelp(matches);
 
 			/*
 			 * Option selection
@@ -1930,7 +1968,7 @@
 				exit_error(PARAMETER_PROBLEM,
 					   "unexpected ! flag before --match");
 
-			m = find_match(optarg, LOAD_MUST_SUCCEED);
+			m = find_match(optarg, LOAD_MUST_SUCCEED, &matches);
 			size = IP6T_ALIGN(sizeof(struct ip6t_entry_match))
 					 + m->size;
 			m->m = fw_calloc(1, size);
@@ -1988,12 +2026,12 @@
 					"-%c requires packet and byte counter",
 					opt2char(OPT_COUNTERS));
 
-			if (sscanf(pcnt, "%llu", &fw.counters.pcnt) != 1)
+			if (sscanf(pcnt, "%llu", (unsigned long long *)&fw.counters.pcnt) != 1)
 				exit_error(PARAMETER_PROBLEM,
 					"-%c packet counter not numeric",
 					opt2char(OPT_COUNTERS));
 
-			if (sscanf(bcnt, "%llu", &fw.counters.bcnt) != 1)
+			if (sscanf(bcnt, "%llu", (unsigned long long *)&fw.counters.bcnt) != 1)
 				exit_error(PARAMETER_PROBLEM,
 					"-%c byte counter not numeric",
 					opt2char(OPT_COUNTERS));
@@ -2022,18 +2060,16 @@
 					       argv, invert,
 					       &target->tflags,
 					       &fw, &target->t))) {
-				for (m = ip6tables_matches; m; m = m->next) {
-					if (!m->used)
-						continue;
-
-					if (m->parse(c - m->option_offset,
+				for (matchp = matches; matchp; matchp = matchp->next) {
+					if (matchp->match->parse(c - matchp->match->option_offset,
 						     argv, invert,
-						     &m->mflags,
+						     &matchp->match->mflags,
 						     &fw,
 						     &fw.nfcache,
-						     &m->m))
+						     &matchp->match->m))
 						break;
 				}
+				m = matchp ? matchp->match : NULL;
 
 				/* If you listen carefully, you can
 				   actually hear this code suck. */
@@ -2061,13 +2097,13 @@
 				if (m == NULL
 				    && protocol
 				    && (!find_proto(protocol, DONT_LOAD,
-						   options&OPT_NUMERIC) 
+						   options&OPT_NUMERIC, NULL) 
 					|| (find_proto(protocol, DONT_LOAD,
-							options&OPT_NUMERIC)
+							options&OPT_NUMERIC, NULL)
 					    && (proto_used == 0))
 				       )
 				    && (m = find_proto(protocol, TRY_LOAD,
-						       options&OPT_NUMERIC))) {
+						       options&OPT_NUMERIC, &matches))) {
 					/* Try loading protocol */
 					size_t size;
 					
@@ -2097,12 +2133,8 @@
 		invert = FALSE;
 	}
 
-	for (m = ip6tables_matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		m->final_check(m->mflags);
-	}
+	for (matchp = matches; matchp; matchp = matchp->next)
+		matchp->match->final_check(matchp->match->mflags);
 
 	if (target)
 		target->final_check(target->tflags);
@@ -2192,6 +2224,9 @@
 			printf("Warning: using chain %s, not extension\n",
 			       jumpto);
 
+			if (target->t)
+				free(target->t);
+
 			target = NULL;
 		}
 
@@ -2220,7 +2255,8 @@
 			 * chain. */
 			find_target(jumpto, LOAD_MUST_SUCCEED);
 		} else {
-			e = generate_entry(&fw, ip6tables_matches, target->t);
+			e = generate_entry(&fw, matches, target->t);
+			free(target->t);
 		}
 	}
 
@@ -2235,7 +2271,7 @@
 		ret = delete_entry(chain, e,
 				   nsaddrs, saddrs, ndaddrs, daddrs,
 				   options&OPT_VERBOSE,
-				   handle);
+				   handle, matches);
 		break;
 	case CMD_DELETE_NUM:
 		ret = ip6tc_delete_num_entry(chain, rulenum - 1, handle);
@@ -2296,5 +2332,24 @@
 	if (verbose > 1)
 		dump_entries6(*handle);
 
+	clear_rule_matches(&matches);
+
+	if (e != NULL) {
+		free(e);
+		e = NULL;
+	}
+
+	for (c = 0; c < nsaddrs; c++)
+		free(&saddrs[c]);
+
+	for (c = 0; c < ndaddrs; c++)
+		free(&daddrs[c]);
+
+	if (opts != original_opts) {
+		free(opts);
+		opts = original_opts;
+		global_option_offset = 0;
+	}
+
 	return ret;
 }
diff -urN iptables-1.2.9/iptables-restore.c iptables-1.2.10/iptables-restore.c
--- iptables-1.2.9/iptables-restore.c	2003-05-03 20:52:13.000000000 +0200
+++ iptables-1.2.10/iptables-restore.c	2004-06-15 00:02:16.000000000 +0200
@@ -4,7 +4,7 @@
  *
  * This code is distributed under the terms of GNU GPL v2
  *
- * $Id: iptables-restore.c,v 1.26 2003/05/02 15:30:11 laforge Exp $
+ * $Id: iptables-restore.c,v 1.34 2004/05/26 16:04:48 gandalf Exp $
  */
 
 #include <getopt.h>
@@ -27,7 +27,8 @@
 static struct option options[] = {
 	{ "binary", 0, 0, 'b' },
 	{ "counters", 0, 0, 'c' },
-	{ "verbose", 1, 0, 'v' },
+	{ "verbose", 0, 0, 'v' },
+	{ "test", 0, 0, 't' },
 	{ "help", 0, 0, 'h' },
 	{ "noflush", 0, 0, 'n'},
 	{ "modprobe", 1, 0, 'M'},
@@ -38,10 +39,11 @@
 
 static void print_usage(const char *name, const char *version)
 {
-	fprintf(stderr, "Usage: %s [-b] [-c] [-v] [-h]\n"
+	fprintf(stderr, "Usage: %s [-b] [-c] [-v] [-t] [-h]\n"
 			"	   [ --binary ]\n"
 			"	   [ --counters ]\n"
 			"	   [ --verbose ]\n"
+			"	   [ --test ]\n"
 			"	   [ --help ]\n"
 			"	   [ --noflush ]\n"
 		        "          [ --modprobe=<command>]\n", name);
@@ -71,7 +73,7 @@
 
 int parse_counters(char *string, struct ipt_counters *ctr)
 {
-	return (sscanf(string, "[%llu:%llu]", &ctr->pcnt, &ctr->bcnt) == 2);
+	return (sscanf(string, "[%llu:%llu]", (unsigned long long *)&ctr->pcnt, (unsigned long long *)&ctr->bcnt) == 2);
 }
 
 /* global new argv and argc */
@@ -105,7 +107,7 @@
 	char curtable[IPT_TABLE_MAXNAMELEN + 1];
 	FILE *in;
 	const char *modprobe = 0;
-	int in_table = 0;
+	int in_table = 0, testing = 0;
 
 	program_name = "iptables-restore";
 	program_version = IPTABLES_VERSION;
@@ -115,7 +117,7 @@
 	init_extensions();
 #endif
 
-	while ((c = getopt_long(argc, argv, "bcvhnM:", options, NULL)) != -1) {
+	while ((c = getopt_long(argc, argv, "bcvthnM:", options, NULL)) != -1) {
 		switch (c) {
 			case 'b':
 				binary = 1;
@@ -126,6 +128,9 @@
 			case 'v':
 				verbose = 1;
 				break;
+			case 't':
+				testing = 1;
+				break;
 			case 'h':
 				print_usage("iptables-restore",
 					    IPTABLES_VERSION);
@@ -158,13 +163,20 @@
 		int ret = 0;
 
 		line++;
-		if (buffer[0] == '\n') continue;
+		if (buffer[0] == '\n')
+			continue;
 		else if (buffer[0] == '#') {
-			if (verbose) fputs(buffer, stdout);
+			if (verbose)
+				fputs(buffer, stdout);
 			continue;
 		} else if ((strcmp(buffer, "COMMIT\n") == 0) && (in_table)) {
-			DEBUGP("Calling commit\n");
-			ret = iptc_commit(&handle);
+			if (!testing) {
+				DEBUGP("Calling commit\n");
+				ret = iptc_commit(&handle);
+			} else {
+				DEBUGP("Not calling commit, testing\n");
+				ret = 1;
+			}
 			in_table = 0;
 		} else if ((buffer[0] == '*') && (!in_table)) {
 			/* New table */
@@ -179,6 +191,7 @@
 				exit(1);
 			}
 			strncpy(curtable, table, IPT_TABLE_MAXNAMELEN);
+			curtable[IPT_TABLE_MAXNAMELEN] = '\0';
 
 			if (handle)
 				iptc_free(&handle);
@@ -318,7 +331,11 @@
 			
 			for (curchar = parsestart; *curchar; curchar++) {
 				if (*curchar == '"') {
-					if (quote_open) {
+					/* quote_open cannot be true if there
+					 * was no previous character.  Thus, 
+					 * curchar-1 has to be within bounds */
+					if (quote_open && 
+					    *(curchar-1) != '\\') {
 						quote_open = 0;
 						*curchar = ' ';
 					} else {
@@ -379,6 +396,11 @@
 			exit(1);
 		}
 	}
+	if (in_table) {
+		fprintf(stderr, "%s: COMMIT expected at line %u\n",
+				program_name, line + 1);
+		exit(1);
+	}
 
 	return 0;
 }
diff -urN iptables-1.2.9/iptables-save.c iptables-1.2.10/iptables-save.c
--- iptables-1.2.9/iptables-save.c	2003-05-03 20:52:13.000000000 +0200
+++ iptables-1.2.10/iptables-save.c	2004-06-15 00:02:16.000000000 +0200
@@ -13,6 +13,7 @@
 #include <string.h>
 #include <dlfcn.h>
 #include <time.h>
+#include <netdb.h>
 #include "libiptc/libiptc.h"
 #include "iptables.h"
 
@@ -75,6 +76,7 @@
 	{ "icmp", IPPROTO_ICMP },
 	{ "esp", IPPROTO_ESP },
 	{ "ah", IPPROTO_AH },
+	{ "sctp", IPPROTO_SCTP },
 };
 
 static void print_proto(u_int16_t proto, int invert)
@@ -83,6 +85,12 @@
 		unsigned int i;
 		const char *invertstr = invert ? "! " : "";
 
+		struct protoent *pent = getprotobynumber(proto);
+		if (pent) {
+			printf("-p %s%s ", invertstr, pent->p_name);
+			return;
+		}
+
 		for (i = 0; i < sizeof(chain_protos)/sizeof(struct pprot); i++)
 			if (chain_protos[i].num == proto) {
 				printf("-p %s%s ",
@@ -111,7 +119,7 @@
 			const struct ipt_ip *ip)
 {
 	struct iptables_match *match
-		= find_match(e->u.user.name, TRY_LOAD);
+		= find_match(e->u.user.name, TRY_LOAD, NULL);
 
 	if (match) {
 		printf("-m %s ", e->u.user.name);
@@ -157,7 +165,7 @@
 
 	/* print counters */
 	if (counters)
-		printf("[%llu:%llu] ", e->counters.pcnt, e->counters.bcnt);
+		printf("[%llu:%llu] ", (unsigned long long)e->counters.pcnt, (unsigned long long)e->counters.bcnt);
 
 	/* print chain name */
 	printf("-A %s ", chain);
@@ -276,7 +284,7 @@
 				struct ipt_counters count;
 				printf("%s ",
 				       iptc_get_policy(chain, &count, &h));
-				printf("[%llu:%llu]\n", count.pcnt, count.bcnt);
+				printf("[%llu:%llu]\n", (unsigned long long)count.pcnt, (unsigned long long)count.bcnt);
 			} else {
 				printf("- [0:0]\n");
 			}
diff -urN iptables-1.2.9/iptables.8 iptables-1.2.10/iptables.8
--- iptables-1.2.9/iptables.8	2003-06-30 18:16:54.000000000 +0200
+++ iptables-1.2.10/iptables.8	1970-01-01 01:00:00.000000000 +0100
@@ -1,1072 +0,0 @@
-.TH IPTABLES 8 "Mar 09, 2002" "" ""
-.\"
-.\" Man page written by Herve Eychenne <rv@wallfire.org> (May 1999)
-.\" It is based on ipchains page.
-.\" TODO: add a word for protocol helpers (FTP, IRC, SNMP-ALG)
-.\"
-.\" ipchains page by Paul ``Rusty'' Russell March 1997
-.\" Based on the original ipfwadm man page by Jos Vos <jos@xos.nl>
-.\"
-.\"	This program is free software; you can redistribute it and/or modify
-.\"	it under the terms of the GNU General Public License as published by
-.\"	the Free Software Foundation; either version 2 of the License, or
-.\"	(at your option) any later version.
-.\"
-.\"	This program is distributed in the hope that it will be useful,
-.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
-.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-.\"	GNU General Public License for more details.
-.\"
-.\"	You should have received a copy of the GNU General Public License
-.\"	along with this program; if not, write to the Free Software
-.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-.\"
-.\"
-.SH NAME
-iptables \- administration tool for IPv4 packet filtering and NAT
-.SH SYNOPSIS
-.BR "iptables [-t table] -[AD] " "chain rule-specification [options]"
-.br
-.BR "iptables [-t table] -I " "chain [rulenum] rule-specification [options]"
-.br
-.BR "iptables [-t table] -R " "chain rulenum rule-specification [options]"
-.br
-.BR "iptables [-t table] -D " "chain rulenum [options]"
-.br
-.BR "iptables [-t table] -[LFZ] " "[chain] [options]"
-.br
-.BR "iptables [-t table] -N " "chain"
-.br
-.BR "iptables [-t table] -X " "[chain]"
-.br
-.BR "iptables [-t table] -P " "chain target [options]"
-.br
-.BR "iptables [-t table] -E " "old-chain-name new-chain-name"
-.SH DESCRIPTION
-.B Iptables
-is used to set up, maintain, and inspect the tables of IP packet
-filter rules in the Linux kernel.  Several different tables
-may be defined.  Each table contains a number of built-in
-chains and may also contain user-defined chains.
-
-Each chain is a list of rules which can match a set of packets.  Each
-rule specifies what to do with a packet that matches.  This is called
-a `target', which may be a jump to a user-defined chain in the same
-table.
-
-.SH TARGETS
-A firewall rule specifies criteria for a packet, and a target.  If the
-packet does not match, the next rule in the chain is the examined; if
-it does match, then the next rule is specified by the value of the
-target, which can be the name of a user-defined chain or one of the
-special values 
-.IR ACCEPT ,
-.IR DROP ,
-.IR QUEUE ,
-or
-.IR RETURN .
-.PP
-.I ACCEPT 
-means to let the packet through.
-.I DROP
-means to drop the packet on the floor.
-.I QUEUE
-means to pass the packet to userspace (if supported by the kernel).
-.I RETURN
-means stop traversing this chain and resume at the next rule in the
-previous (calling) chain.  If the end of a built-in chain is reached
-or a rule in a built-in chain with target
-.I RETURN
-is matched, the target specified by the chain policy determines the
-fate of the packet.
-.SH TABLES
-There are currently three independent tables (which tables are present
-at any time depends on the kernel configuration options and which
-modules are present).
-.TP
-.BI "-t, --table " "table"
-This option specifies the packet matching table which the command
-should operate on.  If the kernel is configured with automatic module
-loading, an attempt will be made to load the appropriate module for
-that table if it is not already there.
-
-The tables are as follows:
-.RS
-.TP .4i
-.BR "filter" :
-This is the default table (if no -t option is passed).  It contains
-the built-in chains
-.B INPUT
-(for packets coming into the box itself),
-.B FORWARD
-(for packets being routed through the box), and
-.B OUTPUT
-(for locally-generated packets).
-.TP
-.BR "nat" :
-This table is consulted when a packet that creates a new
-connection is encountered.  It consists of three built-ins:
-.B PREROUTING
-(for altering packets as soon as they come in),
-.B OUTPUT
-(for altering locally-generated packets before routing), and
-.B POSTROUTING
-(for altering packets as they are about to go out).
-.TP
-.BR "mangle" :
-This table is used for specialized packet alteration.  Until kernel
-2.4.17 it had two built-in chains:
-.B PREROUTING
-(for altering incoming packets before routing) and
-.B OUTPUT
-(for altering locally-generated packets before routing).
-Since kernel 2.4.18, three other built-in chains are also supported:
-.B INPUT
-(for packets coming into the box itself),
-.B FORWARD
-(for altering packets being routed through the box), and
-.B POSTROUTING
-(for altering packets as they are about to go out).
-.RE
-.SH OPTIONS
-The options that are recognized by
-.B iptables
-can be divided into several different groups.
-.SS COMMANDS
-These options specify the specific action to perform.  Only one of them
-can be specified on the command line unless otherwise specified
-below.  For all the long versions of the command and option names, you
-need to use only enough letters to ensure that
-.B iptables
-can differentiate it from all other options.
-.TP
-.BI "-A, --append " "chain rule-specification"
-Append one or more rules to the end of the selected chain.
-When the source and/or destination names resolve to more than one
-address, a rule will be added for each possible address combination.
-.TP
-.BI "-D, --delete " "chain rule-specification"
-.ns
-.TP
-.BI "-D, --delete " "chain rulenum"
-Delete one or more rules from the selected chain.  There are two
-versions of this command: the rule can be specified as a number in the
-chain (starting at 1 for the first rule) or a rule to match.
-.TP
-.BR "-I, --insert " "\fIchain\fP [\fIrulenum\fP] \fIrule-specification\fP"
-Insert one or more rules in the selected chain as the given rule
-number.  So, if the rule number is 1, the rule or rules are inserted
-at the head of the chain.  This is also the default if no rule number
-is specified.
-.TP
-.BI "-R, --replace " "chain rulenum rule-specification"
-Replace a rule in the selected chain.  If the source and/or
-destination names resolve to multiple addresses, the command will
-fail.  Rules are numbered starting at 1.
-.TP
-.BR "-L, --list " "[\fIchain\fP]"
-List all rules in the selected chain.  If no chain is selected, all
-chains are listed.  As every other iptables command, it applies to the
-specified table (filter is the default), so NAT rules get listed by
-.nf
- iptables -t nat -n -L
-.fi
-Please note that it is often used with the
-.B -n
-option, in order to avoid long reverse DNS lookups.
-It is legal to specify the
-.B -Z
-(zero) option as well, in which case the chain(s) will be atomically
-listed and zeroed.  The exact output is affected by the other
-arguments given. The exact rules are suppressed until you use
-.nf
- iptables -L -v
-.fi
-.TP
-.BR "-F, --flush " "[\fIchain\fP]"
-Flush the selected chain (all the chains in the table if none is given).
-This is equivalent to deleting all the rules one by one.
-.TP
-.BR "-Z, --zero " "[\fIchain\fP]"
-Zero the packet and byte counters in all chains.  It is legal to
-specify the
-.B "-L, --list"
-(list) option as well, to see the counters immediately before they are
-cleared. (See above.)
-.TP
-.BI "-N, --new-chain " "chain"
-Create a new user-defined chain by the given name.  There must be no
-target of that name already.
-.TP
-.BR "-X, --delete-chain " "[\fIchain\fP]"
-Delete the optional user-defined chain specified.  There must be no references
-to the chain.  If there are, you must delete or replace the referring
-rules before the chain can be deleted.  If no argument is given, it
-will attempt to delete every non-builtin chain in the table.
-.TP
-.BI "-P, --policy " "chain target"
-Set the policy for the chain to the given target.  See the section
-.B TARGETS
-for the legal targets.  Only built-in (non-user-defined) chains can have
-policies, and neither built-in nor user-defined chains can be policy
-targets.
-.TP
-.BI "-E, --rename-chain " "old-chain new-chain"
-Rename the user specified chain to the user supplied name.  This is
-cosmetic, and has no effect on the structure of the table.
-.TP
-.B -h
-Help.
-Give a (currently very brief) description of the command syntax.
-.SS PARAMETERS
-The following parameters make up a rule specification (as used in the
-add, delete, insert, replace and append commands).
-.TP
-.BR "-p, --protocol " "[!] \fIprotocol\fP"
-The protocol of the rule or of the packet to check.
-The specified protocol can be one of
-.IR tcp ,
-.IR udp ,
-.IR icmp ,
-or
-.IR all ,
-or it can be a numeric value, representing one of these protocols or a
-different one.  A protocol name from /etc/protocols is also allowed.
-A "!" argument before the protocol inverts the
-test.  The number zero is equivalent to
-.IR all .
-Protocol
-.I all
-will match with all protocols and is taken as default when this
-option is omitted.
-.TP
-.BR "-s, --source " "[!] \fIaddress\fP[/\fImask\fP]"
-Source specification.
-.I Address
-can be either a network name, a hostname (please note that specifying
-any name to be resolved with a remote query such as DNS is a really bad idea),
-a network IP address (with /mask), or a plain IP address.
-The
-.I mask
-can be either a network mask or a plain number,
-specifying the number of 1's at the left side of the network mask.
-Thus, a mask of
-.I 24
-is equivalent to
-.IR 255.255.255.0 .
-A "!" argument before the address specification inverts the sense of
-the address. The flag
-.B --src
-is an alias for this option.
-.TP
-.BR "-d, --destination " "[!] \fIaddress\fP[/\fImask\fP]"
-Destination specification. 
-See the description of the
-.B -s
-(source) flag for a detailed description of the syntax.  The flag
-.B --dst
-is an alias for this option.
-.TP
-.BI "-j, --jump " "target"
-This specifies the target of the rule; i.e., what to do if the packet
-matches it.  The target can be a user-defined chain (other than the
-one this rule is in), one of the special builtin targets which decide
-the fate of the packet immediately, or an extension (see
-.B EXTENSIONS
-below).  If this
-option is omitted in a rule, then matching the rule will have no
-effect on the packet's fate, but the counters on the rule will be
-incremented.
-.TP
-.BR "-i, --in-interface " "[!] \fIname\fP"
-Name of an interface via which a packet is going to be received (only for
-packets entering the 
-.BR INPUT ,
-.B FORWARD
-and
-.B PREROUTING
-chains).  When the "!" argument is used before the interface name, the
-sense is inverted.  If the interface name ends in a "+", then any
-interface which begins with this name will match.  If this option is
-omitted, any interface name will match.
-.TP
-.BR "-o, --out-interface " "[!] \fIname\fP"
-Name of an interface via which a packet is going to be sent (for packets
-entering the
-.BR FORWARD ,
-.B OUTPUT
-and
-.B POSTROUTING
-chains).  When the "!" argument is used before the interface name, the
-sense is inverted.  If the interface name ends in a "+", then any
-interface which begins with this name will match.  If this option is
-omitted, any interface name will match.
-.TP
-.B "[!] " "-f, --fragment"
-This means that the rule only refers to second and further fragments
-of fragmented packets.  Since there is no way to tell the source or
-destination ports of such a packet (or ICMP type), such a packet will
-not match any rules which specify them.  When the "!" argument
-precedes the "-f" flag, the rule will only match head fragments, or
-unfragmented packets.
-.TP
-.BI "-c, --set-counters " "PKTS BYTES"
-This enables the administrator to initialize the packet and byte
-counters of a rule (during
-.B INSERT,
-.B APPEND,
-.B REPLACE
-operations).
-.SS "OTHER OPTIONS"
-The following additional options can be specified:
-.TP
-.B "-v, --verbose"
-Verbose output.  This option makes the list command show the interface
-name, the rule options (if any), and the TOS masks.  The packet and
-byte counters are also listed, with the suffix 'K', 'M' or 'G' for
-1000, 1,000,000 and 1,000,000,000 multipliers respectively (but see
-the
-.B -x
-flag to change this).
-For appending, insertion, deletion and replacement, this causes
-detailed information on the rule or rules to be printed.
-.TP
-.B "-n, --numeric"
-Numeric output.
-IP addresses and port numbers will be printed in numeric format.
-By default, the program will try to display them as host names,
-network names, or services (whenever applicable).
-.TP
-.B "-x, --exact"
-Expand numbers.
-Display the exact value of the packet and byte counters,
-instead of only the rounded number in K's (multiples of 1000)
-M's (multiples of 1000K) or G's (multiples of 1000M).  This option is
-only relevant for the 
-.B -L
-command.
-.TP
-.B "--line-numbers"
-When listing rules, add line numbers to the beginning of each rule,
-corresponding to that rule's position in the chain.
-.TP
-.B "--modprobe=command"
-When adding or inserting rules into a chain, use
-.B command
-to load any necessary modules (targets, match extensions, etc).
-.SH MATCH EXTENSIONS
-iptables can use extended packet matching modules.  These are loaded
-in two ways: implicitly, when
-.B -p
-or
-.B --protocol
-is specified, or with the
-.B -m
-or
-.B --match
-options, followed by the matching module name; after these, various
-extra command line options become available, depending on the specific
-module.  You can specify multiple extended match modules in one line,
-and you can use the
-.B -h
-or
-.B --help
-options after the module has been specified to receive help specific
-to that module.
-
-The following are included in the base package, and most of these can
-be preceded by a
-.B !
-to invert the sense of the match.
-.SS ah
-This module matches the SPIs in AH header of IPSec packets.
-.TP
-.BR "--ahspi " "[!] \fIspi\fP[:\fIspi\fP]"
-.SS conntrack
-This module, when combined with connection tracking, allows access to
-more connection tracking information than the "state" match.
-(this module is present only if iptables was compiled under a kernel
-supporting this feature)
-.TP
-.BI "--ctstate " "state"
-Where state is a comma separated list of the connection states to
-match.  Possible states are
-.B INVALID
-meaning that the packet is associated with no known connection,
-.B ESTABLISHED
-meaning that the packet is associated with a connection which has seen
-packets in both directions,
-.B NEW
-meaning that the packet has started a new connection, or otherwise
-associated with a connection which has not seen packets in both
-directions, and
-.B RELATED
-meaning that the packet is starting a new connection, but is
-associated with an existing connection, such as an FTP data transfer,
-or an ICMP error.
-.B SNAT
-A virtual state, matching if the original source address differs from
-the reply destination.
-.B DNAT
-A virtual state, matching if the original destination differs from the
-reply source.
-.TP
-.BI "--ctproto " "proto"
-Protocol to match (by number or name)
-.TP
-.BI "--ctorigsrc " "[!] \fIaddress\fP[/\fImask\fP]"
-Match against original source address
-.TP
-.BI "--ctorigdst " "[!] \fIaddress\fP[/\fImask\fP]"
-Match against original destination address
-.TP
-.BI "--ctreplsrc " "[!] \fIaddress\fP[/\fImask\fP]"
-Match against reply source address
-.TP
-.BI "--ctrepldst " "[!] \fIaddress\fB[/\fImask\fP]"
-Match against reply destination address
-.TP
-.BI "--ctstatus " "[\fINONE|EXPECTED|SEEN_REPLY|ASSURED\fP][,...]"
-Match against internal conntrack states
-.TP
-.BI "--ctexpire " "\fItime\fP[\fI:time\fP]"
-Match remaining lifetime in seconds against given value
-or range of values (inclusive)
-.SS dscp
-This module matches the 6 bit DSCP field within the TOS field in the
-IP header.  DSCP has superseded TOS within the IETF.
-.TP
-.BI "--dscp " "value"
-Match against a numeric (decimal or hex) value [0-32].
-.TP
-.BI "--dscp-class " "\fIDiffServ Class\fP"
-Match the DiffServ class. This value may be any of the
-BE, EF, AFxx or CSx classes.  It will then be converted
-into it's according numeric value.
-.SS esp
-This module matches the SPIs in ESP header of IPSec packets.
-.TP
-.BR "--espspi " "[!] \fIspi\fP[:\fIspi\fP]"
-.SS helper
-This module matches packets related to a specific conntrack-helper.
-.TP
-.BI "--helper " "string"
-Matches packets related to the specified conntrack-helper.
-.RS
-.PP
-string can be "ftp" for packets related to a ftp-session on default port.
-For other ports append -portnr to the value, ie. "ftp-2121".
-.PP
-Same rules apply for other conntrack-helpers.
-.RE
-.SS icmp
-This extension is loaded if `--protocol icmp' is specified.  It
-provides the following option:
-.TP
-.BR "--icmp-type " "[!] \fItypename\fP"
-This allows specification of the ICMP type, which can be a numeric
-ICMP type, or one of the ICMP type names shown by the command
-.nf
- iptables -p icmp -h
-.fi
-.SS length
-This module matches the length of a packet against a specific value
-or range of values.
-.TP
-.BR "--length " "\fIlength\fP[:\fIlength\fP]"
-.SS limit
-This module matches at a limited rate using a token bucket filter.
-A rule using this extension will match until this limit is reached
-(unless the `!' flag is used).  It can be used in combination with the
-.B LOG
-target to give limited logging, for example.
-.TP
-.BI "--limit " "rate"
-Maximum average matching rate: specified as a number, with an optional
-`/second', `/minute', `/hour', or `/day' suffix; the default is
-3/hour.
-.TP
-.BI "--limit-burst " "number"
-Maximum initial number of packets to match: this number gets
-recharged by one every time the limit specified above is not reached,
-up to this number; the default is 5.
-.SS mac
-.TP
-.BR "--mac-source " "[!] \fIaddress\fP"
-Match source MAC address.  It must be of the form XX:XX:XX:XX:XX:XX.
-Note that this only makes sense for packets coming from an Ethernet device
-and entering the
-.BR PREROUTING ,
-.B FORWARD
-or
-.B INPUT
-chains.
-.SS mark
-This module matches the netfilter mark field associated with a packet
-(which can be set using the
-.B MARK
-target below).
-.TP
-.BR "--mark " "\fIvalue\fP[/\fImask\fP]"
-Matches packets with the given unsigned mark value (if a mask is
-specified, this is logically ANDed with the mask before the
-comparison).
-.SS multiport
-This module matches a set of source or destination ports.  Up to 15
-ports can be specified.  It can only be used in conjunction with
-.B "-p tcp"
-or
-.BR "-p udp" .
-.TP
-.BR "--source-ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
-Match if the source port is one of the given ports.  The flag
-.B --sports
-is a convenient alias for this option.
-.TP
-.BR "--destination-ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
-Match if the destination port is one of the given ports.  The flag
-.B --dports
-is a convenient alias for this option.
-.TP
-.BR "--ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
-Match if the both the source and destination ports are equal to each
-other and to one of the given ports.
-.SS owner
-This module attempts to match various characteristics of the packet
-creator, for locally-generated packets.  It is only valid in the
-.B OUTPUT
-chain, and even this some packets (such as ICMP ping responses) may
-have no owner, and hence never match.
-.TP
-.BI "--uid-owner " "userid"
-Matches if the packet was created by a process with the given
-effective user id.
-.TP
-.BI "--gid-owner " "groupid"
-Matches if the packet was created by a process with the given
-effective group id.
-.TP
-.BI "--pid-owner " "processid"
-Matches if the packet was created by a process with the given
-process id.
-.TP
-.BI "--sid-owner " "sessionid"
-Matches if the packet was created by a process in the given session
-group.
-.TP
-.BI "--cmd-owner " "name"
-Matches if the packet was created by a process with the given command name.
-(this option is present only if iptables was compiled under a kernel
-supporting this feature)
-.SS physdev
-This module matches on the bridge port input and output devices enslaved
-to a bridge device. This module is a part of the infrastructure that enables
-a transparent bridging IP firewall and is only useful for kernel versions
-above version 2.5.44.
-.TP
-.B --physdev-in name
-Name of a bridge port via which a packet is received (only for
-packets entering the
-.BR INPUT ,
-.B FORWARD
-and
-.B PREROUTING
-chains). If the interface name ends in a "+", then any
-interface which begins with this name will match. If the packet didn't arrive
-through a bridge device, this packet won't match this option, unless '!' is used.
-.TP
-.B --physdev-out name
-Name of a bridge port via which a packet is going to be sent (for packets
-entering the
-.BR FORWARD ,
-.B OUTPUT
-and
-.B POSTROUTING
-chains).  If the interface name ends in a "+", then any
-interface which begins with this name will match. Note that in the
-.BR nat " and " mangle
-.B OUTPUT
-chains one cannot match on the bridge output port, however one can in the
-.B "filter OUTPUT"
-chain. If the packet won't leave by a bridge device or it is yet unknown what
-the output device will be, then the packet won't match this option, unless
-'!' is used.
-.TP
-.B --physdev-is-in
-Matches if the packet has entered through a bridge interface.
-.TP
-.B --physdev-is-out
-Matches if the packet will leave through a bridge interface.
-.TP
-.B --physdev-is-bridged
-Matches if the packet is being bridged and therefore is not being routed.
-This is only useful in the FORWARD and POSTROUTING chains.
-.SS pkttype
-This module matches the link-layer packet type.
-.TP
-.BI "--pkt-type " "[\fIunicast\fP|\fIbroadcast\fP|\fImulticast\fP]"
-.SS state
-This module, when combined with connection tracking, allows access to
-the connection tracking state for this packet.
-.TP
-.BI "--state " "state"
-Where state is a comma separated list of the connection states to
-match.  Possible states are
-.B INVALID
-meaning that the packet could not be identified for some reason which
-includes running out of memory and ICMP errors which don't correspond to any
-known connection,
-.B ESTABLISHED
-meaning that the packet is associated with a connection which has seen
-packets in both directions,
-.B NEW
-meaning that the packet has started a new connection, or otherwise
-associated with a connection which has not seen packets in both
-directions, and
-.B RELATED
-meaning that the packet is starting a new connection, but is
-associated with an existing connection, such as an FTP data transfer,
-or an ICMP error.
-.SS tcp
-These extensions are loaded if `--protocol tcp' is specified. It
-provides the following options:
-.TP
-.BR "--source-port " "[!] \fIport\fP[:\fIport\fP]"
-Source port or port range specification. This can either be a service
-name or a port number. An inclusive range can also be specified,
-using the format
-.IR port : port .
-If the first port is omitted, "0" is assumed; if the last is omitted,
-"65535" is assumed.
-If the second port greater then the first they will be swapped.
-The flag
-.B --sport
-is a convenient alias for this option.
-.TP
-.BR "--destination-port " "[!] \fIport\fP[:\fIport\fP]"
-Destination port or port range specification.  The flag
-.B --dport
-is a convenient alias for this option.
-.TP
-.BR "--tcp-flags " "[!] \fImask\fP \fIcomp\fP"
-Match when the TCP flags are as specified.  The first argument is the
-flags which we should examine, written as a comma-separated list, and
-the second argument is a comma-separated list of flags which must be
-set.  Flags are:
-.BR "SYN ACK FIN RST URG PSH ALL NONE" .
-Hence the command
-.nf
- iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN
-.fi
-will only match packets with the SYN flag set, and the ACK, FIN and
-RST flags unset.
-.TP
-.B "[!] --syn"
-Only match TCP packets with the SYN bit set and the ACK and RST bits
-cleared.  Such packets are used to request TCP connection initiation;
-for example, blocking such packets coming in an interface will prevent
-incoming TCP connections, but outgoing TCP connections will be
-unaffected.
-It is equivalent to \fB--tcp-flags SYN,RST,ACK SYN\fP.
-If the "!" flag precedes the "--syn", the sense of the
-option is inverted.
-.TP
-.BR "--tcp-option " "[!] \fInumber\fP"
-Match if TCP option set.
-.TP
-.BR "--mss " "\fIvalue\fP[:\fIvalue\fP]"
-Match TCP SYN or SYN/ACK packets with the specified MSS value (or range),
-which control the maximum packet size for that connection.
-.SS tos
-This module matches the 8 bits of Type of Service field in the IP
-header (ie. including the precedence bits).
-.TP
-.BI "--tos " "tos"
-The argument is either a standard name, (use
-.br
- iptables -m tos -h
-.br
-to see the list), or a numeric value to match.
-.SS ttl
-This module matches the time to live field in the IP header.
-.TP
-.BI "--ttl " "ttl"
-Matches the given TTL value.
-.SS udp
-These extensions are loaded if `--protocol udp' is specified.  It
-provides the following options:
-.TP
-.BR "--source-port " "[!] \fIport\fP[:\fIport\fP]"
-Source port or port range specification.
-See the description of the
-.B --source-port
-option of the TCP extension for details.
-.TP
-.BR "--destination-port " "[!] \fIport\fP[:\fIport\fP]"
-Destination port or port range specification.
-See the description of the
-.B --destination-port
-option of the TCP extension for details.
-.SS unclean
-This module takes no options, but attempts to match packets which seem
-malformed or unusual.  This is regarded as experimental.
-.SH TARGET EXTENSIONS
-iptables can use extended target modules: the following are included
-in the standard distribution.
-.SS DNAT
-This target is only valid in the
-.B nat
-table, in the
-.B PREROUTING
-and
-.B OUTPUT
-chains, and user-defined chains which are only called from those
-chains.  It specifies that the destination address of the packet
-should be modified (and all future packets in this connection will
-also be mangled), and rules should cease being examined.  It takes one
-type of option:
-.TP
-.BR "--to-destination " "\fIipaddr\fP[-\fIipaddr\fP][:\fIport\fP-\fIport\fP]"
-which can specify a single new destination IP address, an inclusive
-range of IP addresses, and optionally, a port range (which is only
-valid if the rule also specifies
-.B "-p tcp"
-or
-.BR "-p udp" ).
-If no port range is specified, then the destination port will never be
-modified.
-.RS
-.PP
-You can add several --to-destination options.  If you specify more
-than one destination address, either via an address range or multiple
---to-destination options, a simple round-robin (one after another in
-cycle) load balancing takes place between these adresses.
-.SS DSCP
-This target allows to alter the value of the DSCP bits within the TOS
-header of the IPv4 packet.  As this manipulates a packet, it can only
-be used in the mangle table.
-.TP
-.BI "--set-dscp " "value"
-Set the DSCP field to a numerical value (can be decimal or hex)
-.TP
-.BI "--set-dscp-class " "class"
-Set the DSCP field to a DiffServ class.
-.SS ECN
-This target allows to selectively work around known ECN blackholes.
-It can only be used in the mangle table.
-.TP
-.BI "--ecn-tcp-remove"
-Remove all ECN bits from the TCP header.  Of course, it can only be used
-in conjunction with
-.BR "-p tcp" .
-.SS LOG
-Turn on kernel logging of matching packets.  When this option is set
-for a rule, the Linux kernel will print some information on all
-matching packets (like most IP header fields) via the kernel log
-(where it can be read with
-.I dmesg
-or 
-.IR syslogd (8)).
-This is a "non-terminating target", i.e. rule traversal continues at
-the next rule.  So if you want to LOG the packets you refuse, use two
-separate rules with the same matching criteria, first using target LOG
-then DROP (or REJECT).
-.TP
-.BI "--log-level " "level"
-Level of logging (numeric or see \fIsyslog.conf\fP(5)).
-.TP
-.BI "--log-prefix " "prefix"
-Prefix log messages with the specified prefix; up to 29 letters long,
-and useful for distinguishing messages in the logs.
-.TP
-.B --log-tcp-sequence
-Log TCP sequence numbers. This is a security risk if the log is
-readable by users.
-.TP
-.B --log-tcp-options
-Log options from the TCP packet header.
-.TP
-.B --log-ip-options
-Log options from the IP packet header.
-.SS MARK
-This is used to set the netfilter mark value associated with the
-packet.  It is only valid in the
-.B mangle
-table.  It can for example be used in conjunction with iproute2.
-.TP
-.BI "--set-mark " "mark"
-.SS MASQUERADE
-This target is only valid in the
-.B nat
-table, in the
-.B POSTROUTING
-chain.  It should only be used with dynamically assigned IP (dialup)
-connections: if you have a static IP address, you should use the SNAT
-target.  Masquerading is equivalent to specifying a mapping to the IP
-address of the interface the packet is going out, but also has the
-effect that connections are
-.I forgotten
-when the interface goes down.  This is the correct behavior when the
-next dialup is unlikely to have the same interface address (and hence
-any established connections are lost anyway).  It takes one option:
-.TP
-.BR "--to-ports " "\fIport\fP[-\fIport\fP]"
-This specifies a range of source ports to use, overriding the default
-.B SNAT
-source port-selection heuristics (see above).  This is only valid
-if the rule also specifies
-.B "-p tcp"
-or
-.BR "-p udp" .
-.SS MIRROR
-This is an experimental demonstration target which inverts the source
-and destination fields in the IP header and retransmits the packet.
-It is only valid in the
-.BR INPUT ,
-.B FORWARD
-and
-.B PREROUTING
-chains, and user-defined chains which are only called from those
-chains.  Note that the outgoing packets are
-.B NOT
-seen by any packet filtering chains, connection tracking or NAT, to
-avoid loops and other problems.
-.SS REDIRECT
-This target is only valid in the
-.B nat
-table, in the
-.B PREROUTING
-and
-.B OUTPUT
-chains, and user-defined chains which are only called from those
-chains.  It alters the destination IP address to send the packet to
-the machine itself (locally-generated packets are mapped to the
-127.0.0.1 address).  It takes one option:
-.TP
-.BR "--to-ports " "\fIport\fP[-\fIport\fP]"
-This specifies a destination port or range of ports to use: without
-this, the destination port is never altered.  This is only valid
-if the rule also specifies
-.B "-p tcp"
-or
-.BR "-p udp" .
-.SS REJECT
-This is used to send back an error packet in response to the matched
-packet: otherwise it is equivalent to
-.B DROP
-so it is a terminating TARGET, ending rule traversal.
-This target is only valid in the
-.BR INPUT ,
-.B FORWARD
-and
-.B OUTPUT
-chains, and user-defined chains which are only called from those
-chains.  The following option controls the nature of the error packet
-returned:
-.TP
-.BI "--reject-with " "type"
-The type given can be
-.nf
-.B " icmp-net-unreachable"
-.B " icmp-host-unreachable"
-.B " icmp-port-unreachable"
-.B " icmp-proto-unreachable"
-.B " icmp-net-prohibited"
-.B " icmp-host-prohibited or"
-.B " icmp-admin-prohibited (*)"
-.fi
-which return the appropriate ICMP error message (\fBport-unreachable\fP is
-the default).  The option
-.B tcp-reset
-can be used on rules which only match the TCP protocol: this causes a
-TCP RST packet to be sent back.  This is mainly useful for blocking 
-.I ident
-(113/tcp) probes which frequently occur when sending mail to broken mail
-hosts (which won't accept your mail otherwise).
-.TP
-(*) Using icmp-admin-prohibited with kernels that do not support it will result in a plain DROP instead of REJECT
-.SS SNAT
-This target is only valid in the
-.B nat
-table, in the
-.B POSTROUTING
-chain.  It specifies that the source address of the packet should be
-modified (and all future packets in this connection will also be
-mangled), and rules should cease being examined.  It takes one type
-of option:
-.TP
-.BR "--to-source  " "\fIipaddr\fP[-\fIipaddr\fP][:\fIport\fP-\fIport\fP]"
-which can specify a single new source IP address, an inclusive range
-of IP addresses, and optionally, a port range (which is only valid if
-the rule also specifies
-.B "-p tcp"
-or
-.BR "-p udp" ).
-If no port range is specified, then source ports below 512 will be
-mapped to other ports below 512: those between 512 and 1023 inclusive
-will be mapped to ports below 1024, and other ports will be mapped to
-1024 or above. Where possible, no port alteration will occur.
-.RS
-.PP
-You can add several --to-source options.  If you specify more
-than one source address, either via an address range or multiple
---to-source options, a simple round-robin (one after another in
-cycle) takes place between these adresses.
-.SS TCPMSS
-This target allows to alter the MSS value of TCP SYN packets, to control
-the maximum size for that connection (usually limiting it to your
-outgoing interface's MTU minus 40).  Of course, it can only be used
-in conjunction with
-.BR "-p tcp" .
-.br
-This target is used to overcome criminally braindead ISPs or servers
-which block ICMP Fragmentation Needed packets.  The symptoms of this
-problem are that everything works fine from your Linux
-firewall/router, but machines behind it can never exchange large
-packets:
-.PD 0
-.RS 0.1i
-.TP 0.3i
-1)
-Web browsers connect, then hang with no data received.
-.TP
-2)
-Small mail works fine, but large emails hang.
-.TP
-3)
-ssh works fine, but scp hangs after initial handshaking.
-.RE
-.PD
-Workaround: activate this option and add a rule to your firewall
-configuration like:
-.nf
- iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN \\
-             -j TCPMSS --clamp-mss-to-pmtu
-.fi
-.TP
-.BI "--set-mss " "value"
-Explicitly set MSS option to specified value.
-.TP
-.B "--clamp-mss-to-pmtu"
-Automatically clamp MSS value to (path_MTU - 40).
-.TP
-These options are mutually exclusive.
-.SS TOS
-This is used to set the 8-bit Type of Service field in the IP header.
-It is only valid in the
-.B mangle
-table.
-.TP
-.BI "--set-tos " "tos"
-You can use a numeric TOS values, or use
-.nf
- iptables -j TOS -h
-.fi
-to see the list of valid TOS names.
-.SS ULOG
-This target provides userspace logging of matching packets.  When this
-target is set for a rule, the Linux kernel will multicast this packet
-through a
-.IR netlink 
-socket. One or more userspace processes may then subscribe to various 
-multicast groups and receive the packets.
-Like LOG, this is a "non-terminating target", i.e. rule traversal
-continues at the next rule.
-.TP
-.BI "--ulog-nlgroup " "nlgroup"
-This specifies the netlink group (1-32) to which the packet is sent.
-Default value is 1.
-.TP
-.BI "--ulog-prefix " "prefix"
-Prefix log messages with the specified prefix; up to 32 characters
-long, and useful for distinguishing messages in the logs.
-.TP
-.BI "--ulog-cprange " "size"
-Number of bytes to be copied to userspace.  A value of 0 always copies
-the entire packet, regardless of its size.  Default is 0.
-.TP
-.BI "--ulog-qthreshold " "size"
-Number of packet to queue inside kernel.  Setting this value to, e.g. 10
-accumulates ten packets inside the kernel and transmits them as one
-netlink multipart message to userspace.  Default is 1 (for backwards
-compatibility).
-.br
-.SH DIAGNOSTICS
-Various error messages are printed to standard error.  The exit code
-is 0 for correct functioning.  Errors which appear to be caused by
-invalid or abused command line parameters cause an exit code of 2, and
-other errors cause an exit code of 1.
-.SH BUGS
-Bugs?  What's this? ;-)
-Well... the counters are not reliable on sparc64.
-.SH COMPATIBILITY WITH IPCHAINS
-This
-.B iptables
-is very similar to ipchains by Rusty Russell.  The main difference is
-that the chains
-.B INPUT
-and
-.B OUTPUT
-are only traversed for packets coming into the local host and
-originating from the local host respectively.  Hence every packet only
-passes through one of the three chains (except loopback traffic, which
-involves both INPUT and OUTPUT chains); previously a forwarded packet
-would pass through all three.
-.PP
-The other main difference is that
-.B -i
-refers to the input interface;
-.B -o
-refers to the output interface, and both are available for packets
-entering the
-.B FORWARD
-chain.
-.PP The various forms of NAT have been separated out; 
-.B iptables 
-is a pure packet filter when using the default `filter' table, with
-optional extension modules.  This should simplify much of the previous
-confusion over the combination of IP masquerading and packet filtering
-seen previously.  So the following options are handled differently:
-.nf
- -j MASQ
- -M -S
- -M -L
-.fi
-There are several other changes in iptables.
-.SH SEE ALSO
-.BR iptables-save (8),
-.BR iptables-restore (8),
-.BR ip6tables (8),
-.BR ip6tables-save (8),
-.BR ip6tables-restore (8).
-.P
-The packet-filtering-HOWTO details iptables usage for
-packet filtering, the NAT-HOWTO details NAT,
-the netfilter-extensions-HOWTO details the extensions that are
-not in the standard distribution,
-and the netfilter-hacking-HOWTO details the netfilter internals.
-.br
-See
-.BR "http://www.netfilter.org/" .
-.SH AUTHORS
-Rusty Russell wrote iptables, in early consultation with Michael
-Neuling.
-.PP
-Marc Boucher made Rusty abandon ipnatctl by lobbying for a generic packet
-selection framework in iptables, then wrote the mangle table, the owner match,
-the mark stuff, and ran around doing cool stuff everywhere.
-.PP
-James Morris wrote the TOS target, and tos match.
-.PP
-Jozsef Kadlecsik wrote the REJECT target.
-.PP
-Harald Welte wrote the ULOG target, TTL, DSCP, ECN matches and targets.
-.PP
-The Netfilter Core Team is: Marc Boucher, Martin Josefsson, Jozsef Kadlecsik, 
-James Morris, Harald Welte and Rusty Russell.
-.PP
-Man page written by Herve Eychenne <rv@wallfire.org>.
-.\" .. and did I mention that we are incredibly cool people?
-.\" .. sexy, too ..
-.\" .. witty, charming, powerful ..
-.\" .. and most of all, modest ..
diff -urN iptables-1.2.9/iptables.8.in iptables-1.2.10/iptables.8.in
--- iptables-1.2.9/iptables.8.in	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.2.10/iptables.8.in	2004-03-17 15:15:00.000000000 +0100
@@ -0,0 +1,464 @@
+.TH IPTABLES 8 "Mar 09, 2002" "" ""
+.\"
+.\" Man page written by Herve Eychenne <rv@wallfire.org> (May 1999)
+.\" It is based on ipchains page.
+.\" TODO: add a word for protocol helpers (FTP, IRC, SNMP-ALG)
+.\"
+.\" ipchains page by Paul ``Rusty'' Russell March 1997
+.\" Based on the original ipfwadm man page by Jos Vos <jos@xos.nl>
+.\"
+.\"	This program is free software; you can redistribute it and/or modify
+.\"	it under the terms of the GNU General Public License as published by
+.\"	the Free Software Foundation; either version 2 of the License, or
+.\"	(at your option) any later version.
+.\"
+.\"	This program is distributed in the hope that it will be useful,
+.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
+.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+.\"	GNU General Public License for more details.
+.\"
+.\"	You should have received a copy of the GNU General Public License
+.\"	along with this program; if not, write to the Free Software
+.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+.\"
+.\"
+.SH NAME
+iptables \- administration tool for IPv4 packet filtering and NAT
+.SH SYNOPSIS
+.BR "iptables [-t table] -[AD] " "chain rule-specification [options]"
+.br
+.BR "iptables [-t table] -I " "chain [rulenum] rule-specification [options]"
+.br
+.BR "iptables [-t table] -R " "chain rulenum rule-specification [options]"
+.br
+.BR "iptables [-t table] -D " "chain rulenum [options]"
+.br
+.BR "iptables [-t table] -[LFZ] " "[chain] [options]"
+.br
+.BR "iptables [-t table] -N " "chain"
+.br
+.BR "iptables [-t table] -X " "[chain]"
+.br
+.BR "iptables [-t table] -P " "chain target [options]"
+.br
+.BR "iptables [-t table] -E " "old-chain-name new-chain-name"
+.SH DESCRIPTION
+.B Iptables
+is used to set up, maintain, and inspect the tables of IP packet
+filter rules in the Linux kernel.  Several different tables
+may be defined.  Each table contains a number of built-in
+chains and may also contain user-defined chains.
+
+Each chain is a list of rules which can match a set of packets.  Each
+rule specifies what to do with a packet that matches.  This is called
+a `target', which may be a jump to a user-defined chain in the same
+table.
+
+.SH TARGETS
+A firewall rule specifies criteria for a packet, and a target.  If the
+packet does not match, the next rule in the chain is the examined; if
+it does match, then the next rule is specified by the value of the
+target, which can be the name of a user-defined chain or one of the
+special values 
+.IR ACCEPT ,
+.IR DROP ,
+.IR QUEUE ,
+or
+.IR RETURN .
+.PP
+.I ACCEPT 
+means to let the packet through.
+.I DROP
+means to drop the packet on the floor.
+.I QUEUE
+means to pass the packet to userspace (if supported by the kernel).
+.I RETURN
+means stop traversing this chain and resume at the next rule in the
+previous (calling) chain.  If the end of a built-in chain is reached
+or a rule in a built-in chain with target
+.I RETURN
+is matched, the target specified by the chain policy determines the
+fate of the packet.
+.SH TABLES
+There are currently three independent tables (which tables are present
+at any time depends on the kernel configuration options and which
+modules are present).
+.TP
+.BI "-t, --table " "table"
+This option specifies the packet matching table which the command
+should operate on.  If the kernel is configured with automatic module
+loading, an attempt will be made to load the appropriate module for
+that table if it is not already there.
+
+The tables are as follows:
+.RS
+.TP .4i
+.BR "filter" :
+This is the default table (if no -t option is passed).  It contains
+the built-in chains
+.B INPUT
+(for packets coming into the box itself),
+.B FORWARD
+(for packets being routed through the box), and
+.B OUTPUT
+(for locally-generated packets).
+.TP
+.BR "nat" :
+This table is consulted when a packet that creates a new
+connection is encountered.  It consists of three built-ins:
+.B PREROUTING
+(for altering packets as soon as they come in),
+.B OUTPUT
+(for altering locally-generated packets before routing), and
+.B POSTROUTING
+(for altering packets as they are about to go out).
+.TP
+.BR "mangle" :
+This table is used for specialized packet alteration.  Until kernel
+2.4.17 it had two built-in chains:
+.B PREROUTING
+(for altering incoming packets before routing) and
+.B OUTPUT
+(for altering locally-generated packets before routing).
+Since kernel 2.4.18, three other built-in chains are also supported:
+.B INPUT
+(for packets coming into the box itself),
+.B FORWARD
+(for altering packets being routed through the box), and
+.B POSTROUTING
+(for altering packets as they are about to go out).
+.RE
+.SH OPTIONS
+The options that are recognized by
+.B iptables
+can be divided into several different groups.
+.SS COMMANDS
+These options specify the specific action to perform.  Only one of them
+can be specified on the command line unless otherwise specified
+below.  For all the long versions of the command and option names, you
+need to use only enough letters to ensure that
+.B iptables
+can differentiate it from all other options.
+.TP
+.BI "-A, --append " "chain rule-specification"
+Append one or more rules to the end of the selected chain.
+When the source and/or destination names resolve to more than one
+address, a rule will be added for each possible address combination.
+.TP
+.BI "-D, --delete " "chain rule-specification"
+.ns
+.TP
+.BI "-D, --delete " "chain rulenum"
+Delete one or more rules from the selected chain.  There are two
+versions of this command: the rule can be specified as a number in the
+chain (starting at 1 for the first rule) or a rule to match.
+.TP
+.BR "-I, --insert " "\fIchain\fP [\fIrulenum\fP] \fIrule-specification\fP"
+Insert one or more rules in the selected chain as the given rule
+number.  So, if the rule number is 1, the rule or rules are inserted
+at the head of the chain.  This is also the default if no rule number
+is specified.
+.TP
+.BI "-R, --replace " "chain rulenum rule-specification"
+Replace a rule in the selected chain.  If the source and/or
+destination names resolve to multiple addresses, the command will
+fail.  Rules are numbered starting at 1.
+.TP
+.BR "-L, --list " "[\fIchain\fP]"
+List all rules in the selected chain.  If no chain is selected, all
+chains are listed.  As every other iptables command, it applies to the
+specified table (filter is the default), so NAT rules get listed by
+.nf
+ iptables -t nat -n -L
+.fi
+Please note that it is often used with the
+.B -n
+option, in order to avoid long reverse DNS lookups.
+It is legal to specify the
+.B -Z
+(zero) option as well, in which case the chain(s) will be atomically
+listed and zeroed.  The exact output is affected by the other
+arguments given. The exact rules are suppressed until you use
+.nf
+ iptables -L -v
+.fi
+.TP
+.BR "-F, --flush " "[\fIchain\fP]"
+Flush the selected chain (all the chains in the table if none is given).
+This is equivalent to deleting all the rules one by one.
+.TP
+.BR "-Z, --zero " "[\fIchain\fP]"
+Zero the packet and byte counters in all chains.  It is legal to
+specify the
+.B "-L, --list"
+(list) option as well, to see the counters immediately before they are
+cleared. (See above.)
+.TP
+.BI "-N, --new-chain " "chain"
+Create a new user-defined chain by the given name.  There must be no
+target of that name already.
+.TP
+.BR "-X, --delete-chain " "[\fIchain\fP]"
+Delete the optional user-defined chain specified.  There must be no references
+to the chain.  If there are, you must delete or replace the referring
+rules before the chain can be deleted.  If no argument is given, it
+will attempt to delete every non-builtin chain in the table.
+.TP
+.BI "-P, --policy " "chain target"
+Set the policy for the chain to the given target.  See the section
+.B TARGETS
+for the legal targets.  Only built-in (non-user-defined) chains can have
+policies, and neither built-in nor user-defined chains can be policy
+targets.
+.TP
+.BI "-E, --rename-chain " "old-chain new-chain"
+Rename the user specified chain to the user supplied name.  This is
+cosmetic, and has no effect on the structure of the table.
+.TP
+.B -h
+Help.
+Give a (currently very brief) description of the command syntax.
+.SS PARAMETERS
+The following parameters make up a rule specification (as used in the
+add, delete, insert, replace and append commands).
+.TP
+.BR "-p, --protocol " "[!] \fIprotocol\fP"
+The protocol of the rule or of the packet to check.
+The specified protocol can be one of
+.IR tcp ,
+.IR udp ,
+.IR icmp ,
+or
+.IR all ,
+or it can be a numeric value, representing one of these protocols or a
+different one.  A protocol name from /etc/protocols is also allowed.
+A "!" argument before the protocol inverts the
+test.  The number zero is equivalent to
+.IR all .
+Protocol
+.I all
+will match with all protocols and is taken as default when this
+option is omitted.
+.TP
+.BR "-s, --source " "[!] \fIaddress\fP[/\fImask\fP]"
+Source specification.
+.I Address
+can be either a network name, a hostname (please note that specifying
+any name to be resolved with a remote query such as DNS is a really bad idea),
+a network IP address (with /mask), or a plain IP address.
+The
+.I mask
+can be either a network mask or a plain number,
+specifying the number of 1's at the left side of the network mask.
+Thus, a mask of
+.I 24
+is equivalent to
+.IR 255.255.255.0 .
+A "!" argument before the address specification inverts the sense of
+the address. The flag
+.B --src
+is an alias for this option.
+.TP
+.BR "-d, --destination " "[!] \fIaddress\fP[/\fImask\fP]"
+Destination specification. 
+See the description of the
+.B -s
+(source) flag for a detailed description of the syntax.  The flag
+.B --dst
+is an alias for this option.
+.TP
+.BI "-j, --jump " "target"
+This specifies the target of the rule; i.e., what to do if the packet
+matches it.  The target can be a user-defined chain (other than the
+one this rule is in), one of the special builtin targets which decide
+the fate of the packet immediately, or an extension (see
+.B EXTENSIONS
+below).  If this
+option is omitted in a rule, then matching the rule will have no
+effect on the packet's fate, but the counters on the rule will be
+incremented.
+.TP
+.BR "-i, --in-interface " "[!] \fIname\fP"
+Name of an interface via which a packet was received (only for
+packets entering the 
+.BR INPUT ,
+.B FORWARD
+and
+.B PREROUTING
+chains).  When the "!" argument is used before the interface name, the
+sense is inverted.  If the interface name ends in a "+", then any
+interface which begins with this name will match.  If this option is
+omitted, any interface name will match.
+.TP
+.BR "-o, --out-interface " "[!] \fIname\fP"
+Name of an interface via which a packet is going to be sent (for packets
+entering the
+.BR FORWARD ,
+.B OUTPUT
+and
+.B POSTROUTING
+chains).  When the "!" argument is used before the interface name, the
+sense is inverted.  If the interface name ends in a "+", then any
+interface which begins with this name will match.  If this option is
+omitted, any interface name will match.
+.TP
+.B "[!] " "-f, --fragment"
+This means that the rule only refers to second and further fragments
+of fragmented packets.  Since there is no way to tell the source or
+destination ports of such a packet (or ICMP type), such a packet will
+not match any rules which specify them.  When the "!" argument
+precedes the "-f" flag, the rule will only match head fragments, or
+unfragmented packets.
+.TP
+.BI "-c, --set-counters " "PKTS BYTES"
+This enables the administrator to initialize the packet and byte
+counters of a rule (during
+.B INSERT,
+.B APPEND,
+.B REPLACE
+operations).
+.SS "OTHER OPTIONS"
+The following additional options can be specified:
+.TP
+.B "-v, --verbose"
+Verbose output.  This option makes the list command show the interface
+name, the rule options (if any), and the TOS masks.  The packet and
+byte counters are also listed, with the suffix 'K', 'M' or 'G' for
+1000, 1,000,000 and 1,000,000,000 multipliers respectively (but see
+the
+.B -x
+flag to change this).
+For appending, insertion, deletion and replacement, this causes
+detailed information on the rule or rules to be printed.
+.TP
+.B "-n, --numeric"
+Numeric output.
+IP addresses and port numbers will be printed in numeric format.
+By default, the program will try to display them as host names,
+network names, or services (whenever applicable).
+.TP
+.B "-x, --exact"
+Expand numbers.
+Display the exact value of the packet and byte counters,
+instead of only the rounded number in K's (multiples of 1000)
+M's (multiples of 1000K) or G's (multiples of 1000M).  This option is
+only relevant for the 
+.B -L
+command.
+.TP
+.B "--line-numbers"
+When listing rules, add line numbers to the beginning of each rule,
+corresponding to that rule's position in the chain.
+.TP
+.B "--modprobe=command"
+When adding or inserting rules into a chain, use
+.B command
+to load any necessary modules (targets, match extensions, etc).
+.SH MATCH EXTENSIONS
+iptables can use extended packet matching modules.  These are loaded
+in two ways: implicitly, when
+.B -p
+or
+.B --protocol
+is specified, or with the
+.B -m
+or
+.B --match
+options, followed by the matching module name; after these, various
+extra command line options become available, depending on the specific
+module.  You can specify multiple extended match modules in one line,
+and you can use the
+.B -h
+or
+.B --help
+options after the module has been specified to receive help specific
+to that module.
+
+The following are included in the base package, and most of these can
+be preceded by a
+.B !
+to invert the sense of the match.
+.\" @MATCH@
+.SH TARGET EXTENSIONS
+iptables can use extended target modules: the following are included
+in the standard distribution.
+.\" @TARGET@
+.SH DIAGNOSTICS
+Various error messages are printed to standard error.  The exit code
+is 0 for correct functioning.  Errors which appear to be caused by
+invalid or abused command line parameters cause an exit code of 2, and
+other errors cause an exit code of 1.
+.SH BUGS
+Bugs?  What's this? ;-)
+Well... the counters are not reliable on sparc64.
+.SH COMPATIBILITY WITH IPCHAINS
+This
+.B iptables
+is very similar to ipchains by Rusty Russell.  The main difference is
+that the chains
+.B INPUT
+and
+.B OUTPUT
+are only traversed for packets coming into the local host and
+originating from the local host respectively.  Hence every packet only
+passes through one of the three chains (except loopback traffic, which
+involves both INPUT and OUTPUT chains); previously a forwarded packet
+would pass through all three.
+.PP
+The other main difference is that
+.B -i
+refers to the input interface;
+.B -o
+refers to the output interface, and both are available for packets
+entering the
+.B FORWARD
+chain.
+.PP The various forms of NAT have been separated out; 
+.B iptables 
+is a pure packet filter when using the default `filter' table, with
+optional extension modules.  This should simplify much of the previous
+confusion over the combination of IP masquerading and packet filtering
+seen previously.  So the following options are handled differently:
+.nf
+ -j MASQ
+ -M -S
+ -M -L
+.fi
+There are several other changes in iptables.
+.SH SEE ALSO
+.BR iptables-save (8),
+.BR iptables-restore (8),
+.BR ip6tables (8),
+.BR ip6tables-save (8),
+.BR ip6tables-restore (8).
+.P
+The packet-filtering-HOWTO details iptables usage for
+packet filtering, the NAT-HOWTO details NAT,
+the netfilter-extensions-HOWTO details the extensions that are
+not in the standard distribution,
+and the netfilter-hacking-HOWTO details the netfilter internals.
+.br
+See
+.BR "http://www.netfilter.org/" .
+.SH AUTHORS
+Rusty Russell wrote iptables, in early consultation with Michael
+Neuling.
+.PP
+Marc Boucher made Rusty abandon ipnatctl by lobbying for a generic packet
+selection framework in iptables, then wrote the mangle table, the owner match,
+the mark stuff, and ran around doing cool stuff everywhere.
+.PP
+James Morris wrote the TOS target, and tos match.
+.PP
+Jozsef Kadlecsik wrote the REJECT target.
+.PP
+Harald Welte wrote the ULOG target, TTL, DSCP, ECN matches and targets.
+.PP
+The Netfilter Core Team is: Marc Boucher, Martin Josefsson, Jozsef Kadlecsik, 
+Patrick McHardy, James Morris, Harald Welte and Rusty Russell.
+.PP
+Man page written by Herve Eychenne <rv@wallfire.org>.
+.\" .. and did I mention that we are incredibly cool people?
+.\" .. sexy, too ..
+.\" .. witty, charming, powerful ..
+.\" .. and most of all, modest ..
diff -urN iptables-1.2.9/iptables.c iptables-1.2.10/iptables.c
--- iptables-1.2.9/iptables.c	2003-06-15 00:39:35.000000000 +0200
+++ iptables-1.2.10/iptables.c	2004-06-15 00:02:16.000000000 +0200
@@ -235,6 +235,7 @@
 	{ "icmp", IPPROTO_ICMP },
 	{ "esp", IPPROTO_ESP },
 	{ "ah", IPPROTO_AH },
+	{ "sctp", IPPROTO_SCTP },
 	{ "all", 0 },
 };
 
@@ -268,6 +269,7 @@
 
 	/* copy dotted string, because we need to modify it */
 	strncpy(buf, dotted, sizeof(buf) - 1);
+	buf[sizeof(buf) - 1] = '\0';
 	addrp = (unsigned char *) &(addr.s_addr);
 
 	p = buf;
@@ -344,9 +346,9 @@
 }
 
 void
-exit_printhelp(void)
+exit_printhelp(struct iptables_rule_match *matches)
 {
-	struct iptables_match *m = NULL;
+	struct iptables_rule_match *matchp = NULL;
 	struct iptables_target *t = NULL;
 
 	printf("%s v%s\n\n"
@@ -411,14 +413,16 @@
 
 	/* Print out any special helps. A user might like to be able
 	   to add a --help to the commandline, and see expected
-	   results. So we call help for all matches & targets */
-	for (t=iptables_targets;t;t=t->next) {
-		printf("\n");
-		t->help();
+	   results. So we call help for all specified matches & targets */
+	for (t = iptables_targets; t ;t = t->next) {
+		if (t->used) {
+			printf("\n");
+			t->help();
+		}
 	}
-	for (m=iptables_matches;m;m=m->next) {
+	for (matchp = matches; matchp; matchp = matchp->next) {
 		printf("\n");
-		m->help();
+		matchp->match->help();
 	}
 	exit(0);
 }
@@ -633,6 +637,7 @@
 	int i, j, k, n;
 
 	strncpy(buf, name, sizeof(buf) - 1);
+	buf[sizeof(buf) - 1] = '\0';
 	if ((p = strrchr(buf, '/')) != NULL) {
 		*p = '\0';
 		addrp = parse_mask(p + 1);
@@ -659,7 +664,7 @@
 }
 
 struct iptables_match *
-find_match(const char *name, enum ipt_tryload tryload)
+find_match(const char *name, enum ipt_tryload tryload, struct iptables_rule_match **matches)
 {
 	struct iptables_match *ptr;
 
@@ -676,7 +681,7 @@
 		if (dlopen(path, RTLD_NOW)) {
 			/* Found library.  If it didn't register itself,
 			   maybe they specified target as match. */
-			ptr = find_match(name, DONT_LOAD);
+			ptr = find_match(name, DONT_LOAD, NULL);
 
 			if (!ptr)
 				exit_error(PARAMETER_PROBLEM,
@@ -700,15 +705,24 @@
 	}
 #endif
 
-	if (ptr)
-		ptr->used = 1;
+	if (ptr && matches) {
+		struct iptables_rule_match **i;
+		struct iptables_rule_match *newentry;
+
+		newentry = fw_malloc(sizeof(struct iptables_rule_match));
+
+		for (i = matches; *i; i = &(*i)->next);
+		newentry->match = ptr;
+		newentry->next = NULL;
+		*i = newentry;
+	}
 
 	return ptr;
 }
 
 /* Christophe Burki wants `-p 6' to imply `-m tcp'.  */
 static struct iptables_match *
-find_proto(const char *pname, enum ipt_tryload tryload, int nolookup)
+find_proto(const char *pname, enum ipt_tryload tryload, int nolookup, struct iptables_rule_match **matches)
 {
 	unsigned int proto;
 
@@ -716,9 +730,9 @@
 		char *protoname = proto_to_name(proto, nolookup);
 
 		if (protoname)
-			return find_match(protoname, tryload);
+			return find_match(protoname, tryload, matches);
 	} else
-		return find_match(pname, tryload);
+		return find_match(pname, tryload, matches);
 
 	return NULL;
 }
@@ -768,7 +782,7 @@
 			   " (%i)", arg, IFNAMSIZ-1);
 
 	strcpy(vianame, arg);
-	if (vialen == 0)
+	if ((vialen == 0) || (vialen == 1 && vianame[0] == '+'))
 		memset(mask, 0, IFNAMSIZ);
 	else if (vianame[vialen - 1] == '+') {
 		memset(mask, 0xFF, vialen - 1);
@@ -815,8 +829,8 @@
 
 	if (strlen(targetname)+1 > sizeof(ipt_chainlabel))
 		exit_error(PARAMETER_PROBLEM,
-			   "Invalid target name `%s' (%i chars max)",
-			   targetname, sizeof(ipt_chainlabel)-1);
+			   "Invalid target name `%s' (%u chars max)",
+			   targetname, (unsigned int)sizeof(ipt_chainlabel)-1);
 
 	for (ptr = targetname; *ptr; ptr++)
 		if (isspace(*ptr))
@@ -886,18 +900,18 @@
 }
 
 int
-string_to_number(const char *s, unsigned int min, unsigned int max,
-		 unsigned int *ret)
+string_to_number_ll(const char *s, unsigned long long min, unsigned long long max,
+		 unsigned long long *ret)
 {
-	long number;
+	unsigned long long number;
 	char *end;
 
 	/* Handle hex, octal, etc. */
 	errno = 0;
-	number = strtol(s, &end, 0);
+	number = strtoull(s, &end, 0);
 	if (*end == '\0' && end != s) {
 		/* we parsed a number, let's see if we want this */
-		if (errno != ERANGE && min <= number && number <= max) {
+		if (errno != ERANGE && min <= number && (!max || number <= max)) {
 			*ret = number;
 			return 0;
 		}
@@ -905,6 +919,31 @@
 	return -1;
 }
 
+int
+string_to_number_l(const char *s, unsigned long min, unsigned long max,
+		 unsigned long *ret)
+{
+	int result;
+	unsigned long long number;
+
+	result = string_to_number_ll(s, min, max, &number);
+	*ret = (unsigned long)number;
+
+	return result;
+}
+
+int string_to_number(const char *s, unsigned int min, unsigned int max,
+		unsigned int *ret)
+{
+	int result;
+	unsigned long number;
+
+	result = string_to_number_l(s, min, max, &number);
+	*ret = (unsigned int)number;
+
+	return result;
+}
+
 static void
 set_option(unsigned int *options, unsigned int option, u_int8_t *invflg,
 	   int invert)
@@ -1016,7 +1055,7 @@
 		exit(1);
 	}
 
-	if (find_match(me->name, DONT_LOAD)) {
+	if (find_match(me->name, DONT_LOAD, NULL)) {
 		fprintf(stderr, "%s: match `%s' already registered.\n",
 			program_name, me->name);
 		exit(1);
@@ -1024,7 +1063,7 @@
 
 	if (me->size != IPT_ALIGN(me->size)) {
 		fprintf(stderr, "%s: match `%s' has invalid size %u.\n",
-			program_name, me->name, me->size);
+			program_name, me->name, (unsigned int)me->size);
 		exit(1);
 	}
 
@@ -1054,7 +1093,7 @@
 
 	if (me->size != IPT_ALIGN(me->size)) {
 		fprintf(stderr, "%s: target `%s' has invalid size %u.\n",
-			program_name, me->name, me->size);
+			program_name, me->name, (unsigned int)me->size);
 		exit(1);
 	}
 
@@ -1077,17 +1116,17 @@
 					number = (number + 500) / 1000;
 					if (number > 9999) {
 						number = (number + 500) / 1000;
-						printf(FMT("%4lluT ","%lluT "), number);
+						printf(FMT("%4lluT ","%lluT "), (unsigned long long)number);
 					}
-					else printf(FMT("%4lluG ","%lluG "), number);
+					else printf(FMT("%4lluG ","%lluG "), (unsigned long long)number);
 				}
-				else printf(FMT("%4lluM ","%lluM "), number);
+				else printf(FMT("%4lluM ","%lluM "), (unsigned long long)number);
 			} else
-				printf(FMT("%4lluK ","%lluK "), number);
+				printf(FMT("%4lluK ","%lluK "), (unsigned long long)number);
 		} else
-			printf(FMT("%5llu ","%llu "), number);
+			printf(FMT("%5llu ","%llu "), (unsigned long long)number);
 	} else
-		printf(FMT("%8llu ","%llu "), number);
+		printf(FMT("%8llu ","%llu "), (unsigned long long)number);
 }
 
 
@@ -1146,7 +1185,7 @@
 	    const struct ipt_ip *ip,
 	    int numeric)
 {
-	struct iptables_match *match = find_match(m->u.user.name, TRY_LOAD);
+	struct iptables_match *match = find_match(m->u.user.name, TRY_LOAD, NULL);
 
 	if (match) {
 		if (match->print)
@@ -1275,7 +1314,7 @@
 			target->print(&fw->ip, t, format & FMT_NUMERIC);
 	} else if (t->u.target_size != sizeof(*t))
 		printf("[%u bytes of unknown target data] ",
-		       t->u.target_size - sizeof(*t));
+		       (unsigned int)(t->u.target_size - sizeof(*t)));
 
 	if (!(format & FMT_NONEWLINE))
 		fputc('\n', stdout);
@@ -1362,20 +1401,16 @@
 }
 
 static unsigned char *
-make_delete_mask(struct ipt_entry *fw)
+make_delete_mask(struct ipt_entry *fw, struct iptables_rule_match *matches)
 {
 	/* Establish mask for comparison */
 	unsigned int size;
-	struct iptables_match *m;
+	struct iptables_rule_match *matchp;
 	unsigned char *mask, *mptr;
 
 	size = sizeof(struct ipt_entry);
-	for (m = iptables_matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		size += IPT_ALIGN(sizeof(struct ipt_entry_match)) + m->size;
-	}
+	for (matchp = matches; matchp; matchp = matchp->next)
+		size += IPT_ALIGN(sizeof(struct ipt_entry_match)) + matchp->match->size;
 
 	mask = fw_calloc(1, size
 			 + IPT_ALIGN(sizeof(struct ipt_entry_target))
@@ -1384,14 +1419,11 @@
 	memset(mask, 0xFF, sizeof(struct ipt_entry));
 	mptr = mask + sizeof(struct ipt_entry);
 
-	for (m = iptables_matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
+	for (matchp = matches; matchp; matchp = matchp->next) {
 		memset(mptr, 0xFF,
 		       IPT_ALIGN(sizeof(struct ipt_entry_match))
-		       + m->userspacesize);
-		mptr += IPT_ALIGN(sizeof(struct ipt_entry_match)) + m->size;
+		       + matchp->match->userspacesize);
+		mptr += IPT_ALIGN(sizeof(struct ipt_entry_match)) + matchp->match->size;
 	}
 
 	memset(mptr, 0xFF,
@@ -1409,13 +1441,14 @@
 	     unsigned int ndaddrs,
 	     const struct in_addr daddrs[],
 	     int verbose,
-	     iptc_handle_t *handle)
+	     iptc_handle_t *handle,
+	     struct iptables_rule_match *matches)
 {
 	unsigned int i, j;
 	int ret = 1;
 	unsigned char *mask;
 
-	mask = make_delete_mask(fw);
+	mask = make_delete_mask(fw, matches);
 	for (i = 0; i < nsaddrs; i++) {
 		fw->ip.src.s_addr = saddrs[i].s_addr;
 		for (j = 0; j < ndaddrs; j++) {
@@ -1425,6 +1458,8 @@
 			ret &= iptc_delete_entry(chain, fw, mask, handle);
 		}
 	}
+	free(mask);
+
 	return ret;
 }
 
@@ -1614,20 +1649,16 @@
 
 static struct ipt_entry *
 generate_entry(const struct ipt_entry *fw,
-	       struct iptables_match *matches,
+	       struct iptables_rule_match *matches,
 	       struct ipt_entry_target *target)
 {
 	unsigned int size;
-	struct iptables_match *m;
+	struct iptables_rule_match *matchp;
 	struct ipt_entry *e;
 
 	size = sizeof(struct ipt_entry);
-	for (m = matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		size += m->m->u.match_size;
-	}
+	for (matchp = matches; matchp; matchp = matchp->next)
+		size += matchp->match->m->u.match_size;
 
 	e = fw_malloc(size + target->u.target_size);
 	*e = *fw;
@@ -1635,18 +1666,30 @@
 	e->next_offset = size + target->u.target_size;
 
 	size = 0;
-	for (m = matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		memcpy(e->elems + size, m->m, m->m->u.match_size);
-		size += m->m->u.match_size;
+	for (matchp = matches; matchp; matchp = matchp->next) {
+		memcpy(e->elems + size, matchp->match->m, matchp->match->m->u.match_size);
+		size += matchp->match->m->u.match_size;
 	}
 	memcpy(e->elems + size, target, target->u.target_size);
 
 	return e;
 }
 
+void clear_rule_matches(struct iptables_rule_match **matches)
+{
+	struct iptables_rule_match *matchp, *tmp;
+
+	for (matchp = *matches; matchp;) {
+		tmp = matchp->next;
+		if (matchp->match->m)
+			free(matchp->match->m);
+		free(matchp);
+		matchp = tmp;
+	}
+
+	*matches = NULL;
+}
+
 int do_command(int argc, char *argv[], char **table, iptc_handle_t *handle)
 {
 	struct ipt_entry fw, *e = NULL;
@@ -1662,6 +1705,8 @@
 	const char *pcnt = NULL, *bcnt = NULL;
 	int ret = 1;
 	struct iptables_match *m;
+	struct iptables_rule_match *matches = NULL;
+	struct iptables_rule_match *matchp;
 	struct iptables_target *target = NULL;
 	struct iptables_target *t;
 	const char *jumpto = "";
@@ -1671,19 +1716,14 @@
 
 	memset(&fw, 0, sizeof(fw));
 
-	opts = original_opts;
-	global_option_offset = 0;
-
 	/* re-set optind to 0 in case do_command gets called
 	 * a second time */
 	optind = 0;
 
 	/* clear mflags in case do_command gets called a second time
 	 * (we clear the global list of all matches for security)*/
-	for (m = iptables_matches; m; m = m->next) {
+	for (m = iptables_matches; m; m = m->next)
 		m->mflags = 0;
-		m->used = 0;
-	}
 
 	for (t = iptables_targets; t; t = t->next) {
 		t->tflags = 0;
@@ -1823,10 +1863,10 @@
 				optarg = argv[optind];
 
 			/* iptables -p icmp -h */
-			if (!iptables_matches && protocol)
-				find_match(protocol, TRY_LOAD);
+			if (!matches && protocol)
+				find_match(protocol, TRY_LOAD, &matches);
 
-			exit_printhelp();
+			exit_printhelp(matches);
 
 			/*
 			 * Option selection
@@ -1929,7 +1969,7 @@
 				exit_error(PARAMETER_PROBLEM,
 					   "unexpected ! flag before --match");
 
-			m = find_match(optarg, LOAD_MUST_SUCCEED);
+			m = find_match(optarg, LOAD_MUST_SUCCEED, &matches);
 			size = IPT_ALIGN(sizeof(struct ipt_entry_match))
 					 + m->size;
 			m->m = fw_calloc(1, size);
@@ -1987,12 +2027,12 @@
 					"-%c requires packet and byte counter",
 					opt2char(OPT_COUNTERS));
 
-			if (sscanf(pcnt, "%llu", &fw.counters.pcnt) != 1)
+			if (sscanf(pcnt, "%llu", (unsigned long long *)&fw.counters.pcnt) != 1)
 				exit_error(PARAMETER_PROBLEM,
 					"-%c packet counter not numeric",
 					opt2char(OPT_COUNTERS));
 
-			if (sscanf(bcnt, "%llu", &fw.counters.bcnt) != 1)
+			if (sscanf(bcnt, "%llu", (unsigned long long *)&fw.counters.bcnt) != 1)
 				exit_error(PARAMETER_PROBLEM,
 					"-%c byte counter not numeric",
 					opt2char(OPT_COUNTERS));
@@ -2021,18 +2061,16 @@
 					       argv, invert,
 					       &target->tflags,
 					       &fw, &target->t))) {
-				for (m = iptables_matches; m; m = m->next) {
-					if (!m->used)
-						continue;
-
-					if (m->parse(c - m->option_offset,
+				for (matchp = matches; matchp; matchp = matchp->next) {
+					if (matchp->match->parse(c - matchp->match->option_offset,
 						     argv, invert,
-						     &m->mflags,
+						     &matchp->match->mflags,
 						     &fw,
 						     &fw.nfcache,
-						     &m->m))
+						     &matchp->match->m))
 						break;
 				}
+				m = matchp ? matchp->match : NULL;
 
 				/* If you listen carefully, you can
 				   actually hear this code suck. */
@@ -2060,13 +2098,13 @@
 				if (m == NULL
 				    && protocol
 				    && (!find_proto(protocol, DONT_LOAD,
-						   options&OPT_NUMERIC) 
+						   options&OPT_NUMERIC, NULL) 
 					|| (find_proto(protocol, DONT_LOAD,
-							options&OPT_NUMERIC)
+							options&OPT_NUMERIC, NULL)
 					    && (proto_used == 0))
 				       )
 				    && (m = find_proto(protocol, TRY_LOAD,
-						       options&OPT_NUMERIC))) {
+						       options&OPT_NUMERIC, &matches))) {
 					/* Try loading protocol */
 					size_t size;
 					
@@ -2095,12 +2133,8 @@
 		invert = FALSE;
 	}
 
-	for (m = iptables_matches; m; m = m->next) {
-		if (!m->used)
-			continue;
-
-		m->final_check(m->mflags);
-	}
+	for (matchp = matches; matchp; matchp = matchp->next)
+		matchp->match->final_check(matchp->match->mflags);
 
 	if (target)
 		target->final_check(target->tflags);
@@ -2190,6 +2224,9 @@
 			printf("Warning: using chain %s, not extension\n",
 			       jumpto);
 
+			if (target->t)
+				free(target->t);
+
 			target = NULL;
 		}
 
@@ -2218,7 +2255,8 @@
 			 * chain. */
 			find_target(jumpto, LOAD_MUST_SUCCEED);
 		} else {
-			e = generate_entry(&fw, iptables_matches, target->t);
+			e = generate_entry(&fw, matches, target->t);
+			free(target->t);
 		}
 	}
 
@@ -2233,7 +2271,7 @@
 		ret = delete_entry(chain, e,
 				   nsaddrs, saddrs, ndaddrs, daddrs,
 				   options&OPT_VERBOSE,
-				   handle);
+				   handle, matches);
 		break;
 	case CMD_DELETE_NUM:
 		ret = iptc_delete_num_entry(chain, rulenum - 1, handle);
@@ -2294,5 +2332,24 @@
 	if (verbose > 1)
 		dump_entries(*handle);
 
+	clear_rule_matches(&matches);
+
+	if (e != NULL) {
+		free(e);
+		e = NULL;
+	}
+
+	for (c = 0; c < nsaddrs; c++)
+		free(&saddrs[c]);
+
+	for (c = 0; c < ndaddrs; c++)
+		free(&daddrs[c]);
+
+	if (opts != original_opts) {
+		free(opts);
+		opts = original_opts;
+		global_option_offset = 0;
+	}
+
 	return ret;
 }
diff -urN iptables-1.2.9/libipq/libipq.c iptables-1.2.10/libipq/libipq.c
--- iptables-1.2.9/libipq/libipq.c	2001-11-24 16:09:20.000000000 +0100
+++ iptables-1.2.10/libipq/libipq.c	2003-11-14 20:17:45.000000000 +0100
@@ -171,6 +171,10 @@
 		ipq_errno = IPQ_ERR_RECV;
 		return -1;
 	}
+	if (h->peer.nl_pid != 0) {
+		ipq_errno = IPQ_ERR_RECV;
+		return -1;
+	}
 	if (status == 0) {
 		ipq_errno = IPQ_ERR_NLEOF;
 		return -1;
diff -urN iptables-1.2.9/libiptc/libip4tc.c iptables-1.2.10/libiptc/libip4tc.c
--- iptables-1.2.9/libiptc/libip4tc.c	2003-10-07 20:54:30.000000000 +0200
+++ iptables-1.2.10/libiptc/libip4tc.c	2004-06-15 00:02:18.000000000 +0200
@@ -145,7 +145,7 @@
 	printf("Flags: %02X\n", e->ip.flags);
 	printf("Invflags: %02X\n", e->ip.invflags);
 	printf("Counters: %llu packets, %llu bytes\n",
-	       e->counters.pcnt, e->counters.bcnt);
+	       (unsigned long long)e->counters.pcnt, (unsigned long long)e->counters.bcnt);
 	printf("Cache: %08X ", e->nfcache);
 	if (e->nfcache & NFC_ALTERED) printf("ALTERED ");
 	if (e->nfcache & NFC_UNKNOWN) printf("UNKNOWN ");
diff -urN iptables-1.2.9/libiptc/libip6tc.c iptables-1.2.10/libiptc/libip6tc.c
--- iptables-1.2.9/libiptc/libip6tc.c	2003-10-08 00:11:20.000000000 +0200
+++ iptables-1.2.10/libiptc/libip6tc.c	2004-06-15 00:02:18.000000000 +0200
@@ -176,7 +176,7 @@
 	printf("Flags: %02X\n", e->ipv6.flags);
 	printf("Invflags: %02X\n", e->ipv6.invflags);
 	printf("Counters: %llu packets, %llu bytes\n",
-	       e->counters.pcnt, e->counters.bcnt);
+	       (unsigned long long)e->counters.pcnt, (unsigned long long)e->counters.bcnt);
 	printf("Cache: %08X ", e->nfcache);
 	if (e->nfcache & NFC_ALTERED) printf("ALTERED ");
 	if (e->nfcache & NFC_UNKNOWN) printf("UNKNOWN ");
diff -urN iptables-1.2.9/libiptc/libip6tc.c.orig iptables-1.2.10/libiptc/libip6tc.c.orig
--- iptables-1.2.9/libiptc/libip6tc.c.orig	2003-06-24 20:28:36.000000000 +0200
+++ iptables-1.2.10/libiptc/libip6tc.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,449 +0,0 @@
-/* Library which manipulates firewall rules.  Version 0.1. */
-
-/* Architecture of firewall rules is as follows:
- *
- * Chains go INPUT, FORWARD, OUTPUT then user chains.
- * Each user chain starts with an ERROR node.
- * Every chain ends with an unconditional jump: a RETURN for user chains,
- * and a POLICY for built-ins.
- */
-
-/* (C)1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
-   COPYING for details). */
-
-#include <assert.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <arpa/inet.h>
-
-#ifdef DEBUG_CONNTRACK
-#define inline
-#endif
-
-#if !defined(__GLIBC__) || (__GLIBC__ < 2)
-typedef unsigned int socklen_t;
-#endif
-
-#include "libiptc/libip6tc.h"
-
-#define HOOK_PRE_ROUTING	NF_IP6_PRE_ROUTING
-#define HOOK_LOCAL_IN		NF_IP6_LOCAL_IN
-#define HOOK_FORWARD		NF_IP6_FORWARD
-#define HOOK_LOCAL_OUT		NF_IP6_LOCAL_OUT
-#define HOOK_POST_ROUTING	NF_IP6_POST_ROUTING
-
-#define STRUCT_ENTRY_TARGET	struct ip6t_entry_target
-#define STRUCT_ENTRY		struct ip6t_entry
-#define STRUCT_ENTRY_MATCH	struct ip6t_entry_match
-#define STRUCT_GETINFO		struct ip6t_getinfo
-#define STRUCT_GET_ENTRIES	struct ip6t_get_entries
-#define STRUCT_COUNTERS		struct ip6t_counters
-#define STRUCT_COUNTERS_INFO	struct ip6t_counters_info
-#define STRUCT_STANDARD_TARGET	struct ip6t_standard_target
-#define STRUCT_REPLACE		struct ip6t_replace
-
-#define STRUCT_TC_HANDLE	struct ip6tc_handle
-#define TC_HANDLE_T		ip6tc_handle_t
-
-#define ENTRY_ITERATE		IP6T_ENTRY_ITERATE
-#define TABLE_MAXNAMELEN	IP6T_TABLE_MAXNAMELEN
-#define FUNCTION_MAXNAMELEN	IP6T_FUNCTION_MAXNAMELEN
-
-#define GET_TARGET		ip6t_get_target
-
-#define ERROR_TARGET		IP6T_ERROR_TARGET
-#define NUMHOOKS		NF_IP6_NUMHOOKS
-
-#define IPT_CHAINLABEL		ip6t_chainlabel
-
-#define TC_DUMP_ENTRIES		dump_entries6
-#define TC_IS_CHAIN		ip6tc_is_chain
-#define TC_FIRST_CHAIN		ip6tc_first_chain
-#define TC_NEXT_CHAIN		ip6tc_next_chain
-#define TC_FIRST_RULE		ip6tc_first_rule
-#define TC_NEXT_RULE		ip6tc_next_rule
-#define TC_GET_TARGET		ip6tc_get_target
-#define TC_BUILTIN		ip6tc_builtin
-#define TC_GET_POLICY		ip6tc_get_policy
-#define TC_INSERT_ENTRY		ip6tc_insert_entry
-#define TC_REPLACE_ENTRY	ip6tc_replace_entry
-#define TC_APPEND_ENTRY		ip6tc_append_entry
-#define TC_DELETE_ENTRY		ip6tc_delete_entry
-#define TC_DELETE_NUM_ENTRY	ip6tc_delete_num_entry
-#define TC_CHECK_PACKET		ip6tc_check_packet
-#define TC_FLUSH_ENTRIES	ip6tc_flush_entries
-#define TC_ZERO_ENTRIES		ip6tc_zero_entries
-#define TC_ZERO_COUNTER		ip6tc_zero_counter
-#define TC_READ_COUNTER		ip6tc_read_counter
-#define TC_SET_COUNTER		ip6tc_set_counter
-#define TC_CREATE_CHAIN		ip6tc_create_chain
-#define TC_GET_REFERENCES	ip6tc_get_references
-#define TC_DELETE_CHAIN		ip6tc_delete_chain
-#define TC_RENAME_CHAIN		ip6tc_rename_chain
-#define TC_SET_POLICY		ip6tc_set_policy
-#define TC_GET_RAW_SOCKET	ip6tc_get_raw_socket
-#define TC_INIT			ip6tc_init
-#define TC_FREE			ip6tc_free
-#define TC_COMMIT		ip6tc_commit
-#define TC_STRERROR		ip6tc_strerror
-
-#define TC_AF			AF_INET6
-#define TC_IPPROTO		IPPROTO_IPV6
-
-#define SO_SET_REPLACE		IP6T_SO_SET_REPLACE
-#define SO_SET_ADD_COUNTERS	IP6T_SO_SET_ADD_COUNTERS
-#define SO_GET_INFO		IP6T_SO_GET_INFO
-#define SO_GET_ENTRIES		IP6T_SO_GET_ENTRIES
-#define SO_GET_VERSION		IP6T_SO_GET_VERSION
-
-#define STANDARD_TARGET		IP6T_STANDARD_TARGET
-#define LABEL_RETURN		IP6TC_LABEL_RETURN
-#define LABEL_ACCEPT		IP6TC_LABEL_ACCEPT
-#define LABEL_DROP		IP6TC_LABEL_DROP
-#define LABEL_QUEUE		IP6TC_LABEL_QUEUE
-
-#define ALIGN			IP6T_ALIGN
-#define RETURN			IP6T_RETURN
-
-#include "libiptc.c"
-
-#define BIT6(a, l) \
- ((ntohl(a->in6_u.u6_addr32[(l) / 32]) >> (31 - ((l) & 31))) & 1)
-
-int
-ipv6_prefix_length(const struct in6_addr *a)
-{
-	int l, i;
-	for (l = 0; l < 128; l++) {
-		if (BIT6(a, l) == 0)
-			break;
-	}
-	for (i = l + 1; i < 128; i++) {
-		if (BIT6(a, i) == 1)
-			return -1;
-	}
-	return l;
-}
-
-static int
-dump_entry(struct ip6t_entry *e, const ip6tc_handle_t handle)
-{
-	size_t i;
-	char buf[40];
-	int len;
-	struct ip6t_entry_target *t;
-	
-	printf("Entry %u (%lu):\n", entry2index(handle, e),
-	       entry2offset(handle, e));
-	puts("SRC IP: ");
-	inet_ntop(AF_INET6, &e->ipv6.src, buf, sizeof buf);
-	puts(buf);
-	putchar('/');
-	len = ipv6_prefix_length(&e->ipv6.smsk);
-	if (len != -1)
-		printf("%d", len);
-	else {
-		inet_ntop(AF_INET6, &e->ipv6.smsk, buf, sizeof buf);
-		puts(buf);
-	}
-	putchar('\n');
-	
-	puts("DST IP: ");
-	inet_ntop(AF_INET6, &e->ipv6.dst, buf, sizeof buf);
-	puts(buf);
-	putchar('/');
-	len = ipv6_prefix_length(&e->ipv6.dmsk);
-	if (len != -1)
-		printf("%d", len);
-	else {
-		inet_ntop(AF_INET6, &e->ipv6.dmsk, buf, sizeof buf);
-		puts(buf);
-	}
-	putchar('\n');
-	
-	printf("Interface: `%s'/", e->ipv6.iniface);
-	for (i = 0; i < IFNAMSIZ; i++)
-		printf("%c", e->ipv6.iniface_mask[i] ? 'X' : '.');
-	printf("to `%s'/", e->ipv6.outiface);
-	for (i = 0; i < IFNAMSIZ; i++)
-		printf("%c", e->ipv6.outiface_mask[i] ? 'X' : '.');
-	printf("\nProtocol: %u\n", e->ipv6.proto);
-	if (e->ipv6.flags & IP6T_F_TOS)
-		printf("TOS: %u\n", e->ipv6.tos);
-	printf("Flags: %02X\n", e->ipv6.flags);
-	printf("Invflags: %02X\n", e->ipv6.invflags);
-	printf("Counters: %llu packets, %llu bytes\n",
-	       e->counters.pcnt, e->counters.bcnt);
-	printf("Cache: %08X ", e->nfcache);
-	if (e->nfcache & NFC_ALTERED) printf("ALTERED ");
-	if (e->nfcache & NFC_UNKNOWN) printf("UNKNOWN ");
-	if (e->nfcache & NFC_IP6_SRC) printf("IP6_SRC ");
-	if (e->nfcache & NFC_IP6_DST) printf("IP6_DST ");
-	if (e->nfcache & NFC_IP6_IF_IN) printf("IP6_IF_IN ");
-	if (e->nfcache & NFC_IP6_IF_OUT) printf("IP6_IF_OUT ");
-	if (e->nfcache & NFC_IP6_TOS) printf("IP6_TOS ");
-	if (e->nfcache & NFC_IP6_PROTO) printf("IP6_PROTO ");
-	if (e->nfcache & NFC_IP6_OPTIONS) printf("IP6_OPTIONS ");
-	if (e->nfcache & NFC_IP6_TCPFLAGS) printf("IP6_TCPFLAGS ");
-	if (e->nfcache & NFC_IP6_SRC_PT) printf("IP6_SRC_PT ");
-	if (e->nfcache & NFC_IP6_DST_PT) printf("IP6_DST_PT ");
-	if (e->nfcache & NFC_IP6_PROTO_UNKNOWN) printf("IP6_PROTO_UNKNOWN ");
-	printf("\n");
-	
-	IP6T_MATCH_ITERATE(e, print_match);
-
-	t = ip6t_get_target(e);
-	printf("Target name: `%s' [%u]\n", t->u.user.name, t->u.target_size);
-	if (strcmp(t->u.user.name, IP6T_STANDARD_TARGET) == 0) {
-		int pos = *(int *)t->data;
-		if (pos < 0)
-			printf("verdict=%s\n",
-			       pos == -NF_ACCEPT-1 ? "NF_ACCEPT"
-			       : pos == -NF_DROP-1 ? "NF_DROP"
-			       : pos == IP6T_RETURN ? "RETURN"
-			       : "UNKNOWN");
-		else
-			printf("verdict=%u\n", pos);
-	} else if (strcmp(t->u.user.name, IP6T_ERROR_TARGET) == 0)
-		printf("error=`%s'\n", t->data);
-
-	printf("\n");
-	return 0;
-}
-
-static int
-is_same(const STRUCT_ENTRY *a, const STRUCT_ENTRY *b,
-	unsigned char *matchmask)
-{
-	unsigned int i;
-	STRUCT_ENTRY_TARGET *ta, *tb;
-	unsigned char *mptr;
-
-	/* Always compare head structures: ignore mask here. */
-	if (memcmp(&a->ipv6.src, &b->ipv6.src, sizeof(struct in6_addr))
-	    || memcmp(&a->ipv6.dst, &b->ipv6.dst, sizeof(struct in6_addr))
-	    || memcmp(&a->ipv6.smsk, &b->ipv6.smsk, sizeof(struct in6_addr))
-	    || memcmp(&a->ipv6.dmsk, &b->ipv6.dmsk, sizeof(struct in6_addr))
-	    || a->ipv6.proto != b->ipv6.proto
-	    || a->ipv6.tos != b->ipv6.tos
-	    || a->ipv6.flags != b->ipv6.flags
-	    || a->ipv6.invflags != b->ipv6.invflags)
-		return 0;
-
-	for (i = 0; i < IFNAMSIZ; i++) {
-		if (a->ipv6.iniface_mask[i] != b->ipv6.iniface_mask[i])
-			return 0;
-		if ((a->ipv6.iniface[i] & a->ipv6.iniface_mask[i])
-		    != (b->ipv6.iniface[i] & b->ipv6.iniface_mask[i]))
-			return 0;
-		if (a->ipv6.outiface_mask[i] != b->ipv6.outiface_mask[i])
-			return 0;
-		if ((a->ipv6.outiface[i] & a->ipv6.outiface_mask[i])
-		    != (b->ipv6.outiface[i] & b->ipv6.outiface_mask[i]))
-			return 0;
-	}
-
-	if (a->nfcache != b->nfcache
-	    || a->target_offset != b->target_offset
-	    || a->next_offset != b->next_offset)
-		return 0;
-
-	mptr = matchmask + sizeof(STRUCT_ENTRY);
-	if (IP6T_MATCH_ITERATE(a, match_different, a->elems, b->elems, &mptr))
-		return 0;
-
-	ta = GET_TARGET((STRUCT_ENTRY *)a);
-	tb = GET_TARGET((STRUCT_ENTRY *)b);
-	if (ta->u.target_size != tb->u.target_size)
-		return 0;
-	if (strcmp(ta->u.user.name, tb->u.user.name) != 0)
-		return 0;
-	mptr += sizeof(*ta);
-
-	if (target_different(ta->data, tb->data,
-			     ta->u.target_size - sizeof(*ta), mptr))
-		return 0;
-
-	return 1;
-}
-
-/* All zeroes == unconditional rule. */
-static inline int
-unconditional(const struct ip6t_ip6 *ipv6)
-{
-	unsigned int i;
-
-	for (i = 0; i < sizeof(*ipv6); i++)
-		if (((char *)ipv6)[i])
-			break;
-
-	return (i == sizeof(*ipv6));
-}
-
-#ifdef IPTC_DEBUG
-/* Do every conceivable sanity check on the handle */
-static void
-do_check(TC_HANDLE_T h, unsigned int line)
-{
-	unsigned int i, n;
-	unsigned int user_offset; /* Offset of first user chain */
-	int was_return;
-
-	assert(h->changed == 0 || h->changed == 1);
-	if (strcmp(h->info.name, "filter") == 0) {
-		assert(h->info.valid_hooks
-		       == (1 << NF_IP6_LOCAL_IN
-			   | 1 << NF_IP6_FORWARD
-			   | 1 << NF_IP6_LOCAL_OUT));
-
-		/* Hooks should be first three */
-		assert(h->info.hook_entry[NF_IP6_LOCAL_IN] == 0);
-
-		n = get_chain_end(h, 0);
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP6_FORWARD] == n);
-
-		n = get_chain_end(h, n);
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
-
-		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
-	} else if (strcmp(h->info.name, "nat") == 0) {
-		assert((h->info.valid_hooks
-			== (1 << NF_IP6_PRE_ROUTING
-			    | 1 << NF_IP6_LOCAL_OUT
-			    | 1 << NF_IP6_POST_ROUTING)) ||
-		       (h->info.valid_hooks
-			== (1 << NF_IP6_PRE_ROUTING
-			    | 1 << NF_IP6_LOCAL_IN
-			    | 1 << NF_IP6_LOCAL_OUT
-			    | 1 << NF_IP6_POST_ROUTING)));
-
-		assert(h->info.hook_entry[NF_IP6_PRE_ROUTING] == 0);
-
-		n = get_chain_end(h, 0);
-
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP6_POST_ROUTING] == n);
-		n = get_chain_end(h, n);
-
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
-		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
-
-		if (h->info.valid_hooks & (1 << NF_IP6_LOCAL_IN)) {
-			n = get_chain_end(h, n);
-			n += get_entry(h, n)->next_offset;
-			assert(h->info.hook_entry[NF_IP6_LOCAL_IN] == n);
-			user_offset = h->info.hook_entry[NF_IP6_LOCAL_IN];
-		}
-
-	} else if (strcmp(h->info.name, "mangle") == 0) {
-		/* This code is getting ugly because linux < 2.4.18-pre6 had
-		 * two mangle hooks, linux >= 2.4.18-pre6 has five mangle hooks
-		 * */
-		assert((h->info.valid_hooks
-			== (1 << NF_IP6_PRE_ROUTING
-			    | 1 << NF_IP6_LOCAL_OUT)) ||
-		       (h->info.valid_hooks
-			== (1 << NF_IP6_PRE_ROUTING
-			    | 1 << NF_IP6_LOCAL_IN
-			    | 1 << NF_IP6_FORWARD
-			    | 1 << NF_IP6_LOCAL_OUT
-			    | 1 << NF_IP6_POST_ROUTING)));
-
-		/* Hooks should be first five */
-		assert(h->info.hook_entry[NF_IP6_PRE_ROUTING] == 0);
-
-		n = get_chain_end(h, 0);
-
-		if (h->info.valid_hooks & (1 << NF_IP6_LOCAL_IN)) {
-			n += get_entry(h, n)->next_offset;
-			assert(h->info.hook_entry[NF_IP6_LOCAL_IN] == n);
-			n = get_chain_end(h, n);
-		}
-
-		if (h->info.valid_hooks & (1 << NF_IP6_FORWARD)) {
-			n += get_entry(h, n)->next_offset;
-			assert(h->info.hook_entry[NF_IP6_FORWARD] == n);
-			n = get_chain_end(h, n);
-		}
-
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
-		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
-
-		if (h->info.valid_hooks & (1 << NF_IP6_POST_ROUTING)) {
-			n = get_chain_end(h, n);
-			n += get_entry(h, n)->next_offset;
-			assert(h->info.hook_entry[NF_IP6_POST_ROUTING] == n);
-			user_offset = h->info.hook_entry[NF_IP6_POST_ROUTING];
-		}
-	} else {
-                fprintf(stderr, "Unknown table `%s'\n", h->info.name);
-		abort();
-	}
-
-	/* User chain == end of last builtin + policy entry */
-	user_offset = get_chain_end(h, user_offset);
-	user_offset += get_entry(h, user_offset)->next_offset;
-
-	/* Overflows should be end of entry chains, and unconditional
-           policy nodes. */
-	for (i = 0; i < NUMHOOKS; i++) {
-		STRUCT_ENTRY *e;
-		STRUCT_STANDARD_TARGET *t;
-
-		if (!(h->info.valid_hooks & (1 << i)))
-			continue;
-		assert(h->info.underflow[i]
-		       == get_chain_end(h, h->info.hook_entry[i]));
-
-		e = get_entry(h, get_chain_end(h, h->info.hook_entry[i]));
-		assert(unconditional(&e->ipv6));
-		assert(e->target_offset == sizeof(*e));
-		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-		printf("target_size=%u, align=%u\n",
-			t->target.u.target_size, ALIGN(sizeof(*t)));
-		assert(t->target.u.target_size == ALIGN(sizeof(*t)));
-		assert(e->next_offset == sizeof(*e) + ALIGN(sizeof(*t)));
-
-		assert(strcmp(t->target.u.user.name, STANDARD_TARGET)==0);
-		assert(t->verdict == -NF_DROP-1 || t->verdict == -NF_ACCEPT-1);
-
-		/* Hooks and underflows must be valid entries */
-		entry2index(h, get_entry(h, h->info.hook_entry[i]));
-		entry2index(h, get_entry(h, h->info.underflow[i]));
-	}
-
-	assert(h->info.size
-	       >= h->info.num_entries * (sizeof(STRUCT_ENTRY)
-					 +sizeof(STRUCT_STANDARD_TARGET)));
-
-	assert(h->entries.size
-	       >= (h->new_number
-		   * (sizeof(STRUCT_ENTRY)
-		      + sizeof(STRUCT_STANDARD_TARGET))));
-	assert(strcmp(h->info.name, h->entries.name) == 0);
-
-	i = 0; n = 0;
-	was_return = 0;
-
-#if 0
-	/* Check all the entries. */
-	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-		      check_entry, &i, &n, user_offset, &was_return, h);
-
-	assert(i == h->new_number);
-	assert(n == h->entries.size);
-
-	/* Final entry must be error node */
-	assert(strcmp(GET_TARGET(index2entry(h, h->new_number-1))
-		      ->u.user.name,
-		      ERROR_TARGET) == 0);
-#endif
-}
-#endif /*IPTC_DEBUG*/
diff -urN iptables-1.2.9/libiptc/libiptc.c iptables-1.2.10/libiptc/libiptc.c
--- iptables-1.2.9/libiptc/libiptc.c	2003-07-05 22:11:11.000000000 +0200
+++ iptables-1.2.10/libiptc/libiptc.c	2004-06-15 00:02:18.000000000 +0200
@@ -1,4 +1,4 @@
-/* Library which manipulates firewall rules.  Version $Revision: 1.41 $ */
+/* Library which manipulates firewall rules.  Version $Revision: 1.47 $ */
 
 /* Architecture of firewall rules is as follows:
  *
@@ -20,6 +20,9 @@
  * 	  up after a ruleset change.  
  */
 
+#include <sys/types.h>
+#include <sys/socket.h>
+
 #ifndef IPT_LIB_DIR
 #define IPT_LIB_DIR "/usr/local/lib/iptables"
 #endif
@@ -131,8 +134,8 @@
 
 	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
 			  get_number, seek, &pos) == 0) {
-		fprintf(stderr, "ERROR: offset %i not an entry!\n",
-			(char *)seek - (char *)h->entries.entrytable);
+		fprintf(stderr, "ERROR: offset %u not an entry!\n",
+			(unsigned int)((char *)seek - (char *)h->entries.entrytable));
 		abort();
 	}
 	return pos;
@@ -526,6 +529,7 @@
 	h->cache_num_chains++;
 
 	strncpy(newcc->name, name, TABLE_MAXNAMELEN-1);
+	newcc->name[TABLE_MAXNAMELEN-1] = '\0';
 	newcc->start_off = start_off;
 	newcc->end_off = end_off;
 
diff -urN iptables-1.2.9/libiptc2/.#libiptc.c.1.40 iptables-1.2.10/libiptc2/.#libiptc.c.1.40
--- iptables-1.2.9/libiptc2/.#libiptc.c.1.40	2003-07-13 17:52:11.000000000 +0200
+++ iptables-1.2.10/libiptc2/.#libiptc.c.1.40	1970-01-01 01:00:00.000000000 +0100
@@ -1,1972 +0,0 @@
-/* Library which manipulates firewall rules.  Version $Revision: 1.40 $ */
-
-/* Architecture of firewall rules is as follows:
- *
- * Chains go INPUT, FORWARD, OUTPUT then user chains.
- * Each user chain starts with an ERROR node.
- * Every chain ends with an unconditional jump: a RETURN for user chains,
- * and a POLICY for built-ins.
- */
-
-/* (C) 1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
- * COPYING for details). 
- * (C) 2000-2003 by the Netfilter Core Team <coreteam@netfilter.org>
- *
- * 2003-Jun-20: Harald Welte <laforge@netfilter.org>:
- *	- Reimplementation of chain cache to use offsets instead of entries
- * 2003-Jun-23: Harald Welte <laforge@netfilter.org>:
- * 	- speed optimization, sponsored by Astaro AG (http://www.astaro.com/)
- * 	  don't rebuild the chain cache after every operation, instead fix it
- * 	  up after a ruleset change.  
- * 2003-Jun-30: Harald Welte <laforge@netfilter.org>:
- * 	- total reimplementation
- */
-#include "linux_listhelp.h"
-
-#ifndef IPT_LIB_DIR
-#define IPT_LIB_DIR "/usr/local/lib/iptables"
-#endif
-
-static int sockfd = -1;
-static void *iptc_fn = NULL;
-
-static const char *hooknames[]
-= { [HOOK_PRE_ROUTING]  "PREROUTING",
-    [HOOK_LOCAL_IN]     "INPUT",
-    [HOOK_FORWARD]      "FORWARD",
-    [HOOK_LOCAL_OUT]    "OUTPUT",
-    [HOOK_POST_ROUTING] "POSTROUTING",
-#ifdef HOOK_DROPPING
-    [HOOK_DROPPING]	"DROPPING"
-#endif
-};
-
-struct counter_map
-{
-	enum {
-		COUNTER_MAP_NOMAP,
-		COUNTER_MAP_NORMAL_MAP,
-		COUNTER_MAP_ZEROED,
-		COUNTER_MAP_SET
-	} maptype;
-	unsigned int mappos;
-};
-
-/* Convenience structures */
-struct ipt_error_target
-{
-	STRUCT_ENTRY_TARGET t;
-	char error[TABLE_MAXNAMELEN];
-};
-
-struct rule_head
-{
-	struct list_head list;		/* list of rules in chain */
-	
-	struct chain_head *chain;	/* we're part of this chain */
-	struct rule_head *target;	/* target of this rule, in case
-					   it is a jump rule */
-
-
-	unsigned int size;		/* size of rule */
-	STRUCT_ENTRY *entry_blob;	/* pointer to entry in blob */
-	STRUCT_ENTRY entry[0];
-};
-
-struct chain_head
-{
-	struct list_head list;
-
-	char name[TABLE_MAXNAMELEN];
-	unsigned int hooknum;
-	struct list_head rules;
-};
-
-STRUCT_TC_HANDLE
-{
-	/* Have changes been made? */
-	int changed;
-
-	/* linked list of chains in this table */
-	struct list_head chains;
-	
-	/* current position of first_chain() / next_chain() */
-	struct chain_head *chain_iterator_cur;
-
-	/* current position of first_rule() / next_rule() */
-	struct rule_head *rule_iterator_cur;
-
-	struct counter_map *counter_map;
-
-	/* the structure we receive from getsockopt() */
-	STRUCT_GETINFO info;
-
-	/* Array of hook names */
-	const char **hooknames;
-#if 0
-	/* Size in here reflects original state. */
-
-
-	/* Cached position of chain heads (NULL = no cache). */
-	unsigned int cache_num_chains;
-	unsigned int cache_num_builtins;
-	struct chain_cache *cache_chain_heads;
-
-	/* Chain iterator: current chain cache entry. */
-	struct chain_cache *cache_chain_iteration;
-
-	/* Rule iterator: terminal rule */
-	STRUCT_ENTRY *cache_rule_end;
-
-	/* Number in here reflects current state. */
-	unsigned int new_number;
-#endif
-	STRUCT_GET_ENTRIES entries;
-};
-
-static void
-set_changed(TC_HANDLE_T h)
-{
-	h->changed = 1;
-}
-
-#ifdef IPTC_DEBUG
-static void do_check(TC_HANDLE_T h, unsigned int line);
-#define CHECK(h) do { if (!getenv("IPTC_NO_CHECK")) do_check((h), __LINE__); } while(0)
-#else
-#define CHECK(h)
-#endif
-
-static struct rule_head *ruleh_alloc(unsigned int size)
-{
-	struct rule_head *ruleh = malloc(sizeof(*ruleh)+size);
-	if (!ruleh)
-		return NULL;
-	
-	memset(ruleh, 0, sizeof(*ruleh)+size);
-	ruleh->size = size;
-
-	return ruleh;
-}
-
-static void ruleh_free(struct rule_head *ruleh)
-{
-	list_del(&ruleh->list);
-	free(ruleh);
-}
-
-static struct rule_head *ruleh_get_n(struct chain_head *chain, int num)
-{
-	return NULL;
-}
-
-static struct chain_head *chainh_alloc(TC_HANDLE_T h, const char *name)
-{
-	struct chain_head *chainh = malloc(sizeof(*chainh));
-	if (!chainh)
-		return NULL;
-
-	memset(chainh, 0, sizeof(*chainh));
-	strncpy(chainh->name, name, sizeof(&chainh->name));
-	list_append(&chainh->list, &h->chains);
-
-	return chainh;
-}
-
-static void
-chainh_free(struct chain_head *chainh)
-{
-	/* FIXME */
-	struct list_head *cur_item, *item2;
-
-	list_for_each_safe(cur_item, item2, &chainh->rules) {
-		struct rule_head *ruleh = list_entry(cur_item, 
-						     struct rule_head,
-						    list);
-		ruleh_free(ruleh);
-	}
-
-	list_del(&chainh->list);
-}
-
-#if 0
-static inline int
-get_number(const STRUCT_ENTRY *i,
-	   const STRUCT_ENTRY *seek,
-	   unsigned int *pos)
-{
-	if (i == seek)
-		return 1;
-	(*pos)++;
-	return 0;
-}
-#endif
-
-static struct chain_head *
-chainh_find(TC_HANDLE_T h, const IPT_CHAINLABEL name)
-{
-	struct list_head *cur;
-
-	list_for_each(cur, &h->chains) {
-		struct chain_head *ch = list_entry(cur, struct chain_head, 
-						   list);
-		if (!strcmp(name, ch->name))
-			return ch;
-	}
-	return NULL;
-}
-
-static inline unsigned long
-entry2offset(const TC_HANDLE_T h, const STRUCT_ENTRY *e)
-{
-	return (void *)e - (void *)h->entries.entrytable;
-}
-
-#if 0
-static unsigned int
-entry2index(const TC_HANDLE_T h, const STRUCT_ENTRY *seek)
-{
-	unsigned int pos = 0;
-
-	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-			  get_number, seek, &pos) == 0) {
-		fprintf(stderr, "ERROR: offset %i not an entry!\n",
-			(char *)seek - (char *)h->entries.entrytable);
-		abort();
-	}
-	return pos;
-}
-
-static inline int
-get_entry_n(STRUCT_ENTRY *i,
-	    unsigned int number,
-	    unsigned int *pos,
-	    STRUCT_ENTRY **pe)
-{
-	if (*pos == number) {
-		*pe = i;
-		return 1;
-	}
-	(*pos)++;
-	return 0;
-}
-
-static STRUCT_ENTRY *
-index2entry(TC_HANDLE_T h, unsigned int index)
-{
-	unsigned int pos = 0;
-	STRUCT_ENTRY *ret = NULL;
-
-	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-		      get_entry_n, index, &pos, &ret);
-
-	return ret;
-}
-
-static inline STRUCT_ENTRY *
-get_entry(TC_HANDLE_T h, unsigned int offset)
-{
-	return (STRUCT_ENTRY *)((char *)h->entries.entrytable + offset);
-}
-
-
-static inline unsigned long
-index2offset(TC_HANDLE_T h, unsigned int index)
-{
-	return entry2offset(h, index2entry(h, index));
-}
-
-static inline STRUCT_ENTRY *
-offset2entry(TC_HANDLE_T h, unsigned int offset)
-{
-	return (STRUCT_ENTRY *) ((void *)h->entries.entrytable+offset);
-}
-
-static inline unsigned int
-offset2index(const TC_HANDLE_T h, unsigned int offset)
-{
-	return entry2index(h, offset2entry(h, offset));
-}
-
-
-static const char *
-get_errorlabel(TC_HANDLE_T h, unsigned int offset)
-{
-	STRUCT_ENTRY *e;
-
-	e = get_entry(h, offset);
-	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) != 0) {
-		fprintf(stderr, "ERROR: offset %u not an error node!\n",
-			offset);
-		abort();
-	}
-
-	return (const char *)GET_TARGET(e)->data;
-}
-#endif
-
-/* Allocate handle of given size */
-static TC_HANDLE_T
-alloc_handle(const char *tablename, unsigned int size, unsigned int num_rules)
-{
-	size_t len;
-	TC_HANDLE_T h;
-
-	len = sizeof(STRUCT_TC_HANDLE)
-		+ size
-		+ num_rules * sizeof(struct counter_map);
-
-	if ((h = malloc(len)) == NULL) {
-		errno = ENOMEM;
-		return NULL;
-	}
-
-	h->changed = 0;
-
-	h->counter_map = (void *)h
-		+ sizeof(STRUCT_TC_HANDLE)
-		+ size;
-	strcpy(h->info.name, tablename);
-	strcpy(h->entries.name, tablename);
-	INIT_LIST_HEAD(&h->chains);
-
-	return h;
-}
-
-struct rule_head *
-append_entrycopy(STRUCT_ENTRY *e, struct chain_head *chain)
-{
-	struct rule_head *ruleh = ruleh_alloc(e->next_offset);
-	if (!ruleh)
-		return NULL;
-	
-	memcpy(&ruleh->entry, e, e->next_offset);
-	ruleh->chain = chain;
-	ruleh->entry_blob = e;
-	list_append(&ruleh->list, &chain->rules);
-
-	return ruleh;
-}
-
-
-/* have to return 0 on success, bcf ENTRY_ITERATE */
-static inline int 
-parse_entry(STRUCT_ENTRY *e, TC_HANDLE_T h, struct chain_head **curchain)
-{
-	int i;
-	union tgt_u {
-		STRUCT_ENTRY_TARGET ent;
-		STRUCT_STANDARD_TARGET std;
-		struct ipt_error_target err;
-	} *tgt;
-
-	tgt = (union tgt_u *) GET_TARGET(e);
-
-	if (e->target_offset == sizeof(STRUCT_ENTRY)
-	    && (strcmp(tgt->ent.u.user.name, IPT_STANDARD_TARGET) == 0)) {
-		/* jump to somewhere else */
-		append_entrycopy(e, *curchain);
-		/* FIXME: */
-	} else if (e->target_offset == sizeof(STRUCT_ENTRY)
-		   && e->next_offset == sizeof(STRUCT_ENTRY)
-		   			+ ALIGN(sizeof(struct ipt_error_target))
-		   && !strcmp(tgt->ent.u.user.name, ERROR_TARGET)) {
-		/* chain head */
-		*curchain = chainh_find(h, tgt->err.error);
-		if (*curchain) {
-			/* FIXME: error handling */
-			return 1;
-		}
-
-		*curchain = chainh_alloc(h, tgt->err.error);
-		/* FIXME: error handling */
-		append_entrycopy(e, *curchain);
-	} else if (e->target_offset == sizeof(STRUCT_ENTRY)
-		   && e->next_offset == sizeof(STRUCT_ENTRY)
-		   			+ ALIGN(sizeof(STRUCT_STANDARD_TARGET))
-		   && tgt->std.verdict == RETURN) {
-		/* chain end */
-		append_entrycopy(e, *curchain);
-		*curchain = NULL;
-	} else {
-		/* normal rule */
-		append_entrycopy(e, *curchain);
-	}
-
-	/* iterate over hook_entries, needed to connect builtin
-	 * chains with hook numbers */
-	for (i = 0; i < NUMHOOKS; i++) {
-		if (!(h->info.valid_hooks & (1 << i)))
-			continue;
-		if (h->info.hook_entry[i] == entry2offset(h, e)) {
-			/* found hook entry point */
-			if (*curchain)
-				(*curchain)->hooknum = i;
-		}
-		if (h->info.underflow[i] == entry2offset(h, e)) {
-			/* found underflow point */
-		}
-	}
-
-	return 0;
-}
-
-static int parse_ruleset(TC_HANDLE_T h)
-{
-	struct chain_head *curchain;
-	
-	/* iterate over ruleset; create linked list of rule_head/chain_head */
-	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size, 
-		      parse_entry, h, &curchain)) {
-		/* some error happened while iterating */
-		return 0;
-	}
-
-	return 1;
-}
-
-TC_HANDLE_T
-TC_INIT(const char *tablename)
-{
-	TC_HANDLE_T h;
-	STRUCT_GETINFO info;
-	unsigned int i;
-	int tmp;
-	socklen_t s;
-
-	iptc_fn = TC_INIT;
-
-	if (sockfd != -1) {
-		close(sockfd);
-		sockfd = -1;
-	}
-
-	if (strlen(tablename) >= TABLE_MAXNAMELEN) {
-		errno = EINVAL;
-		return NULL;
-	}
-	
-	sockfd = socket(TC_AF, SOCK_RAW, IPPROTO_RAW);
-	if (sockfd < 0)
-		return NULL;
-
-	s = sizeof(info);
-
-	strcpy(info.name, tablename);
-	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_INFO, &info, &s) < 0)
-		return NULL;
-
-	if ((h = alloc_handle(info.name, info.size, info.num_entries))
-	    == NULL) {
-		close(sockfd);
-		sockfd = -1;
-		return NULL;
-	}
-
-/* Too hard --RR */
-#if 0
-	sprintf(pathname, "%s/%s", IPT_LIB_DIR, info.name);
-	dynlib = dlopen(pathname, RTLD_NOW);
-	if (!dynlib) {
-		errno = ENOENT;
-		return NULL;
-	}
-	h->hooknames = dlsym(dynlib, "hooknames");
-	if (!h->hooknames) {
-		errno = ENOENT;
-		return NULL;
-	}
-#else
-	h->hooknames = hooknames;
-#endif
-
-	/* Initialize current state */
-	h->info = info;
-	//h->new_number = h->info.num_entries;
-	for (i = 0; i < h->info.num_entries; i++)
-		h->counter_map[i]
-			= ((struct counter_map){COUNTER_MAP_NORMAL_MAP, i});
-
-	h->entries.size = h->info.size;
-
-	tmp = sizeof(STRUCT_GET_ENTRIES) + h->info.size;
-
-	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_ENTRIES, &h->entries,
-		       &tmp) < 0) {
-		close(sockfd);
-		sockfd = -1;
-		free(h);
-		return NULL;
-	}
-
-	CHECK(h);
-	parse_ruleset(h);
-
-	return h;
-}
-
-void
-TC_FREE(TC_HANDLE_T *h)
-{
-	struct list_head *cur_item, *item2;
-
-	close(sockfd);
-	sockfd = -1;
-
-	/* free all chains */
-	list_for_each_safe(cur_item, item2, (*h)->chains.next) {
-		struct chain_head *chead = list_entry(cur_item,
-						      struct chain_head,
-						      list);
-		chainh_free(chead);
-	}
-
-	/* FIXME: free all other ressources we might be using */
-
-	free(*h);
-	*h = NULL;
-}
-
-static inline int
-print_match(const STRUCT_ENTRY_MATCH *m)
-{
-	printf("Match name: `%s'\n", m->u.user.name);
-	return 0;
-}
-
-static int dump_entry(STRUCT_ENTRY *e, const TC_HANDLE_T handle);
- 
-#if 0
-void
-TC_DUMP_ENTRIES(const TC_HANDLE_T handle)
-{
-	CHECK(handle);
-
-	printf("libiptc v%s.  %u entries, %u bytes.\n",
-	       IPTABLES_VERSION,
-	       handle->new_number, handle->entries.size);
-	printf("Table `%s'\n", handle->info.name);
-	printf("Hooks: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
-	       handle->info.hook_entry[HOOK_PRE_ROUTING],
-	       handle->info.hook_entry[HOOK_LOCAL_IN],
-	       handle->info.hook_entry[HOOK_FORWARD],
-	       handle->info.hook_entry[HOOK_LOCAL_OUT],
-	       handle->info.hook_entry[HOOK_POST_ROUTING]);
-	printf("Underflows: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
-	       handle->info.underflow[HOOK_PRE_ROUTING],
-	       handle->info.underflow[HOOK_LOCAL_IN],
-	       handle->info.underflow[HOOK_FORWARD],
-	       handle->info.underflow[HOOK_LOCAL_OUT],
-	       handle->info.underflow[HOOK_POST_ROUTING]);
-
-	ENTRY_ITERATE(handle->entries.entrytable, handle->entries.size,
-		      dump_entry, handle);
-}
-
-/* Returns 0 if not hook entry, else hooknumber + 1 */
-static inline unsigned int
-is_hook_entry(STRUCT_ENTRY *e, TC_HANDLE_T h)
-{
-	unsigned int i;
-
-	for (i = 0; i < NUMHOOKS; i++) {
-		if ((h->info.valid_hooks & (1 << i))
-		    && get_entry(h, h->info.hook_entry[i]) == e)
-			return i+1;
-	}
-	return 0;
-}
-
-
-static int alphasort(const void *a, const void *b)
-{
-	return strcmp(((struct chain_cache *)a)->name,
-		      ((struct chain_cache *)b)->name);
-}
-#endif
-
-/* Returns chain head if found, otherwise NULL. */
-static struct chain_head *
-find_label(const char *name, TC_HANDLE_T handle)
-{
-	struct list_head *pos;
-
-	if (list_empty(&handle->chains))
-		return NULL;
-
-	list_for_each(pos, &handle->chains) {
-		struct chain_head *c = list_entry(pos, struct chain_head, list);
-		if (!strcmp(c->name, name))
-			return c;
-	}
-
-	return NULL;
-}
-
-/* Does this chain exist? */
-int TC_IS_CHAIN(const char *chain, const TC_HANDLE_T handle)
-{
-	return find_label(chain, handle) != NULL;
-}
-
-#if 0
-/* Returns the position of the final (ie. unconditional) element. */
-static unsigned int
-get_chain_end(const TC_HANDLE_T handle, unsigned int start)
-{
-	unsigned int last_off, off;
-	STRUCT_ENTRY *e;
-
-	last_off = start;
-	e = get_entry(handle, start);
-
-	/* Terminate when we meet a error label or a hook entry. */
-	for (off = start + e->next_offset;
-	     off < handle->entries.size;
-	     last_off = off, off += e->next_offset) {
-		STRUCT_ENTRY_TARGET *t;
-		unsigned int i;
-
-		e = get_entry(handle, off);
-
-		/* We hit an entry point. */
-		for (i = 0; i < NUMHOOKS; i++) {
-			if ((handle->info.valid_hooks & (1 << i))
-			    && off == handle->info.hook_entry[i])
-				return last_off;
-		}
-
-		/* We hit a user chain label */
-		t = GET_TARGET(e);
-		if (strcmp(t->u.user.name, ERROR_TARGET) == 0)
-			return last_off;
-	}
-	/* SHOULD NEVER HAPPEN */
-	fprintf(stderr, "ERROR: Off end (%u) of chain from %u!\n",
-		handle->entries.size, off);
-	abort();
-}
-#endif
-
-/* Iterator functions to run through the chains. */
-const char *
-TC_FIRST_CHAIN(TC_HANDLE_T *handle)
-{
-	struct chain_head *firsthead = list_entry((*handle)->chains.next,
-						   struct chain_head, list);
-	(*handle)->chain_iterator_cur = firsthead;
-
-	return firsthead->name;
-}
-
-/* Iterator functions to run through the chains.  Returns NULL at end. */
-const char *
-TC_NEXT_CHAIN(TC_HANDLE_T *handle)
-{
-	struct chain_head *next = list_entry(&(*handle)->chain_iterator_cur->list.next, struct chain_head, list);
-	(*handle)->chain_iterator_cur = next;
-
-	if (&next->list == &(*handle)->chains)
-		return NULL;
-
-	return next->name;
-}
-
-/* Get first rule in the given chain: NULL for empty chain. */
-const STRUCT_ENTRY *
-TC_FIRST_RULE(const char *chain, TC_HANDLE_T *handle)
-{
-	struct chain_head *c;
-	struct rule_head *r;
-
-	c = find_label(chain, *handle);
-	if (!c) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	/* Empty chain: single return/policy rule */
-	if (list_empty(&c->rules))
-		return NULL;
-
-	r = list_entry(c->rules.next, struct rule_head, list);
-	(*handle)->rule_iterator_cur = r;
-
-	return r->entry;
-}
-
-/* Returns NULL when rules run out. */
-const STRUCT_ENTRY *
-TC_NEXT_RULE(const STRUCT_ENTRY *prev, TC_HANDLE_T *handle)
-{
-	struct rule_head *r = list_entry((*handle)->rule_iterator_cur->list.next, struct rule_head, list);
-
-	if (&r->list == &r->chain->rules)
-		return NULL;
-
-	/* NOTE: prev is without any influence ! */
-	return r->entry;
-}
-
-#if 0
-/* How many rules in this chain? */
-unsigned int
-TC_NUM_RULES(const char *chain, TC_HANDLE_T *handle)
-{
-	unsigned int off = 0;
-	STRUCT_ENTRY *start, *end;
-
-	CHECK(*handle);
-	if (!find_label(&off, chain, *handle)) {
-		errno = ENOENT;
-		return (unsigned int)-1;
-	}
-
-	start = get_entry(*handle, off);
-	end = get_entry(*handle, get_chain_end(*handle, off));
-
-	return entry2index(*handle, end) - entry2index(*handle, start);
-}
-
-/* Get n'th rule in this chain. */
-const STRUCT_ENTRY *TC_GET_RULE(const char *chain,
-				unsigned int n,
-				TC_HANDLE_T *handle)
-{
-	unsigned int pos = 0, chainindex;
-
-	CHECK(*handle);
-	if (!find_label(&pos, chain, *handle)) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	chainindex = entry2index(*handle, get_entry(*handle, pos));
-
-	return index2entry(*handle, chainindex + n);
-}
-#endif
-
-static const char *
-target_name(TC_HANDLE_T handle, const STRUCT_ENTRY *ce)
-{
-	int spos;
-	unsigned int labelidx;
-	STRUCT_ENTRY *jumpto;
-
-	/* To avoid const warnings */
-	STRUCT_ENTRY *e = (STRUCT_ENTRY *)ce;
-
-	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) != 0)
-		return GET_TARGET(e)->u.user.name;
-
-	/* Standard target: evaluate */
-	spos = *(int *)GET_TARGET(e)->data;
-	if (spos < 0) {
-		if (spos == RETURN)
-			return LABEL_RETURN;
-		else if (spos == -NF_ACCEPT-1)
-			return LABEL_ACCEPT;
-		else if (spos == -NF_DROP-1)
-			return LABEL_DROP;
-		else if (spos == -NF_QUEUE-1)
-			return LABEL_QUEUE;
-
-		fprintf(stderr, "ERROR: off %lu/%u not a valid target (%d)\n",
-			entry2offset(handle, e), handle->entries.size,
-			spos);
-		abort();
-	}
-
-	jumpto = get_entry(handle, spos);
-
-	/* Fall through rule */
-	if (jumpto == (void *)e + e->next_offset)
-		return "";
-
-	/* Must point to head of a chain: ie. after error rule */
-	/* FIXME: this needs to deal with internal jump targets */
-	labelidx = entry2index(handle, jumpto) - 1;
-	return get_errorlabel(handle, index2offset(handle, labelidx));
-}
-
-/* Returns a pointer to the target name of this position. */
-const char *TC_GET_TARGET(const STRUCT_ENTRY *e,
-			  TC_HANDLE_T *handle)
-{
-	return target_name(*handle, e);
-}
-
-/* Is this a built-in chain?  Actually returns hook + 1. */
-int
-TC_BUILTIN(const char *chain, const TC_HANDLE_T handle)
-{
-	unsigned int i;
-
-	for (i = 0; i < NUMHOOKS; i++) {
-		if ((handle->info.valid_hooks & (1 << i))
-		    && handle->hooknames[i]
-		    && strcmp(handle->hooknames[i], chain) == 0)
-			return i+1;
-	}
-	return 0;
-}
-
-/* Get the policy of a given built-in chain */
-const char *
-TC_GET_POLICY(const char *chain,
-	      STRUCT_COUNTERS *counters,
-	      TC_HANDLE_T *handle)
-{
-	unsigned int start;
-	STRUCT_ENTRY *e;
-	int hook;
-
-	hook = TC_BUILTIN(chain, *handle);
-	if (hook != 0)
-		start = (*handle)->info.hook_entry[hook-1];
-	else
-		return NULL;
-
-	e = get_entry(*handle, get_chain_end(*handle, start));
-	*counters = e->counters;
-
-	return target_name(*handle, e);
-}
-
-static int
-correct_verdict(STRUCT_ENTRY *e,
-		char *base,
-		unsigned int offset, int delta_offset)
-{
-	STRUCT_STANDARD_TARGET *t = (void *)GET_TARGET(e);
-	unsigned int curr = (char *)e - base;
-
-	/* Trap: insert of fall-through rule.  Don't change fall-through
-	   verdict to jump-over-next-rule. */
-	if (strcmp(t->target.u.user.name, STANDARD_TARGET) == 0
-	    && t->verdict > (int)offset
-	    && !(curr == offset &&
-		 t->verdict == curr + e->next_offset)) {
-		t->verdict += delta_offset;
-	}
-
-	return 0;
-}
-
-/* Adjusts standard verdict jump positions after an insertion/deletion. */
-static int
-set_verdict(unsigned int offset, int delta_offset, TC_HANDLE_T *handle)
-{
-	ENTRY_ITERATE((*handle)->entries.entrytable,
-		      (*handle)->entries.size,
-		      correct_verdict, (char *)(*handle)->entries.entrytable,
-		      offset, delta_offset);
-
-	set_changed(*handle);
-	return 1;
-}
-
-/* If prepend is set, then we are prepending to a chain: if the
- * insertion position is an entry point, keep the entry point. */
-static int
-insert_rules(unsigned int num_rules, unsigned int rules_size,
-	     const STRUCT_ENTRY *insert,
-	     unsigned int offset, unsigned int num_rules_offset,
-	     int prepend,
-	     TC_HANDLE_T *handle)
-{
-	TC_HANDLE_T newh;
-	STRUCT_GETINFO newinfo;
-	unsigned int i;
-
-	if (offset >= (*handle)->entries.size) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	newinfo = (*handle)->info;
-
-	/* Fix up entry points. */
-	for (i = 0; i < NUMHOOKS; i++) {
-		/* Entry points to START of chain, so keep same if
-                   inserting on at that point. */
-		if ((*handle)->info.hook_entry[i] > offset)
-			newinfo.hook_entry[i] += rules_size;
-
-		/* Underflow always points to END of chain (policy),
-		   so if something is inserted at same point, it
-		   should be advanced. */
-		if ((*handle)->info.underflow[i] >= offset)
-			newinfo.underflow[i] += rules_size;
-	}
-
-	newh = alloc_handle((*handle)->info.name,
-			    (*handle)->entries.size + rules_size,
-			    (*handle)->new_number + num_rules);
-	if (!newh)
-		return 0;
-	newh->info = newinfo;
-
-	/* Copy pre... */
-	memcpy(newh->entries.entrytable, (*handle)->entries.entrytable,offset);
-	/* ... Insert new ... */
-	memcpy((char *)newh->entries.entrytable + offset, insert, rules_size);
-	/* ... copy post */
-	memcpy((char *)newh->entries.entrytable + offset + rules_size,
-	       (char *)(*handle)->entries.entrytable + offset,
-	       (*handle)->entries.size - offset);
-
-	/* Move counter map. */
-	/* Copy pre... */
-	memcpy(newh->counter_map, (*handle)->counter_map,
-	       sizeof(struct counter_map) * num_rules_offset);
-	/* ... copy post */
-	memcpy(newh->counter_map + num_rules_offset + num_rules,
-	       (*handle)->counter_map + num_rules_offset,
-	       sizeof(struct counter_map) * ((*handle)->new_number
-					     - num_rules_offset));
-	/* Set intermediates to no counter copy */
-	for (i = 0; i < num_rules; i++)
-		newh->counter_map[num_rules_offset+i]
-			= ((struct counter_map){ COUNTER_MAP_SET, 0 });
-
-	newh->new_number = (*handle)->new_number + num_rules;
-	newh->entries.size = (*handle)->entries.size + rules_size;
-	newh->hooknames = (*handle)->hooknames;
-
-	if ((*handle)->cache_chain_heads)
-		free((*handle)->cache_chain_heads);
-	free(*handle);
-	*handle = newh;
-
-	return set_verdict(offset, rules_size, handle);
-}
-
-static int
-delete_rules(unsigned int num_rules, unsigned int rules_size,
-	     unsigned int offset, unsigned int num_rules_offset,
-	     TC_HANDLE_T *handle)
-{
-	unsigned int i;
-
-	if (offset + rules_size > (*handle)->entries.size) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	/* Fix up entry points. */
-	for (i = 0; i < NUMHOOKS; i++) {
-		/* In practice, we never delete up to a hook entry,
-		   since the built-in chains are always first,
-		   so these two are never equal */
-		if ((*handle)->info.hook_entry[i] >= offset + rules_size)
-			(*handle)->info.hook_entry[i] -= rules_size;
-		else if ((*handle)->info.hook_entry[i] > offset) {
-			fprintf(stderr, "ERROR: Deleting entry %u %u %u\n",
-				i, (*handle)->info.hook_entry[i], offset);
-			abort();
-		}
-
-		/* Underflow points to policy (terminal) rule in
-                   built-in, so sequality is valid here (when deleting
-                   the last rule). */
-		if ((*handle)->info.underflow[i] >= offset + rules_size)
-			(*handle)->info.underflow[i] -= rules_size;
-		else if ((*handle)->info.underflow[i] > offset) {
-			fprintf(stderr, "ERROR: Deleting uflow %u %u %u\n",
-				i, (*handle)->info.underflow[i], offset);
-			abort();
-		}
-	}
-
-	/* Move the rules down. */
-	memmove((char *)(*handle)->entries.entrytable + offset,
-		(char *)(*handle)->entries.entrytable + offset + rules_size,
-		(*handle)->entries.size - (offset + rules_size));
-
-	/* Move the counter map down. */
-	memmove(&(*handle)->counter_map[num_rules_offset],
-		&(*handle)->counter_map[num_rules_offset + num_rules],
-		sizeof(struct counter_map)
-		* ((*handle)->new_number - (num_rules + num_rules_offset)));
-
-	/* Fix numbers */
-	(*handle)->new_number -= num_rules;
-	(*handle)->entries.size -= rules_size;
-
-	return set_verdict(offset, -(int)rules_size, handle);
-}
-
-static int
-standard_map(STRUCT_ENTRY *e, int verdict)
-{
-	STRUCT_STANDARD_TARGET *t;
-
-	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-
-	if (t->target.u.target_size
-	    != ALIGN(sizeof(STRUCT_STANDARD_TARGET))) {
-		errno = EINVAL;
-		return 0;
-	}
-	/* memset for memcmp convenience on delete/replace */
-	memset(t->target.u.user.name, 0, FUNCTION_MAXNAMELEN);
-	strcpy(t->target.u.user.name, STANDARD_TARGET);
-	t->verdict = verdict;
-
-	return 1;
-}
-
-static int
-map_target(const TC_HANDLE_T handle,
-	   STRUCT_ENTRY *e,
-	   unsigned int offset,
-	   STRUCT_ENTRY_TARGET *old)
-{
-	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
-
-	/* Save old target (except data, which we don't change, except for
-	   standard case, where we don't care). */
-	*old = *t;
-
-	/* Maybe it's empty (=> fall through) */
-	if (strcmp(t->u.user.name, "") == 0)
-		return standard_map(e, offset + e->next_offset);
-	/* Maybe it's a standard target name... */
-	else if (strcmp(t->u.user.name, LABEL_ACCEPT) == 0)
-		return standard_map(e, -NF_ACCEPT - 1);
-	else if (strcmp(t->u.user.name, LABEL_DROP) == 0)
-		return standard_map(e, -NF_DROP - 1);
-	else if (strcmp(t->u.user.name, LABEL_QUEUE) == 0)
-		return standard_map(e, -NF_QUEUE - 1);
-	else if (strcmp(t->u.user.name, LABEL_RETURN) == 0)
-		return standard_map(e, RETURN);
-	else if (TC_BUILTIN(t->u.user.name, handle)) {
-		/* Can't jump to builtins. */
-		errno = EINVAL;
-		return 0;
-	} else {
-		/* Maybe it's an existing chain name. */
-		struct chain_cache *c;
-
-		c = find_label(t->u.user.name, handle);
-		if (c)
-			return standard_map(e, c->start_off);
-	}
-
-	/* Must be a module?  If not, kernel will reject... */
-	/* memset to all 0 for your memcmp convenience. */
-	memset(t->u.user.name + strlen(t->u.user.name),
-	       0,
-	       FUNCTION_MAXNAMELEN - strlen(t->u.user.name));
-	return 1;
-}
-
-static void
-unmap_target(STRUCT_ENTRY *e, STRUCT_ENTRY_TARGET *old)
-{
-	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
-
-	/* Save old target (except data, which we don't change, except for
-	   standard case, where we don't care). */
-	*t = *old;
-}
-
-/* Insert the entry `fw' in chain `chain' into position `rulenum'. */
-int
-TC_INSERT_ENTRY(const IPT_CHAINLABEL chain,
-		const STRUCT_ENTRY *e,
-		unsigned int rulenum,
-		TC_HANDLE_T *handle)
-{
-	unsigned int chainindex, offset;
-	STRUCT_ENTRY_TARGET old;
-	struct chain_cache *c;
-	STRUCT_ENTRY *tmp;
-	int ret;
-
-	iptc_fn = TC_INSERT_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-
-	tmp = index2entry(*handle, chainindex + rulenum);
-	if (!tmp || tmp > offset2entry(*handle, c->end_off)) {
-		errno = E2BIG;
-		return 0;
-	}
-	offset = index2offset(*handle, chainindex + rulenum);
-
-	/* Mapping target actually alters entry, but that's
-           transparent to the caller. */
-	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
-		return 0;
-
-	ret = insert_rules(1, e->next_offset, e, offset,
-			   chainindex + rulenum, rulenum == 0, handle);
-	unmap_target((STRUCT_ENTRY *)e, &old);
-	return ret;
-}
-
-/* Atomically replace rule `rulenum' in `chain' with `fw'. */
-int
-TC_REPLACE_ENTRY(const IPT_CHAINLABEL chain,
-		 const STRUCT_ENTRY *e,
-		 unsigned int rulenum,
-		 TC_HANDLE_T *handle)
-{
-	unsigned int chainindex, offset;
-	STRUCT_ENTRY_TARGET old;
-	struct chain_cache *c;
-	STRUCT_ENTRY *tmp;
-	int ret;
-
-	iptc_fn = TC_REPLACE_ENTRY;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-
-	tmp = index2entry(*handle, chainindex + rulenum);
-	if (!tmp || tmp >= offset2entry(*handle, c->end_off)) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	offset = index2offset(*handle, chainindex + rulenum);
-	/* Replace = delete and insert. */
-	if (!delete_rules(1, get_entry(*handle, offset)->next_offset,
-			  offset, chainindex + rulenum, handle))
-		return 0;
-
-	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
-		return 0;
-
-	ret = insert_rules(1, e->next_offset, e, offset,
-			   chainindex + rulenum, 1, handle);
-	unmap_target((STRUCT_ENTRY *)e, &old);
-	return ret;
-}
-
-/* Append entry `fw' to chain `chain'.  Equivalent to insert with
-   rulenum = length of chain. */
-int
-TC_APPEND_ENTRY(const IPT_CHAINLABEL chain,
-		const STRUCT_ENTRY *e,
-		TC_HANDLE_T *handle)
-{
-	struct chain_cache *c;
-	STRUCT_ENTRY_TARGET old;
-	int ret;
-
-	iptc_fn = TC_APPEND_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	if (!map_target(*handle, (STRUCT_ENTRY *)e,
-			c->end_off, &old))
-		return 0;
-
-	ret = insert_rules(1, e->next_offset, e, c->end_off, 
-			   offset2index(*handle, c->end_off), 0, handle);
-	unmap_target((STRUCT_ENTRY *)e, &old);
-	return ret;
-}
-
-static inline int
-match_different(const STRUCT_ENTRY_MATCH *a,
-		const unsigned char *a_elems,
-		const unsigned char *b_elems,
-		unsigned char **maskptr)
-{
-	const STRUCT_ENTRY_MATCH *b;
-	unsigned int i;
-
-	/* Offset of b is the same as a. */
-	b = (void *)b_elems + ((unsigned char *)a - a_elems);
-
-	if (a->u.match_size != b->u.match_size)
-		return 1;
-
-	if (strcmp(a->u.user.name, b->u.user.name) != 0)
-		return 1;
-
-	*maskptr += ALIGN(sizeof(*a));
-
-	for (i = 0; i < a->u.match_size - ALIGN(sizeof(*a)); i++)
-		if (((a->data[i] ^ b->data[i]) & (*maskptr)[i]) != 0)
-			return 1;
-	*maskptr += i;
-	return 0;
-}
-
-static inline int
-target_different(const unsigned char *a_targdata,
-		 const unsigned char *b_targdata,
-		 unsigned int tdatasize,
-		 const unsigned char *mask)
-{
-	unsigned int i;
-	for (i = 0; i < tdatasize; i++)
-		if (((a_targdata[i] ^ b_targdata[i]) & mask[i]) != 0)
-			return 1;
-
-	return 0;
-}
-
-static int
-is_same(const STRUCT_ENTRY *a,
-	const STRUCT_ENTRY *b,
-	unsigned char *matchmask);
-
-/* Delete the first rule in `chain' which matches `fw'. */
-int
-TC_DELETE_ENTRY(const IPT_CHAINLABEL chain,
-		const STRUCT_ENTRY *origfw,
-		unsigned char *matchmask,
-		TC_HANDLE_T *handle)
-{
-	unsigned int offset;
-	struct chain_cache *c;
-	STRUCT_ENTRY *e, *fw;
-
-	iptc_fn = TC_DELETE_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	fw = malloc(origfw->next_offset);
-	if (fw == NULL) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	for (offset = c->start_off; offset < c->end_off;
-	     offset += e->next_offset) {
-		STRUCT_ENTRY_TARGET discard;
-
-		memcpy(fw, origfw, origfw->next_offset);
-
-		/* FIXME: handle this in is_same --RR */
-		if (!map_target(*handle, fw, offset, &discard)) {
-			free(fw);
-			return 0;
-		}
-		e = get_entry(*handle, offset);
-
-#if 0
-		printf("Deleting:\n");
-		dump_entry(newe);
-#endif
-		if (is_same(e, fw, matchmask)) {
-			int ret;
-			ret = delete_rules(1, e->next_offset,
-					   offset, entry2index(*handle, e),
-					   handle);
-			free(fw);
-			return ret;
-		}
-	}
-
-	free(fw);
-	errno = ENOENT;
-	return 0;
-}
-
-/* Delete the rule in position `rulenum' in `chain'. */
-int
-TC_DELETE_NUM_ENTRY(const IPT_CHAINLABEL chain,
-		    unsigned int rulenum,
-		    TC_HANDLE_T *handle)
-{
-	unsigned int index;
-	int ret;
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-
-	iptc_fn = TC_DELETE_NUM_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	index = offset2index(*handle, c->start_off) + rulenum;
-
-	if (index >= offset2index(*handle, c->end_off)) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	e = index2entry(*handle, index);
-	if (e == NULL) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	ret = delete_rules(1, e->next_offset, entry2offset(*handle, e),
-			   index, handle);
-	return ret;
-}
-
-/* Check the packet `fw' on chain `chain'.  Returns the verdict, or
-   NULL and sets errno. */
-const char *
-TC_CHECK_PACKET(const IPT_CHAINLABEL chain,
-		STRUCT_ENTRY *entry,
-		TC_HANDLE_T *handle)
-{
-	errno = ENOSYS;
-	return NULL;
-}
-
-/* Flushes the entries in the given chain (ie. empties chain). */
-int
-TC_FLUSH_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	unsigned int startindex, endindex;
-	STRUCT_ENTRY *startentry, *endentry;
-	struct chain_cache *c;
-	int ret;
-
-	iptc_fn = TC_FLUSH_ENTRIES;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-	startindex = offset2index(*handle, c->start_off);
-	endindex = offset2index(*handle, c->end_off);
-	startentry = offset2entry(*handle, c->start_off);
-	endentry = offset2entry(*handle, c->end_off);
-
-	ret = delete_rules(endindex - startindex,
-			   (char *)endentry - (char *)startentry,
-			   c->start_off, startindex,
-			   handle);
-	return ret;
-}
-
-/* Zeroes the counters in a chain. */
-int
-TC_ZERO_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	unsigned int i, end;
-	struct chain_cache *c;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	i = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	for (; i <= end; i++) {
-		if ((*handle)->counter_map[i].maptype ==COUNTER_MAP_NORMAL_MAP)
-			(*handle)->counter_map[i].maptype = COUNTER_MAP_ZEROED;
-	}
-	set_changed(*handle);
-
-	return 1;
-}
-
-STRUCT_COUNTERS *
-TC_READ_COUNTER(const IPT_CHAINLABEL chain,
-		unsigned int rulenum,
-		TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-	unsigned int chainindex, end;
-
-	iptc_fn = TC_READ_COUNTER;
-	CHECK(*handle);
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	if (chainindex + rulenum > end) {
-		errno = E2BIG;
-		return NULL;
-	}
-
-	e = index2entry(*handle, chainindex + rulenum);
-
-	return &e->counters;
-}
-
-int
-TC_ZERO_COUNTER(const IPT_CHAINLABEL chain,
-		unsigned int rulenum,
-		TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-	unsigned int chainindex, end;
-	
-	iptc_fn = TC_ZERO_COUNTER;
-	CHECK(*handle);
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	if (chainindex + rulenum > end) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	e = index2entry(*handle, chainindex + rulenum);
-
-	if ((*handle)->counter_map[chainindex + rulenum].maptype
-			== COUNTER_MAP_NORMAL_MAP) {
-		(*handle)->counter_map[chainindex + rulenum].maptype
-			 = COUNTER_MAP_ZEROED;
-	}
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-int 
-TC_SET_COUNTER(const IPT_CHAINLABEL chain,
-	       unsigned int rulenum,
-	       STRUCT_COUNTERS *counters,
-	       TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-	unsigned int chainindex, end;
-
-	iptc_fn = TC_SET_COUNTER;
-	CHECK(*handle);
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	if (chainindex + rulenum > end) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	e = index2entry(*handle, chainindex + rulenum);
-
-	(*handle)->counter_map[chainindex + rulenum].maptype
-		= COUNTER_MAP_SET;
-
-	memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-/* Creates a new chain. */
-/* To create a chain, create two rules: error node and unconditional
- * return. */
-int
-TC_CREATE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	int ret;
-	struct chainstart {
-		STRUCT_ENTRY head;
-		struct ipt_error_target name;
-	} *newc1;
-	struct chainend {
-		STRUCT_ENTRY ret;
-		STRUCT_STANDARD_TARGET target;
-	} *newc2;
-	struct chain_head *chead;
-
-	iptc_fn = TC_CREATE_CHAIN;
-
-	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
-           QUEUE, RETURN. */
-	if (find_label(chain, *handle)
-	    || strcmp(chain, LABEL_DROP) == 0
-	    || strcmp(chain, LABEL_ACCEPT) == 0
-	    || strcmp(chain, LABEL_QUEUE) == 0
-	    || strcmp(chain, LABEL_RETURN) == 0) {
-		errno = EEXIST;
-		return 0;
-	}
-
-	if (strlen(chain)+1 > sizeof(IPT_CHAINLABEL)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	chead = chainh_alloc(*handle, chain);
-	if (!chead) {
-		errno = ENOMEM;
-		return 0;
-	}
-	
-	newc1 = ruleh_alloc(sizeof(*newc1));
-	if (!newc1) {
-		chainh_free(chead);
-		return 0;
-	}
-
-	newc2 = ruleh_alloc(sizeof(*newc2));
-	if (!newc2) {
-		chainh_free(chead);
-		ruleh_free(newc1);
-		return 0;
-	}
-
-	newc1->head.target_offset = sizeof(STRUCT_ENTRY);
-	newc1->head.next_offset
-		= sizeof(STRUCT_ENTRY)
-		+ ALIGN(sizeof(struct ipt_error_target));
-	strcpy(newc1->name.t.u.user.name, ERROR_TARGET);
-	newc1->name.t.u.target_size = ALIGN(sizeof(struct ipt_error_target));
-	strcpy(newc1->name.error, chain);
-
-	newc2->ret.target_offset = sizeof(STRUCT_ENTRY);
-	newc2->ret.next_offset
-		= sizeof(STRUCT_ENTRY)
-		+ ALIGN(sizeof(STRUCT_STANDARD_TARGET));
-	strcpy(newc2->target.target.u.user.name, STANDARD_TARGET);
-	newc->target.target.u.target_size
-		= ALIGN(sizeof(STRUCT_STANDARD_TARGET));
-	newc->target.verdict = RETURN;
-
-	list_prepend(newc1, &chead->rules);
-	list_append(newc2, &chead->rules);
-
-	return 1;
-}
-
-static int
-count_ref(STRUCT_ENTRY *e, unsigned int offset, unsigned int *ref)
-{
-	STRUCT_STANDARD_TARGET *t;
-
-	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) == 0) {
-		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-
-		if (t->verdict == offset)
-			(*ref)++;
-	}
-
-	return 0;
-}
-
-/* Get the number of references to this chain. */
-int
-TC_GET_REFERENCES(unsigned int *ref, const IPT_CHAINLABEL chain,
-		  TC_HANDLE_T *handle)
-{
-	struct chain_cache *c;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	*ref = 0;
-	ENTRY_ITERATE((*handle)->entries.entrytable,
-		      (*handle)->entries.size,
-		      count_ref, c->start_off, ref);
-	return 1;
-}
-
-/* Deletes a chain. */
-int
-TC_DELETE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	unsigned int labelidx, labeloff;
-	unsigned int references;
-	struct chain_cache *c;
-	int ret;
-	STRUCT_ENTRY *start;
-
-	if (!TC_GET_REFERENCES(&references, chain, handle))
-		return 0;
-
-	iptc_fn = TC_DELETE_CHAIN;
-
-	if (TC_BUILTIN(chain, *handle)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	if (references > 0) {
-		errno = EMLINK;
-		return 0;
-	}
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	if (c->start_off != c->end_off) {
-		errno = ENOTEMPTY;
-		return 0;
-	}
-
-	/* Need label index: preceeds chain start */
-	labelidx = offset2index(*handle, c->start_off) - 1;
-	labeloff = index2offset(*handle, labelidx);
-
-	start = offset2entry(*handle, c->start_off);
-
-	ret = delete_rules(2,
-			   get_entry(*handle, labeloff)->next_offset
-			   + start->next_offset,
-			   labeloff, labelidx, handle);
-	return ret;
-}
-
-/* Renames a chain. */
-int TC_RENAME_CHAIN(const IPT_CHAINLABEL oldname,
-		    const IPT_CHAINLABEL newname,
-		    TC_HANDLE_T *handle)
-{
-	unsigned int labeloff, labelidx;
-	struct chain_cache *c;
-	struct ipt_error_target *t;
-
-	iptc_fn = TC_RENAME_CHAIN;
-
-	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
-           QUEUE, RETURN. */
-	if (find_label(newname, *handle)
-	    || strcmp(newname, LABEL_DROP) == 0
-	    || strcmp(newname, LABEL_ACCEPT) == 0
-	    || strcmp(newname, LABEL_QUEUE) == 0
-	    || strcmp(newname, LABEL_RETURN) == 0) {
-		errno = EEXIST;
-		return 0;
-	}
-
-	if (!(c = find_label(oldname, *handle))
-	    || TC_BUILTIN(oldname, *handle)) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	if (strlen(newname)+1 > sizeof(IPT_CHAINLABEL)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	/* Need label index: preceeds chain start */
-	labelidx = offset2index(*handle, c->start_off) - 1;
-	labeloff = index2offset(*handle, labelidx);
-
-	t = (struct ipt_error_target *)
-		GET_TARGET(get_entry(*handle, labeloff));
-
-	memset(t->error, 0, sizeof(t->error));
-	strcpy(t->error, newname);
-	set_changed(*handle);
-
-	return 1;
-}
-
-/* Sets the policy on a built-in chain. */
-int
-TC_SET_POLICY(const IPT_CHAINLABEL chain,
-	      const IPT_CHAINLABEL policy,
-	      STRUCT_COUNTERS *counters,
-	      TC_HANDLE_T *handle)
-{
-	unsigned int hook;
-	unsigned int policyoff, ctrindex;
-	STRUCT_ENTRY *e;
-	STRUCT_STANDARD_TARGET *t;
-
-	iptc_fn = TC_SET_POLICY;
-	/* Figure out which chain. */
-	hook = TC_BUILTIN(chain, *handle);
-	if (hook == 0) {
-		errno = ENOENT;
-		return 0;
-	} else
-		hook--;
-
-	policyoff = get_chain_end(*handle, (*handle)->info.hook_entry[hook]);
-	if (policyoff != (*handle)->info.underflow[hook]) {
-		printf("ERROR: Policy for `%s' offset %u != underflow %u\n",
-		       chain, policyoff, (*handle)->info.underflow[hook]);
-		return 0;
-	}
-
-	e = get_entry(*handle, policyoff);
-	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-
-	if (strcmp(policy, LABEL_ACCEPT) == 0)
-		t->verdict = -NF_ACCEPT - 1;
-	else if (strcmp(policy, LABEL_DROP) == 0)
-		t->verdict = -NF_DROP - 1;
-	else {
-		errno = EINVAL;
-		return 0;
-	}
-
-	ctrindex = entry2index(*handle, e);
-
-	if (counters) {
-		/* set byte and packet counters */
-		memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
-
-		(*handle)->counter_map[ctrindex].maptype
-			= COUNTER_MAP_SET;
-
-	} else {
-		(*handle)->counter_map[ctrindex]
-			= ((struct counter_map){ COUNTER_MAP_NOMAP, 0 });
-	}
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-/* Without this, on gcc 2.7.2.3, we get:
-   libiptc.c: In function `TC_COMMIT':
-   libiptc.c:833: fixed or forbidden register was spilled.
-   This may be due to a compiler bug or to impossible asm
-   statements or clauses.
-*/
-static void
-subtract_counters(STRUCT_COUNTERS *answer,
-		  const STRUCT_COUNTERS *a,
-		  const STRUCT_COUNTERS *b)
-{
-	answer->pcnt = a->pcnt - b->pcnt;
-	answer->bcnt = a->bcnt - b->bcnt;
-}
-
-int
-TC_COMMIT(TC_HANDLE_T *handle)
-{
-	/* Replace, then map back the counters. */
-	STRUCT_REPLACE *repl;
-	STRUCT_COUNTERS_INFO *newcounters;
-	unsigned int i;
-	size_t counterlen;
-
-	CHECK(*handle);
-
-	counterlen = sizeof(STRUCT_COUNTERS_INFO)
-			+ sizeof(STRUCT_COUNTERS) * (*handle)->new_number;
-
-#if 0
-	TC_DUMP_ENTRIES(*handle);
-#endif
-
-	/* Don't commit if nothing changed. */
-	if (!(*handle)->changed)
-		goto finished;
-
-	repl = malloc(sizeof(*repl) + (*handle)->entries.size);
-	if (!repl) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	/* These are the old counters we will get from kernel */
-	repl->counters = malloc(sizeof(STRUCT_COUNTERS)
-				* (*handle)->info.num_entries);
-	if (!repl->counters) {
-		free(repl);
-		errno = ENOMEM;
-		return 0;
-	}
-
-	/* These are the counters we're going to put back, later. */
-	newcounters = malloc(counterlen);
-	if (!newcounters) {
-		free(repl->counters);
-		free(repl);
-		errno = ENOMEM;
-		return 0;
-	}
-
-	strcpy(repl->name, (*handle)->info.name);
-	repl->num_entries = (*handle)->new_number;
-	repl->size = (*handle)->entries.size;
-	memcpy(repl->hook_entry, (*handle)->info.hook_entry,
-	       sizeof(repl->hook_entry));
-	memcpy(repl->underflow, (*handle)->info.underflow,
-	       sizeof(repl->underflow));
-	repl->num_counters = (*handle)->info.num_entries;
-	repl->valid_hooks = (*handle)->info.valid_hooks;
-	memcpy(repl->entries, (*handle)->entries.entrytable,
-	       (*handle)->entries.size);
-
-	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_REPLACE, repl,
-		       sizeof(*repl) + (*handle)->entries.size) < 0) {
-		free(repl->counters);
-		free(repl);
-		free(newcounters);
-		return 0;
-	}
-
-	/* Put counters back. */
-	strcpy(newcounters->name, (*handle)->info.name);
-	newcounters->num_counters = (*handle)->new_number;
-	for (i = 0; i < (*handle)->new_number; i++) {
-		unsigned int mappos = (*handle)->counter_map[i].mappos;
-		switch ((*handle)->counter_map[i].maptype) {
-		case COUNTER_MAP_NOMAP:
-			newcounters->counters[i]
-				= ((STRUCT_COUNTERS){ 0, 0 });
-			break;
-
-		case COUNTER_MAP_NORMAL_MAP:
-			/* Original read: X.
-			 * Atomic read on replacement: X + Y.
-			 * Currently in kernel: Z.
-			 * Want in kernel: X + Y + Z.
-			 * => Add in X + Y
-			 * => Add in replacement read.
-			 */
-			newcounters->counters[i] = repl->counters[mappos];
-			break;
-
-		case COUNTER_MAP_ZEROED:
-			/* Original read: X.
-			 * Atomic read on replacement: X + Y.
-			 * Currently in kernel: Z.
-			 * Want in kernel: Y + Z.
-			 * => Add in Y.
-			 * => Add in (replacement read - original read).
-			 */
-			subtract_counters(&newcounters->counters[i],
-					  &repl->counters[mappos],
-					  &index2entry(*handle, i)->counters);
-			break;
-
-		case COUNTER_MAP_SET:
-			/* Want to set counter (iptables-restore) */
-
-			memcpy(&newcounters->counters[i],
-			       &index2entry(*handle, i)->counters,
-			       sizeof(STRUCT_COUNTERS));
-
-			break;
-		}
-	}
-
-#ifdef KERNEL_64_USERSPACE_32
-	{
-		/* Kernel will think that pointer should be 64-bits, and get
-		   padding.  So we accomodate here (assumption: alignment of
-		   `counters' is on 64-bit boundary). */
-		u_int64_t *kernptr = (u_int64_t *)&newcounters->counters;
-		if ((unsigned long)&newcounters->counters % 8 != 0) {
-			fprintf(stderr,
-				"counters alignment incorrect! Mail rusty!\n");
-			abort();
-		}
-		*kernptr = newcounters->counters;
-	}
-#endif /* KERNEL_64_USERSPACE_32 */
-
-	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_ADD_COUNTERS,
-		       newcounters, counterlen) < 0) {
-		free(repl->counters);
-		free(repl);
-		free(newcounters);
-		return 0;
-	}
-
-	free(repl->counters);
-	free(repl);
-	free(newcounters);
-
- finished:
-	TC_FREE(handle);
-	return 1;
-}
-
-/* Get raw socket. */
-int
-TC_GET_RAW_SOCKET()
-{
-	return sockfd;
-}
-
-/* Translates errno numbers into more human-readable form than strerror. */
-const char *
-TC_STRERROR(int err)
-{
-	unsigned int i;
-	struct table_struct {
-		void *fn;
-		int err;
-		const char *message;
-	} table [] =
-	  { { TC_INIT, EPERM, "Permission denied (you must be root)" },
-	    { TC_INIT, EINVAL, "Module is wrong version" },
-	    { TC_INIT, ENOENT, 
-		    "Table does not exist (do you need to insmod?)" },
-	    { TC_DELETE_CHAIN, ENOTEMPTY, "Chain is not empty" },
-	    { TC_DELETE_CHAIN, EINVAL, "Can't delete built-in chain" },
-	    { TC_DELETE_CHAIN, EMLINK,
-	      "Can't delete chain with references left" },
-	    { TC_CREATE_CHAIN, EEXIST, "Chain already exists" },
-	    { TC_INSERT_ENTRY, E2BIG, "Index of insertion too big" },
-	    { TC_REPLACE_ENTRY, E2BIG, "Index of replacement too big" },
-	    { TC_DELETE_NUM_ENTRY, E2BIG, "Index of deletion too big" },
-	    { TC_READ_COUNTER, E2BIG, "Index of counter too big" },
-	    { TC_ZERO_COUNTER, E2BIG, "Index of counter too big" },
-	    { TC_INSERT_ENTRY, ELOOP, "Loop found in table" },
-	    { TC_INSERT_ENTRY, EINVAL, "Target problem" },
-	    /* EINVAL for CHECK probably means bad interface. */
-	    { TC_CHECK_PACKET, EINVAL,
-	      "Bad arguments (does that interface exist?)" },
-	    { TC_CHECK_PACKET, ENOSYS,
-	      "Checking will most likely never get implemented" },
-	    /* ENOENT for DELETE probably means no matching rule */
-	    { TC_DELETE_ENTRY, ENOENT,
-	      "Bad rule (does a matching rule exist in that chain?)" },
-	    { TC_SET_POLICY, ENOENT,
-	      "Bad built-in chain name" },
-	    { TC_SET_POLICY, EINVAL,
-	      "Bad policy name" },
-
-	    { NULL, 0, "Incompatible with this kernel" },
-	    { NULL, ENOPROTOOPT, "iptables who? (do you need to insmod?)" },
-	    { NULL, ENOSYS, "Will be implemented real soon.  I promise ;)" },
-	    { NULL, ENOMEM, "Memory allocation problem" },
-	    { NULL, ENOENT, "No chain/target/match by that name" },
-	  };
-
-	for (i = 0; i < sizeof(table)/sizeof(struct table_struct); i++) {
-		if ((!table[i].fn || table[i].fn == iptc_fn)
-		    && table[i].err == err)
-			return table[i].message;
-	}
-
-	return strerror(err);
-}
diff -urN iptables-1.2.9/libiptc2/foo.diff iptables-1.2.10/libiptc2/foo.diff
--- iptables-1.2.9/libiptc2/foo.diff	2003-06-30 19:13:13.000000000 +0200
+++ iptables-1.2.10/libiptc2/foo.diff	1970-01-01 01:00:00.000000000 +0100
@@ -1,391 +0,0 @@
---- libiptc.c	2003-06-30 18:26:59.000000000 +0200
-+++ libiptc.c	2003-06-30 18:27:24.000000000 +0200
-@@ -64,19 +61,35 @@
- 	char error[TABLE_MAXNAMELEN];
- };
- 
--struct chain_cache
-+struct rule_head
- {
-+	struct list_head list;
-+	
-+	struct chain_head *chain;
-+
-+	unsigned int size;
-+	STRUCT_ENTRY entry[0];
-+}
-+
-+struct chain_head
-+{
-+	struct list_head list;
-+
- 	char name[TABLE_MAXNAMELEN];
--	/* This is the first rule in chain. */
--	unsigned int start_off;
--	/* Last rule in chain */
--	unsigned int end_off;
-+	unsigned int hooknum;
-+	struct list_head rules;
- };
- 
- STRUCT_TC_HANDLE
- {
- 	/* Have changes been made? */
- 	int changed;
-+
-+	struct list_head chains;
-+	
-+	struct chain_head *chain_iterator_cur;
-+
-+#if 0
- 	/* Size in here reflects original state. */
- 	STRUCT_GETINFO info;
- 
-@@ -98,6 +111,7 @@
- 	/* Number in here reflects current state. */
- 	unsigned int new_number;
- 	STRUCT_GET_ENTRIES entries;
-+#endif
- };
- 
- static void
-@@ -375,173 +389,25 @@
- 	}
- 	return 0;
- }
--
--static inline int
--add_chain(STRUCT_ENTRY *e, TC_HANDLE_T h, STRUCT_ENTRY **prev)
--{
--	unsigned int builtin;
--
--	/* Last entry.  End it. */
--	if (entry2offset(h, e) + e->next_offset == h->entries.size) {
--		/* This is the ERROR node at end of the table */
--		h->cache_chain_heads[h->cache_num_chains-1].end_off = 
--			entry2offset(h, *prev);
--		return 0;
--	}
--
--	/* We know this is the start of a new chain if it's an ERROR
--	   target, or a hook entry point */
--	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) == 0) {
--		/* prev was last entry in previous chain */
--		h->cache_chain_heads[h->cache_num_chains-1].end_off
--			= entry2offset(h, *prev);
--
--		strcpy(h->cache_chain_heads[h->cache_num_chains].name,
--		       (const char *)GET_TARGET(e)->data);
--		h->cache_chain_heads[h->cache_num_chains].start_off
--			= entry2offset(h, (void *)e + e->next_offset);
--		h->cache_num_chains++;
--	} else if ((builtin = is_hook_entry(e, h)) != 0) {
--		if (h->cache_num_chains > 0)
--			/* prev was last entry in previous chain */
--			h->cache_chain_heads[h->cache_num_chains-1].end_off
--				= entry2offset(h, *prev);
--
--		strcpy(h->cache_chain_heads[h->cache_num_chains].name,
--		       h->hooknames[builtin-1]);
--		h->cache_chain_heads[h->cache_num_chains].start_off
--			= entry2offset(h, (void *)e);
--		h->cache_num_chains++;
--	}
--
--	*prev = e;
--	return 0;
--}
--
- static int alphasort(const void *a, const void *b)
- {
- 	return strcmp(((struct chain_cache *)a)->name,
- 		      ((struct chain_cache *)b)->name);
- }
- 
--static int populate_cache(TC_HANDLE_T h)
--{
--	unsigned int i;
--	STRUCT_ENTRY *prev;
--
--	/* # chains < # rules / 2 + num builtins - 1 */
--	h->cache_chain_heads = malloc((h->new_number / 2 + 4)
--				      * sizeof(struct chain_cache));
--	if (!h->cache_chain_heads) {
--		errno = ENOMEM;
--		return 0;
--	}
--
--	h->cache_num_chains = 0;
--	h->cache_num_builtins = 0;
--
--	/* Count builtins */
--	for (i = 0; i < NUMHOOKS; i++) {
--		if (h->info.valid_hooks & (1 << i))
--			h->cache_num_builtins++;
--	}
--
--	prev = NULL;
--	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
--		      add_chain, h, &prev);
--
--	qsort(h->cache_chain_heads + h->cache_num_builtins,
--	      h->cache_num_chains - h->cache_num_builtins,
--	      sizeof(struct chain_cache), alphasort);
--
--	return 1;
--}
--
--static int 
--correct_cache(TC_HANDLE_T h, unsigned int offset, int delta)
--{
--	int i;		/* needs to be signed because deleting first
--			   chain can make it drop to -1 */
--
--	if (!delta)
--		return 1;
--
--	for (i = 0; i < h->cache_num_chains; i++) {
--		struct chain_cache *cc = &h->cache_chain_heads[i];
--
--		if (delta < 0) {
--			/* take care about deleted chains */
--			if (cc->start_off >= offset+delta
--			    && cc->end_off <= offset) {
--				/* this chain is within the deleted range,
--				 * let's remove it from the cache */
--				void *start;
--				unsigned int size;
--
--				h->cache_num_chains--;
--				if (i+1 >= h->cache_num_chains)
--					continue;
--				start = &h->cache_chain_heads[i+1];
--				size = (h->cache_num_chains-i)
--					* sizeof(struct chain_cache);
--				memmove(cc, start, size);
--
--				/* iterate over same index again, since
--				 * it is now a different chain */
--				i--;
--				continue;
--			}
--		}
--
--		if (cc->start_off > offset)
--			cc->start_off += delta;
--
--		if (cc->end_off >= offset)
--			cc->end_off += delta;
--	}
--	/* HW_FIXME: sorting might be needed, but just in case a new chain was
--	 * added */
--
--	return 1;
--}
--
--static int
--add_chain_cache(TC_HANDLE_T h, const char *name, unsigned int start_off,
--		unsigned int end_off)
--{
--	struct chain_cache *ccs = realloc(h->cache_chain_heads, 
--					  (h->new_number / 2 + 4 + 1)
--					   * sizeof(struct chain_cache));
--	struct chain_cache *newcc;
--	
--	if (!ccs)
--		return 0;
--
--	h->cache_chain_heads = ccs;
--	newcc = &h->cache_chain_heads[h->cache_num_chains];
--	h->cache_num_chains++;
--
--	strncpy(newcc->name, name, TABLE_MAXNAMELEN-1);
--	newcc->start_off = start_off;
--	newcc->end_off = end_off;
--
--	return 1;
--}
--
--/* Returns cache ptr if found, otherwise NULL. */
--static struct chain_cache *
-+/* Returns chain head if found, otherwise NULL. */
-+static struct chain_head *
- find_label(const char *name, TC_HANDLE_T handle)
- {
--	unsigned int i;
-+	struct list_head *pos;
- 
--	if (handle->cache_chain_heads == NULL
--	    && !populate_cache(handle))
-+	if (!handle->chains)
- 		return NULL;
- 
--	/* FIXME: Linear search through builtins, then binary --RR */
--	for (i = 0; i < handle->cache_num_chains; i++) {
--		if (strcmp(handle->cache_chain_heads[i].name, name) == 0)
--			return &handle->cache_chain_heads[i];
-+	list_for_each(pos, &handle->chains) {
-+		struct chain_head *c = list_entry(pos, struct chain_head, list);
-+		if (!strcmp(c->name, name))
-+			return c;
- 	}
- 
- 	return NULL;
-@@ -594,34 +460,30 @@
- const char *
- TC_FIRST_CHAIN(TC_HANDLE_T *handle)
- {
--	if ((*handle)->cache_chain_heads == NULL
--	    && !populate_cache(*handle))
--		return NULL;
-+	(*handle)->chain_iterator_cur = (*handle)->chains;
- 
--	(*handle)->cache_chain_iteration
--		= &(*handle)->cache_chain_heads[0];
--
--	return (*handle)->cache_chain_iteration->name;
-+	return (*handle)->chains.name;
- }
- 
- /* Iterator functions to run through the chains.  Returns NULL at end. */
- const char *
- TC_NEXT_CHAIN(TC_HANDLE_T *handle)
- {
--	(*handle)->cache_chain_iteration++;
-+	struct chain_head *next = list_entry(&(*handle)->chain_iterator_cur->list.next, struct chain_head, list);
-+	(*handle)->chain_iterator_cur = next;
- 
--	if ((*handle)->cache_chain_iteration - (*handle)->cache_chain_heads
--	    == (*handle)->cache_num_chains)
-+	if (next == (*handle)->chains)
- 		return NULL;
- 
--	return (*handle)->cache_chain_iteration->name;
-+	return next->name;
- }
- 
- /* Get first rule in the given chain: NULL for empty chain. */
- const STRUCT_ENTRY *
- TC_FIRST_RULE(const char *chain, TC_HANDLE_T *handle)
- {
--	struct chain_cache *c;
-+	struct chain_head *c;
-+	struct rule_head *r;
- 
- 	c = find_label(chain, *handle);
- 	if (!c) {
-@@ -630,22 +492,26 @@
- 	}
- 
- 	/* Empty chain: single return/policy rule */
--	if (c->start_off == c->end_off)
-+	if (list_empty(c->rules))
- 		return NULL;
- 
--	(*handle)->cache_rule_end = offset2entry(*handle, c->end_off);
--	return offset2entry(*handle, c->start_off);
-+	r = list_entry(&c->rules.next, struct rule_head, list);
-+	(*handle)->rule_iterator_cur = r;
-+
-+	return r->entry;
- }
- 
- /* Returns NULL when rules run out. */
- const STRUCT_ENTRY *
- TC_NEXT_RULE(const STRUCT_ENTRY *prev, TC_HANDLE_T *handle)
- {
--	if ((void *)prev + prev->next_offset
--	    == (void *)(*handle)->cache_rule_end)
-+	struct rule_head *r = list_entry((*handle)->rule_iterator_cur->list.next, struct rule_head, list);
-+
-+	if (r == r->chain)
- 		return NULL;
- 
--	return (void *)prev + prev->next_offset;
-+	/* NOTE: prev is without any influence ! */
-+	return r->entry;
- }
- 
- #if 0
-@@ -773,7 +639,7 @@
- 	return target_name(*handle, e);
- }
- 
--static inline int
-+static int
- correct_verdict(STRUCT_ENTRY *e,
- 		char *base,
- 		unsigned int offset, int delta_offset)
-@@ -874,16 +740,8 @@
- 	newh->entries.size = (*handle)->entries.size + rules_size;
- 	newh->hooknames = (*handle)->hooknames;
- 
--	newh->cache_chain_heads = (*handle)->cache_chain_heads;
--	newh->cache_num_builtins = (*handle)->cache_num_builtins;
--	newh->cache_num_chains = (*handle)->cache_num_chains;
--	newh->cache_rule_end = (*handle)->cache_rule_end;
--	newh->cache_chain_iteration = (*handle)->cache_chain_iteration;
--	if (!correct_cache(newh, offset, rules_size)) {
--		free(newh);
--		return 0;
--	}
--
-+	if ((*handle)->cache_chain_heads)
-+		free((*handle)->cache_chain_heads);
- 	free(*handle);
- 	*handle = newh;
- 
-@@ -942,10 +800,6 @@
- 	(*handle)->new_number -= num_rules;
- 	(*handle)->entries.size -= rules_size;
- 
--	/* Fix the chain cache */
--	if (!correct_cache(*handle, offset, -(int)rules_size))
--		return 0;
--
- 	return set_verdict(offset, -(int)rules_size, handle);
- }
- 
-@@ -1449,7 +1303,6 @@
- 		STRUCT_ENTRY ret;
- 		STRUCT_STANDARD_TARGET target;
- 	} newc;
--	unsigned int destination;
- 
- 	iptc_fn = TC_CREATE_CHAIN;
- 
-@@ -1487,21 +1340,11 @@
- 		= ALIGN(sizeof(STRUCT_STANDARD_TARGET));
- 	newc.target.verdict = RETURN;
- 
--	destination = index2offset(*handle, (*handle)->new_number -1);
--
- 	/* Add just before terminal entry */
- 	ret = insert_rules(2, sizeof(newc), &newc.head,
--			   destination,
-+			   index2offset(*handle, (*handle)->new_number - 1),
- 			   (*handle)->new_number - 1,
- 			   0, handle);
--
--	set_changed(*handle);
--
--	/* add chain cache info for this chain */
--	add_chain_cache(*handle, chain, 
--			destination+newc.head.next_offset, 
--			destination+newc.head.next_offset);
--
- 	return ret;
- }
- 
-@@ -1629,11 +1472,6 @@
- 
- 	memset(t->error, 0, sizeof(t->error));
- 	strcpy(t->error, newname);
--
--	/* update chain cache */
--	memset(c->name, 0, sizeof(c->name));
--	strcpy(c->name, newname);
--
- 	set_changed(*handle);
- 
- 	return 1;
diff -urN iptables-1.2.9/libiptc2/libip4tc.c iptables-1.2.10/libiptc2/libip4tc.c
--- iptables-1.2.9/libiptc2/libip4tc.c	2003-05-03 20:52:15.000000000 +0200
+++ iptables-1.2.10/libiptc2/libip4tc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,507 +0,0 @@
-/* Library which manipulates firewall rules.  Version 0.1. */
-
-/* Architecture of firewall rules is as follows:
- *
- * Chains go INPUT, FORWARD, OUTPUT then user chains.
- * Each user chain starts with an ERROR node.
- * Every chain ends with an unconditional jump: a RETURN for user chains,
- * and a POLICY for built-ins.
- */
-
-/* (C)1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
-   COPYING for details). */
-
-#include <assert.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-
-#ifdef DEBUG_CONNTRACK
-#define inline
-#endif
-
-#if !defined(__GLIBC__) || (__GLIBC__ < 2)
-typedef unsigned int socklen_t;
-#endif
-
-#include "libiptc/libiptc.h"
-
-#define IP_VERSION	4
-#define IP_OFFSET	0x1FFF
-
-#define HOOK_PRE_ROUTING	NF_IP_PRE_ROUTING
-#define HOOK_LOCAL_IN		NF_IP_LOCAL_IN
-#define HOOK_FORWARD		NF_IP_FORWARD
-#define HOOK_LOCAL_OUT		NF_IP_LOCAL_OUT
-#define HOOK_POST_ROUTING	NF_IP_POST_ROUTING
-#ifdef NF_IP_DROPPING
-#define HOOK_DROPPING		NF_IP_DROPPING
-#endif
-
-#define STRUCT_ENTRY_TARGET	struct ipt_entry_target
-#define STRUCT_ENTRY		struct ipt_entry
-#define STRUCT_ENTRY_MATCH	struct ipt_entry_match
-#define STRUCT_GETINFO		struct ipt_getinfo
-#define STRUCT_GET_ENTRIES	struct ipt_get_entries
-#define STRUCT_COUNTERS		struct ipt_counters
-#define STRUCT_COUNTERS_INFO	struct ipt_counters_info
-#define STRUCT_STANDARD_TARGET	struct ipt_standard_target
-#define STRUCT_REPLACE		struct ipt_replace
-
-#define STRUCT_TC_HANDLE	struct iptc_handle
-#define TC_HANDLE_T		iptc_handle_t
-
-#define ENTRY_ITERATE		IPT_ENTRY_ITERATE
-#define TABLE_MAXNAMELEN	IPT_TABLE_MAXNAMELEN
-#define FUNCTION_MAXNAMELEN	IPT_FUNCTION_MAXNAMELEN
-
-#define GET_TARGET		ipt_get_target
-
-#define ERROR_TARGET		IPT_ERROR_TARGET
-#define NUMHOOKS		NF_IP_NUMHOOKS
-
-#define IPT_CHAINLABEL		ipt_chainlabel
-
-#define TC_DUMP_ENTRIES		dump_entries
-#define TC_IS_CHAIN		iptc_is_chain
-#define TC_FIRST_CHAIN		iptc_first_chain
-#define TC_NEXT_CHAIN		iptc_next_chain
-#define TC_FIRST_RULE		iptc_first_rule
-#define TC_NEXT_RULE		iptc_next_rule
-#define TC_GET_TARGET		iptc_get_target
-#define TC_BUILTIN		iptc_builtin
-#define TC_GET_POLICY		iptc_get_policy
-#define TC_INSERT_ENTRY		iptc_insert_entry
-#define TC_REPLACE_ENTRY	iptc_replace_entry
-#define TC_APPEND_ENTRY		iptc_append_entry
-#define TC_DELETE_ENTRY		iptc_delete_entry
-#define TC_DELETE_NUM_ENTRY	iptc_delete_num_entry
-#define TC_CHECK_PACKET		iptc_check_packet
-#define TC_FLUSH_ENTRIES	iptc_flush_entries
-#define TC_ZERO_ENTRIES		iptc_zero_entries
-#define TC_READ_COUNTER		iptc_read_counter
-#define TC_ZERO_COUNTER		iptc_zero_counter
-#define TC_SET_COUNTER		iptc_set_counter
-#define TC_CREATE_CHAIN		iptc_create_chain
-#define TC_GET_REFERENCES	iptc_get_references
-#define TC_DELETE_CHAIN		iptc_delete_chain
-#define TC_RENAME_CHAIN		iptc_rename_chain
-#define TC_SET_POLICY		iptc_set_policy
-#define TC_GET_RAW_SOCKET	iptc_get_raw_socket
-#define TC_INIT			iptc_init
-#define TC_FREE			iptc_free
-#define TC_COMMIT		iptc_commit
-#define TC_STRERROR		iptc_strerror
-
-#define TC_AF			AF_INET
-#define TC_IPPROTO		IPPROTO_IP
-
-#define SO_SET_REPLACE		IPT_SO_SET_REPLACE
-#define SO_SET_ADD_COUNTERS	IPT_SO_SET_ADD_COUNTERS
-#define SO_GET_INFO		IPT_SO_GET_INFO
-#define SO_GET_ENTRIES		IPT_SO_GET_ENTRIES
-#define SO_GET_VERSION		IPT_SO_GET_VERSION
-
-#define STANDARD_TARGET		IPT_STANDARD_TARGET
-#define LABEL_RETURN		IPTC_LABEL_RETURN
-#define LABEL_ACCEPT		IPTC_LABEL_ACCEPT
-#define LABEL_DROP		IPTC_LABEL_DROP
-#define LABEL_QUEUE		IPTC_LABEL_QUEUE
-
-#define ALIGN			IPT_ALIGN
-#define RETURN			IPT_RETURN
-
-#include "libiptc.c"
-
-#define IP_PARTS_NATIVE(n)			\
-(unsigned int)((n)>>24)&0xFF,			\
-(unsigned int)((n)>>16)&0xFF,			\
-(unsigned int)((n)>>8)&0xFF,			\
-(unsigned int)((n)&0xFF)
-
-#define IP_PARTS(n) IP_PARTS_NATIVE(ntohl(n))
-
-int
-dump_entry(STRUCT_ENTRY *e, const TC_HANDLE_T handle)
-{
-	size_t i;
-	STRUCT_ENTRY_TARGET *t;
-
-	printf("Entry %u (%lu):\n", entry2index(handle, e),
-	       entry2offset(handle, e));
-	printf("SRC IP: %u.%u.%u.%u/%u.%u.%u.%u\n",
-	       IP_PARTS(e->ip.src.s_addr),IP_PARTS(e->ip.smsk.s_addr));
-	printf("DST IP: %u.%u.%u.%u/%u.%u.%u.%u\n",
-	       IP_PARTS(e->ip.dst.s_addr),IP_PARTS(e->ip.dmsk.s_addr));
-	printf("Interface: `%s'/", e->ip.iniface);
-	for (i = 0; i < IFNAMSIZ; i++)
-		printf("%c", e->ip.iniface_mask[i] ? 'X' : '.');
-	printf("to `%s'/", e->ip.outiface);
-	for (i = 0; i < IFNAMSIZ; i++)
-		printf("%c", e->ip.outiface_mask[i] ? 'X' : '.');
-	printf("\nProtocol: %u\n", e->ip.proto);
-	printf("Flags: %02X\n", e->ip.flags);
-	printf("Invflags: %02X\n", e->ip.invflags);
-	printf("Counters: %llu packets, %llu bytes\n",
-	       e->counters.pcnt, e->counters.bcnt);
-	printf("Cache: %08X ", e->nfcache);
-	if (e->nfcache & NFC_ALTERED) printf("ALTERED ");
-	if (e->nfcache & NFC_UNKNOWN) printf("UNKNOWN ");
-	if (e->nfcache & NFC_IP_SRC) printf("IP_SRC ");
-	if (e->nfcache & NFC_IP_DST) printf("IP_DST ");
-	if (e->nfcache & NFC_IP_IF_IN) printf("IP_IF_IN ");
-	if (e->nfcache & NFC_IP_IF_OUT) printf("IP_IF_OUT ");
-	if (e->nfcache & NFC_IP_TOS) printf("IP_TOS ");
-	if (e->nfcache & NFC_IP_PROTO) printf("IP_PROTO ");
-	if (e->nfcache & NFC_IP_OPTIONS) printf("IP_OPTIONS ");
-	if (e->nfcache & NFC_IP_TCPFLAGS) printf("IP_TCPFLAGS ");
-	if (e->nfcache & NFC_IP_SRC_PT) printf("IP_SRC_PT ");
-	if (e->nfcache & NFC_IP_DST_PT) printf("IP_DST_PT ");
-	if (e->nfcache & NFC_IP_PROTO_UNKNOWN) printf("IP_PROTO_UNKNOWN ");
-	printf("\n");
-
-	IPT_MATCH_ITERATE(e, print_match);
-
-	t = GET_TARGET(e);
-	printf("Target name: `%s' [%u]\n", t->u.user.name, t->u.target_size);
-	if (strcmp(t->u.user.name, STANDARD_TARGET) == 0) {
-		int pos = *(int *)t->data;
-		if (pos < 0)
-			printf("verdict=%s\n",
-			       pos == -NF_ACCEPT-1 ? "NF_ACCEPT"
-			       : pos == -NF_DROP-1 ? "NF_DROP"
-			       : pos == -NF_QUEUE-1 ? "NF_QUEUE"
-			       : pos == RETURN ? "RETURN"
-			       : "UNKNOWN");
-		else
-			printf("verdict=%u\n", pos);
-	} else if (strcmp(t->u.user.name, IPT_ERROR_TARGET) == 0)
-		printf("error=`%s'\n", t->data);
-
-	printf("\n");
-	return 0;
-}
-
-static int
-is_same(const STRUCT_ENTRY *a, const STRUCT_ENTRY *b, unsigned char *matchmask)
-{
-	unsigned int i;
-	STRUCT_ENTRY_TARGET *ta, *tb;
-	unsigned char *mptr;
-
-	/* Always compare head structures: ignore mask here. */
-	if (a->ip.src.s_addr != b->ip.src.s_addr
-	    || a->ip.dst.s_addr != b->ip.dst.s_addr
-	    || a->ip.smsk.s_addr != b->ip.smsk.s_addr
-	    || a->ip.dmsk.s_addr != b->ip.dmsk.s_addr
-	    || a->ip.proto != b->ip.proto
-	    || a->ip.flags != b->ip.flags
-	    || a->ip.invflags != b->ip.invflags)
-		return 0;
-
-	for (i = 0; i < IFNAMSIZ; i++) {
-		if (a->ip.iniface_mask[i] != b->ip.iniface_mask[i])
-			return 0;
-		if ((a->ip.iniface[i] & a->ip.iniface_mask[i])
-		    != (b->ip.iniface[i] & b->ip.iniface_mask[i]))
-			return 0;
-		if (a->ip.outiface_mask[i] != b->ip.outiface_mask[i])
-			return 0;
-		if ((a->ip.outiface[i] & a->ip.outiface_mask[i])
-		    != (b->ip.outiface[i] & b->ip.outiface_mask[i]))
-			return 0;
-	}
-
-	if (a->nfcache != b->nfcache
-	    || a->target_offset != b->target_offset
-	    || a->next_offset != b->next_offset)
-		return 0;
-
-	mptr = matchmask + sizeof(STRUCT_ENTRY);
-	if (IPT_MATCH_ITERATE(a, match_different, a->elems, b->elems, &mptr))
-		return 0;
-
-	ta = GET_TARGET((STRUCT_ENTRY *)a);
-	tb = GET_TARGET((STRUCT_ENTRY *)b);
-	if (ta->u.target_size != tb->u.target_size)
-		return 0;
-	if (strcmp(ta->u.user.name, tb->u.user.name) != 0)
-		return 0;
-
-	mptr += sizeof(*ta);
-	if (target_different(ta->data, tb->data,
-			     ta->u.target_size - sizeof(*ta), mptr))
-		return 0;
-
-   	return 1;
-}
-
-/***************************** DEBUGGING ********************************/
-static inline int
-unconditional(const struct ipt_ip *ip)
-{
-	unsigned int i;
-
-	for (i = 0; i < sizeof(*ip)/sizeof(u_int32_t); i++)
-		if (((u_int32_t *)ip)[i])
-			return 0;
-
-	return 1;
-}
-
-static inline int
-check_match(const STRUCT_ENTRY_MATCH *m, unsigned int *off)
-{
-	assert(m->u.match_size >= sizeof(STRUCT_ENTRY_MATCH));
-	assert(ALIGN(m->u.match_size) == m->u.match_size);
-
-	(*off) += m->u.match_size;
-	return 0;
-}
-
-static inline int
-check_entry(const STRUCT_ENTRY *e, unsigned int *i, unsigned int *off,
-	    unsigned int user_offset, int *was_return,
-	    TC_HANDLE_T h)
-{
-	unsigned int toff;
-	STRUCT_STANDARD_TARGET *t;
-
-	assert(e->target_offset >= sizeof(STRUCT_ENTRY));
-	assert(e->next_offset >= e->target_offset
-	       + sizeof(STRUCT_ENTRY_TARGET));
-	toff = sizeof(STRUCT_ENTRY);
-	IPT_MATCH_ITERATE(e, check_match, &toff);
-
-	assert(toff == e->target_offset);
-
-	t = (STRUCT_STANDARD_TARGET *)
-		GET_TARGET((STRUCT_ENTRY *)e);
-	/* next_offset will have to be multiple of entry alignment. */
-	assert(e->next_offset == ALIGN(e->next_offset));
-	assert(e->target_offset == ALIGN(e->target_offset));
-	assert(t->target.u.target_size == ALIGN(t->target.u.target_size));
-	assert(!TC_IS_CHAIN(t->target.u.user.name, h));
-
-	if (strcmp(t->target.u.user.name, STANDARD_TARGET) == 0) {
-		assert(t->target.u.target_size
-		       == ALIGN(sizeof(STRUCT_STANDARD_TARGET)));
-
-		assert(t->verdict == -NF_DROP-1
-		       || t->verdict == -NF_ACCEPT-1
-		       || t->verdict == RETURN
-		       || t->verdict < (int)h->entries.size);
-
-		if (t->verdict >= 0) {
-			STRUCT_ENTRY *te = get_entry(h, t->verdict);
-			int idx;
-
-			idx = entry2index(h, te);
-			assert(strcmp(GET_TARGET(te)->u.user.name,
-				      IPT_ERROR_TARGET)
-			       != 0);
-			assert(te != e);
-
-			/* Prior node must be error node, or this node. */
-			assert(t->verdict == entry2offset(h, e)+e->next_offset
-			       || strcmp(GET_TARGET(index2entry(h, idx-1))
-					 ->u.user.name, IPT_ERROR_TARGET)
-			       == 0);
-		}
-
-		if (t->verdict == RETURN
-		    && unconditional(&e->ip)
-		    && e->target_offset == sizeof(*e))
-			*was_return = 1;
-		else
-			*was_return = 0;
-	} else if (strcmp(t->target.u.user.name, IPT_ERROR_TARGET) == 0) {
-		assert(t->target.u.target_size
-		       == ALIGN(sizeof(struct ipt_error_target)));
-
-		/* If this is in user area, previous must have been return */
-		if (*off > user_offset)
-			assert(*was_return);
-
-		*was_return = 0;
-	}
-	else *was_return = 0;
-
-	if (*off == user_offset)
-		assert(strcmp(t->target.u.user.name, IPT_ERROR_TARGET) == 0);
-
-	(*off) += e->next_offset;
-	(*i)++;
-	return 0;
-}
-
-#ifdef IPTC_DEBUG
-/* Do every conceivable sanity check on the handle */
-static void
-do_check(TC_HANDLE_T h, unsigned int line)
-{
-	unsigned int i, n;
-	unsigned int user_offset; /* Offset of first user chain */
-	int was_return;
-
-	assert(h->changed == 0 || h->changed == 1);
-	if (strcmp(h->info.name, "filter") == 0) {
-		assert(h->info.valid_hooks
-		       == (1 << NF_IP_LOCAL_IN
-			   | 1 << NF_IP_FORWARD
-			   | 1 << NF_IP_LOCAL_OUT));
-
-		/* Hooks should be first three */
-		assert(h->info.hook_entry[NF_IP_LOCAL_IN] == 0);
-
-		n = get_chain_end(h, 0);
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP_FORWARD] == n);
-
-		n = get_chain_end(h, n);
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP_LOCAL_OUT] == n);
-
-		user_offset = h->info.hook_entry[NF_IP_LOCAL_OUT];
-	} else if (strcmp(h->info.name, "nat") == 0) {
-		assert((h->info.valid_hooks
-		        == (1 << NF_IP_PRE_ROUTING
-			    | 1 << NF_IP_POST_ROUTING
-			    | 1 << NF_IP_LOCAL_OUT)) ||
-		       (h->info.valid_hooks
-			== (1 << NF_IP_PRE_ROUTING
-			    | 1 << NF_IP_LOCAL_IN
-			    | 1 << NF_IP_POST_ROUTING
-			    | 1 << NF_IP_LOCAL_OUT)));
-
-		assert(h->info.hook_entry[NF_IP_PRE_ROUTING] == 0);
-
-		n = get_chain_end(h, 0);
-
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP_POST_ROUTING] == n);
-		n = get_chain_end(h, n);
-
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP_LOCAL_OUT] == n);
-		user_offset = h->info.hook_entry[NF_IP_LOCAL_OUT];
-
-		if (h->info.valid_hooks & (1 << NF_IP_LOCAL_IN)) {
-			n = get_chain_end(h, n);
-			n += get_entry(h, n)->next_offset;
-			assert(h->info.hook_entry[NF_IP_LOCAL_IN] == n);
-			user_offset = h->info.hook_entry[NF_IP_LOCAL_IN];
-		}
-
-	} else if (strcmp(h->info.name, "mangle") == 0) {
-		/* This code is getting ugly because linux < 2.4.18-pre6 had
-		 * two mangle hooks, linux >= 2.4.18-pre6 has five mangle hooks
-		 * */
-		assert((h->info.valid_hooks
-			== (1 << NF_IP_PRE_ROUTING
-			    | 1 << NF_IP_LOCAL_OUT)) || 
-		       (h->info.valid_hooks
-			== (1 << NF_IP_PRE_ROUTING
-			    | 1 << NF_IP_LOCAL_IN
-			    | 1 << NF_IP_FORWARD
-			    | 1 << NF_IP_LOCAL_OUT
-			    | 1 << NF_IP_POST_ROUTING)));
-
-		/* Hooks should be first five */
-		assert(h->info.hook_entry[NF_IP_PRE_ROUTING] == 0);
-
-		n = get_chain_end(h, 0);
-
-		if (h->info.valid_hooks & (1 << NF_IP_LOCAL_IN)) {
-			n += get_entry(h, n)->next_offset;
-			assert(h->info.hook_entry[NF_IP_LOCAL_IN] == n);
-			n = get_chain_end(h, n);
-		}
-
-		if (h->info.valid_hooks & (1 << NF_IP_FORWARD)) {
-			n += get_entry(h, n)->next_offset;
-			assert(h->info.hook_entry[NF_IP_FORWARD] == n);
-			n = get_chain_end(h, n);
-		}
-
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP_LOCAL_OUT] == n);
-		user_offset = h->info.hook_entry[NF_IP_LOCAL_OUT];
-
-		if (h->info.valid_hooks & (1 << NF_IP_POST_ROUTING)) {
-			n = get_chain_end(h, n);
-			n += get_entry(h, n)->next_offset;
-			assert(h->info.hook_entry[NF_IP_POST_ROUTING] == n);
-			user_offset = h->info.hook_entry[NF_IP_POST_ROUTING];
-		}
-
-#ifdef NF_IP_DROPPING
-	} else if (strcmp(h->info.name, "drop") == 0) {
-		assert(h->info.valid_hooks == (1 << NF_IP_DROPPING));
-
-		/* Hook should be first */
-		assert(h->info.hook_entry[NF_IP_DROPPING] == 0);
-		user_offset = 0;
-#endif
-	} else {
-		fprintf(stderr, "Unknown table `%s'\n", h->info.name);
-		abort();
-	}
-
-	/* User chain == end of last builtin + policy entry */
-	user_offset = get_chain_end(h, user_offset);
-	user_offset += get_entry(h, user_offset)->next_offset;
-
-	/* Overflows should be end of entry chains, and unconditional
-           policy nodes. */
-	for (i = 0; i < NUMHOOKS; i++) {
-		STRUCT_ENTRY *e;
-		STRUCT_STANDARD_TARGET *t;
-
-		if (!(h->info.valid_hooks & (1 << i)))
-			continue;
-		assert(h->info.underflow[i]
-		       == get_chain_end(h, h->info.hook_entry[i]));
-
-		e = get_entry(h, get_chain_end(h, h->info.hook_entry[i]));
-		assert(unconditional(&e->ip));
-		assert(e->target_offset == sizeof(*e));
-		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-		assert(t->target.u.target_size == ALIGN(sizeof(*t)));
-		assert(e->next_offset == sizeof(*e) + ALIGN(sizeof(*t)));
-
-		assert(strcmp(t->target.u.user.name, STANDARD_TARGET)==0);
-		assert(t->verdict == -NF_DROP-1 || t->verdict == -NF_ACCEPT-1);
-
-		/* Hooks and underflows must be valid entries */
-		entry2index(h, get_entry(h, h->info.hook_entry[i]));
-		entry2index(h, get_entry(h, h->info.underflow[i]));
-	}
-
-	assert(h->info.size
-	       >= h->info.num_entries * (sizeof(STRUCT_ENTRY)
-					 +sizeof(STRUCT_STANDARD_TARGET)));
-
-	assert(h->entries.size
-	       >= (h->new_number
-		   * (sizeof(STRUCT_ENTRY)
-		      + sizeof(STRUCT_STANDARD_TARGET))));
-	assert(strcmp(h->info.name, h->entries.name) == 0);
-
-	i = 0; n = 0;
-	was_return = 0;
-	/* Check all the entries. */
-	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-		      check_entry, &i, &n, user_offset, &was_return, h);
-
-	assert(i == h->new_number);
-	assert(n == h->entries.size);
-
-	/* Final entry must be error node */
-	assert(strcmp(GET_TARGET(index2entry(h, h->new_number-1))
-		      ->u.user.name,
-		      ERROR_TARGET) == 0);
-}
-#endif /*IPTC_DEBUG*/
diff -urN iptables-1.2.9/libiptc2/libip6tc.c iptables-1.2.10/libiptc2/libip6tc.c
--- iptables-1.2.9/libiptc2/libip6tc.c	2003-06-30 18:16:54.000000000 +0200
+++ iptables-1.2.10/libiptc2/libip6tc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,449 +0,0 @@
-/* Library which manipulates firewall rules.  Version 0.1. */
-
-/* Architecture of firewall rules is as follows:
- *
- * Chains go INPUT, FORWARD, OUTPUT then user chains.
- * Each user chain starts with an ERROR node.
- * Every chain ends with an unconditional jump: a RETURN for user chains,
- * and a POLICY for built-ins.
- */
-
-/* (C)1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
-   COPYING for details). */
-
-#include <assert.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <arpa/inet.h>
-
-#ifdef DEBUG_CONNTRACK
-#define inline
-#endif
-
-#if !defined(__GLIBC__) || (__GLIBC__ < 2)
-typedef unsigned int socklen_t;
-#endif
-
-#include "libiptc/libip6tc.h"
-
-#define HOOK_PRE_ROUTING	NF_IP6_PRE_ROUTING
-#define HOOK_LOCAL_IN		NF_IP6_LOCAL_IN
-#define HOOK_FORWARD		NF_IP6_FORWARD
-#define HOOK_LOCAL_OUT		NF_IP6_LOCAL_OUT
-#define HOOK_POST_ROUTING	NF_IP6_POST_ROUTING
-
-#define STRUCT_ENTRY_TARGET	struct ip6t_entry_target
-#define STRUCT_ENTRY		struct ip6t_entry
-#define STRUCT_ENTRY_MATCH	struct ip6t_entry_match
-#define STRUCT_GETINFO		struct ip6t_getinfo
-#define STRUCT_GET_ENTRIES	struct ip6t_get_entries
-#define STRUCT_COUNTERS		struct ip6t_counters
-#define STRUCT_COUNTERS_INFO	struct ip6t_counters_info
-#define STRUCT_STANDARD_TARGET	struct ip6t_standard_target
-#define STRUCT_REPLACE		struct ip6t_replace
-
-#define STRUCT_TC_HANDLE	struct ip6tc_handle
-#define TC_HANDLE_T		ip6tc_handle_t
-
-#define ENTRY_ITERATE		IP6T_ENTRY_ITERATE
-#define TABLE_MAXNAMELEN	IP6T_TABLE_MAXNAMELEN
-#define FUNCTION_MAXNAMELEN	IP6T_FUNCTION_MAXNAMELEN
-
-#define GET_TARGET		ip6t_get_target
-
-#define ERROR_TARGET		IP6T_ERROR_TARGET
-#define NUMHOOKS		NF_IP6_NUMHOOKS
-
-#define IPT_CHAINLABEL		ip6t_chainlabel
-
-#define TC_DUMP_ENTRIES		dump_entries6
-#define TC_IS_CHAIN		ip6tc_is_chain
-#define TC_FIRST_CHAIN		ip6tc_first_chain
-#define TC_NEXT_CHAIN		ip6tc_next_chain
-#define TC_FIRST_RULE		ip6tc_first_rule
-#define TC_NEXT_RULE		ip6tc_next_rule
-#define TC_GET_TARGET		ip6tc_get_target
-#define TC_BUILTIN		ip6tc_builtin
-#define TC_GET_POLICY		ip6tc_get_policy
-#define TC_INSERT_ENTRY		ip6tc_insert_entry
-#define TC_REPLACE_ENTRY	ip6tc_replace_entry
-#define TC_APPEND_ENTRY		ip6tc_append_entry
-#define TC_DELETE_ENTRY		ip6tc_delete_entry
-#define TC_DELETE_NUM_ENTRY	ip6tc_delete_num_entry
-#define TC_CHECK_PACKET		ip6tc_check_packet
-#define TC_FLUSH_ENTRIES	ip6tc_flush_entries
-#define TC_ZERO_ENTRIES		ip6tc_zero_entries
-#define TC_ZERO_COUNTER		ip6tc_zero_counter
-#define TC_READ_COUNTER		ip6tc_read_counter
-#define TC_SET_COUNTER		ip6tc_set_counter
-#define TC_CREATE_CHAIN		ip6tc_create_chain
-#define TC_GET_REFERENCES	ip6tc_get_references
-#define TC_DELETE_CHAIN		ip6tc_delete_chain
-#define TC_RENAME_CHAIN		ip6tc_rename_chain
-#define TC_SET_POLICY		ip6tc_set_policy
-#define TC_GET_RAW_SOCKET	ip6tc_get_raw_socket
-#define TC_INIT			ip6tc_init
-#define TC_FREE			ip6tc_free
-#define TC_COMMIT		ip6tc_commit
-#define TC_STRERROR		ip6tc_strerror
-
-#define TC_AF			AF_INET6
-#define TC_IPPROTO		IPPROTO_IPV6
-
-#define SO_SET_REPLACE		IP6T_SO_SET_REPLACE
-#define SO_SET_ADD_COUNTERS	IP6T_SO_SET_ADD_COUNTERS
-#define SO_GET_INFO		IP6T_SO_GET_INFO
-#define SO_GET_ENTRIES		IP6T_SO_GET_ENTRIES
-#define SO_GET_VERSION		IP6T_SO_GET_VERSION
-
-#define STANDARD_TARGET		IP6T_STANDARD_TARGET
-#define LABEL_RETURN		IP6TC_LABEL_RETURN
-#define LABEL_ACCEPT		IP6TC_LABEL_ACCEPT
-#define LABEL_DROP		IP6TC_LABEL_DROP
-#define LABEL_QUEUE		IP6TC_LABEL_QUEUE
-
-#define ALIGN			IP6T_ALIGN
-#define RETURN			IP6T_RETURN
-
-#include "libiptc.c"
-
-#define BIT6(a, l) \
- ((ntohl(a->in6_u.u6_addr32[(l) / 32]) >> (31 - ((l) & 31))) & 1)
-
-int
-ipv6_prefix_length(const struct in6_addr *a)
-{
-	int l, i;
-	for (l = 0; l < 128; l++) {
-		if (BIT6(a, l) == 0)
-			break;
-	}
-	for (i = l + 1; i < 128; i++) {
-		if (BIT6(a, i) == 1)
-			return -1;
-	}
-	return l;
-}
-
-static int
-dump_entry(struct ip6t_entry *e, const ip6tc_handle_t handle)
-{
-	size_t i;
-	char buf[40];
-	int len;
-	struct ip6t_entry_target *t;
-	
-	printf("Entry %u (%lu):\n", entry2index(handle, e),
-	       entry2offset(handle, e));
-	puts("SRC IP: ");
-	inet_ntop(AF_INET6, &e->ipv6.src, buf, sizeof buf);
-	puts(buf);
-	putchar('/');
-	len = ipv6_prefix_length(&e->ipv6.smsk);
-	if (len != -1)
-		printf("%d", len);
-	else {
-		inet_ntop(AF_INET6, &e->ipv6.smsk, buf, sizeof buf);
-		puts(buf);
-	}
-	putchar('\n');
-	
-	puts("DST IP: ");
-	inet_ntop(AF_INET6, &e->ipv6.dst, buf, sizeof buf);
-	puts(buf);
-	putchar('/');
-	len = ipv6_prefix_length(&e->ipv6.dmsk);
-	if (len != -1)
-		printf("%d", len);
-	else {
-		inet_ntop(AF_INET6, &e->ipv6.dmsk, buf, sizeof buf);
-		puts(buf);
-	}
-	putchar('\n');
-	
-	printf("Interface: `%s'/", e->ipv6.iniface);
-	for (i = 0; i < IFNAMSIZ; i++)
-		printf("%c", e->ipv6.iniface_mask[i] ? 'X' : '.');
-	printf("to `%s'/", e->ipv6.outiface);
-	for (i = 0; i < IFNAMSIZ; i++)
-		printf("%c", e->ipv6.outiface_mask[i] ? 'X' : '.');
-	printf("\nProtocol: %u\n", e->ipv6.proto);
-	if (e->ipv6.flags & IP6T_F_TOS)
-		printf("TOS: %u\n", e->ipv6.tos);
-	printf("Flags: %02X\n", e->ipv6.flags);
-	printf("Invflags: %02X\n", e->ipv6.invflags);
-	printf("Counters: %llu packets, %llu bytes\n",
-	       e->counters.pcnt, e->counters.bcnt);
-	printf("Cache: %08X ", e->nfcache);
-	if (e->nfcache & NFC_ALTERED) printf("ALTERED ");
-	if (e->nfcache & NFC_UNKNOWN) printf("UNKNOWN ");
-	if (e->nfcache & NFC_IP6_SRC) printf("IP6_SRC ");
-	if (e->nfcache & NFC_IP6_DST) printf("IP6_DST ");
-	if (e->nfcache & NFC_IP6_IF_IN) printf("IP6_IF_IN ");
-	if (e->nfcache & NFC_IP6_IF_OUT) printf("IP6_IF_OUT ");
-	if (e->nfcache & NFC_IP6_TOS) printf("IP6_TOS ");
-	if (e->nfcache & NFC_IP6_PROTO) printf("IP6_PROTO ");
-	if (e->nfcache & NFC_IP6_OPTIONS) printf("IP6_OPTIONS ");
-	if (e->nfcache & NFC_IP6_TCPFLAGS) printf("IP6_TCPFLAGS ");
-	if (e->nfcache & NFC_IP6_SRC_PT) printf("IP6_SRC_PT ");
-	if (e->nfcache & NFC_IP6_DST_PT) printf("IP6_DST_PT ");
-	if (e->nfcache & NFC_IP6_PROTO_UNKNOWN) printf("IP6_PROTO_UNKNOWN ");
-	printf("\n");
-	
-	IP6T_MATCH_ITERATE(e, print_match);
-
-	t = ip6t_get_target(e);
-	printf("Target name: `%s' [%u]\n", t->u.user.name, t->u.target_size);
-	if (strcmp(t->u.user.name, IP6T_STANDARD_TARGET) == 0) {
-		int pos = *(int *)t->data;
-		if (pos < 0)
-			printf("verdict=%s\n",
-			       pos == -NF_ACCEPT-1 ? "NF_ACCEPT"
-			       : pos == -NF_DROP-1 ? "NF_DROP"
-			       : pos == IP6T_RETURN ? "RETURN"
-			       : "UNKNOWN");
-		else
-			printf("verdict=%u\n", pos);
-	} else if (strcmp(t->u.user.name, IP6T_ERROR_TARGET) == 0)
-		printf("error=`%s'\n", t->data);
-
-	printf("\n");
-	return 0;
-}
-
-static int
-is_same(const STRUCT_ENTRY *a, const STRUCT_ENTRY *b,
-	unsigned char *matchmask)
-{
-	unsigned int i;
-	STRUCT_ENTRY_TARGET *ta, *tb;
-	unsigned char *mptr;
-
-	/* Always compare head structures: ignore mask here. */
-	if (memcmp(&a->ipv6.src, &b->ipv6.src, sizeof(struct in6_addr))
-	    || memcmp(&a->ipv6.dst, &b->ipv6.dst, sizeof(struct in6_addr))
-	    || memcmp(&a->ipv6.smsk, &b->ipv6.smsk, sizeof(struct in6_addr))
-	    || memcmp(&a->ipv6.dmsk, &b->ipv6.dmsk, sizeof(struct in6_addr))
-	    || a->ipv6.proto != b->ipv6.proto
-	    || a->ipv6.tos != b->ipv6.tos
-	    || a->ipv6.flags != b->ipv6.flags
-	    || a->ipv6.invflags != b->ipv6.invflags)
-		return 0;
-
-	for (i = 0; i < IFNAMSIZ; i++) {
-		if (a->ipv6.iniface_mask[i] != b->ipv6.iniface_mask[i])
-			return 0;
-		if ((a->ipv6.iniface[i] & a->ipv6.iniface_mask[i])
-		    != (b->ipv6.iniface[i] & b->ipv6.iniface_mask[i]))
-			return 0;
-		if (a->ipv6.outiface_mask[i] != b->ipv6.outiface_mask[i])
-			return 0;
-		if ((a->ipv6.outiface[i] & a->ipv6.outiface_mask[i])
-		    != (b->ipv6.outiface[i] & b->ipv6.outiface_mask[i]))
-			return 0;
-	}
-
-	if (a->nfcache != b->nfcache
-	    || a->target_offset != b->target_offset
-	    || a->next_offset != b->next_offset)
-		return 0;
-
-	mptr = matchmask + sizeof(STRUCT_ENTRY);
-	if (IP6T_MATCH_ITERATE(a, match_different, a->elems, b->elems, &mptr))
-		return 0;
-
-	ta = GET_TARGET((STRUCT_ENTRY *)a);
-	tb = GET_TARGET((STRUCT_ENTRY *)b);
-	if (ta->u.target_size != tb->u.target_size)
-		return 0;
-	if (strcmp(ta->u.user.name, tb->u.user.name) != 0)
-		return 0;
-	mptr += sizeof(*ta);
-
-	if (target_different(ta->data, tb->data,
-			     ta->u.target_size - sizeof(*ta), mptr))
-		return 0;
-
-	return 1;
-}
-
-/* All zeroes == unconditional rule. */
-static inline int
-unconditional(const struct ip6t_ip6 *ipv6)
-{
-	unsigned int i;
-
-	for (i = 0; i < sizeof(*ipv6); i++)
-		if (((char *)ipv6)[i])
-			break;
-
-	return (i == sizeof(*ipv6));
-}
-
-#ifdef IPTC_DEBUG
-/* Do every conceivable sanity check on the handle */
-static void
-do_check(TC_HANDLE_T h, unsigned int line)
-{
-	unsigned int i, n;
-	unsigned int user_offset; /* Offset of first user chain */
-	int was_return;
-
-	assert(h->changed == 0 || h->changed == 1);
-	if (strcmp(h->info.name, "filter") == 0) {
-		assert(h->info.valid_hooks
-		       == (1 << NF_IP6_LOCAL_IN
-			   | 1 << NF_IP6_FORWARD
-			   | 1 << NF_IP6_LOCAL_OUT));
-
-		/* Hooks should be first three */
-		assert(h->info.hook_entry[NF_IP6_LOCAL_IN] == 0);
-
-		n = get_chain_end(h, 0);
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP6_FORWARD] == n);
-
-		n = get_chain_end(h, n);
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
-
-		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
-	} else if (strcmp(h->info.name, "nat") == 0) {
-		assert((h->info.valid_hooks
-			== (1 << NF_IP6_PRE_ROUTING
-			    | 1 << NF_IP6_LOCAL_OUT
-			    | 1 << NF_IP6_POST_ROUTING)) ||
-		       (h->info.valid_hooks
-			== (1 << NF_IP6_PRE_ROUTING
-			    | 1 << NF_IP6_LOCAL_IN
-			    | 1 << NF_IP6_LOCAL_OUT
-			    | 1 << NF_IP6_POST_ROUTING)));
-
-		assert(h->info.hook_entry[NF_IP6_PRE_ROUTING] == 0);
-
-		n = get_chain_end(h, 0);
-
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP6_POST_ROUTING] == n);
-		n = get_chain_end(h, n);
-
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
-		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
-
-		if (h->info.valid_hooks & (1 << NF_IP6_LOCAL_IN)) {
-			n = get_chain_end(h, n);
-			n += get_entry(h, n)->next_offset;
-			assert(h->info.hook_entry[NF_IP6_LOCAL_IN] == n);
-			user_offset = h->info.hook_entry[NF_IP6_LOCAL_IN];
-		}
-
-	} else if (strcmp(h->info.name, "mangle") == 0) {
-		/* This code is getting ugly because linux < 2.4.18-pre6 had
-		 * two mangle hooks, linux >= 2.4.18-pre6 has five mangle hooks
-		 * */
-		assert((h->info.valid_hooks
-			== (1 << NF_IP6_PRE_ROUTING
-			    | 1 << NF_IP6_LOCAL_OUT)) ||
-		       (h->info.valid_hooks
-			== (1 << NF_IP6_PRE_ROUTING
-			    | 1 << NF_IP6_LOCAL_IN
-			    | 1 << NF_IP6_FORWARD
-			    | 1 << NF_IP6_LOCAL_OUT
-			    | 1 << NF_IP6_POST_ROUTING)));
-
-		/* Hooks should be first five */
-		assert(h->info.hook_entry[NF_IP6_PRE_ROUTING] == 0);
-
-		n = get_chain_end(h, 0);
-
-		if (h->info.valid_hooks & (1 << NF_IP6_LOCAL_IN)) {
-			n += get_entry(h, n)->next_offset;
-			assert(h->info.hook_entry[NF_IP6_LOCAL_IN] == n);
-			n = get_chain_end(h, n);
-		}
-
-		if (h->info.valid_hooks & (1 << NF_IP6_FORWARD)) {
-			n += get_entry(h, n)->next_offset;
-			assert(h->info.hook_entry[NF_IP6_FORWARD] == n);
-			n = get_chain_end(h, n);
-		}
-
-		n += get_entry(h, n)->next_offset;
-		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
-		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
-
-		if (h->info.valid_hooks & (1 << NF_IP6_POST_ROUTING)) {
-			n = get_chain_end(h, n);
-			n += get_entry(h, n)->next_offset;
-			assert(h->info.hook_entry[NF_IP6_POST_ROUTING] == n);
-			user_offset = h->info.hook_entry[NF_IP6_POST_ROUTING];
-		}
-	} else {
-                fprintf(stderr, "Unknown table `%s'\n", h->info.name);
-		abort();
-	}
-
-	/* User chain == end of last builtin + policy entry */
-	user_offset = get_chain_end(h, user_offset);
-	user_offset += get_entry(h, user_offset)->next_offset;
-
-	/* Overflows should be end of entry chains, and unconditional
-           policy nodes. */
-	for (i = 0; i < NUMHOOKS; i++) {
-		STRUCT_ENTRY *e;
-		STRUCT_STANDARD_TARGET *t;
-
-		if (!(h->info.valid_hooks & (1 << i)))
-			continue;
-		assert(h->info.underflow[i]
-		       == get_chain_end(h, h->info.hook_entry[i]));
-
-		e = get_entry(h, get_chain_end(h, h->info.hook_entry[i]));
-		assert(unconditional(&e->ipv6));
-		assert(e->target_offset == sizeof(*e));
-		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-		printf("target_size=%u, align=%u\n",
-			t->target.u.target_size, ALIGN(sizeof(*t)));
-		assert(t->target.u.target_size == ALIGN(sizeof(*t)));
-		assert(e->next_offset == sizeof(*e) + ALIGN(sizeof(*t)));
-
-		assert(strcmp(t->target.u.user.name, STANDARD_TARGET)==0);
-		assert(t->verdict == -NF_DROP-1 || t->verdict == -NF_ACCEPT-1);
-
-		/* Hooks and underflows must be valid entries */
-		entry2index(h, get_entry(h, h->info.hook_entry[i]));
-		entry2index(h, get_entry(h, h->info.underflow[i]));
-	}
-
-	assert(h->info.size
-	       >= h->info.num_entries * (sizeof(STRUCT_ENTRY)
-					 +sizeof(STRUCT_STANDARD_TARGET)));
-
-	assert(h->entries.size
-	       >= (h->new_number
-		   * (sizeof(STRUCT_ENTRY)
-		      + sizeof(STRUCT_STANDARD_TARGET))));
-	assert(strcmp(h->info.name, h->entries.name) == 0);
-
-	i = 0; n = 0;
-	was_return = 0;
-
-#if 0
-	/* Check all the entries. */
-	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-		      check_entry, &i, &n, user_offset, &was_return, h);
-
-	assert(i == h->new_number);
-	assert(n == h->entries.size);
-
-	/* Final entry must be error node */
-	assert(strcmp(GET_TARGET(index2entry(h, h->new_number-1))
-		      ->u.user.name,
-		      ERROR_TARGET) == 0);
-#endif
-}
-#endif /*IPTC_DEBUG*/
diff -urN iptables-1.2.9/libiptc2/libiptc.c iptables-1.2.10/libiptc2/libiptc.c
--- iptables-1.2.9/libiptc2/libiptc.c	2003-07-23 16:58:21.000000000 +0200
+++ iptables-1.2.10/libiptc2/libiptc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1830 +0,0 @@
-/* Library which manipulates firewall rules.  Version $Revision: 1.41 $ */
-
-/* Architecture of firewall rules is as follows:
- *
- * Chains go INPUT, FORWARD, OUTPUT then user chains.
- * Each user chain starts with an ERROR node.
- * Every chain ends with an unconditional jump: a RETURN for user chains,
- * and a POLICY for built-ins.
- */
-
-/* (C) 1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
- * COPYING for details). 
- * (C) 2000-2003 by the Netfilter Core Team <coreteam@netfilter.org>
- *
- * 2003-Jun-20: Harald Welte <laforge@netfilter.org>:
- *	- Reimplementation of chain cache to use offsets instead of entries
- * 2003-Jun-23: Harald Welte <laforge@netfilter.org>:
- * 	- speed optimization, sponsored by Astaro AG (http://www.astaro.com/)
- * 	  don't rebuild the chain cache after every operation, instead fix it
- * 	  up after a ruleset change.  
- * 2003-Jun-30: Harald Welte <laforge@netfilter.org>:
- * 	- reimplementation from scratch. *sigh*.  I hope nobody has to touch 
- * 	  this code ever again.
- */
-#include "linux_listhelp.h"
-
-#ifndef IPT_LIB_DIR
-#define IPT_LIB_DIR "/usr/local/lib/iptables"
-#endif
-
-static int sockfd = -1;
-static void *iptc_fn = NULL;
-
-static const char *hooknames[]
-= { [HOOK_PRE_ROUTING]  "PREROUTING",
-    [HOOK_LOCAL_IN]     "INPUT",
-    [HOOK_FORWARD]      "FORWARD",
-    [HOOK_LOCAL_OUT]    "OUTPUT",
-    [HOOK_POST_ROUTING] "POSTROUTING",
-#ifdef HOOK_DROPPING
-    [HOOK_DROPPING]	"DROPPING"
-#endif
-};
-
-struct counter_map
-{
-	enum {
-		COUNTER_MAP_NOMAP,
-		COUNTER_MAP_NORMAL_MAP,
-		COUNTER_MAP_ZEROED,
-		COUNTER_MAP_SET
-	} maptype;
-	unsigned int mappos;
-};
-
-/* Convenience structures */
-struct ipt_error_target
-{
-	STRUCT_ENTRY_TARGET t;
-	char error[TABLE_MAXNAMELEN];
-};
-
-struct rule_head
-{
-	struct list_head list;		/* list of rules in chain */
-	
-	struct chain_head *chain;	/* we're part of this chain */
-
-	struct chain_head *jumpto;	/* target of this rule, in case
-					   it is a jump rule */
-
-	struct counter_map counter_map;
-
-	unsigned int size;		/* size of rule */
-	STRUCT_ENTRY *entry_blob;	/* pointer to entry in blob */
-	STRUCT_ENTRY entry[0];
-};
-
-struct chain_head
-{
-	struct list_head list;
-
-	char name[TABLE_MAXNAMELEN];
-	unsigned int hooknum;
-	struct list_head rules;
-	struct rule_head *firstrule; 	/* first (ERROR) rule */
-	struct rule_head *lastrule;	/* last (RETURN) rule */
-};
-
-STRUCT_TC_HANDLE
-{
-	/* Have changes been made? */
-	int changed;
-
-	/* linked list of chains in this table */
-	struct list_head chains;
-	
-	/* current position of first_chain() / next_chain() */
-	struct chain_head *chain_iterator_cur;
-
-	/* current position of first_rule() / next_rule() */
-	struct rule_head *rule_iterator_cur;
-
-	/* the structure we receive from getsockopt() */
-	STRUCT_GETINFO info;
-
-	/* Array of hook names */
-	const char **hooknames;
-#if 0
-	/* Size in here reflects original state. */
-
-
-	/* Cached position of chain heads (NULL = no cache). */
-	unsigned int cache_num_chains;
-	unsigned int cache_num_builtins;
-	struct chain_cache *cache_chain_heads;
-
-	/* Chain iterator: current chain cache entry. */
-	struct chain_cache *cache_chain_iteration;
-
-	/* Rule iterator: terminal rule */
-	STRUCT_ENTRY *cache_rule_end;
-
-	/* Number in here reflects current state. */
-	unsigned int new_number;
-#endif
-	STRUCT_GET_ENTRIES entries;
-};
-
-static void
-set_changed(TC_HANDLE_T h)
-{
-	h->changed = 1;
-}
-
-#ifdef IPTC_DEBUG
-static void do_check(TC_HANDLE_T h, unsigned int line);
-#define CHECK(h) do { if (!getenv("IPTC_NO_CHECK")) do_check((h), __LINE__); } while(0)
-#else
-#define CHECK(h)
-#endif
-
-static struct rule_head *ruleh_alloc(unsigned int size)
-{
-	struct rule_head *ruleh = malloc(sizeof(*ruleh)+size);
-	if (!ruleh)
-		return NULL;
-	
-	memset(ruleh, 0, sizeof(*ruleh)+size);
-	ruleh->size = size;
-
-	return ruleh;
-}
-
-static void ruleh_free(struct rule_head *ruleh)
-{
-	list_del(&ruleh->list);
-	free(ruleh);
-}
-
-static struct chain_head *chainh_alloc(TC_HANDLE_T h, const char *name)
-{
-	struct chain_head *chainh = malloc(sizeof(*chainh));
-	if (!chainh)
-		return NULL;
-
-	memset(chainh, 0, sizeof(*chainh));
-	strncpy(chainh->name, name, sizeof(&chainh->name));
-	list_append(&chainh->list, &h->chains);
-
-	return chainh;
-}
-
-static void
-chainh_clean(struct chain_head *chainh)
-{
-	/* FIXME */
-	struct list_head *cur_item, *item2;
-
-	list_for_each_safe(cur_item, item2, &chainh->rules) {
-		struct rule_head *ruleh = list_entry(cur_item, 
-						     struct rule_head,
-						    list);
-		ruleh_free(ruleh);
-	}
-}
-
-static void 
-chainh_free(struct chain_head *chainh)
-{
-	chainh_clean(chainh);
-	list_del(&chainh->list);
-}
-
-static struct chain_head *
-chainh_find(TC_HANDLE_T h, const IPT_CHAINLABEL name)
-{
-	struct list_head *cur;
-
-	list_for_each(cur, &h->chains) {
-		struct chain_head *ch = list_entry(cur, struct chain_head, 
-						   list);
-		if (!strcmp(name, ch->name))
-			return ch;
-	}
-	return NULL;
-}
-
-/* Returns chain head if found, otherwise NULL. */
-static struct chain_head *
-find_label(const char *name, TC_HANDLE_T handle)
-{
-	return chainh_find(handle, name);
-}
-
-
-/* 
- * functions that directly operate on the blob 
- */
-
-static inline unsigned long
-entry2offset(const TC_HANDLE_T h, const STRUCT_ENTRY *e)
-{
-	return (void *)e - (void *)h->entries.entrytable;
-}
-
-static inline STRUCT_ENTRY *
-get_entry(TC_HANDLE_T h, unsigned int offset)
-{
-	return (STRUCT_ENTRY *)((char *)h->entries.entrytable + offset);
-}
-
-/* needed by entry2index */
-static inline int
-get_number(const STRUCT_ENTRY *i,
-	   const STRUCT_ENTRY *seek,
-	   unsigned int *pos)
-{
-	if (i == seek)
-		return 1;
-	(*pos)++;
-	return 0;
-}
-
-static unsigned int
-entry2index(const TC_HANDLE_T h, const STRUCT_ENTRY *seek)
-{
-	unsigned int pos = 0;
-
-	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-			  get_number, seek, &pos) == 0) {
-		fprintf(stderr, "ERROR: offset %i not an entry!\n",
-			(char *)seek - (char *)h->entries.entrytable);
-		abort();
-	}
-	return pos;
-}
-
-static inline int
-get_entry_n(STRUCT_ENTRY *i,
-	    unsigned int number,
-	    unsigned int *pos,
-	    STRUCT_ENTRY **pe)
-{
-	if (*pos == number) {
-		*pe = i;
-		return 1;
-	}
-	(*pos)++;
-	return 0;
-}
-
-static STRUCT_ENTRY *
-index2entry(TC_HANDLE_T h, unsigned int index)
-{
-	unsigned int pos = 0;
-	STRUCT_ENTRY *ret = NULL;
-
-	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-		      get_entry_n, index, &pos, &ret);
-
-	return ret;
-}
-
-static inline unsigned long
-index2offset(TC_HANDLE_T h, unsigned int index)
-{
-	return entry2offset(h, index2entry(h, index));
-}
-
-static char *
-get_errorlabel(TC_HANDLE_T h, unsigned int offset)
-{
-	STRUCT_ENTRY *e;
-
-	e = get_entry(h, offset);
-	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) != 0) {
-		fprintf(stderr, "ERROR: offset %u not an error node!\n",
-			offset);
-		abort();
-	}
-
-	return (char *)GET_TARGET(e)->data;
-}
-
-#if 0
-static inline STRUCT_ENTRY *
-offset2entry(TC_HANDLE_T h, unsigned int offset)
-{
-	return (STRUCT_ENTRY *) ((void *)h->entries.entrytable+offset);
-}
-
-static inline unsigned int
-offset2index(const TC_HANDLE_T h, unsigned int offset)
-{
-	return entry2index(h, offset2entry(h, offset));
-}
-
-
-#endif
-
-/* Allocate handle of given size */
-static TC_HANDLE_T
-alloc_tc_handle(const char *tablename, unsigned int size, 
-		unsigned int num_rules)
-{
-	size_t len;
-	TC_HANDLE_T h;
-
-	len = sizeof(STRUCT_TC_HANDLE)
-		+ size
-		+ num_rules * sizeof(struct counter_map);
-
-	if ((h = malloc(len)) == NULL) {
-		errno = ENOMEM;
-		return NULL;
-	}
-
-	h->changed = 0;
-
-	strcpy(h->info.name, tablename);
-	strcpy(h->entries.name, tablename);
-	INIT_LIST_HEAD(&h->chains);
-
-	return h;
-}
-
-/* get the name of the chain that we jump to */
-static char *
-parse_jumptarget(const STRUCT_ENTRY *e, TC_HANDLE_T h)
-{
-	STRUCT_ENTRY *jumpto;
-	int spos, labelidx;
-
-	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) != 0) {
-		/* called for non-standard target */
-		return "__FIXME";
-	}
-	/* Standard target: evaluate */
-	spos = *(int *)GET_TARGET(e)->data;
-	if (spos < 0) {
-		return "__FIXME";
-	}
-
-	jumpto = get_entry(h, spos);
-
-	/* Fall through rule */
-	if (jumpto == (void *)e + e->next_offset)
-		return "";
-
-	/* Must point to head of a chain: ie. after error rule */
-	/* FIXME: this needs to deal with internal jump targets */
-	labelidx = entry2index(h, jumpto) - 1;
-	return get_errorlabel(h, index2offset(h, labelidx));
-}
-
-/* parser functions */
-
-struct rule_head *
-append_entrycopy(const STRUCT_ENTRY *e, struct rule_head *prev)
-{
-	struct rule_head *ruleh = ruleh_alloc(e->next_offset);
-	if (!ruleh)
-		return NULL;
-	
-	memcpy(&ruleh->entry, e, e->next_offset);
-	ruleh->chain = prev->chain;
-	ruleh->entry_blob = e;
-	list_append(&ruleh->list, &prev->list);
-
-	return ruleh;
-}
-
-/* have to return 0 on success, bcf ENTRY_ITERATE */
-static inline int 
-parse_entry(const STRUCT_ENTRY *e, TC_HANDLE_T h, struct chain_head **curchain)
-{
-	int i;
-	union tgt_u {
-		STRUCT_ENTRY_TARGET ent;
-		STRUCT_STANDARD_TARGET std;
-		struct ipt_error_target err;
-	} *tgt;
-
-	struct rule_head *lastrule = list_entry((*curchain)->rules.prev,
-						 struct rule_head, list);
-	struct rule_head *newrule;
-
-	tgt = (union tgt_u *) GET_TARGET(e);
-
-	if (e->target_offset == sizeof(STRUCT_ENTRY)
-	    && (strcmp(tgt->ent.u.user.name, IPT_STANDARD_TARGET) == 0)) {
-		/* jump to somewhere else */
-		char *targname;
-		struct chain_head *chainh;
-
-		newrule = append_entrycopy(e, lastrule);
-
-		targname = parse_jumptarget(e, h);
-		if (!(chainh = find_label(targname, h))) {
-			chainh = chainh_alloc(h, targname);
-		}
-		if (!chainh) {
-			errno = ENOMEM;
-			return 1;
-		}
-		newrule->jumpto = chainh;
-
-	} else if (e->target_offset == sizeof(STRUCT_ENTRY)
-		   && e->next_offset == sizeof(STRUCT_ENTRY)
-		   			+ ALIGN(sizeof(struct ipt_error_target))
-		   && !strcmp(tgt->ent.u.user.name, ERROR_TARGET)) {
-		/* chain head */
-		*curchain = chainh_find(h, tgt->err.error);
-		if (!(*curchain)) {
-			*curchain = chainh_alloc(h, tgt->err.error);
-			/* FIXME: error handling */
-		}
-		newrule = append_entrycopy(e, lastrule);
-		(*curchain)->firstrule = newrule;
-
-	} else if (e->target_offset == sizeof(STRUCT_ENTRY)
-		   && e->next_offset == sizeof(STRUCT_ENTRY)
-		   			+ ALIGN(sizeof(STRUCT_STANDARD_TARGET))
-		   && tgt->std.verdict == RETURN) {
-		/* chain end */
-		newrule = append_entrycopy(e, lastrule);
-		(*curchain)->lastrule = newrule;
-		*curchain = NULL;
-	} else {
-		/* normal rule */
-		newrule = append_entrycopy(e, lastrule);
-	}
-
-	/* create counter map entry */
-	newrule->counter_map.maptype = COUNTER_MAP_NORMAL_MAP;
-	newrule->counter_map.mappos = entry2index(h, e);
-
-	/* iterate over hook_entries, needed to connect builtin
-	 * chains with hook numbers */
-	for (i = 0; i < NUMHOOKS; i++) {
-		if (!(h->info.valid_hooks & (1 << i)))
-			continue;
-		if (h->info.hook_entry[i] == entry2offset(h, e)) {
-			/* found hook entry point */
-			if (*curchain)
-				(*curchain)->hooknum = i;
-		}
-		if (h->info.underflow[i] == entry2offset(h, e)) {
-			/* found underflow point */
-		}
-	}
-
-	return 0;
-}
-
-static int parse_ruleset(TC_HANDLE_T h)
-{
-	struct chain_head *curchain;
-	
-	/* iterate over ruleset; create linked list of rule_head/chain_head */
-	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size, 
-		      parse_entry, h, &curchain)) {
-		/* some error happened while iterating */
-		return 0;
-	}
-
-	return 1;
-}
-
-TC_HANDLE_T
-TC_INIT(const char *tablename)
-{
-	TC_HANDLE_T h;
-	STRUCT_GETINFO info;
-	int tmp;
-	socklen_t s;
-
-	iptc_fn = TC_INIT;
-
-	if (sockfd != -1) {
-		close(sockfd);
-		sockfd = -1;
-	}
-
-	if (strlen(tablename) >= TABLE_MAXNAMELEN) {
-		errno = EINVAL;
-		return NULL;
-	}
-	
-	sockfd = socket(TC_AF, SOCK_RAW, IPPROTO_RAW);
-	if (sockfd < 0)
-		return NULL;
-
-	s = sizeof(info);
-
-	strcpy(info.name, tablename);
-	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_INFO, &info, &s) < 0)
-		return NULL;
-
-	if ((h = alloc_tc_handle(info.name, info.size, info.num_entries))
-	    == NULL) {
-		close(sockfd);
-		sockfd = -1;
-		return NULL;
-	}
-
-/* Too hard --RR */
-#if 0
-	sprintf(pathname, "%s/%s", IPT_LIB_DIR, info.name);
-	dynlib = dlopen(pathname, RTLD_NOW);
-	if (!dynlib) {
-		errno = ENOENT;
-		return NULL;
-	}
-	h->hooknames = dlsym(dynlib, "hooknames");
-	if (!h->hooknames) {
-		errno = ENOENT;
-		return NULL;
-	}
-#else
-	h->hooknames = hooknames;
-#endif
-
-	/* Initialize current state */
-	h->info = info;
-	//h->new_number = h->info.num_entries;
-	//
-	h->entries.size = h->info.size;
-
-	tmp = sizeof(STRUCT_GET_ENTRIES) + h->info.size;
-
-	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_ENTRIES, &h->entries,
-		       &tmp) < 0) {
-		close(sockfd);
-		sockfd = -1;
-		free(h);
-		return NULL;
-	}
-
-	CHECK(h);
-	parse_ruleset(h);
-
-	return h;
-}
-
-void
-TC_FREE(TC_HANDLE_T *h)
-{
-	struct list_head *cur_item, *item2;
-
-	close(sockfd);
-	sockfd = -1;
-
-	/* free all chains */
-	list_for_each_safe(cur_item, item2, &(*h)->chains) {
-		struct chain_head *chead = list_entry(cur_item,
-						      struct chain_head,
-						      list);
-		chainh_free(chead);
-	}
-
-	/* FIXME: free all other ressources we might be using */
-
-	free(*h);
-	*h = NULL;
-}
-
-static inline int
-print_match(const STRUCT_ENTRY_MATCH *m)
-{
-	printf("Match name: `%s'\n", m->u.user.name);
-	return 0;
-}
-
-static int dump_entry(STRUCT_ENTRY *e, const TC_HANDLE_T handle);
- 
-#if 0
-void
-TC_DUMP_ENTRIES(const TC_HANDLE_T handle)
-{
-	CHECK(handle);
-
-	printf("libiptc v%s.  %u entries, %u bytes.\n",
-	       IPTABLES_VERSION,
-	       handle->new_number, handle->entries.size);
-	printf("Table `%s'\n", handle->info.name);
-	printf("Hooks: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
-	       handle->info.hook_entry[HOOK_PRE_ROUTING],
-	       handle->info.hook_entry[HOOK_LOCAL_IN],
-	       handle->info.hook_entry[HOOK_FORWARD],
-	       handle->info.hook_entry[HOOK_LOCAL_OUT],
-	       handle->info.hook_entry[HOOK_POST_ROUTING]);
-	printf("Underflows: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
-	       handle->info.underflow[HOOK_PRE_ROUTING],
-	       handle->info.underflow[HOOK_LOCAL_IN],
-	       handle->info.underflow[HOOK_FORWARD],
-	       handle->info.underflow[HOOK_LOCAL_OUT],
-	       handle->info.underflow[HOOK_POST_ROUTING]);
-
-	ENTRY_ITERATE(handle->entries.entrytable, handle->entries.size,
-		      dump_entry, handle);
-}
-
-/* Returns 0 if not hook entry, else hooknumber + 1 */
-static inline unsigned int
-is_hook_entry(STRUCT_ENTRY *e, TC_HANDLE_T h)
-{
-	unsigned int i;
-
-	for (i = 0; i < NUMHOOKS; i++) {
-		if ((h->info.valid_hooks & (1 << i))
-		    && get_entry(h, h->info.hook_entry[i]) == e)
-			return i+1;
-	}
-	return 0;
-}
-
-
-static int alphasort(const void *a, const void *b)
-{
-	return strcmp(((struct chain_cache *)a)->name,
-		      ((struct chain_cache *)b)->name);
-}
-#endif
-
-/* Does this chain exist? */
-int TC_IS_CHAIN(const char *chain, const TC_HANDLE_T handle)
-{
-	return find_label(chain, handle) != NULL;
-}
-
-#if 0
-/* Returns the position of the final (ie. unconditional) element. */
-static unsigned int
-get_chain_end(const TC_HANDLE_T handle, unsigned int start)
-{
-	unsigned int last_off, off;
-	STRUCT_ENTRY *e;
-
-	last_off = start;
-	e = get_entry(handle, start);
-
-	/* Terminate when we meet a error label or a hook entry. */
-	for (off = start + e->next_offset;
-	     off < handle->entries.size;
-	     last_off = off, off += e->next_offset) {
-		STRUCT_ENTRY_TARGET *t;
-		unsigned int i;
-
-		e = get_entry(handle, off);
-
-		/* We hit an entry point. */
-		for (i = 0; i < NUMHOOKS; i++) {
-			if ((handle->info.valid_hooks & (1 << i))
-			    && off == handle->info.hook_entry[i])
-				return last_off;
-		}
-
-		/* We hit a user chain label */
-		t = GET_TARGET(e);
-		if (strcmp(t->u.user.name, ERROR_TARGET) == 0)
-			return last_off;
-	}
-	/* SHOULD NEVER HAPPEN */
-	fprintf(stderr, "ERROR: Off end (%u) of chain from %u!\n",
-		handle->entries.size, off);
-	abort();
-}
-#endif
-
-/* Iterator functions to run through the chains. */
-const char *
-TC_FIRST_CHAIN(TC_HANDLE_T *handle)
-{
-	struct chain_head *firsthead = list_entry((*handle)->chains.next,
-						   struct chain_head, list);
-	(*handle)->chain_iterator_cur = firsthead;
-
-	return firsthead->name;
-}
-
-/* Iterator functions to run through the chains.  Returns NULL at end. */
-const char *
-TC_NEXT_CHAIN(TC_HANDLE_T *handle)
-{
-	struct chain_head *next = list_entry(&(*handle)->chain_iterator_cur->list.next, struct chain_head, list);
-	(*handle)->chain_iterator_cur = next;
-
-	if (&next->list == &(*handle)->chains)
-		return NULL;
-
-	return next->name;
-}
-
-/* Get first rule in the given chain: NULL for empty chain. */
-const STRUCT_ENTRY *
-TC_FIRST_RULE(const char *chain, TC_HANDLE_T *handle)
-{
-	struct chain_head *c;
-	struct rule_head *r;
-
-	c = find_label(chain, *handle);
-	if (!c) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	/* Empty chain: single return/policy rule */
-	if (list_empty(&c->rules))
-		return NULL;
-
-	r = list_entry(c->rules.next, struct rule_head, list);
-	(*handle)->rule_iterator_cur = r;
-
-	return r->entry;
-}
-
-/* Returns NULL when rules run out. */
-const STRUCT_ENTRY *
-TC_NEXT_RULE(const STRUCT_ENTRY *prev, TC_HANDLE_T *handle)
-{
-	struct rule_head *r = list_entry((*handle)->rule_iterator_cur->list.next, struct rule_head, list);
-
-	if (&r->list == &r->chain->rules)
-		return NULL;
-
-	/* NOTE: prev is without any influence ! */
-	return r->entry;
-}
-
-#if 0
-/* How many rules in this chain? */
-unsigned int
-TC_NUM_RULES(const char *chain, TC_HANDLE_T *handle)
-{
-	unsigned int off = 0;
-	STRUCT_ENTRY *start, *end;
-
-	CHECK(*handle);
-	if (!find_label(&off, chain, *handle)) {
-		errno = ENOENT;
-		return (unsigned int)-1;
-	}
-
-	start = get_entry(*handle, off);
-	end = get_entry(*handle, get_chain_end(*handle, off));
-
-	return entry2index(*handle, end) - entry2index(*handle, start);
-}
-
-/* Get n'th rule in this chain. */
-const STRUCT_ENTRY *TC_GET_RULE(const char *chain,
-				unsigned int n,
-				TC_HANDLE_T *handle)
-{
-	unsigned int pos = 0, chainindex;
-
-	CHECK(*handle);
-	if (!find_label(&pos, chain, *handle)) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	chainindex = entry2index(*handle, get_entry(*handle, pos));
-
-	return index2entry(*handle, chainindex + n);
-}
-#endif
-
-static const char *
-target_name(TC_HANDLE_T handle, const STRUCT_ENTRY *ce)
-{
-	int spos;
-
-	/* To avoid const warnings */
-	STRUCT_ENTRY *e = (STRUCT_ENTRY *)ce;
-
-	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) != 0)
-		return GET_TARGET(e)->u.user.name;
-
-	/* Standard target: evaluate */
-	spos = *(int *)GET_TARGET(e)->data;
-	if (spos < 0) {
-		if (spos == RETURN)
-			return LABEL_RETURN;
-		else if (spos == -NF_ACCEPT-1)
-			return LABEL_ACCEPT;
-		else if (spos == -NF_DROP-1)
-			return LABEL_DROP;
-		else if (spos == -NF_QUEUE-1)
-			return LABEL_QUEUE;
-
-		fprintf(stderr, "ERROR: entry %p not a valid target (%d)\n",
-			e, spos);
-		abort();
-	}
-
-#if 0
-//	jumpto = get_entry(handle, spos);
-
-	/* Fall through rule */
-	if (jumpto == (void *)e + e->next_offset)
-		return "";
-
-	/* Must point to head of a chain: ie. after error rule */
-	/* FIXME: this needs to deal with internal jump targets */
-	labelidx = entry2index(handle, jumpto) - 1;
-	return get_errorlabel(handle, index2offset(handle, labelidx));
-#endif
-	return "";
-}
-
-/* Returns a pointer to the target name of this position. */
-const char *TC_GET_TARGET(const STRUCT_ENTRY *e,
-			  TC_HANDLE_T *handle)
-{
-	return target_name(*handle, e);
-}
-
-/* Is this a built-in chain?  Actually returns hook + 1. */
-int
-TC_BUILTIN(const char *chain, const TC_HANDLE_T handle)
-{
-	unsigned int i;
-
-	for (i = 0; i < NUMHOOKS; i++) {
-		if ((handle->info.valid_hooks & (1 << i))
-		    && handle->hooknames[i]
-		    && strcmp(handle->hooknames[i], chain) == 0)
-			return i+1;
-	}
-	return 0;
-}
-
-/* Get the policy of a given built-in chain */
-const char *
-TC_GET_POLICY(const char *chain,
-	      STRUCT_COUNTERS *counters,
-	      TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_head *chainh;
-	struct rule_head *ruleh;
-	int hook;
-
-	hook = TC_BUILTIN(chain, *handle);
-	if (hook == 0)
-		return NULL;
-
-	chainh = find_label(chain, *handle);
-	if (!chainh) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	ruleh = chainh->lastrule;
-
-	e = ruleh->entry;
-	*counters = e->counters;
-
-	return target_name(*handle, e);
-}
-
-#if 0
-static int
-correct_verdict(STRUCT_ENTRY *e,
-		char *base,
-		unsigned int offset, int delta_offset)
-{
-	STRUCT_STANDARD_TARGET *t = (void *)GET_TARGET(e);
-	unsigned int curr = (char *)e - base;
-
-	/* Trap: insert of fall-through rule.  Don't change fall-through
-	   verdict to jump-over-next-rule. */
-	if (strcmp(t->target.u.user.name, STANDARD_TARGET) == 0
-	    && t->verdict > (int)offset
-	    && !(curr == offset &&
-		 t->verdict == curr + e->next_offset)) {
-		t->verdict += delta_offset;
-	}
-
-	return 0;
-}
-
-/* Adjusts standard verdict jump positions after an insertion/deletion. */
-static int
-set_verdict(unsigned int offset, int delta_offset, TC_HANDLE_T *handle)
-{
-	ENTRY_ITERATE((*handle)->entries.entrytable,
-		      (*handle)->entries.size,
-		      correct_verdict, (char *)(*handle)->entries.entrytable,
-		      offset, delta_offset);
-
-	set_changed(*handle);
-	return 1;
-}
-#endif
-
-
-
-static int
-standard_map(STRUCT_ENTRY *e, int verdict)
-{
-	STRUCT_STANDARD_TARGET *t;
-
-	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-
-	if (t->target.u.target_size
-	    != ALIGN(sizeof(STRUCT_STANDARD_TARGET))) {
-		errno = EINVAL;
-		return 0;
-	}
-	/* memset for memcmp convenience on delete/replace */
-	memset(t->target.u.user.name, 0, FUNCTION_MAXNAMELEN);
-	strcpy(t->target.u.user.name, STANDARD_TARGET);
-	t->verdict = verdict;
-
-	return 1;
-}
-
-static int
-map_target(const TC_HANDLE_T handle,
-	   STRUCT_ENTRY *e,
-	   unsigned int offset,
-	   STRUCT_ENTRY_TARGET *old)
-{
-	STRUCT_ENTRY_TARGET *t = (STRUCT_ENTRY_TARGET *)GET_TARGET(e);
-
-	/* Save old target (except data, which we don't change, except for
-	   standard case, where we don't care). */
-	*old = *t;
-
-	/* Maybe it's empty (=> fall through) */
-	if (strcmp(t->u.user.name, "") == 0)
-		return standard_map(e, offset + e->next_offset);
-	/* Maybe it's a standard target name... */
-	else if (strcmp(t->u.user.name, LABEL_ACCEPT) == 0)
-		return standard_map(e, -NF_ACCEPT - 1);
-	else if (strcmp(t->u.user.name, LABEL_DROP) == 0)
-		return standard_map(e, -NF_DROP - 1);
-	else if (strcmp(t->u.user.name, LABEL_QUEUE) == 0)
-		return standard_map(e, -NF_QUEUE - 1);
-	else if (strcmp(t->u.user.name, LABEL_RETURN) == 0)
-		return standard_map(e, RETURN);
-	else if (TC_BUILTIN(t->u.user.name, handle)) {
-		/* Can't jump to builtins. */
-		errno = EINVAL;
-		return 0;
-	} else {
-		/* Maybe it's an existing chain name. */
-		struct chain_head *c;
-
-#if 0
-		/* FIXME */
-		c = find_label(t->u.user.name, handle);
-		if (c)
-			return standard_map(e, c->start_off);
-#endif
-	}
-
-	/* Must be a module?  If not, kernel will reject... */
-	/* memset to all 0 for your memcmp convenience. */
-	memset(t->u.user.name + strlen(t->u.user.name),
-	       0,
-	       FUNCTION_MAXNAMELEN - strlen(t->u.user.name));
-	return 1;
-}
-
-static void
-unmap_target(STRUCT_ENTRY *e, STRUCT_ENTRY_TARGET *old)
-{
-	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
-
-	/* Save old target (except data, which we don't change, except for
-	   standard case, where we don't care). */
-	*t = *old;
-}
-
-static struct rule_head *
-ruleh_get_n(struct chain_head *chead, int rulenum) 
-{
-	int i = 0;
-	struct list_head *list;
-
-	
-	list_for_each(list, &chead->rules) {
-		struct rule_head *rhead = list_entry(list, struct rule_head, 
-							list);
-		i++;
-		if (i == rulenum)
-			return rhead;
-	}
-	return NULL;
-}
-
-/* Insert the entry `e' in chain `chain' into position `rulenum'. */
-int
-TC_INSERT_ENTRY(const IPT_CHAINLABEL chain,
-		const STRUCT_ENTRY *e,
-		unsigned int rulenum,
-		TC_HANDLE_T *handle)
-{
-	struct chain_head *c;
-	struct rule_head *prev;
-
-	iptc_fn = TC_INSERT_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	prev = ruleh_get_n(c, rulenum-1);
-	if (!prev) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	if (append_entrycopy(e, prev))
-		return 1;
-
-	return 0;
-}
-
-/* Atomically replace rule `rulenum' in `chain' with `fw'. */
-int
-TC_REPLACE_ENTRY(const IPT_CHAINLABEL chain,
-		 const STRUCT_ENTRY *e,
-		 unsigned int rulenum,
-		 TC_HANDLE_T *handle)
-{
-	struct chain_head *c;
-	struct rule_head *repl;
-
-	iptc_fn = TC_REPLACE_ENTRY;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	repl = ruleh_get_n(c, rulenum);
-	if (!repl) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	if (!append_entrycopy(e, repl)) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	ruleh_free(repl);
-	return 1;
-}
-
-/* Append entry `e' to chain `chain'.  Equivalent to insert with
-   rulenum = length of chain. */
-int
-TC_APPEND_ENTRY(const IPT_CHAINLABEL chain,
-		const STRUCT_ENTRY *e,
-		TC_HANDLE_T *handle)
-{
-	struct chain_head *c;
-	struct rule_head *rhead;
-
-	iptc_fn = TC_APPEND_ENTRY;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	rhead = list_entry(c->rules.prev, struct rule_head, list);
-	if(append_entrycopy(e, rhead))
-		return 1;
-	
-	return 0;
-}
-
-static inline int
-match_different(const STRUCT_ENTRY_MATCH *a,
-		const unsigned char *a_elems,
-		const unsigned char *b_elems,
-		unsigned char **maskptr)
-{
-	const STRUCT_ENTRY_MATCH *b;
-	unsigned int i;
-
-	/* Offset of b is the same as a. */
-	b = (void *)b_elems + ((unsigned char *)a - a_elems);
-
-	if (a->u.match_size != b->u.match_size)
-		return 1;
-
-	if (strcmp(a->u.user.name, b->u.user.name) != 0)
-		return 1;
-
-	*maskptr += ALIGN(sizeof(*a));
-
-	for (i = 0; i < a->u.match_size - ALIGN(sizeof(*a)); i++)
-		if (((a->data[i] ^ b->data[i]) & (*maskptr)[i]) != 0)
-			return 1;
-	*maskptr += i;
-	return 0;
-}
-
-static inline int
-target_different(const unsigned char *a_targdata,
-		 const unsigned char *b_targdata,
-		 unsigned int tdatasize,
-		 const unsigned char *mask)
-{
-	unsigned int i;
-	for (i = 0; i < tdatasize; i++)
-		if (((a_targdata[i] ^ b_targdata[i]) & mask[i]) != 0)
-			return 1;
-
-	return 0;
-}
-
-static int
-is_same(const STRUCT_ENTRY *a,
-	const STRUCT_ENTRY *b,
-	unsigned char *matchmask);
-
-/* Delete the first rule in `chain' which matches `origfw'. */
-int
-TC_DELETE_ENTRY(const IPT_CHAINLABEL chain,
-		const STRUCT_ENTRY *origfw,
-		unsigned char *matchmask,
-		TC_HANDLE_T *handle)
-{
-	struct chain_head *c;
-	struct list_head *cur, *cur2;
-
-	iptc_fn = TC_DELETE_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	list_for_each_safe(cur, cur2, &c->rules) {
-		struct rule_head *rhead = list_entry(cur, struct rule_head, 
-							list);
-		if (is_same(rhead->entry, origfw, matchmask)) {
-			ruleh_free(rhead);
-			return 1;
-		}
-	}
-
-	errno = ENOENT;
-	return 0;
-}
-
-/* Delete the rule in position `rulenum' in `chain'. */
-int
-TC_DELETE_NUM_ENTRY(const IPT_CHAINLABEL chain,
-		    unsigned int rulenum,
-		    TC_HANDLE_T *handle)
-{
-	struct chain_head *chainh;
-	struct rule_head *rhead;
-
-	iptc_fn = TC_DELETE_NUM_ENTRY;
-
-	if (!(chainh = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	rhead = ruleh_get_n(chainh, rulenum);
-	if (!rhead) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	ruleh_free(rhead);
-
-	return 1;
-}
-
-/* Check the packet `fw' on chain `chain'.  Returns the verdict, or
-   NULL and sets errno. */
-const char *
-TC_CHECK_PACKET(const IPT_CHAINLABEL chain,
-		STRUCT_ENTRY *entry,
-		TC_HANDLE_T *handle)
-{
-	errno = ENOSYS;
-	return NULL;
-}
-
-/* Flushes the entries in the given chain (ie. empties chain). */
-int
-TC_FLUSH_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	struct list_head *cur, *cur2;
-	struct chain_head *chainh;
-
-	if (!(chainh = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	list_for_each_safe(cur, cur2, &chainh->rules) {
-		struct rule_head *ruleh = list_entry(cur, struct rule_head, 
-							list);
-		/* don't free the entry and policy/return entries */
-		if (ruleh != chainh->firstrule && ruleh != chainh->lastrule)
-			ruleh_free(ruleh);
-	}
-	return 1;
-}
-
-/* Zeroes the counters in a chain. */
-int
-TC_ZERO_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	struct chain_head *c;
-	struct list_head *cur;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	list_for_each(cur, c->rules.next) {
-		struct rule_head *r = list_entry(cur, struct rule_head, list);
-		if (r->counter_map.maptype == COUNTER_MAP_NORMAL_MAP)
-			r->counter_map.maptype = COUNTER_MAP_ZEROED;
-	}
-	set_changed(*handle);
-
-	return 1;
-}
-
-STRUCT_COUNTERS *
-TC_READ_COUNTER(const IPT_CHAINLABEL chain,
-		unsigned int rulenum,
-		TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_head *c;
-	struct rule_head *r;
-
-	iptc_fn = TC_READ_COUNTER;
-	CHECK(*handle);
-
-	if (!(c = find_label(chain, *handle) )
-	      || !(r = ruleh_get_n(c, rulenum))) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	return &r->entry->counters;
-}
-
-int
-TC_ZERO_COUNTER(const IPT_CHAINLABEL chain,
-		unsigned int rulenum,
-		TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_head *c;
-	struct rule_head *r;
-	
-	iptc_fn = TC_ZERO_COUNTER;
-	CHECK(*handle);
-
-	if (!(c = find_label(chain, *handle))
-	      || !(r = ruleh_get_n(c, rulenum))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	if (r->counter_map.maptype == COUNTER_MAP_NORMAL_MAP)
-		r->counter_map.maptype = COUNTER_MAP_ZEROED;
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-int 
-TC_SET_COUNTER(const IPT_CHAINLABEL chain,
-	       unsigned int rulenum,
-	       STRUCT_COUNTERS *counters,
-	       TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_head *c;
-	struct rule_head *r;
-
-	iptc_fn = TC_SET_COUNTER;
-	CHECK(*handle);
-
-	if (!(c = find_label(chain, *handle))
-	      || !(r = ruleh_get_n(c, rulenum))) {
-		errno = ENOENT;
-		return 0;
-	}
-	
-	r->counter_map.maptype = COUNTER_MAP_SET;
-	memcpy(&r->entry->counters, counters, sizeof(STRUCT_COUNTERS));
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-/* Creates a new chain. */
-/* To create a chain, create two rules: error node and unconditional
- * return. */
-int
-TC_CREATE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	int ret;
-	struct chainstart {
-		STRUCT_ENTRY head;
-		struct ipt_error_target name;
-	} *newc1;
-	struct chainend {
-		STRUCT_ENTRY ret;
-		STRUCT_STANDARD_TARGET target;
-	} *newc2;
-	struct rule_head *newr1, *newr2;
-	struct chain_head *chead;
-
-	iptc_fn = TC_CREATE_CHAIN;
-
-	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
-           QUEUE, RETURN. */
-	if (find_label(chain, *handle)
-	    || strcmp(chain, LABEL_DROP) == 0
-	    || strcmp(chain, LABEL_ACCEPT) == 0
-	    || strcmp(chain, LABEL_QUEUE) == 0
-	    || strcmp(chain, LABEL_RETURN) == 0) {
-		errno = EEXIST;
-		return 0;
-	}
-
-	if (strlen(chain)+1 > sizeof(IPT_CHAINLABEL)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	chead = chainh_alloc(*handle, chain);
-	if (!chead) {
-		errno = ENOMEM;
-		return 0;
-	}
-	
-	newr1 = ruleh_alloc(sizeof(*newc1));
-	if (!newr1) {
-		chainh_free(chead);
-		return 0;
-	}
-	newc1 = (struct chainstart *) newr1->entry;
-
-	newr2 = ruleh_alloc(sizeof(*newc2));
-	if (!newr2) {
-		chainh_free(chead);
-		ruleh_free(newr1);
-		return 0;
-	}
-	newc2 = (struct chainend *) newr2->entry;
-
-	newc1->head.target_offset = sizeof(STRUCT_ENTRY);
-	newc1->head.next_offset
-		= sizeof(STRUCT_ENTRY)
-		+ ALIGN(sizeof(struct ipt_error_target));
-	strcpy(newc1->name.t.u.user.name, ERROR_TARGET);
-	newc1->name.t.u.target_size = ALIGN(sizeof(struct ipt_error_target));
-	strcpy(newc1->name.error, chain);
-
-	newc2->ret.target_offset = sizeof(STRUCT_ENTRY);
-	newc2->ret.next_offset
-		= sizeof(STRUCT_ENTRY)
-		+ ALIGN(sizeof(STRUCT_STANDARD_TARGET));
-	strcpy(newc2->target.target.u.user.name, STANDARD_TARGET);
-	newc2->target.target.u.target_size
-		= ALIGN(sizeof(STRUCT_STANDARD_TARGET));
-	newc2->target.verdict = RETURN;
-
-	list_prepend(&newr1->list, &chead->rules);
-	chead->firstrule = newr1;
-	list_append(&newr2->list, &chead->rules);
-	chead->lastrule = newr2;
-
-	return 1;
-}
-
-#if 0
-static int
-count_ref(STRUCT_ENTRY *e, unsigned int offset, unsigned int *ref)
-{
-	STRUCT_STANDARD_TARGET *t;
-
-	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) == 0) {
-		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-
-		if (t->verdict == offset)
-			(*ref)++;
-	}
-
-	return 0;
-}
-
-/* Get the number of references to this chain. */
-int
-TC_GET_REFERENCES(unsigned int *ref, const IPT_CHAINLABEL chain,
-		  TC_HANDLE_T *handle)
-{
-	struct chain_cache *c;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	*ref = 0;
-	ENTRY_ITERATE((*handle)->entries.entrytable,
-		      (*handle)->entries.size,
-		      count_ref, c->start_off, ref);
-	return 1;
-}
-#endif
-
-static unsigned int
-count_rules(struct chain_head *chainh)
-{
-	unsigned int numrules = 0;
-	struct list_head *cur;
-
-	list_for_each(cur, &chainh->rules) {
-		numrules++;
-	}
-
-	if (numrules <=2)
-		return 0;
-	else
-		return numrules-2;
-}
-
-/* Deletes a chain. */
-int
-TC_DELETE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	unsigned int references;
-	struct chain_head *chainh;
-
-#if 0
-	if (!TC_GET_REFERENCES(&references, chain, handle))
-		return 0;
-
-	iptc_fn = TC_DELETE_CHAIN;
-
-	if (TC_BUILTIN(chain, *handle)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	if (references > 0) {
-		errno = EMLINK;
-		return 0;
-	}
-#endif 
-
-	if (!(chainh = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	if (!(count_rules(chainh) == 0)) {
-		errno = ENOTEMPTY;
-		return 0;
-	}
-
-	chainh_free(chainh);
-	return 1;
-}
-
-/* Renames a chain. */
-int TC_RENAME_CHAIN(const IPT_CHAINLABEL oldname,
-		    const IPT_CHAINLABEL newname,
-		    TC_HANDLE_T *handle)
-{
-	struct chain_head *c;
-	struct rule_head *ruleh;
-	struct ipt_error_target *t;
-
-	iptc_fn = TC_RENAME_CHAIN;
-
-	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
-           QUEUE, RETURN. */
-	if (find_label(newname, *handle)
-	    || strcmp(newname, LABEL_DROP) == 0
-	    || strcmp(newname, LABEL_ACCEPT) == 0
-	    || strcmp(newname, LABEL_QUEUE) == 0
-	    || strcmp(newname, LABEL_RETURN) == 0) {
-		errno = EEXIST;
-		return 0;
-	}
-
-	if (!(c = find_label(oldname, *handle))
-	    || TC_BUILTIN(oldname, *handle)) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	if (strlen(newname)+1 > sizeof(IPT_CHAINLABEL)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	ruleh = list_entry(&c->rules.next, struct rule_head, list);
-
-	t = (struct ipt_error_target *)
-		GET_TARGET(ruleh->entry);
-
-	memset(t->error, 0, sizeof(t->error));
-	strcpy(t->error, newname);
-
-	return 1;
-}
-
-/* Sets the policy on a built-in chain. */
-int
-TC_SET_POLICY(const IPT_CHAINLABEL chain,
-	      const IPT_CHAINLABEL policy,
-	      STRUCT_COUNTERS *counters,
-	      TC_HANDLE_T *handle)
-{
-	int ctrindex;
-	unsigned int hook;
-	struct chain_head *chainh;
-	struct rule_head *policyrh;
-	STRUCT_ENTRY *e;
-	STRUCT_STANDARD_TARGET *t;
-
-	iptc_fn = TC_SET_POLICY;
-	/* Figure out which chain. */
-	hook = TC_BUILTIN(chain, *handle);
-	if (hook == 0) {
-		errno = ENOENT;
-		return 0;
-	} else
-		hook--;
-
-	if (!(chainh = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	policyrh = chainh->lastrule;
-	if (policyrh) {
-		printf("ERROR: Policy for `%s' non-existant", chain);
-		return 0;
-	}
-
-	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(policyrh->entry);
-
-	if (strcmp(policy, LABEL_ACCEPT) == 0)
-		t->verdict = -NF_ACCEPT - 1;
-	else if (strcmp(policy, LABEL_DROP) == 0)
-		t->verdict = -NF_DROP - 1;
-	else {
-		errno = EINVAL;
-		return 0;
-	}
-
-	ctrindex = entry2index(*handle, e);
-
-	if (counters) {
-		/* set byte and packet counters */
-		memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
-
-		policyrh->counter_map.maptype = COUNTER_MAP_SET;
-
-	} else {
-		policyrh->counter_map.maptype = COUNTER_MAP_NOMAP;
-		policyrh->counter_map.mappos = 0;
-	}
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-/* Without this, on gcc 2.7.2.3, we get:
-   libiptc.c: In function `TC_COMMIT':
-   libiptc.c:833: fixed or forbidden register was spilled.
-   This may be due to a compiler bug or to impossible asm
-   statements or clauses.
-*/
-static void
-subtract_counters(STRUCT_COUNTERS *answer,
-		  const STRUCT_COUNTERS *a,
-		  const STRUCT_COUNTERS *b)
-{
-	answer->pcnt = a->pcnt - b->pcnt;
-	answer->bcnt = a->bcnt - b->bcnt;
-}
-
-int
-TC_COMMIT(TC_HANDLE_T *handle)
-{
-	/* Replace, then map back the counters. */
-	STRUCT_REPLACE *repl;
-	STRUCT_COUNTERS_INFO *newcounters;
-	unsigned int i;
-	size_t counterlen;
-
-	CHECK(*handle);
-
-	counterlen = sizeof(STRUCT_COUNTERS_INFO)
-			+ sizeof(STRUCT_COUNTERS) * (*handle)->new_number;
-
-#if 0
-	TC_DUMP_ENTRIES(*handle);
-#endif
-
-	/* Don't commit if nothing changed. */
-	if (!(*handle)->changed)
-		goto finished;
-
-	repl = malloc(sizeof(*repl) + (*handle)->entries.size);
-	if (!repl) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	/* These are the old counters we will get from kernel */
-	repl->counters = malloc(sizeof(STRUCT_COUNTERS)
-				* (*handle)->info.num_entries);
-	if (!repl->counters) {
-		free(repl);
-		errno = ENOMEM;
-		return 0;
-	}
-
-	/* These are the counters we're going to put back, later. */
-	newcounters = malloc(counterlen);
-	if (!newcounters) {
-		free(repl->counters);
-		free(repl);
-		errno = ENOMEM;
-		return 0;
-	}
-
-	strcpy(repl->name, (*handle)->info.name);
-	repl->num_entries = (*handle)->new_number;
-	repl->size = (*handle)->entries.size;
-	memcpy(repl->hook_entry, (*handle)->info.hook_entry,
-	       sizeof(repl->hook_entry));
-	memcpy(repl->underflow, (*handle)->info.underflow,
-	       sizeof(repl->underflow));
-	repl->num_counters = (*handle)->info.num_entries;
-	repl->valid_hooks = (*handle)->info.valid_hooks;
-	memcpy(repl->entries, (*handle)->entries.entrytable,
-	       (*handle)->entries.size);
-
-	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_REPLACE, repl,
-		       sizeof(*repl) + (*handle)->entries.size) < 0) {
-		free(repl->counters);
-		free(repl);
-		free(newcounters);
-		return 0;
-	}
-
-	/* Put counters back. */
-	strcpy(newcounters->name, (*handle)->info.name);
-	newcounters->num_counters = (*handle)->new_number;
-	for (i = 0; i < (*handle)->new_number; i++) {
-		unsigned int mappos = (*handle)->counter_map[i].mappos;
-		switch ((*handle)->counter_map[i].maptype) {
-		case COUNTER_MAP_NOMAP:
-			newcounters->counters[i]
-				= ((STRUCT_COUNTERS){ 0, 0 });
-			break;
-
-		case COUNTER_MAP_NORMAL_MAP:
-			/* Original read: X.
-			 * Atomic read on replacement: X + Y.
-			 * Currently in kernel: Z.
-			 * Want in kernel: X + Y + Z.
-			 * => Add in X + Y
-			 * => Add in replacement read.
-			 */
-			newcounters->counters[i] = repl->counters[mappos];
-			break;
-
-		case COUNTER_MAP_ZEROED:
-			/* Original read: X.
-			 * Atomic read on replacement: X + Y.
-			 * Currently in kernel: Z.
-			 * Want in kernel: Y + Z.
-			 * => Add in Y.
-			 * => Add in (replacement read - original read).
-			 */
-			subtract_counters(&newcounters->counters[i],
-					  &repl->counters[mappos],
-					  &index2entry(*handle, i)->counters);
-			break;
-
-		case COUNTER_MAP_SET:
-			/* Want to set counter (iptables-restore) */
-
-			memcpy(&newcounters->counters[i],
-			       &index2entry(*handle, i)->counters,
-			       sizeof(STRUCT_COUNTERS));
-
-			break;
-		}
-	}
-
-#ifdef KERNEL_64_USERSPACE_32
-	{
-		/* Kernel will think that pointer should be 64-bits, and get
-		   padding.  So we accomodate here (assumption: alignment of
-		   `counters' is on 64-bit boundary). */
-		u_int64_t *kernptr = (u_int64_t *)&newcounters->counters;
-		if ((unsigned long)&newcounters->counters % 8 != 0) {
-			fprintf(stderr,
-				"counters alignment incorrect! Mail rusty!\n");
-			abort();
-		}
-		*kernptr = newcounters->counters;
-	}
-#endif /* KERNEL_64_USERSPACE_32 */
-
-	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_ADD_COUNTERS,
-		       newcounters, counterlen) < 0) {
-		free(repl->counters);
-		free(repl);
-		free(newcounters);
-		return 0;
-	}
-
-	free(repl->counters);
-	free(repl);
-	free(newcounters);
-
- finished:
-	TC_FREE(handle);
-	return 1;
-}
-
-/* Get raw socket. */
-int
-TC_GET_RAW_SOCKET()
-{
-	return sockfd;
-}
-
-/* Translates errno numbers into more human-readable form than strerror. */
-const char *
-TC_STRERROR(int err)
-{
-	unsigned int i;
-	struct table_struct {
-		void *fn;
-		int err;
-		const char *message;
-	} table [] =
-	  { { TC_INIT, EPERM, "Permission denied (you must be root)" },
-	    { TC_INIT, EINVAL, "Module is wrong version" },
-	    { TC_INIT, ENOENT, 
-		    "Table does not exist (do you need to insmod?)" },
-	    { TC_DELETE_CHAIN, ENOTEMPTY, "Chain is not empty" },
-	    { TC_DELETE_CHAIN, EINVAL, "Can't delete built-in chain" },
-	    { TC_DELETE_CHAIN, EMLINK,
-	      "Can't delete chain with references left" },
-	    { TC_CREATE_CHAIN, EEXIST, "Chain already exists" },
-	    { TC_INSERT_ENTRY, E2BIG, "Index of insertion too big" },
-	    { TC_REPLACE_ENTRY, E2BIG, "Index of replacement too big" },
-	    { TC_DELETE_NUM_ENTRY, E2BIG, "Index of deletion too big" },
-	    { TC_READ_COUNTER, E2BIG, "Index of counter too big" },
-	    { TC_ZERO_COUNTER, E2BIG, "Index of counter too big" },
-	    { TC_INSERT_ENTRY, ELOOP, "Loop found in table" },
-	    { TC_INSERT_ENTRY, EINVAL, "Target problem" },
-	    /* EINVAL for CHECK probably means bad interface. */
-	    { TC_CHECK_PACKET, EINVAL,
-	      "Bad arguments (does that interface exist?)" },
-	    { TC_CHECK_PACKET, ENOSYS,
-	      "Checking will most likely never get implemented" },
-	    /* ENOENT for DELETE probably means no matching rule */
-	    { TC_DELETE_ENTRY, ENOENT,
-	      "Bad rule (does a matching rule exist in that chain?)" },
-	    { TC_SET_POLICY, ENOENT,
-	      "Bad built-in chain name" },
-	    { TC_SET_POLICY, EINVAL,
-	      "Bad policy name" },
-
-	    { NULL, 0, "Incompatible with this kernel" },
-	    { NULL, ENOPROTOOPT, "iptables who? (do you need to insmod?)" },
-	    { NULL, ENOSYS, "Will be implemented real soon.  I promise ;)" },
-	    { NULL, ENOMEM, "Memory allocation problem" },
-	    { NULL, ENOENT, "No chain/target/match by that name" },
-	  };
-
-	for (i = 0; i < sizeof(table)/sizeof(struct table_struct); i++) {
-		if ((!table[i].fn || table[i].fn == iptc_fn)
-		    && table[i].err == err)
-			return table[i].message;
-	}
-
-	return strerror(err);
-}
diff -urN iptables-1.2.9/libiptc2/libiptc.cvs.c iptables-1.2.10/libiptc2/libiptc.cvs.c
--- iptables-1.2.9/libiptc2/libiptc.cvs.c	2003-06-30 21:03:53.000000000 +0200
+++ iptables-1.2.10/libiptc2/libiptc.cvs.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1920 +0,0 @@
-/* Library which manipulates firewall rules.  Version $Revision: 1.40 $ */
-
-/* Architecture of firewall rules is as follows:
- *
- * Chains go INPUT, FORWARD, OUTPUT then user chains.
- * Each user chain starts with an ERROR node.
- * Every chain ends with an unconditional jump: a RETURN for user chains,
- * and a POLICY for built-ins.
- */
-
-/* (C) 1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
- * COPYING for details). 
- * (C) 2000-2003 by the Netfilter Core Team <coreteam@netfilter.org>
- *
- * 2003-Jun-20: Harald Welte <laforge@netfilter.org>:
- *	- Reimplementation of chain cache to use offsets instead of entries
- * 2003-Jun-23: Harald Welte <laforge@netfilter.org>:
- * 	- performance optimization, sponsored by Astaro AG (http://www.astaro.com/)
- * 	  don't rebuild the chain cache after every operation, instead fix it
- * 	  up after a ruleset change.  
- */
-
-#ifndef IPT_LIB_DIR
-#define IPT_LIB_DIR "/usr/local/lib/iptables"
-#endif
-
-#ifndef __OPTIMIZE__
-STRUCT_ENTRY_TARGET *
-GET_TARGET(STRUCT_ENTRY *e)
-{
-	return (void *)e + e->target_offset;
-}
-#endif
-
-static int sockfd = -1;
-static void *iptc_fn = NULL;
-
-static const char *hooknames[]
-= { [HOOK_PRE_ROUTING]  "PREROUTING",
-    [HOOK_LOCAL_IN]     "INPUT",
-    [HOOK_FORWARD]      "FORWARD",
-    [HOOK_LOCAL_OUT]    "OUTPUT",
-    [HOOK_POST_ROUTING] "POSTROUTING",
-#ifdef HOOK_DROPPING
-    [HOOK_DROPPING]	"DROPPING"
-#endif
-};
-
-struct counter_map
-{
-	enum {
-		COUNTER_MAP_NOMAP,
-		COUNTER_MAP_NORMAL_MAP,
-		COUNTER_MAP_ZEROED,
-		COUNTER_MAP_SET
-	} maptype;
-	unsigned int mappos;
-};
-
-/* Convenience structures */
-struct ipt_error_target
-{
-	STRUCT_ENTRY_TARGET t;
-	char error[TABLE_MAXNAMELEN];
-};
-
-struct chain_cache
-{
-	char name[TABLE_MAXNAMELEN];
-	/* This is the first rule in chain. */
-	unsigned int start_off;
-	/* Last rule in chain */
-	unsigned int end_off;
-};
-
-STRUCT_TC_HANDLE
-{
-	/* Have changes been made? */
-	int changed;
-	/* Size in here reflects original state. */
-	STRUCT_GETINFO info;
-
-	struct counter_map *counter_map;
-	/* Array of hook names */
-	const char **hooknames;
-
-	/* Cached position of chain heads (NULL = no cache). */
-	unsigned int cache_num_chains;
-	unsigned int cache_num_builtins;
-	struct chain_cache *cache_chain_heads;
-
-	/* Chain iterator: current chain cache entry. */
-	struct chain_cache *cache_chain_iteration;
-
-	/* Rule iterator: terminal rule */
-	STRUCT_ENTRY *cache_rule_end;
-
-	/* Number in here reflects current state. */
-	unsigned int new_number;
-	STRUCT_GET_ENTRIES entries;
-};
-
-static void
-set_changed(TC_HANDLE_T h)
-{
-	h->changed = 1;
-}
-
-#ifdef IPTC_DEBUG
-static void do_check(TC_HANDLE_T h, unsigned int line);
-#define CHECK(h) do { if (!getenv("IPTC_NO_CHECK")) do_check((h), __LINE__); } while(0)
-#else
-#define CHECK(h)
-#endif
-
-static inline int
-get_number(const STRUCT_ENTRY *i,
-	   const STRUCT_ENTRY *seek,
-	   unsigned int *pos)
-{
-	if (i == seek)
-		return 1;
-	(*pos)++;
-	return 0;
-}
-
-static unsigned int
-entry2index(const TC_HANDLE_T h, const STRUCT_ENTRY *seek)
-{
-	unsigned int pos = 0;
-
-	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-			  get_number, seek, &pos) == 0) {
-		fprintf(stderr, "ERROR: offset %i not an entry!\n",
-			(char *)seek - (char *)h->entries.entrytable);
-		abort();
-	}
-	return pos;
-}
-
-static inline int
-get_entry_n(STRUCT_ENTRY *i,
-	    unsigned int number,
-	    unsigned int *pos,
-	    STRUCT_ENTRY **pe)
-{
-	if (*pos == number) {
-		*pe = i;
-		return 1;
-	}
-	(*pos)++;
-	return 0;
-}
-
-static STRUCT_ENTRY *
-index2entry(TC_HANDLE_T h, unsigned int index)
-{
-	unsigned int pos = 0;
-	STRUCT_ENTRY *ret = NULL;
-
-	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-		      get_entry_n, index, &pos, &ret);
-
-	return ret;
-}
-
-static inline STRUCT_ENTRY *
-get_entry(TC_HANDLE_T h, unsigned int offset)
-{
-	return (STRUCT_ENTRY *)((char *)h->entries.entrytable + offset);
-}
-
-static inline unsigned long
-entry2offset(const TC_HANDLE_T h, const STRUCT_ENTRY *e)
-{
-	return (void *)e - (void *)h->entries.entrytable;
-}
-
-static inline unsigned long
-index2offset(TC_HANDLE_T h, unsigned int index)
-{
-	return entry2offset(h, index2entry(h, index));
-}
-
-static inline STRUCT_ENTRY *
-offset2entry(TC_HANDLE_T h, unsigned int offset)
-{
-	return (STRUCT_ENTRY *) ((void *)h->entries.entrytable+offset);
-}
-
-static inline unsigned int
-offset2index(const TC_HANDLE_T h, unsigned int offset)
-{
-	return entry2index(h, offset2entry(h, offset));
-}
-
-
-static const char *
-get_errorlabel(TC_HANDLE_T h, unsigned int offset)
-{
-	STRUCT_ENTRY *e;
-
-	e = get_entry(h, offset);
-	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) != 0) {
-		fprintf(stderr, "ERROR: offset %u not an error node!\n",
-			offset);
-		abort();
-	}
-
-	return (const char *)GET_TARGET(e)->data;
-}
-
-/* Allocate handle of given size */
-static TC_HANDLE_T
-alloc_handle(const char *tablename, unsigned int size, unsigned int num_rules)
-{
-	size_t len;
-	TC_HANDLE_T h;
-
-	len = sizeof(STRUCT_TC_HANDLE)
-		+ size
-		+ num_rules * sizeof(struct counter_map);
-
-	if ((h = malloc(len)) == NULL) {
-		errno = ENOMEM;
-		return NULL;
-	}
-
-	h->changed = 0;
-	h->cache_num_chains = 0;
-	h->cache_chain_heads = NULL;
-	h->counter_map = (void *)h
-		+ sizeof(STRUCT_TC_HANDLE)
-		+ size;
-	strcpy(h->info.name, tablename);
-	strcpy(h->entries.name, tablename);
-
-	return h;
-}
-
-TC_HANDLE_T
-TC_INIT(const char *tablename)
-{
-	TC_HANDLE_T h;
-	STRUCT_GETINFO info;
-	unsigned int i;
-	int tmp;
-	socklen_t s;
-
-	iptc_fn = TC_INIT;
-
-	if (sockfd != -1) {
-		close(sockfd);
-		sockfd = -1;
-	}
-
-	if (strlen(tablename) >= TABLE_MAXNAMELEN) {
-		errno = EINVAL;
-		return NULL;
-	}
-	
-	sockfd = socket(TC_AF, SOCK_RAW, IPPROTO_RAW);
-	if (sockfd < 0)
-		return NULL;
-
-	s = sizeof(info);
-
-	strcpy(info.name, tablename);
-	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_INFO, &info, &s) < 0)
-		return NULL;
-
-	if ((h = alloc_handle(info.name, info.size, info.num_entries))
-	    == NULL) {
-		close(sockfd);
-		sockfd = -1;
-		return NULL;
-	}
-
-/* Too hard --RR */
-#if 0
-	sprintf(pathname, "%s/%s", IPT_LIB_DIR, info.name);
-	dynlib = dlopen(pathname, RTLD_NOW);
-	if (!dynlib) {
-		errno = ENOENT;
-		return NULL;
-	}
-	h->hooknames = dlsym(dynlib, "hooknames");
-	if (!h->hooknames) {
-		errno = ENOENT;
-		return NULL;
-	}
-#else
-	h->hooknames = hooknames;
-#endif
-
-	/* Initialize current state */
-	h->info = info;
-	h->new_number = h->info.num_entries;
-	for (i = 0; i < h->info.num_entries; i++)
-		h->counter_map[i]
-			= ((struct counter_map){COUNTER_MAP_NORMAL_MAP, i});
-
-	h->entries.size = h->info.size;
-
-	tmp = sizeof(STRUCT_GET_ENTRIES) + h->info.size;
-
-	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_ENTRIES, &h->entries,
-		       &tmp) < 0) {
-		close(sockfd);
-		sockfd = -1;
-		free(h);
-		return NULL;
-	}
-
-	CHECK(h);
-	return h;
-}
-
-void
-TC_FREE(TC_HANDLE_T *h)
-{
-	close(sockfd);
-	sockfd = -1;
-	if ((*h)->cache_chain_heads)
-		free((*h)->cache_chain_heads);
-	free(*h);
-	*h = NULL;
-}
-
-static inline int
-print_match(const STRUCT_ENTRY_MATCH *m)
-{
-	printf("Match name: `%s'\n", m->u.user.name);
-	return 0;
-}
-
-static int dump_entry(STRUCT_ENTRY *e, const TC_HANDLE_T handle);
- 
-void
-TC_DUMP_ENTRIES(const TC_HANDLE_T handle)
-{
-	CHECK(handle);
-
-	printf("libiptc v%s.  %u entries, %u bytes.\n",
-	       IPTABLES_VERSION,
-	       handle->new_number, handle->entries.size);
-	printf("Table `%s'\n", handle->info.name);
-	printf("Hooks: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
-	       handle->info.hook_entry[HOOK_PRE_ROUTING],
-	       handle->info.hook_entry[HOOK_LOCAL_IN],
-	       handle->info.hook_entry[HOOK_FORWARD],
-	       handle->info.hook_entry[HOOK_LOCAL_OUT],
-	       handle->info.hook_entry[HOOK_POST_ROUTING]);
-	printf("Underflows: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
-	       handle->info.underflow[HOOK_PRE_ROUTING],
-	       handle->info.underflow[HOOK_LOCAL_IN],
-	       handle->info.underflow[HOOK_FORWARD],
-	       handle->info.underflow[HOOK_LOCAL_OUT],
-	       handle->info.underflow[HOOK_POST_ROUTING]);
-
-	ENTRY_ITERATE(handle->entries.entrytable, handle->entries.size,
-		      dump_entry, handle);
-}
-
-/* Returns 0 if not hook entry, else hooknumber + 1 */
-static inline unsigned int
-is_hook_entry(STRUCT_ENTRY *e, TC_HANDLE_T h)
-{
-	unsigned int i;
-
-	for (i = 0; i < NUMHOOKS; i++) {
-		if ((h->info.valid_hooks & (1 << i))
-		    && get_entry(h, h->info.hook_entry[i]) == e)
-			return i+1;
-	}
-	return 0;
-}
-
-static inline int
-add_chain(STRUCT_ENTRY *e, TC_HANDLE_T h, STRUCT_ENTRY **prev)
-{
-	unsigned int builtin;
-
-	/* Last entry.  End it. */
-	if (entry2offset(h, e) + e->next_offset == h->entries.size) {
-		/* This is the ERROR node at end of the table */
-		h->cache_chain_heads[h->cache_num_chains-1].end_off = 
-			entry2offset(h, *prev);
-		return 0;
-	}
-
-	/* We know this is the start of a new chain if it's an ERROR
-	   target, or a hook entry point */
-	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) == 0) {
-		/* prev was last entry in previous chain */
-		h->cache_chain_heads[h->cache_num_chains-1].end_off
-			= entry2offset(h, *prev);
-
-		strcpy(h->cache_chain_heads[h->cache_num_chains].name,
-		       (const char *)GET_TARGET(e)->data);
-		h->cache_chain_heads[h->cache_num_chains].start_off
-			= entry2offset(h, (void *)e + e->next_offset);
-		h->cache_num_chains++;
-	} else if ((builtin = is_hook_entry(e, h)) != 0) {
-		if (h->cache_num_chains > 0)
-			/* prev was last entry in previous chain */
-			h->cache_chain_heads[h->cache_num_chains-1].end_off
-				= entry2offset(h, *prev);
-
-		strcpy(h->cache_chain_heads[h->cache_num_chains].name,
-		       h->hooknames[builtin-1]);
-		h->cache_chain_heads[h->cache_num_chains].start_off
-			= entry2offset(h, (void *)e);
-		h->cache_num_chains++;
-	}
-
-	*prev = e;
-	return 0;
-}
-
-static int alphasort(const void *a, const void *b)
-{
-	return strcmp(((struct chain_cache *)a)->name,
-		      ((struct chain_cache *)b)->name);
-}
-
-static int populate_cache(TC_HANDLE_T h)
-{
-	unsigned int i;
-	STRUCT_ENTRY *prev;
-
-	/* # chains < # rules / 2 + num builtins - 1 */
-	h->cache_chain_heads = malloc((h->new_number / 2 + 4)
-				      * sizeof(struct chain_cache));
-	if (!h->cache_chain_heads) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	h->cache_num_chains = 0;
-	h->cache_num_builtins = 0;
-
-	/* Count builtins */
-	for (i = 0; i < NUMHOOKS; i++) {
-		if (h->info.valid_hooks & (1 << i))
-			h->cache_num_builtins++;
-	}
-
-	prev = NULL;
-	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-		      add_chain, h, &prev);
-
-	qsort(h->cache_chain_heads + h->cache_num_builtins,
-	      h->cache_num_chains - h->cache_num_builtins,
-	      sizeof(struct chain_cache), alphasort);
-
-	return 1;
-}
-
-static int 
-correct_cache(TC_HANDLE_T h, unsigned int offset, int delta)
-{
-	int i;		/* needs to be signed because deleting first
-			   chain can make it drop to -1 */
-
-	if (!delta)
-		return 1;
-
-	for (i = 0; i < h->cache_num_chains; i++) {
-		struct chain_cache *cc = &h->cache_chain_heads[i];
-
-		if (delta < 0) {
-			/* take care about deleted chains */
-			if (cc->start_off >= offset+delta
-			    && cc->end_off <= offset) {
-				/* this chain is within the deleted range,
-				 * let's remove it from the cache */
-				void *start;
-				unsigned int size;
-
-				h->cache_num_chains--;
-				if (i+1 >= h->cache_num_chains)
-					continue;
-				start = &h->cache_chain_heads[i+1];
-				size = (h->cache_num_chains-i)
-					* sizeof(struct chain_cache);
-				memmove(cc, start, size);
-
-				/* iterate over same index again, since
-				 * it is now a different chain */
-				i--;
-				continue;
-			}
-		}
-
-		if (cc->start_off > offset)
-			cc->start_off += delta;
-
-		if (cc->end_off >= offset)
-			cc->end_off += delta;
-	}
-	/* HW_FIXME: sorting might be needed, but just in case a new chain was
-	 * added */
-
-	return 1;
-}
-
-static int
-add_chain_cache(TC_HANDLE_T h, const char *name, unsigned int start_off,
-		unsigned int end_off)
-{
-	struct chain_cache *ccs = realloc(h->cache_chain_heads, 
-					  (h->new_number / 2 + 4 + 1)
-					   * sizeof(struct chain_cache));
-	struct chain_cache *newcc;
-	
-	if (!ccs)
-		return 0;
-
-	h->cache_chain_heads = ccs;
-	newcc = &h->cache_chain_heads[h->cache_num_chains];
-	h->cache_num_chains++;
-
-	strncpy(newcc->name, name, TABLE_MAXNAMELEN-1);
-	newcc->start_off = start_off;
-	newcc->end_off = end_off;
-
-	return 1;
-}
-
-/* Returns cache ptr if found, otherwise NULL. */
-static struct chain_cache *
-find_label(const char *name, TC_HANDLE_T handle)
-{
-	unsigned int i;
-
-	if (handle->cache_chain_heads == NULL
-	    && !populate_cache(handle))
-		return NULL;
-
-	/* FIXME: Linear search through builtins, then binary --RR */
-	for (i = 0; i < handle->cache_num_chains; i++) {
-		if (strcmp(handle->cache_chain_heads[i].name, name) == 0)
-			return &handle->cache_chain_heads[i];
-	}
-
-	return NULL;
-}
-
-/* Does this chain exist? */
-int TC_IS_CHAIN(const char *chain, const TC_HANDLE_T handle)
-{
-	return find_label(chain, handle) != NULL;
-}
-
-/* Returns the position of the final (ie. unconditional) element. */
-static unsigned int
-get_chain_end(const TC_HANDLE_T handle, unsigned int start)
-{
-	unsigned int last_off, off;
-	STRUCT_ENTRY *e;
-
-	last_off = start;
-	e = get_entry(handle, start);
-
-	/* Terminate when we meet a error label or a hook entry. */
-	for (off = start + e->next_offset;
-	     off < handle->entries.size;
-	     last_off = off, off += e->next_offset) {
-		STRUCT_ENTRY_TARGET *t;
-		unsigned int i;
-
-		e = get_entry(handle, off);
-
-		/* We hit an entry point. */
-		for (i = 0; i < NUMHOOKS; i++) {
-			if ((handle->info.valid_hooks & (1 << i))
-			    && off == handle->info.hook_entry[i])
-				return last_off;
-		}
-
-		/* We hit a user chain label */
-		t = GET_TARGET(e);
-		if (strcmp(t->u.user.name, ERROR_TARGET) == 0)
-			return last_off;
-	}
-	/* SHOULD NEVER HAPPEN */
-	fprintf(stderr, "ERROR: Off end (%u) of chain from %u!\n",
-		handle->entries.size, off);
-	abort();
-}
-
-/* Iterator functions to run through the chains. */
-const char *
-TC_FIRST_CHAIN(TC_HANDLE_T *handle)
-{
-	if ((*handle)->cache_chain_heads == NULL
-	    && !populate_cache(*handle))
-		return NULL;
-
-	(*handle)->cache_chain_iteration
-		= &(*handle)->cache_chain_heads[0];
-
-	return (*handle)->cache_chain_iteration->name;
-}
-
-/* Iterator functions to run through the chains.  Returns NULL at end. */
-const char *
-TC_NEXT_CHAIN(TC_HANDLE_T *handle)
-{
-	(*handle)->cache_chain_iteration++;
-
-	if ((*handle)->cache_chain_iteration - (*handle)->cache_chain_heads
-	    == (*handle)->cache_num_chains)
-		return NULL;
-
-	return (*handle)->cache_chain_iteration->name;
-}
-
-/* Get first rule in the given chain: NULL for empty chain. */
-const STRUCT_ENTRY *
-TC_FIRST_RULE(const char *chain, TC_HANDLE_T *handle)
-{
-	struct chain_cache *c;
-
-	c = find_label(chain, *handle);
-	if (!c) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	/* Empty chain: single return/policy rule */
-	if (c->start_off == c->end_off)
-		return NULL;
-
-	(*handle)->cache_rule_end = offset2entry(*handle, c->end_off);
-	return offset2entry(*handle, c->start_off);
-}
-
-/* Returns NULL when rules run out. */
-const STRUCT_ENTRY *
-TC_NEXT_RULE(const STRUCT_ENTRY *prev, TC_HANDLE_T *handle)
-{
-	if ((void *)prev + prev->next_offset
-	    == (void *)(*handle)->cache_rule_end)
-		return NULL;
-
-	return (void *)prev + prev->next_offset;
-}
-
-#if 0
-/* How many rules in this chain? */
-unsigned int
-TC_NUM_RULES(const char *chain, TC_HANDLE_T *handle)
-{
-	unsigned int off = 0;
-	STRUCT_ENTRY *start, *end;
-
-	CHECK(*handle);
-	if (!find_label(&off, chain, *handle)) {
-		errno = ENOENT;
-		return (unsigned int)-1;
-	}
-
-	start = get_entry(*handle, off);
-	end = get_entry(*handle, get_chain_end(*handle, off));
-
-	return entry2index(*handle, end) - entry2index(*handle, start);
-}
-
-/* Get n'th rule in this chain. */
-const STRUCT_ENTRY *TC_GET_RULE(const char *chain,
-				unsigned int n,
-				TC_HANDLE_T *handle)
-{
-	unsigned int pos = 0, chainindex;
-
-	CHECK(*handle);
-	if (!find_label(&pos, chain, *handle)) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	chainindex = entry2index(*handle, get_entry(*handle, pos));
-
-	return index2entry(*handle, chainindex + n);
-}
-#endif
-
-static const char *
-target_name(TC_HANDLE_T handle, const STRUCT_ENTRY *ce)
-{
-	int spos;
-	unsigned int labelidx;
-	STRUCT_ENTRY *jumpto;
-
-	/* To avoid const warnings */
-	STRUCT_ENTRY *e = (STRUCT_ENTRY *)ce;
-
-	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) != 0)
-		return GET_TARGET(e)->u.user.name;
-
-	/* Standard target: evaluate */
-	spos = *(int *)GET_TARGET(e)->data;
-	if (spos < 0) {
-		if (spos == RETURN)
-			return LABEL_RETURN;
-		else if (spos == -NF_ACCEPT-1)
-			return LABEL_ACCEPT;
-		else if (spos == -NF_DROP-1)
-			return LABEL_DROP;
-		else if (spos == -NF_QUEUE-1)
-			return LABEL_QUEUE;
-
-		fprintf(stderr, "ERROR: off %lu/%u not a valid target (%i)\n",
-			entry2offset(handle, e), handle->entries.size,
-			spos);
-		abort();
-	}
-
-	jumpto = get_entry(handle, spos);
-
-	/* Fall through rule */
-	if (jumpto == (void *)e + e->next_offset)
-		return "";
-
-	/* Must point to head of a chain: ie. after error rule */
-	labelidx = entry2index(handle, jumpto) - 1;
-	return get_errorlabel(handle, index2offset(handle, labelidx));
-}
-
-/* Returns a pointer to the target name of this position. */
-const char *TC_GET_TARGET(const STRUCT_ENTRY *e,
-			  TC_HANDLE_T *handle)
-{
-	return target_name(*handle, e);
-}
-
-/* Is this a built-in chain?  Actually returns hook + 1. */
-int
-TC_BUILTIN(const char *chain, const TC_HANDLE_T handle)
-{
-	unsigned int i;
-
-	for (i = 0; i < NUMHOOKS; i++) {
-		if ((handle->info.valid_hooks & (1 << i))
-		    && handle->hooknames[i]
-		    && strcmp(handle->hooknames[i], chain) == 0)
-			return i+1;
-	}
-	return 0;
-}
-
-/* Get the policy of a given built-in chain */
-const char *
-TC_GET_POLICY(const char *chain,
-	      STRUCT_COUNTERS *counters,
-	      TC_HANDLE_T *handle)
-{
-	unsigned int start;
-	STRUCT_ENTRY *e;
-	int hook;
-
-	hook = TC_BUILTIN(chain, *handle);
-	if (hook != 0)
-		start = (*handle)->info.hook_entry[hook-1];
-	else
-		return NULL;
-
-	e = get_entry(*handle, get_chain_end(*handle, start));
-	*counters = e->counters;
-
-	return target_name(*handle, e);
-}
-
-static inline int
-correct_verdict(STRUCT_ENTRY *e,
-		char *base,
-		unsigned int offset, int delta_offset)
-{
-	STRUCT_STANDARD_TARGET *t = (void *)GET_TARGET(e);
-	unsigned int curr = (char *)e - base;
-
-	/* Trap: insert of fall-through rule.  Don't change fall-through
-	   verdict to jump-over-next-rule. */
-	if (strcmp(t->target.u.user.name, STANDARD_TARGET) == 0
-	    && t->verdict > (int)offset
-	    && !(curr == offset &&
-		 t->verdict == curr + e->next_offset)) {
-		t->verdict += delta_offset;
-	}
-
-	return 0;
-}
-
-/* Adjusts standard verdict jump positions after an insertion/deletion. */
-static int
-set_verdict(unsigned int offset, int delta_offset, TC_HANDLE_T *handle)
-{
-	ENTRY_ITERATE((*handle)->entries.entrytable,
-		      (*handle)->entries.size,
-		      correct_verdict, (char *)(*handle)->entries.entrytable,
-		      offset, delta_offset);
-
-	set_changed(*handle);
-	return 1;
-}
-
-/* If prepend is set, then we are prepending to a chain: if the
- * insertion position is an entry point, keep the entry point. */
-static int
-insert_rules(unsigned int num_rules, unsigned int rules_size,
-	     const STRUCT_ENTRY *insert,
-	     unsigned int offset, unsigned int num_rules_offset,
-	     int prepend,
-	     TC_HANDLE_T *handle)
-{
-	TC_HANDLE_T newh;
-	STRUCT_GETINFO newinfo;
-	unsigned int i;
-
-	if (offset >= (*handle)->entries.size) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	newinfo = (*handle)->info;
-
-	/* Fix up entry points. */
-	for (i = 0; i < NUMHOOKS; i++) {
-		/* Entry points to START of chain, so keep same if
-                   inserting on at that point. */
-		if ((*handle)->info.hook_entry[i] > offset)
-			newinfo.hook_entry[i] += rules_size;
-
-		/* Underflow always points to END of chain (policy),
-		   so if something is inserted at same point, it
-		   should be advanced. */
-		if ((*handle)->info.underflow[i] >= offset)
-			newinfo.underflow[i] += rules_size;
-	}
-
-	newh = alloc_handle((*handle)->info.name,
-			    (*handle)->entries.size + rules_size,
-			    (*handle)->new_number + num_rules);
-	if (!newh)
-		return 0;
-	newh->info = newinfo;
-
-	/* Copy pre... */
-	memcpy(newh->entries.entrytable, (*handle)->entries.entrytable,offset);
-	/* ... Insert new ... */
-	memcpy((char *)newh->entries.entrytable + offset, insert, rules_size);
-	/* ... copy post */
-	memcpy((char *)newh->entries.entrytable + offset + rules_size,
-	       (char *)(*handle)->entries.entrytable + offset,
-	       (*handle)->entries.size - offset);
-
-	/* Move counter map. */
-	/* Copy pre... */
-	memcpy(newh->counter_map, (*handle)->counter_map,
-	       sizeof(struct counter_map) * num_rules_offset);
-	/* ... copy post */
-	memcpy(newh->counter_map + num_rules_offset + num_rules,
-	       (*handle)->counter_map + num_rules_offset,
-	       sizeof(struct counter_map) * ((*handle)->new_number
-					     - num_rules_offset));
-	/* Set intermediates to no counter copy */
-	for (i = 0; i < num_rules; i++)
-		newh->counter_map[num_rules_offset+i]
-			= ((struct counter_map){ COUNTER_MAP_SET, 0 });
-
-	newh->new_number = (*handle)->new_number + num_rules;
-	newh->entries.size = (*handle)->entries.size + rules_size;
-	newh->hooknames = (*handle)->hooknames;
-
-	newh->cache_chain_heads = (*handle)->cache_chain_heads;
-	newh->cache_num_builtins = (*handle)->cache_num_builtins;
-	newh->cache_num_chains = (*handle)->cache_num_chains;
-	newh->cache_rule_end = (*handle)->cache_rule_end;
-	newh->cache_chain_iteration = (*handle)->cache_chain_iteration;
-	if (!correct_cache(newh, offset, rules_size)) {
-		free(newh);
-		return 0;
-	}
-
-	free(*handle);
-	*handle = newh;
-
-	return set_verdict(offset, rules_size, handle);
-}
-
-static int
-delete_rules(unsigned int num_rules, unsigned int rules_size,
-	     unsigned int offset, unsigned int num_rules_offset,
-	     TC_HANDLE_T *handle)
-{
-	unsigned int i;
-
-	if (offset + rules_size > (*handle)->entries.size) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	/* Fix up entry points. */
-	for (i = 0; i < NUMHOOKS; i++) {
-		/* In practice, we never delete up to a hook entry,
-		   since the built-in chains are always first,
-		   so these two are never equal */
-		if ((*handle)->info.hook_entry[i] >= offset + rules_size)
-			(*handle)->info.hook_entry[i] -= rules_size;
-		else if ((*handle)->info.hook_entry[i] > offset) {
-			fprintf(stderr, "ERROR: Deleting entry %u %u %u\n",
-				i, (*handle)->info.hook_entry[i], offset);
-			abort();
-		}
-
-		/* Underflow points to policy (terminal) rule in
-                   built-in, so sequality is valid here (when deleting
-                   the last rule). */
-		if ((*handle)->info.underflow[i] >= offset + rules_size)
-			(*handle)->info.underflow[i] -= rules_size;
-		else if ((*handle)->info.underflow[i] > offset) {
-			fprintf(stderr, "ERROR: Deleting uflow %u %u %u\n",
-				i, (*handle)->info.underflow[i], offset);
-			abort();
-		}
-	}
-
-	/* Move the rules down. */
-	memmove((char *)(*handle)->entries.entrytable + offset,
-		(char *)(*handle)->entries.entrytable + offset + rules_size,
-		(*handle)->entries.size - (offset + rules_size));
-
-	/* Move the counter map down. */
-	memmove(&(*handle)->counter_map[num_rules_offset],
-		&(*handle)->counter_map[num_rules_offset + num_rules],
-		sizeof(struct counter_map)
-		* ((*handle)->new_number - (num_rules + num_rules_offset)));
-
-	/* Fix numbers */
-	(*handle)->new_number -= num_rules;
-	(*handle)->entries.size -= rules_size;
-
-	/* Fix the chain cache */
-	if (!correct_cache(*handle, offset, -(int)rules_size))
-		return 0;
-
-	return set_verdict(offset, -(int)rules_size, handle);
-}
-
-static int
-standard_map(STRUCT_ENTRY *e, int verdict)
-{
-	STRUCT_STANDARD_TARGET *t;
-
-	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-
-	if (t->target.u.target_size
-	    != ALIGN(sizeof(STRUCT_STANDARD_TARGET))) {
-		errno = EINVAL;
-		return 0;
-	}
-	/* memset for memcmp convenience on delete/replace */
-	memset(t->target.u.user.name, 0, FUNCTION_MAXNAMELEN);
-	strcpy(t->target.u.user.name, STANDARD_TARGET);
-	t->verdict = verdict;
-
-	return 1;
-}
-
-static int
-map_target(const TC_HANDLE_T handle,
-	   STRUCT_ENTRY *e,
-	   unsigned int offset,
-	   STRUCT_ENTRY_TARGET *old)
-{
-	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
-
-	/* Save old target (except data, which we don't change, except for
-	   standard case, where we don't care). */
-	*old = *t;
-
-	/* Maybe it's empty (=> fall through) */
-	if (strcmp(t->u.user.name, "") == 0)
-		return standard_map(e, offset + e->next_offset);
-	/* Maybe it's a standard target name... */
-	else if (strcmp(t->u.user.name, LABEL_ACCEPT) == 0)
-		return standard_map(e, -NF_ACCEPT - 1);
-	else if (strcmp(t->u.user.name, LABEL_DROP) == 0)
-		return standard_map(e, -NF_DROP - 1);
-	else if (strcmp(t->u.user.name, LABEL_QUEUE) == 0)
-		return standard_map(e, -NF_QUEUE - 1);
-	else if (strcmp(t->u.user.name, LABEL_RETURN) == 0)
-		return standard_map(e, RETURN);
-	else if (TC_BUILTIN(t->u.user.name, handle)) {
-		/* Can't jump to builtins. */
-		errno = EINVAL;
-		return 0;
-	} else {
-		/* Maybe it's an existing chain name. */
-		struct chain_cache *c;
-
-		c = find_label(t->u.user.name, handle);
-		if (c)
-			return standard_map(e, c->start_off);
-	}
-
-	/* Must be a module?  If not, kernel will reject... */
-	/* memset to all 0 for your memcmp convenience. */
-	memset(t->u.user.name + strlen(t->u.user.name),
-	       0,
-	       FUNCTION_MAXNAMELEN - strlen(t->u.user.name));
-	return 1;
-}
-
-static void
-unmap_target(STRUCT_ENTRY *e, STRUCT_ENTRY_TARGET *old)
-{
-	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
-
-	/* Save old target (except data, which we don't change, except for
-	   standard case, where we don't care). */
-	*t = *old;
-}
-
-/* Insert the entry `fw' in chain `chain' into position `rulenum'. */
-int
-TC_INSERT_ENTRY(const IPT_CHAINLABEL chain,
-		const STRUCT_ENTRY *e,
-		unsigned int rulenum,
-		TC_HANDLE_T *handle)
-{
-	unsigned int chainindex, offset;
-	STRUCT_ENTRY_TARGET old;
-	struct chain_cache *c;
-	STRUCT_ENTRY *tmp;
-	int ret;
-
-	iptc_fn = TC_INSERT_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-
-	tmp = index2entry(*handle, chainindex + rulenum);
-	if (!tmp || tmp > offset2entry(*handle, c->end_off)) {
-		errno = E2BIG;
-		return 0;
-	}
-	offset = index2offset(*handle, chainindex + rulenum);
-
-	/* Mapping target actually alters entry, but that's
-           transparent to the caller. */
-	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
-		return 0;
-
-	ret = insert_rules(1, e->next_offset, e, offset,
-			   chainindex + rulenum, rulenum == 0, handle);
-	unmap_target((STRUCT_ENTRY *)e, &old);
-	return ret;
-}
-
-/* Atomically replace rule `rulenum' in `chain' with `fw'. */
-int
-TC_REPLACE_ENTRY(const IPT_CHAINLABEL chain,
-		 const STRUCT_ENTRY *e,
-		 unsigned int rulenum,
-		 TC_HANDLE_T *handle)
-{
-	unsigned int chainindex, offset;
-	STRUCT_ENTRY_TARGET old;
-	struct chain_cache *c;
-	STRUCT_ENTRY *tmp;
-	int ret;
-
-	iptc_fn = TC_REPLACE_ENTRY;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-
-	tmp = index2entry(*handle, chainindex + rulenum);
-	if (!tmp || tmp >= offset2entry(*handle, c->end_off)) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	offset = index2offset(*handle, chainindex + rulenum);
-	/* Replace = delete and insert. */
-	if (!delete_rules(1, get_entry(*handle, offset)->next_offset,
-			  offset, chainindex + rulenum, handle))
-		return 0;
-
-	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
-		return 0;
-
-	ret = insert_rules(1, e->next_offset, e, offset,
-			   chainindex + rulenum, 1, handle);
-	unmap_target((STRUCT_ENTRY *)e, &old);
-	return ret;
-}
-
-/* Append entry `fw' to chain `chain'.  Equivalent to insert with
-   rulenum = length of chain. */
-int
-TC_APPEND_ENTRY(const IPT_CHAINLABEL chain,
-		const STRUCT_ENTRY *e,
-		TC_HANDLE_T *handle)
-{
-	struct chain_cache *c;
-	STRUCT_ENTRY_TARGET old;
-	int ret;
-
-	iptc_fn = TC_APPEND_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	if (!map_target(*handle, (STRUCT_ENTRY *)e,
-			c->end_off, &old))
-		return 0;
-
-	ret = insert_rules(1, e->next_offset, e, c->end_off, 
-			   offset2index(*handle, c->end_off), 0, handle);
-	unmap_target((STRUCT_ENTRY *)e, &old);
-	return ret;
-}
-
-static inline int
-match_different(const STRUCT_ENTRY_MATCH *a,
-		const unsigned char *a_elems,
-		const unsigned char *b_elems,
-		unsigned char **maskptr)
-{
-	const STRUCT_ENTRY_MATCH *b;
-	unsigned int i;
-
-	/* Offset of b is the same as a. */
-	b = (void *)b_elems + ((unsigned char *)a - a_elems);
-
-	if (a->u.match_size != b->u.match_size)
-		return 1;
-
-	if (strcmp(a->u.user.name, b->u.user.name) != 0)
-		return 1;
-
-	*maskptr += ALIGN(sizeof(*a));
-
-	for (i = 0; i < a->u.match_size - ALIGN(sizeof(*a)); i++)
-		if (((a->data[i] ^ b->data[i]) & (*maskptr)[i]) != 0)
-			return 1;
-	*maskptr += i;
-	return 0;
-}
-
-static inline int
-target_different(const unsigned char *a_targdata,
-		 const unsigned char *b_targdata,
-		 unsigned int tdatasize,
-		 const unsigned char *mask)
-{
-	unsigned int i;
-	for (i = 0; i < tdatasize; i++)
-		if (((a_targdata[i] ^ b_targdata[i]) & mask[i]) != 0)
-			return 1;
-
-	return 0;
-}
-
-static int
-is_same(const STRUCT_ENTRY *a,
-	const STRUCT_ENTRY *b,
-	unsigned char *matchmask);
-
-/* Delete the first rule in `chain' which matches `fw'. */
-int
-TC_DELETE_ENTRY(const IPT_CHAINLABEL chain,
-		const STRUCT_ENTRY *origfw,
-		unsigned char *matchmask,
-		TC_HANDLE_T *handle)
-{
-	unsigned int offset;
-	struct chain_cache *c;
-	STRUCT_ENTRY *e, *fw;
-
-	iptc_fn = TC_DELETE_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	fw = malloc(origfw->next_offset);
-	if (fw == NULL) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	for (offset = c->start_off; offset < c->end_off;
-	     offset += e->next_offset) {
-		STRUCT_ENTRY_TARGET discard;
-
-		memcpy(fw, origfw, origfw->next_offset);
-
-		/* FIXME: handle this in is_same --RR */
-		if (!map_target(*handle, fw, offset, &discard)) {
-			free(fw);
-			return 0;
-		}
-		e = get_entry(*handle, offset);
-
-#if 0
-		printf("Deleting:\n");
-		dump_entry(newe);
-#endif
-		if (is_same(e, fw, matchmask)) {
-			int ret;
-			ret = delete_rules(1, e->next_offset,
-					   offset, entry2index(*handle, e),
-					   handle);
-			free(fw);
-			return ret;
-		}
-	}
-
-	free(fw);
-	errno = ENOENT;
-	return 0;
-}
-
-/* Delete the rule in position `rulenum' in `chain'. */
-int
-TC_DELETE_NUM_ENTRY(const IPT_CHAINLABEL chain,
-		    unsigned int rulenum,
-		    TC_HANDLE_T *handle)
-{
-	unsigned int index;
-	int ret;
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-
-	iptc_fn = TC_DELETE_NUM_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	index = offset2index(*handle, c->start_off) + rulenum;
-
-	if (index >= offset2index(*handle, c->end_off)) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	e = index2entry(*handle, index);
-	if (e == NULL) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	ret = delete_rules(1, e->next_offset, entry2offset(*handle, e),
-			   index, handle);
-	return ret;
-}
-
-/* Check the packet `fw' on chain `chain'.  Returns the verdict, or
-   NULL and sets errno. */
-const char *
-TC_CHECK_PACKET(const IPT_CHAINLABEL chain,
-		STRUCT_ENTRY *entry,
-		TC_HANDLE_T *handle)
-{
-	errno = ENOSYS;
-	return NULL;
-}
-
-/* Flushes the entries in the given chain (ie. empties chain). */
-int
-TC_FLUSH_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	unsigned int startindex, endindex;
-	STRUCT_ENTRY *startentry, *endentry;
-	struct chain_cache *c;
-	int ret;
-
-	iptc_fn = TC_FLUSH_ENTRIES;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-	startindex = offset2index(*handle, c->start_off);
-	endindex = offset2index(*handle, c->end_off);
-	startentry = offset2entry(*handle, c->start_off);
-	endentry = offset2entry(*handle, c->end_off);
-
-	ret = delete_rules(endindex - startindex,
-			   (char *)endentry - (char *)startentry,
-			   c->start_off, startindex,
-			   handle);
-	return ret;
-}
-
-/* Zeroes the counters in a chain. */
-int
-TC_ZERO_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	unsigned int i, end;
-	struct chain_cache *c;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	i = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	for (; i <= end; i++) {
-		if ((*handle)->counter_map[i].maptype ==COUNTER_MAP_NORMAL_MAP)
-			(*handle)->counter_map[i].maptype = COUNTER_MAP_ZEROED;
-	}
-	set_changed(*handle);
-
-	return 1;
-}
-
-STRUCT_COUNTERS *
-TC_READ_COUNTER(const IPT_CHAINLABEL chain,
-		unsigned int rulenum,
-		TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-	unsigned int chainindex, end;
-
-	iptc_fn = TC_READ_COUNTER;
-	CHECK(*handle);
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	if (chainindex + rulenum > end) {
-		errno = E2BIG;
-		return NULL;
-	}
-
-	e = index2entry(*handle, chainindex + rulenum);
-
-	return &e->counters;
-}
-
-int
-TC_ZERO_COUNTER(const IPT_CHAINLABEL chain,
-		unsigned int rulenum,
-		TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-	unsigned int chainindex, end;
-	
-	iptc_fn = TC_ZERO_COUNTER;
-	CHECK(*handle);
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	if (chainindex + rulenum > end) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	e = index2entry(*handle, chainindex + rulenum);
-
-	if ((*handle)->counter_map[chainindex + rulenum].maptype
-			== COUNTER_MAP_NORMAL_MAP) {
-		(*handle)->counter_map[chainindex + rulenum].maptype
-			 = COUNTER_MAP_ZEROED;
-	}
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-int 
-TC_SET_COUNTER(const IPT_CHAINLABEL chain,
-	       unsigned int rulenum,
-	       STRUCT_COUNTERS *counters,
-	       TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-	unsigned int chainindex, end;
-
-	iptc_fn = TC_SET_COUNTER;
-	CHECK(*handle);
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	if (chainindex + rulenum > end) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	e = index2entry(*handle, chainindex + rulenum);
-
-	(*handle)->counter_map[chainindex + rulenum].maptype
-		= COUNTER_MAP_SET;
-
-	memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-/* Creates a new chain. */
-/* To create a chain, create two rules: error node and unconditional
- * return. */
-int
-TC_CREATE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	int ret;
-	struct {
-		STRUCT_ENTRY head;
-		struct ipt_error_target name;
-		STRUCT_ENTRY ret;
-		STRUCT_STANDARD_TARGET target;
-	} newc;
-	unsigned int destination;
-
-	iptc_fn = TC_CREATE_CHAIN;
-
-	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
-           QUEUE, RETURN. */
-	if (find_label(chain, *handle)
-	    || strcmp(chain, LABEL_DROP) == 0
-	    || strcmp(chain, LABEL_ACCEPT) == 0
-	    || strcmp(chain, LABEL_QUEUE) == 0
-	    || strcmp(chain, LABEL_RETURN) == 0) {
-		errno = EEXIST;
-		return 0;
-	}
-
-	if (strlen(chain)+1 > sizeof(IPT_CHAINLABEL)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	memset(&newc, 0, sizeof(newc));
-	newc.head.target_offset = sizeof(STRUCT_ENTRY);
-	newc.head.next_offset
-		= sizeof(STRUCT_ENTRY)
-		+ ALIGN(sizeof(struct ipt_error_target));
-	strcpy(newc.name.t.u.user.name, ERROR_TARGET);
-	newc.name.t.u.target_size = ALIGN(sizeof(struct ipt_error_target));
-	strcpy(newc.name.error, chain);
-
-	newc.ret.target_offset = sizeof(STRUCT_ENTRY);
-	newc.ret.next_offset
-		= sizeof(STRUCT_ENTRY)
-		+ ALIGN(sizeof(STRUCT_STANDARD_TARGET));
-	strcpy(newc.target.target.u.user.name, STANDARD_TARGET);
-	newc.target.target.u.target_size
-		= ALIGN(sizeof(STRUCT_STANDARD_TARGET));
-	newc.target.verdict = RETURN;
-
-	destination = index2offset(*handle, (*handle)->new_number -1);
-
-	/* Add just before terminal entry */
-	ret = insert_rules(2, sizeof(newc), &newc.head,
-			   destination,
-			   (*handle)->new_number - 1,
-			   0, handle);
-
-	set_changed(*handle);
-
-	/* add chain cache info for this chain */
-	add_chain_cache(*handle, chain, 
-			destination+newc.head.next_offset, 
-			destination+newc.head.next_offset);
-
-	return ret;
-}
-
-static int
-count_ref(STRUCT_ENTRY *e, unsigned int offset, unsigned int *ref)
-{
-	STRUCT_STANDARD_TARGET *t;
-
-	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) == 0) {
-		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-
-		if (t->verdict == offset)
-			(*ref)++;
-	}
-
-	return 0;
-}
-
-/* Get the number of references to this chain. */
-int
-TC_GET_REFERENCES(unsigned int *ref, const IPT_CHAINLABEL chain,
-		  TC_HANDLE_T *handle)
-{
-	struct chain_cache *c;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	*ref = 0;
-	ENTRY_ITERATE((*handle)->entries.entrytable,
-		      (*handle)->entries.size,
-		      count_ref, c->start_off, ref);
-	return 1;
-}
-
-/* Deletes a chain. */
-int
-TC_DELETE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	unsigned int labelidx, labeloff;
-	unsigned int references;
-	struct chain_cache *c;
-	int ret;
-	STRUCT_ENTRY *start;
-
-	if (!TC_GET_REFERENCES(&references, chain, handle))
-		return 0;
-
-	iptc_fn = TC_DELETE_CHAIN;
-
-	if (TC_BUILTIN(chain, *handle)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	if (references > 0) {
-		errno = EMLINK;
-		return 0;
-	}
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	if (c->start_off != c->end_off) {
-		errno = ENOTEMPTY;
-		return 0;
-	}
-
-	/* Need label index: preceeds chain start */
-	labelidx = offset2index(*handle, c->start_off) - 1;
-	labeloff = index2offset(*handle, labelidx);
-
-	start = offset2entry(*handle, c->start_off);
-
-	ret = delete_rules(2,
-			   get_entry(*handle, labeloff)->next_offset
-			   + start->next_offset,
-			   labeloff, labelidx, handle);
-	return ret;
-}
-
-/* Renames a chain. */
-int TC_RENAME_CHAIN(const IPT_CHAINLABEL oldname,
-		    const IPT_CHAINLABEL newname,
-		    TC_HANDLE_T *handle)
-{
-	unsigned int labeloff, labelidx;
-	struct chain_cache *c;
-	struct ipt_error_target *t;
-
-	iptc_fn = TC_RENAME_CHAIN;
-
-	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
-           QUEUE, RETURN. */
-	if (find_label(newname, *handle)
-	    || strcmp(newname, LABEL_DROP) == 0
-	    || strcmp(newname, LABEL_ACCEPT) == 0
-	    || strcmp(newname, LABEL_QUEUE) == 0
-	    || strcmp(newname, LABEL_RETURN) == 0) {
-		errno = EEXIST;
-		return 0;
-	}
-
-	if (!(c = find_label(oldname, *handle))
-	    || TC_BUILTIN(oldname, *handle)) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	if (strlen(newname)+1 > sizeof(IPT_CHAINLABEL)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	/* Need label index: preceeds chain start */
-	labelidx = offset2index(*handle, c->start_off) - 1;
-	labeloff = index2offset(*handle, labelidx);
-
-	t = (struct ipt_error_target *)
-		GET_TARGET(get_entry(*handle, labeloff));
-
-	memset(t->error, 0, sizeof(t->error));
-	strcpy(t->error, newname);
-
-	/* update chain cache */
-	memset(c->name, 0, sizeof(c->name));
-	strcpy(c->name, newname);
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-/* Sets the policy on a built-in chain. */
-int
-TC_SET_POLICY(const IPT_CHAINLABEL chain,
-	      const IPT_CHAINLABEL policy,
-	      STRUCT_COUNTERS *counters,
-	      TC_HANDLE_T *handle)
-{
-	unsigned int hook;
-	unsigned int policyoff, ctrindex;
-	STRUCT_ENTRY *e;
-	STRUCT_STANDARD_TARGET *t;
-
-	iptc_fn = TC_SET_POLICY;
-	/* Figure out which chain. */
-	hook = TC_BUILTIN(chain, *handle);
-	if (hook == 0) {
-		errno = ENOENT;
-		return 0;
-	} else
-		hook--;
-
-	policyoff = get_chain_end(*handle, (*handle)->info.hook_entry[hook]);
-	if (policyoff != (*handle)->info.underflow[hook]) {
-		printf("ERROR: Policy for `%s' offset %u != underflow %u\n",
-		       chain, policyoff, (*handle)->info.underflow[hook]);
-		return 0;
-	}
-
-	e = get_entry(*handle, policyoff);
-	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-
-	if (strcmp(policy, LABEL_ACCEPT) == 0)
-		t->verdict = -NF_ACCEPT - 1;
-	else if (strcmp(policy, LABEL_DROP) == 0)
-		t->verdict = -NF_DROP - 1;
-	else {
-		errno = EINVAL;
-		return 0;
-	}
-
-	ctrindex = entry2index(*handle, e);
-
-	if (counters) {
-		/* set byte and packet counters */
-		memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
-
-		(*handle)->counter_map[ctrindex].maptype
-			= COUNTER_MAP_SET;
-
-	} else {
-		(*handle)->counter_map[ctrindex]
-			= ((struct counter_map){ COUNTER_MAP_NOMAP, 0 });
-	}
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-/* Without this, on gcc 2.7.2.3, we get:
-   libiptc.c: In function `TC_COMMIT':
-   libiptc.c:833: fixed or forbidden register was spilled.
-   This may be due to a compiler bug or to impossible asm
-   statements or clauses.
-*/
-static void
-subtract_counters(STRUCT_COUNTERS *answer,
-		  const STRUCT_COUNTERS *a,
-		  const STRUCT_COUNTERS *b)
-{
-	answer->pcnt = a->pcnt - b->pcnt;
-	answer->bcnt = a->bcnt - b->bcnt;
-}
-
-int
-TC_COMMIT(TC_HANDLE_T *handle)
-{
-	/* Replace, then map back the counters. */
-	STRUCT_REPLACE *repl;
-	STRUCT_COUNTERS_INFO *newcounters;
-	unsigned int i;
-	size_t counterlen;
-
-	CHECK(*handle);
-
-	counterlen = sizeof(STRUCT_COUNTERS_INFO)
-			+ sizeof(STRUCT_COUNTERS) * (*handle)->new_number;
-
-#if 0
-	TC_DUMP_ENTRIES(*handle);
-#endif
-
-	/* Don't commit if nothing changed. */
-	if (!(*handle)->changed)
-		goto finished;
-
-	repl = malloc(sizeof(*repl) + (*handle)->entries.size);
-	if (!repl) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	/* These are the old counters we will get from kernel */
-	repl->counters = malloc(sizeof(STRUCT_COUNTERS)
-				* (*handle)->info.num_entries);
-	if (!repl->counters) {
-		free(repl);
-		errno = ENOMEM;
-		return 0;
-	}
-
-	/* These are the counters we're going to put back, later. */
-	newcounters = malloc(counterlen);
-	if (!newcounters) {
-		free(repl->counters);
-		free(repl);
-		errno = ENOMEM;
-		return 0;
-	}
-
-	strcpy(repl->name, (*handle)->info.name);
-	repl->num_entries = (*handle)->new_number;
-	repl->size = (*handle)->entries.size;
-	memcpy(repl->hook_entry, (*handle)->info.hook_entry,
-	       sizeof(repl->hook_entry));
-	memcpy(repl->underflow, (*handle)->info.underflow,
-	       sizeof(repl->underflow));
-	repl->num_counters = (*handle)->info.num_entries;
-	repl->valid_hooks = (*handle)->info.valid_hooks;
-	memcpy(repl->entries, (*handle)->entries.entrytable,
-	       (*handle)->entries.size);
-
-	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_REPLACE, repl,
-		       sizeof(*repl) + (*handle)->entries.size) < 0) {
-		free(repl->counters);
-		free(repl);
-		free(newcounters);
-		return 0;
-	}
-
-	/* Put counters back. */
-	strcpy(newcounters->name, (*handle)->info.name);
-	newcounters->num_counters = (*handle)->new_number;
-	for (i = 0; i < (*handle)->new_number; i++) {
-		unsigned int mappos = (*handle)->counter_map[i].mappos;
-		switch ((*handle)->counter_map[i].maptype) {
-		case COUNTER_MAP_NOMAP:
-			newcounters->counters[i]
-				= ((STRUCT_COUNTERS){ 0, 0 });
-			break;
-
-		case COUNTER_MAP_NORMAL_MAP:
-			/* Original read: X.
-			 * Atomic read on replacement: X + Y.
-			 * Currently in kernel: Z.
-			 * Want in kernel: X + Y + Z.
-			 * => Add in X + Y
-			 * => Add in replacement read.
-			 */
-			newcounters->counters[i] = repl->counters[mappos];
-			break;
-
-		case COUNTER_MAP_ZEROED:
-			/* Original read: X.
-			 * Atomic read on replacement: X + Y.
-			 * Currently in kernel: Z.
-			 * Want in kernel: Y + Z.
-			 * => Add in Y.
-			 * => Add in (replacement read - original read).
-			 */
-			subtract_counters(&newcounters->counters[i],
-					  &repl->counters[mappos],
-					  &index2entry(*handle, i)->counters);
-			break;
-
-		case COUNTER_MAP_SET:
-			/* Want to set counter (iptables-restore) */
-
-			memcpy(&newcounters->counters[i],
-			       &index2entry(*handle, i)->counters,
-			       sizeof(STRUCT_COUNTERS));
-
-			break;
-		}
-	}
-
-#ifdef KERNEL_64_USERSPACE_32
-	{
-		/* Kernel will think that pointer should be 64-bits, and get
-		   padding.  So we accomodate here (assumption: alignment of
-		   `counters' is on 64-bit boundary). */
-		u_int64_t *kernptr = (u_int64_t *)&newcounters->counters;
-		if ((unsigned long)&newcounters->counters % 8 != 0) {
-			fprintf(stderr,
-				"counters alignment incorrect! Mail rusty!\n");
-			abort();
-		}
-		*kernptr = newcounters->counters;
-	}
-#endif /* KERNEL_64_USERSPACE_32 */
-
-	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_ADD_COUNTERS,
-		       newcounters, counterlen) < 0) {
-		free(repl->counters);
-		free(repl);
-		free(newcounters);
-		return 0;
-	}
-
-	free(repl->counters);
-	free(repl);
-	free(newcounters);
-
- finished:
-	TC_FREE(handle);
-	return 1;
-}
-
-/* Get raw socket. */
-int
-TC_GET_RAW_SOCKET()
-{
-	return sockfd;
-}
-
-/* Translates errno numbers into more human-readable form than strerror. */
-const char *
-TC_STRERROR(int err)
-{
-	unsigned int i;
-	struct table_struct {
-		void *fn;
-		int err;
-		const char *message;
-	} table [] =
-	  { { TC_INIT, EPERM, "Permission denied (you must be root)" },
-	    { TC_INIT, EINVAL, "Module is wrong version" },
-	    { TC_INIT, ENOENT, 
-		    "Table does not exist (do you need to insmod?)" },
-	    { TC_DELETE_CHAIN, ENOTEMPTY, "Chain is not empty" },
-	    { TC_DELETE_CHAIN, EINVAL, "Can't delete built-in chain" },
-	    { TC_DELETE_CHAIN, EMLINK,
-	      "Can't delete chain with references left" },
-	    { TC_CREATE_CHAIN, EEXIST, "Chain already exists" },
-	    { TC_INSERT_ENTRY, E2BIG, "Index of insertion too big" },
-	    { TC_REPLACE_ENTRY, E2BIG, "Index of replacement too big" },
-	    { TC_DELETE_NUM_ENTRY, E2BIG, "Index of deletion too big" },
-	    { TC_READ_COUNTER, E2BIG, "Index of counter too big" },
-	    { TC_ZERO_COUNTER, E2BIG, "Index of counter too big" },
-	    { TC_INSERT_ENTRY, ELOOP, "Loop found in table" },
-	    { TC_INSERT_ENTRY, EINVAL, "Target problem" },
-	    /* EINVAL for CHECK probably means bad interface. */
-	    { TC_CHECK_PACKET, EINVAL,
-	      "Bad arguments (does that interface exist?)" },
-	    { TC_CHECK_PACKET, ENOSYS,
-	      "Checking will most likely never get implemented" },
-	    /* ENOENT for DELETE probably means no matching rule */
-	    { TC_DELETE_ENTRY, ENOENT,
-	      "Bad rule (does a matching rule exist in that chain?)" },
-	    { TC_SET_POLICY, ENOENT,
-	      "Bad built-in chain name" },
-	    { TC_SET_POLICY, EINVAL,
-	      "Bad policy name" },
-
-	    { NULL, 0, "Incompatible with this kernel" },
-	    { NULL, ENOPROTOOPT, "iptables who? (do you need to insmod?)" },
-	    { NULL, ENOSYS, "Will be implemented real soon.  I promise ;)" },
-	    { NULL, ENOMEM, "Memory allocation problem" },
-	    { NULL, ENOENT, "No chain/target/match by that name" },
-	  };
-
-	for (i = 0; i < sizeof(table)/sizeof(struct table_struct); i++) {
-		if ((!table[i].fn || table[i].fn == iptc_fn)
-		    && table[i].err == err)
-			return table[i].message;
-	}
-
-	return strerror(err);
-}
diff -urN iptables-1.2.9/libiptc2/libiptc2.c iptables-1.2.10/libiptc2/libiptc2.c
--- iptables-1.2.9/libiptc2/libiptc2.c	2003-06-30 18:27:24.000000000 +0200
+++ iptables-1.2.10/libiptc2/libiptc2.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1758 +0,0 @@
-/* Library which manipulates firewall rules.  Version $Revision: 1.39 $ */
-
-/* Architecture of firewall rules is as follows:
- *
- * Chains go INPUT, FORWARD, OUTPUT then user chains.
- * Each user chain starts with an ERROR node.
- * Every chain ends with an unconditional jump: a RETURN for user chains,
- * and a POLICY for built-ins.
- */
-
-/* (C) 1999 Paul ``Rusty'' Russell - Placed under the GNU GPL (See
- * COPYING for details). 
- * (C) 2000-2003 by the Netfilter Core Team <coreteam@netfilter.org>
- *
- * 2003-Jun-20: Harald Welte <laforge@netfilter.org:
- *	- Reimplementation of chain cache to use offsets instead of entries
- * 
- */
-
-#ifndef IPT_LIB_DIR
-#define IPT_LIB_DIR "/usr/local/lib/iptables"
-#endif
-
-#ifndef __OPTIMIZE__
-STRUCT_ENTRY_TARGET *
-GET_TARGET(STRUCT_ENTRY *e)
-{
-	return (void *)e + e->target_offset;
-}
-#endif
-
-static int sockfd = -1;
-static void *iptc_fn = NULL;
-
-static const char *hooknames[]
-= { [HOOK_PRE_ROUTING]  "PREROUTING",
-    [HOOK_LOCAL_IN]     "INPUT",
-    [HOOK_FORWARD]      "FORWARD",
-    [HOOK_LOCAL_OUT]    "OUTPUT",
-    [HOOK_POST_ROUTING] "POSTROUTING",
-#ifdef HOOK_DROPPING
-    [HOOK_DROPPING]	"DROPPING"
-#endif
-};
-
-struct counter_map
-{
-	enum {
-		COUNTER_MAP_NOMAP,
-		COUNTER_MAP_NORMAL_MAP,
-		COUNTER_MAP_ZEROED,
-		COUNTER_MAP_SET
-	} maptype;
-	unsigned int mappos;
-};
-
-/* Convenience structures */
-struct ipt_error_target
-{
-	STRUCT_ENTRY_TARGET t;
-	char error[TABLE_MAXNAMELEN];
-};
-
-struct rule_head
-{
-	struct list_head list;
-	
-	struct chain_head *chain;
-
-	unsigned int size;
-	STRUCT_ENTRY entry[0];
-}
-
-struct chain_head
-{
-	struct list_head list;
-
-	char name[TABLE_MAXNAMELEN];
-	unsigned int hooknum;
-	struct list_head rules;
-};
-
-STRUCT_TC_HANDLE
-{
-	/* Have changes been made? */
-	int changed;
-
-	struct list_head chains;
-	
-	struct chain_head *chain_iterator_cur;
-
-#if 0
-	/* Size in here reflects original state. */
-	STRUCT_GETINFO info;
-
-	struct counter_map *counter_map;
-	/* Array of hook names */
-	const char **hooknames;
-
-	/* Cached position of chain heads (NULL = no cache). */
-	unsigned int cache_num_chains;
-	unsigned int cache_num_builtins;
-	struct chain_cache *cache_chain_heads;
-
-	/* Chain iterator: current chain cache entry. */
-	struct chain_cache *cache_chain_iteration;
-
-	/* Rule iterator: terminal rule */
-	STRUCT_ENTRY *cache_rule_end;
-
-	/* Number in here reflects current state. */
-	unsigned int new_number;
-	STRUCT_GET_ENTRIES entries;
-#endif
-};
-
-static void
-set_changed(TC_HANDLE_T h)
-{
-	h->changed = 1;
-}
-
-#ifdef IPTC_DEBUG
-static void do_check(TC_HANDLE_T h, unsigned int line);
-#define CHECK(h) do { if (!getenv("IPTC_NO_CHECK")) do_check((h), __LINE__); } while(0)
-#else
-#define CHECK(h)
-#endif
-
-static inline int
-get_number(const STRUCT_ENTRY *i,
-	   const STRUCT_ENTRY *seek,
-	   unsigned int *pos)
-{
-	if (i == seek)
-		return 1;
-	(*pos)++;
-	return 0;
-}
-
-static unsigned int
-entry2index(const TC_HANDLE_T h, const STRUCT_ENTRY *seek)
-{
-	unsigned int pos = 0;
-
-	if (ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-			  get_number, seek, &pos) == 0) {
-		fprintf(stderr, "ERROR: offset %i not an entry!\n",
-			(char *)seek - (char *)h->entries.entrytable);
-		abort();
-	}
-	return pos;
-}
-
-static inline int
-get_entry_n(STRUCT_ENTRY *i,
-	    unsigned int number,
-	    unsigned int *pos,
-	    STRUCT_ENTRY **pe)
-{
-	if (*pos == number) {
-		*pe = i;
-		return 1;
-	}
-	(*pos)++;
-	return 0;
-}
-
-static STRUCT_ENTRY *
-index2entry(TC_HANDLE_T h, unsigned int index)
-{
-	unsigned int pos = 0;
-	STRUCT_ENTRY *ret = NULL;
-
-	ENTRY_ITERATE(h->entries.entrytable, h->entries.size,
-		      get_entry_n, index, &pos, &ret);
-
-	return ret;
-}
-
-static inline STRUCT_ENTRY *
-get_entry(TC_HANDLE_T h, unsigned int offset)
-{
-	return (STRUCT_ENTRY *)((char *)h->entries.entrytable + offset);
-}
-
-static inline unsigned long
-entry2offset(const TC_HANDLE_T h, const STRUCT_ENTRY *e)
-{
-	return (void *)e - (void *)h->entries.entrytable;
-}
-
-static inline unsigned long
-index2offset(TC_HANDLE_T h, unsigned int index)
-{
-	return entry2offset(h, index2entry(h, index));
-}
-
-static inline STRUCT_ENTRY *
-offset2entry(TC_HANDLE_T h, unsigned int offset)
-{
-	return (STRUCT_ENTRY *) ((void *)h->entries.entrytable+offset);
-}
-
-static inline unsigned int
-offset2index(const TC_HANDLE_T h, unsigned int offset)
-{
-	return entry2index(h, offset2entry(h, offset));
-}
-
-
-static const char *
-get_errorlabel(TC_HANDLE_T h, unsigned int offset)
-{
-	STRUCT_ENTRY *e;
-
-	e = get_entry(h, offset);
-	if (strcmp(GET_TARGET(e)->u.user.name, ERROR_TARGET) != 0) {
-		fprintf(stderr, "ERROR: offset %u not an error node!\n",
-			offset);
-		abort();
-	}
-
-	return (const char *)GET_TARGET(e)->data;
-}
-
-/* Allocate handle of given size */
-static TC_HANDLE_T
-alloc_handle(const char *tablename, unsigned int size, unsigned int num_rules)
-{
-	size_t len;
-	TC_HANDLE_T h;
-
-	len = sizeof(STRUCT_TC_HANDLE)
-		+ size
-		+ num_rules * sizeof(struct counter_map);
-
-	if ((h = malloc(len)) == NULL) {
-		errno = ENOMEM;
-		return NULL;
-	}
-
-	h->changed = 0;
-	h->cache_num_chains = 0;
-	h->cache_chain_heads = NULL;
-	h->counter_map = (void *)h
-		+ sizeof(STRUCT_TC_HANDLE)
-		+ size;
-	strcpy(h->info.name, tablename);
-	strcpy(h->entries.name, tablename);
-
-	return h;
-}
-
-TC_HANDLE_T
-TC_INIT(const char *tablename)
-{
-	TC_HANDLE_T h;
-	STRUCT_GETINFO info;
-	unsigned int i;
-	int tmp;
-	socklen_t s;
-
-	iptc_fn = TC_INIT;
-
-	if (sockfd != -1) {
-		close(sockfd);
-		sockfd = -1;
-	}
-
-	if (strlen(tablename) >= TABLE_MAXNAMELEN) {
-		errno = EINVAL;
-		return NULL;
-	}
-	
-	sockfd = socket(TC_AF, SOCK_RAW, IPPROTO_RAW);
-	if (sockfd < 0)
-		return NULL;
-
-	s = sizeof(info);
-
-	strcpy(info.name, tablename);
-	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_INFO, &info, &s) < 0)
-		return NULL;
-
-	if ((h = alloc_handle(info.name, info.size, info.num_entries))
-	    == NULL) {
-		close(sockfd);
-		sockfd = -1;
-		return NULL;
-	}
-
-/* Too hard --RR */
-#if 0
-	sprintf(pathname, "%s/%s", IPT_LIB_DIR, info.name);
-	dynlib = dlopen(pathname, RTLD_NOW);
-	if (!dynlib) {
-		errno = ENOENT;
-		return NULL;
-	}
-	h->hooknames = dlsym(dynlib, "hooknames");
-	if (!h->hooknames) {
-		errno = ENOENT;
-		return NULL;
-	}
-#else
-	h->hooknames = hooknames;
-#endif
-
-	/* Initialize current state */
-	h->info = info;
-	h->new_number = h->info.num_entries;
-	for (i = 0; i < h->info.num_entries; i++)
-		h->counter_map[i]
-			= ((struct counter_map){COUNTER_MAP_NORMAL_MAP, i});
-
-	h->entries.size = h->info.size;
-
-	tmp = sizeof(STRUCT_GET_ENTRIES) + h->info.size;
-
-	if (getsockopt(sockfd, TC_IPPROTO, SO_GET_ENTRIES, &h->entries,
-		       &tmp) < 0) {
-		close(sockfd);
-		sockfd = -1;
-		free(h);
-		return NULL;
-	}
-
-	CHECK(h);
-	return h;
-}
-
-void
-TC_FREE(TC_HANDLE_T *h)
-{
-	close(sockfd);
-	sockfd = -1;
-	if ((*h)->cache_chain_heads)
-		free((*h)->cache_chain_heads);
-	free(*h);
-	*h = NULL;
-}
-
-static inline int
-print_match(const STRUCT_ENTRY_MATCH *m)
-{
-	printf("Match name: `%s'\n", m->u.user.name);
-	return 0;
-}
-
-static int dump_entry(STRUCT_ENTRY *e, const TC_HANDLE_T handle);
- 
-void
-TC_DUMP_ENTRIES(const TC_HANDLE_T handle)
-{
-	CHECK(handle);
-
-	printf("libiptc v%s.  %u entries, %u bytes.\n",
-	       IPTABLES_VERSION,
-	       handle->new_number, handle->entries.size);
-	printf("Table `%s'\n", handle->info.name);
-	printf("Hooks: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
-	       handle->info.hook_entry[HOOK_PRE_ROUTING],
-	       handle->info.hook_entry[HOOK_LOCAL_IN],
-	       handle->info.hook_entry[HOOK_FORWARD],
-	       handle->info.hook_entry[HOOK_LOCAL_OUT],
-	       handle->info.hook_entry[HOOK_POST_ROUTING]);
-	printf("Underflows: pre/in/fwd/out/post = %u/%u/%u/%u/%u\n",
-	       handle->info.underflow[HOOK_PRE_ROUTING],
-	       handle->info.underflow[HOOK_LOCAL_IN],
-	       handle->info.underflow[HOOK_FORWARD],
-	       handle->info.underflow[HOOK_LOCAL_OUT],
-	       handle->info.underflow[HOOK_POST_ROUTING]);
-
-	ENTRY_ITERATE(handle->entries.entrytable, handle->entries.size,
-		      dump_entry, handle);
-}
-
-/* Returns 0 if not hook entry, else hooknumber + 1 */
-static inline unsigned int
-is_hook_entry(STRUCT_ENTRY *e, TC_HANDLE_T h)
-{
-	unsigned int i;
-
-	for (i = 0; i < NUMHOOKS; i++) {
-		if ((h->info.valid_hooks & (1 << i))
-		    && get_entry(h, h->info.hook_entry[i]) == e)
-			return i+1;
-	}
-	return 0;
-}
-static int alphasort(const void *a, const void *b)
-{
-	return strcmp(((struct chain_cache *)a)->name,
-		      ((struct chain_cache *)b)->name);
-}
-
-/* Returns chain head if found, otherwise NULL. */
-static struct chain_head *
-find_label(const char *name, TC_HANDLE_T handle)
-{
-	struct list_head *pos;
-
-	if (!handle->chains)
-		return NULL;
-
-	list_for_each(pos, &handle->chains) {
-		struct chain_head *c = list_entry(pos, struct chain_head, list);
-		if (!strcmp(c->name, name))
-			return c;
-	}
-
-	return NULL;
-}
-
-/* Does this chain exist? */
-int TC_IS_CHAIN(const char *chain, const TC_HANDLE_T handle)
-{
-	return find_label(chain, handle) != NULL;
-}
-
-/* Returns the position of the final (ie. unconditional) element. */
-static unsigned int
-get_chain_end(const TC_HANDLE_T handle, unsigned int start)
-{
-	unsigned int last_off, off;
-	STRUCT_ENTRY *e;
-
-	last_off = start;
-	e = get_entry(handle, start);
-
-	/* Terminate when we meet a error label or a hook entry. */
-	for (off = start + e->next_offset;
-	     off < handle->entries.size;
-	     last_off = off, off += e->next_offset) {
-		STRUCT_ENTRY_TARGET *t;
-		unsigned int i;
-
-		e = get_entry(handle, off);
-
-		/* We hit an entry point. */
-		for (i = 0; i < NUMHOOKS; i++) {
-			if ((handle->info.valid_hooks & (1 << i))
-			    && off == handle->info.hook_entry[i])
-				return last_off;
-		}
-
-		/* We hit a user chain label */
-		t = GET_TARGET(e);
-		if (strcmp(t->u.user.name, ERROR_TARGET) == 0)
-			return last_off;
-	}
-	/* SHOULD NEVER HAPPEN */
-	fprintf(stderr, "ERROR: Off end (%u) of chain from %u!\n",
-		handle->entries.size, off);
-	abort();
-}
-
-/* Iterator functions to run through the chains. */
-const char *
-TC_FIRST_CHAIN(TC_HANDLE_T *handle)
-{
-	(*handle)->chain_iterator_cur = (*handle)->chains;
-
-	return (*handle)->chains.name;
-}
-
-/* Iterator functions to run through the chains.  Returns NULL at end. */
-const char *
-TC_NEXT_CHAIN(TC_HANDLE_T *handle)
-{
-	struct chain_head *next = list_entry(&(*handle)->chain_iterator_cur->list.next, struct chain_head, list);
-	(*handle)->chain_iterator_cur = next;
-
-	if (next == (*handle)->chains)
-		return NULL;
-
-	return next->name;
-}
-
-/* Get first rule in the given chain: NULL for empty chain. */
-const STRUCT_ENTRY *
-TC_FIRST_RULE(const char *chain, TC_HANDLE_T *handle)
-{
-	struct chain_head *c;
-	struct rule_head *r;
-
-	c = find_label(chain, *handle);
-	if (!c) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	/* Empty chain: single return/policy rule */
-	if (list_empty(c->rules))
-		return NULL;
-
-	r = list_entry(&c->rules.next, struct rule_head, list);
-	(*handle)->rule_iterator_cur = r;
-
-	return r->entry;
-}
-
-/* Returns NULL when rules run out. */
-const STRUCT_ENTRY *
-TC_NEXT_RULE(const STRUCT_ENTRY *prev, TC_HANDLE_T *handle)
-{
-	struct rule_head *r = list_entry((*handle)->rule_iterator_cur->list.next, struct rule_head, list);
-
-	if (r == r->chain)
-		return NULL;
-
-	/* NOTE: prev is without any influence ! */
-	return r->entry;
-}
-
-#if 0
-/* How many rules in this chain? */
-unsigned int
-TC_NUM_RULES(const char *chain, TC_HANDLE_T *handle)
-{
-	unsigned int off = 0;
-	STRUCT_ENTRY *start, *end;
-
-	CHECK(*handle);
-	if (!find_label(&off, chain, *handle)) {
-		errno = ENOENT;
-		return (unsigned int)-1;
-	}
-
-	start = get_entry(*handle, off);
-	end = get_entry(*handle, get_chain_end(*handle, off));
-
-	return entry2index(*handle, end) - entry2index(*handle, start);
-}
-
-/* Get n'th rule in this chain. */
-const STRUCT_ENTRY *TC_GET_RULE(const char *chain,
-				unsigned int n,
-				TC_HANDLE_T *handle)
-{
-	unsigned int pos = 0, chainindex;
-
-	CHECK(*handle);
-	if (!find_label(&pos, chain, *handle)) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	chainindex = entry2index(*handle, get_entry(*handle, pos));
-
-	return index2entry(*handle, chainindex + n);
-}
-#endif
-
-static const char *
-target_name(TC_HANDLE_T handle, const STRUCT_ENTRY *ce)
-{
-	int spos;
-	unsigned int labelidx;
-	STRUCT_ENTRY *jumpto;
-
-	/* To avoid const warnings */
-	STRUCT_ENTRY *e = (STRUCT_ENTRY *)ce;
-
-	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) != 0)
-		return GET_TARGET(e)->u.user.name;
-
-	/* Standard target: evaluate */
-	spos = *(int *)GET_TARGET(e)->data;
-	if (spos < 0) {
-		if (spos == RETURN)
-			return LABEL_RETURN;
-		else if (spos == -NF_ACCEPT-1)
-			return LABEL_ACCEPT;
-		else if (spos == -NF_DROP-1)
-			return LABEL_DROP;
-		else if (spos == -NF_QUEUE-1)
-			return LABEL_QUEUE;
-
-		fprintf(stderr, "ERROR: off %lu/%u not a valid target (%i)\n",
-			entry2offset(handle, e), handle->entries.size,
-			spos);
-		abort();
-	}
-
-	jumpto = get_entry(handle, spos);
-
-	/* Fall through rule */
-	if (jumpto == (void *)e + e->next_offset)
-		return "";
-
-	/* Must point to head of a chain: ie. after error rule */
-	labelidx = entry2index(handle, jumpto) - 1;
-	return get_errorlabel(handle, index2offset(handle, labelidx));
-}
-
-/* Returns a pointer to the target name of this position. */
-const char *TC_GET_TARGET(const STRUCT_ENTRY *e,
-			  TC_HANDLE_T *handle)
-{
-	return target_name(*handle, e);
-}
-
-/* Is this a built-in chain?  Actually returns hook + 1. */
-int
-TC_BUILTIN(const char *chain, const TC_HANDLE_T handle)
-{
-	unsigned int i;
-
-	for (i = 0; i < NUMHOOKS; i++) {
-		if ((handle->info.valid_hooks & (1 << i))
-		    && handle->hooknames[i]
-		    && strcmp(handle->hooknames[i], chain) == 0)
-			return i+1;
-	}
-	return 0;
-}
-
-/* Get the policy of a given built-in chain */
-const char *
-TC_GET_POLICY(const char *chain,
-	      STRUCT_COUNTERS *counters,
-	      TC_HANDLE_T *handle)
-{
-	unsigned int start;
-	STRUCT_ENTRY *e;
-	int hook;
-
-	hook = TC_BUILTIN(chain, *handle);
-	if (hook != 0)
-		start = (*handle)->info.hook_entry[hook-1];
-	else
-		return NULL;
-
-	e = get_entry(*handle, get_chain_end(*handle, start));
-	*counters = e->counters;
-
-	return target_name(*handle, e);
-}
-
-static int
-correct_verdict(STRUCT_ENTRY *e,
-		char *base,
-		unsigned int offset, int delta_offset)
-{
-	STRUCT_STANDARD_TARGET *t = (void *)GET_TARGET(e);
-	unsigned int curr = (char *)e - base;
-
-	/* Trap: insert of fall-through rule.  Don't change fall-through
-	   verdict to jump-over-next-rule. */
-	if (strcmp(t->target.u.user.name, STANDARD_TARGET) == 0
-	    && t->verdict > (int)offset
-	    && !(curr == offset &&
-		 t->verdict == curr + e->next_offset)) {
-		t->verdict += delta_offset;
-	}
-
-	return 0;
-}
-
-/* Adjusts standard verdict jump positions after an insertion/deletion. */
-static int
-set_verdict(unsigned int offset, int delta_offset, TC_HANDLE_T *handle)
-{
-	ENTRY_ITERATE((*handle)->entries.entrytable,
-		      (*handle)->entries.size,
-		      correct_verdict, (char *)(*handle)->entries.entrytable,
-		      offset, delta_offset);
-
-	set_changed(*handle);
-	return 1;
-}
-
-/* If prepend is set, then we are prepending to a chain: if the
- * insertion position is an entry point, keep the entry point. */
-static int
-insert_rules(unsigned int num_rules, unsigned int rules_size,
-	     const STRUCT_ENTRY *insert,
-	     unsigned int offset, unsigned int num_rules_offset,
-	     int prepend,
-	     TC_HANDLE_T *handle)
-{
-	TC_HANDLE_T newh;
-	STRUCT_GETINFO newinfo;
-	unsigned int i;
-
-	if (offset >= (*handle)->entries.size) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	newinfo = (*handle)->info;
-
-	/* Fix up entry points. */
-	for (i = 0; i < NUMHOOKS; i++) {
-		/* Entry points to START of chain, so keep same if
-                   inserting on at that point. */
-		if ((*handle)->info.hook_entry[i] > offset)
-			newinfo.hook_entry[i] += rules_size;
-
-		/* Underflow always points to END of chain (policy),
-		   so if something is inserted at same point, it
-		   should be advanced. */
-		if ((*handle)->info.underflow[i] >= offset)
-			newinfo.underflow[i] += rules_size;
-	}
-
-	newh = alloc_handle((*handle)->info.name,
-			    (*handle)->entries.size + rules_size,
-			    (*handle)->new_number + num_rules);
-	if (!newh)
-		return 0;
-	newh->info = newinfo;
-
-	/* Copy pre... */
-	memcpy(newh->entries.entrytable, (*handle)->entries.entrytable,offset);
-	/* ... Insert new ... */
-	memcpy((char *)newh->entries.entrytable + offset, insert, rules_size);
-	/* ... copy post */
-	memcpy((char *)newh->entries.entrytable + offset + rules_size,
-	       (char *)(*handle)->entries.entrytable + offset,
-	       (*handle)->entries.size - offset);
-
-	/* Move counter map. */
-	/* Copy pre... */
-	memcpy(newh->counter_map, (*handle)->counter_map,
-	       sizeof(struct counter_map) * num_rules_offset);
-	/* ... copy post */
-	memcpy(newh->counter_map + num_rules_offset + num_rules,
-	       (*handle)->counter_map + num_rules_offset,
-	       sizeof(struct counter_map) * ((*handle)->new_number
-					     - num_rules_offset));
-	/* Set intermediates to no counter copy */
-	for (i = 0; i < num_rules; i++)
-		newh->counter_map[num_rules_offset+i]
-			= ((struct counter_map){ COUNTER_MAP_SET, 0 });
-
-	newh->new_number = (*handle)->new_number + num_rules;
-	newh->entries.size = (*handle)->entries.size + rules_size;
-	newh->hooknames = (*handle)->hooknames;
-
-	if ((*handle)->cache_chain_heads)
-		free((*handle)->cache_chain_heads);
-	free(*handle);
-	*handle = newh;
-
-	return set_verdict(offset, rules_size, handle);
-}
-
-static int
-delete_rules(unsigned int num_rules, unsigned int rules_size,
-	     unsigned int offset, unsigned int num_rules_offset,
-	     TC_HANDLE_T *handle)
-{
-	unsigned int i;
-
-	if (offset + rules_size > (*handle)->entries.size) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	/* Fix up entry points. */
-	for (i = 0; i < NUMHOOKS; i++) {
-		/* In practice, we never delete up to a hook entry,
-		   since the built-in chains are always first,
-		   so these two are never equal */
-		if ((*handle)->info.hook_entry[i] >= offset + rules_size)
-			(*handle)->info.hook_entry[i] -= rules_size;
-		else if ((*handle)->info.hook_entry[i] > offset) {
-			fprintf(stderr, "ERROR: Deleting entry %u %u %u\n",
-				i, (*handle)->info.hook_entry[i], offset);
-			abort();
-		}
-
-		/* Underflow points to policy (terminal) rule in
-                   built-in, so sequality is valid here (when deleting
-                   the last rule). */
-		if ((*handle)->info.underflow[i] >= offset + rules_size)
-			(*handle)->info.underflow[i] -= rules_size;
-		else if ((*handle)->info.underflow[i] > offset) {
-			fprintf(stderr, "ERROR: Deleting uflow %u %u %u\n",
-				i, (*handle)->info.underflow[i], offset);
-			abort();
-		}
-	}
-
-	/* Move the rules down. */
-	memmove((char *)(*handle)->entries.entrytable + offset,
-		(char *)(*handle)->entries.entrytable + offset + rules_size,
-		(*handle)->entries.size - (offset + rules_size));
-
-	/* Move the counter map down. */
-	memmove(&(*handle)->counter_map[num_rules_offset],
-		&(*handle)->counter_map[num_rules_offset + num_rules],
-		sizeof(struct counter_map)
-		* ((*handle)->new_number - (num_rules + num_rules_offset)));
-
-	/* Fix numbers */
-	(*handle)->new_number -= num_rules;
-	(*handle)->entries.size -= rules_size;
-
-	return set_verdict(offset, -(int)rules_size, handle);
-}
-
-static int
-standard_map(STRUCT_ENTRY *e, int verdict)
-{
-	STRUCT_STANDARD_TARGET *t;
-
-	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-
-	if (t->target.u.target_size
-	    != ALIGN(sizeof(STRUCT_STANDARD_TARGET))) {
-		errno = EINVAL;
-		return 0;
-	}
-	/* memset for memcmp convenience on delete/replace */
-	memset(t->target.u.user.name, 0, FUNCTION_MAXNAMELEN);
-	strcpy(t->target.u.user.name, STANDARD_TARGET);
-	t->verdict = verdict;
-
-	return 1;
-}
-
-static int
-map_target(const TC_HANDLE_T handle,
-	   STRUCT_ENTRY *e,
-	   unsigned int offset,
-	   STRUCT_ENTRY_TARGET *old)
-{
-	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
-
-	/* Save old target (except data, which we don't change, except for
-	   standard case, where we don't care). */
-	*old = *t;
-
-	/* Maybe it's empty (=> fall through) */
-	if (strcmp(t->u.user.name, "") == 0)
-		return standard_map(e, offset + e->next_offset);
-	/* Maybe it's a standard target name... */
-	else if (strcmp(t->u.user.name, LABEL_ACCEPT) == 0)
-		return standard_map(e, -NF_ACCEPT - 1);
-	else if (strcmp(t->u.user.name, LABEL_DROP) == 0)
-		return standard_map(e, -NF_DROP - 1);
-	else if (strcmp(t->u.user.name, LABEL_QUEUE) == 0)
-		return standard_map(e, -NF_QUEUE - 1);
-	else if (strcmp(t->u.user.name, LABEL_RETURN) == 0)
-		return standard_map(e, RETURN);
-	else if (TC_BUILTIN(t->u.user.name, handle)) {
-		/* Can't jump to builtins. */
-		errno = EINVAL;
-		return 0;
-	} else {
-		/* Maybe it's an existing chain name. */
-		struct chain_cache *c;
-
-		c = find_label(t->u.user.name, handle);
-		if (c)
-			return standard_map(e, c->start_off);
-	}
-
-	/* Must be a module?  If not, kernel will reject... */
-	/* memset to all 0 for your memcmp convenience. */
-	memset(t->u.user.name + strlen(t->u.user.name),
-	       0,
-	       FUNCTION_MAXNAMELEN - strlen(t->u.user.name));
-	return 1;
-}
-
-static void
-unmap_target(STRUCT_ENTRY *e, STRUCT_ENTRY_TARGET *old)
-{
-	STRUCT_ENTRY_TARGET *t = GET_TARGET(e);
-
-	/* Save old target (except data, which we don't change, except for
-	   standard case, where we don't care). */
-	*t = *old;
-}
-
-/* Insert the entry `fw' in chain `chain' into position `rulenum'. */
-int
-TC_INSERT_ENTRY(const IPT_CHAINLABEL chain,
-		const STRUCT_ENTRY *e,
-		unsigned int rulenum,
-		TC_HANDLE_T *handle)
-{
-	unsigned int chainindex, offset;
-	STRUCT_ENTRY_TARGET old;
-	struct chain_cache *c;
-	STRUCT_ENTRY *tmp;
-	int ret;
-
-	iptc_fn = TC_INSERT_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-
-	tmp = index2entry(*handle, chainindex + rulenum);
-	if (!tmp || tmp > offset2entry(*handle, c->end_off)) {
-		errno = E2BIG;
-		return 0;
-	}
-	offset = index2offset(*handle, chainindex + rulenum);
-
-	/* Mapping target actually alters entry, but that's
-           transparent to the caller. */
-	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
-		return 0;
-
-	ret = insert_rules(1, e->next_offset, e, offset,
-			   chainindex + rulenum, rulenum == 0, handle);
-	unmap_target((STRUCT_ENTRY *)e, &old);
-	return ret;
-}
-
-/* Atomically replace rule `rulenum' in `chain' with `fw'. */
-int
-TC_REPLACE_ENTRY(const IPT_CHAINLABEL chain,
-		 const STRUCT_ENTRY *e,
-		 unsigned int rulenum,
-		 TC_HANDLE_T *handle)
-{
-	unsigned int chainindex, offset;
-	STRUCT_ENTRY_TARGET old;
-	struct chain_cache *c;
-	STRUCT_ENTRY *tmp;
-	int ret;
-
-	iptc_fn = TC_REPLACE_ENTRY;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-
-	tmp = index2entry(*handle, chainindex + rulenum);
-	if (!tmp || tmp >= offset2entry(*handle, c->end_off)) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	offset = index2offset(*handle, chainindex + rulenum);
-	/* Replace = delete and insert. */
-	if (!delete_rules(1, get_entry(*handle, offset)->next_offset,
-			  offset, chainindex + rulenum, handle))
-		return 0;
-
-	if (!map_target(*handle, (STRUCT_ENTRY *)e, offset, &old))
-		return 0;
-
-	ret = insert_rules(1, e->next_offset, e, offset,
-			   chainindex + rulenum, 1, handle);
-	unmap_target((STRUCT_ENTRY *)e, &old);
-	return ret;
-}
-
-/* Append entry `fw' to chain `chain'.  Equivalent to insert with
-   rulenum = length of chain. */
-int
-TC_APPEND_ENTRY(const IPT_CHAINLABEL chain,
-		const STRUCT_ENTRY *e,
-		TC_HANDLE_T *handle)
-{
-	struct chain_cache *c;
-	STRUCT_ENTRY_TARGET old;
-	int ret;
-
-	iptc_fn = TC_APPEND_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	if (!map_target(*handle, (STRUCT_ENTRY *)e,
-			c->end_off, &old))
-		return 0;
-
-	ret = insert_rules(1, e->next_offset, e, c->end_off, 
-			   offset2index(*handle, c->end_off), 0, handle);
-	unmap_target((STRUCT_ENTRY *)e, &old);
-	return ret;
-}
-
-static inline int
-match_different(const STRUCT_ENTRY_MATCH *a,
-		const unsigned char *a_elems,
-		const unsigned char *b_elems,
-		unsigned char **maskptr)
-{
-	const STRUCT_ENTRY_MATCH *b;
-	unsigned int i;
-
-	/* Offset of b is the same as a. */
-	b = (void *)b_elems + ((unsigned char *)a - a_elems);
-
-	if (a->u.match_size != b->u.match_size)
-		return 1;
-
-	if (strcmp(a->u.user.name, b->u.user.name) != 0)
-		return 1;
-
-	*maskptr += ALIGN(sizeof(*a));
-
-	for (i = 0; i < a->u.match_size - ALIGN(sizeof(*a)); i++)
-		if (((a->data[i] ^ b->data[i]) & (*maskptr)[i]) != 0)
-			return 1;
-	*maskptr += i;
-	return 0;
-}
-
-static inline int
-target_different(const unsigned char *a_targdata,
-		 const unsigned char *b_targdata,
-		 unsigned int tdatasize,
-		 const unsigned char *mask)
-{
-	unsigned int i;
-	for (i = 0; i < tdatasize; i++)
-		if (((a_targdata[i] ^ b_targdata[i]) & mask[i]) != 0)
-			return 1;
-
-	return 0;
-}
-
-static int
-is_same(const STRUCT_ENTRY *a,
-	const STRUCT_ENTRY *b,
-	unsigned char *matchmask);
-
-/* Delete the first rule in `chain' which matches `fw'. */
-int
-TC_DELETE_ENTRY(const IPT_CHAINLABEL chain,
-		const STRUCT_ENTRY *origfw,
-		unsigned char *matchmask,
-		TC_HANDLE_T *handle)
-{
-	unsigned int offset;
-	struct chain_cache *c;
-	STRUCT_ENTRY *e, *fw;
-
-	iptc_fn = TC_DELETE_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	fw = malloc(origfw->next_offset);
-	if (fw == NULL) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	for (offset = c->start_off; offset < c->end_off;
-	     offset += e->next_offset) {
-		STRUCT_ENTRY_TARGET discard;
-
-		memcpy(fw, origfw, origfw->next_offset);
-
-		/* FIXME: handle this in is_same --RR */
-		if (!map_target(*handle, fw, offset, &discard)) {
-			free(fw);
-			return 0;
-		}
-		e = get_entry(*handle, offset);
-
-#if 0
-		printf("Deleting:\n");
-		dump_entry(newe);
-#endif
-		if (is_same(e, fw, matchmask)) {
-			int ret;
-			ret = delete_rules(1, e->next_offset,
-					   offset, entry2index(*handle, e),
-					   handle);
-			free(fw);
-			return ret;
-		}
-	}
-
-	free(fw);
-	errno = ENOENT;
-	return 0;
-}
-
-/* Delete the rule in position `rulenum' in `chain'. */
-int
-TC_DELETE_NUM_ENTRY(const IPT_CHAINLABEL chain,
-		    unsigned int rulenum,
-		    TC_HANDLE_T *handle)
-{
-	unsigned int index;
-	int ret;
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-
-	iptc_fn = TC_DELETE_NUM_ENTRY;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	index = offset2index(*handle, c->start_off) + rulenum;
-
-	if (index >= offset2index(*handle, c->end_off)) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	e = index2entry(*handle, index);
-	if (e == NULL) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	ret = delete_rules(1, e->next_offset, entry2offset(*handle, e),
-			   index, handle);
-	return ret;
-}
-
-/* Check the packet `fw' on chain `chain'.  Returns the verdict, or
-   NULL and sets errno. */
-const char *
-TC_CHECK_PACKET(const IPT_CHAINLABEL chain,
-		STRUCT_ENTRY *entry,
-		TC_HANDLE_T *handle)
-{
-	errno = ENOSYS;
-	return NULL;
-}
-
-/* Flushes the entries in the given chain (ie. empties chain). */
-int
-TC_FLUSH_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	unsigned int startindex, endindex;
-	STRUCT_ENTRY *startentry, *endentry;
-	struct chain_cache *c;
-	int ret;
-
-	iptc_fn = TC_FLUSH_ENTRIES;
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-	startindex = offset2index(*handle, c->start_off);
-	endindex = offset2index(*handle, c->end_off);
-	startentry = offset2entry(*handle, c->start_off);
-	endentry = offset2entry(*handle, c->end_off);
-
-	ret = delete_rules(endindex - startindex,
-			   (char *)endentry - (char *)startentry,
-			   c->start_off, startindex,
-			   handle);
-	return ret;
-}
-
-/* Zeroes the counters in a chain. */
-int
-TC_ZERO_ENTRIES(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	unsigned int i, end;
-	struct chain_cache *c;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	i = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	for (; i <= end; i++) {
-		if ((*handle)->counter_map[i].maptype ==COUNTER_MAP_NORMAL_MAP)
-			(*handle)->counter_map[i].maptype = COUNTER_MAP_ZEROED;
-	}
-	set_changed(*handle);
-
-	return 1;
-}
-
-STRUCT_COUNTERS *
-TC_READ_COUNTER(const IPT_CHAINLABEL chain,
-		unsigned int rulenum,
-		TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-	unsigned int chainindex, end;
-
-	iptc_fn = TC_READ_COUNTER;
-	CHECK(*handle);
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return NULL;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	if (chainindex + rulenum > end) {
-		errno = E2BIG;
-		return NULL;
-	}
-
-	e = index2entry(*handle, chainindex + rulenum);
-
-	return &e->counters;
-}
-
-int
-TC_ZERO_COUNTER(const IPT_CHAINLABEL chain,
-		unsigned int rulenum,
-		TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-	unsigned int chainindex, end;
-	
-	iptc_fn = TC_ZERO_COUNTER;
-	CHECK(*handle);
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	if (chainindex + rulenum > end) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	e = index2entry(*handle, chainindex + rulenum);
-
-	if ((*handle)->counter_map[chainindex + rulenum].maptype
-			== COUNTER_MAP_NORMAL_MAP) {
-		(*handle)->counter_map[chainindex + rulenum].maptype
-			 = COUNTER_MAP_ZEROED;
-	}
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-int 
-TC_SET_COUNTER(const IPT_CHAINLABEL chain,
-	       unsigned int rulenum,
-	       STRUCT_COUNTERS *counters,
-	       TC_HANDLE_T *handle)
-{
-	STRUCT_ENTRY *e;
-	struct chain_cache *c;
-	unsigned int chainindex, end;
-
-	iptc_fn = TC_SET_COUNTER;
-	CHECK(*handle);
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	chainindex = offset2index(*handle, c->start_off);
-	end = offset2index(*handle, c->end_off);
-
-	if (chainindex + rulenum > end) {
-		errno = E2BIG;
-		return 0;
-	}
-
-	e = index2entry(*handle, chainindex + rulenum);
-
-	(*handle)->counter_map[chainindex + rulenum].maptype
-		= COUNTER_MAP_SET;
-
-	memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-/* Creates a new chain. */
-/* To create a chain, create two rules: error node and unconditional
- * return. */
-int
-TC_CREATE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	int ret;
-	struct {
-		STRUCT_ENTRY head;
-		struct ipt_error_target name;
-		STRUCT_ENTRY ret;
-		STRUCT_STANDARD_TARGET target;
-	} newc;
-
-	iptc_fn = TC_CREATE_CHAIN;
-
-	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
-           QUEUE, RETURN. */
-	if (find_label(chain, *handle)
-	    || strcmp(chain, LABEL_DROP) == 0
-	    || strcmp(chain, LABEL_ACCEPT) == 0
-	    || strcmp(chain, LABEL_QUEUE) == 0
-	    || strcmp(chain, LABEL_RETURN) == 0) {
-		errno = EEXIST;
-		return 0;
-	}
-
-	if (strlen(chain)+1 > sizeof(IPT_CHAINLABEL)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	memset(&newc, 0, sizeof(newc));
-	newc.head.target_offset = sizeof(STRUCT_ENTRY);
-	newc.head.next_offset
-		= sizeof(STRUCT_ENTRY)
-		+ ALIGN(sizeof(struct ipt_error_target));
-	strcpy(newc.name.t.u.user.name, ERROR_TARGET);
-	newc.name.t.u.target_size = ALIGN(sizeof(struct ipt_error_target));
-	strcpy(newc.name.error, chain);
-
-	newc.ret.target_offset = sizeof(STRUCT_ENTRY);
-	newc.ret.next_offset
-		= sizeof(STRUCT_ENTRY)
-		+ ALIGN(sizeof(STRUCT_STANDARD_TARGET));
-	strcpy(newc.target.target.u.user.name, STANDARD_TARGET);
-	newc.target.target.u.target_size
-		= ALIGN(sizeof(STRUCT_STANDARD_TARGET));
-	newc.target.verdict = RETURN;
-
-	/* Add just before terminal entry */
-	ret = insert_rules(2, sizeof(newc), &newc.head,
-			   index2offset(*handle, (*handle)->new_number - 1),
-			   (*handle)->new_number - 1,
-			   0, handle);
-	return ret;
-}
-
-static int
-count_ref(STRUCT_ENTRY *e, unsigned int offset, unsigned int *ref)
-{
-	STRUCT_STANDARD_TARGET *t;
-
-	if (strcmp(GET_TARGET(e)->u.user.name, STANDARD_TARGET) == 0) {
-		t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-
-		if (t->verdict == offset)
-			(*ref)++;
-	}
-
-	return 0;
-}
-
-/* Get the number of references to this chain. */
-int
-TC_GET_REFERENCES(unsigned int *ref, const IPT_CHAINLABEL chain,
-		  TC_HANDLE_T *handle)
-{
-	struct chain_cache *c;
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	*ref = 0;
-	ENTRY_ITERATE((*handle)->entries.entrytable,
-		      (*handle)->entries.size,
-		      count_ref, c->start_off, ref);
-	return 1;
-}
-
-/* Deletes a chain. */
-int
-TC_DELETE_CHAIN(const IPT_CHAINLABEL chain, TC_HANDLE_T *handle)
-{
-	unsigned int labelidx, labeloff;
-	unsigned int references;
-	struct chain_cache *c;
-	int ret;
-	STRUCT_ENTRY *start;
-
-	if (!TC_GET_REFERENCES(&references, chain, handle))
-		return 0;
-
-	iptc_fn = TC_DELETE_CHAIN;
-
-	if (TC_BUILTIN(chain, *handle)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	if (references > 0) {
-		errno = EMLINK;
-		return 0;
-	}
-
-	if (!(c = find_label(chain, *handle))) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	if (c->start_off != c->end_off) {
-		errno = ENOTEMPTY;
-		return 0;
-	}
-
-	/* Need label index: preceeds chain start */
-	labelidx = offset2index(*handle, c->start_off) - 1;
-	labeloff = index2offset(*handle, labelidx);
-
-	start = offset2entry(*handle, c->start_off);
-
-	ret = delete_rules(2,
-			   get_entry(*handle, labeloff)->next_offset
-			   + start->next_offset,
-			   labeloff, labelidx, handle);
-	return ret;
-}
-
-/* Renames a chain. */
-int TC_RENAME_CHAIN(const IPT_CHAINLABEL oldname,
-		    const IPT_CHAINLABEL newname,
-		    TC_HANDLE_T *handle)
-{
-	unsigned int labeloff, labelidx;
-	struct chain_cache *c;
-	struct ipt_error_target *t;
-
-	iptc_fn = TC_RENAME_CHAIN;
-
-	/* find_label doesn't cover built-in targets: DROP, ACCEPT,
-           QUEUE, RETURN. */
-	if (find_label(newname, *handle)
-	    || strcmp(newname, LABEL_DROP) == 0
-	    || strcmp(newname, LABEL_ACCEPT) == 0
-	    || strcmp(newname, LABEL_QUEUE) == 0
-	    || strcmp(newname, LABEL_RETURN) == 0) {
-		errno = EEXIST;
-		return 0;
-	}
-
-	if (!(c = find_label(oldname, *handle))
-	    || TC_BUILTIN(oldname, *handle)) {
-		errno = ENOENT;
-		return 0;
-	}
-
-	if (strlen(newname)+1 > sizeof(IPT_CHAINLABEL)) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	/* Need label index: preceeds chain start */
-	labelidx = offset2index(*handle, c->start_off) - 1;
-	labeloff = index2offset(*handle, labelidx);
-
-	t = (struct ipt_error_target *)
-		GET_TARGET(get_entry(*handle, labeloff));
-
-	memset(t->error, 0, sizeof(t->error));
-	strcpy(t->error, newname);
-	set_changed(*handle);
-
-	return 1;
-}
-
-/* Sets the policy on a built-in chain. */
-int
-TC_SET_POLICY(const IPT_CHAINLABEL chain,
-	      const IPT_CHAINLABEL policy,
-	      STRUCT_COUNTERS *counters,
-	      TC_HANDLE_T *handle)
-{
-	unsigned int hook;
-	unsigned int policyoff, ctrindex;
-	STRUCT_ENTRY *e;
-	STRUCT_STANDARD_TARGET *t;
-
-	iptc_fn = TC_SET_POLICY;
-	/* Figure out which chain. */
-	hook = TC_BUILTIN(chain, *handle);
-	if (hook == 0) {
-		errno = ENOENT;
-		return 0;
-	} else
-		hook--;
-
-	policyoff = get_chain_end(*handle, (*handle)->info.hook_entry[hook]);
-	if (policyoff != (*handle)->info.underflow[hook]) {
-		printf("ERROR: Policy for `%s' offset %u != underflow %u\n",
-		       chain, policyoff, (*handle)->info.underflow[hook]);
-		return 0;
-	}
-
-	e = get_entry(*handle, policyoff);
-	t = (STRUCT_STANDARD_TARGET *)GET_TARGET(e);
-
-	if (strcmp(policy, LABEL_ACCEPT) == 0)
-		t->verdict = -NF_ACCEPT - 1;
-	else if (strcmp(policy, LABEL_DROP) == 0)
-		t->verdict = -NF_DROP - 1;
-	else {
-		errno = EINVAL;
-		return 0;
-	}
-
-	ctrindex = entry2index(*handle, e);
-
-	if (counters) {
-		/* set byte and packet counters */
-		memcpy(&e->counters, counters, sizeof(STRUCT_COUNTERS));
-
-		(*handle)->counter_map[ctrindex].maptype
-			= COUNTER_MAP_SET;
-
-	} else {
-		(*handle)->counter_map[ctrindex]
-			= ((struct counter_map){ COUNTER_MAP_NOMAP, 0 });
-	}
-
-	set_changed(*handle);
-
-	return 1;
-}
-
-/* Without this, on gcc 2.7.2.3, we get:
-   libiptc.c: In function `TC_COMMIT':
-   libiptc.c:833: fixed or forbidden register was spilled.
-   This may be due to a compiler bug or to impossible asm
-   statements or clauses.
-*/
-static void
-subtract_counters(STRUCT_COUNTERS *answer,
-		  const STRUCT_COUNTERS *a,
-		  const STRUCT_COUNTERS *b)
-{
-	answer->pcnt = a->pcnt - b->pcnt;
-	answer->bcnt = a->bcnt - b->bcnt;
-}
-
-int
-TC_COMMIT(TC_HANDLE_T *handle)
-{
-	/* Replace, then map back the counters. */
-	STRUCT_REPLACE *repl;
-	STRUCT_COUNTERS_INFO *newcounters;
-	unsigned int i;
-	size_t counterlen;
-
-	CHECK(*handle);
-
-	counterlen = sizeof(STRUCT_COUNTERS_INFO)
-			+ sizeof(STRUCT_COUNTERS) * (*handle)->new_number;
-
-#if 0
-	TC_DUMP_ENTRIES(*handle);
-#endif
-
-	/* Don't commit if nothing changed. */
-	if (!(*handle)->changed)
-		goto finished;
-
-	repl = malloc(sizeof(*repl) + (*handle)->entries.size);
-	if (!repl) {
-		errno = ENOMEM;
-		return 0;
-	}
-
-	/* These are the old counters we will get from kernel */
-	repl->counters = malloc(sizeof(STRUCT_COUNTERS)
-				* (*handle)->info.num_entries);
-	if (!repl->counters) {
-		free(repl);
-		errno = ENOMEM;
-		return 0;
-	}
-
-	/* These are the counters we're going to put back, later. */
-	newcounters = malloc(counterlen);
-	if (!newcounters) {
-		free(repl->counters);
-		free(repl);
-		errno = ENOMEM;
-		return 0;
-	}
-
-	strcpy(repl->name, (*handle)->info.name);
-	repl->num_entries = (*handle)->new_number;
-	repl->size = (*handle)->entries.size;
-	memcpy(repl->hook_entry, (*handle)->info.hook_entry,
-	       sizeof(repl->hook_entry));
-	memcpy(repl->underflow, (*handle)->info.underflow,
-	       sizeof(repl->underflow));
-	repl->num_counters = (*handle)->info.num_entries;
-	repl->valid_hooks = (*handle)->info.valid_hooks;
-	memcpy(repl->entries, (*handle)->entries.entrytable,
-	       (*handle)->entries.size);
-
-	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_REPLACE, repl,
-		       sizeof(*repl) + (*handle)->entries.size) < 0) {
-		free(repl->counters);
-		free(repl);
-		free(newcounters);
-		return 0;
-	}
-
-	/* Put counters back. */
-	strcpy(newcounters->name, (*handle)->info.name);
-	newcounters->num_counters = (*handle)->new_number;
-	for (i = 0; i < (*handle)->new_number; i++) {
-		unsigned int mappos = (*handle)->counter_map[i].mappos;
-		switch ((*handle)->counter_map[i].maptype) {
-		case COUNTER_MAP_NOMAP:
-			newcounters->counters[i]
-				= ((STRUCT_COUNTERS){ 0, 0 });
-			break;
-
-		case COUNTER_MAP_NORMAL_MAP:
-			/* Original read: X.
-			 * Atomic read on replacement: X + Y.
-			 * Currently in kernel: Z.
-			 * Want in kernel: X + Y + Z.
-			 * => Add in X + Y
-			 * => Add in replacement read.
-			 */
-			newcounters->counters[i] = repl->counters[mappos];
-			break;
-
-		case COUNTER_MAP_ZEROED:
-			/* Original read: X.
-			 * Atomic read on replacement: X + Y.
-			 * Currently in kernel: Z.
-			 * Want in kernel: Y + Z.
-			 * => Add in Y.
-			 * => Add in (replacement read - original read).
-			 */
-			subtract_counters(&newcounters->counters[i],
-					  &repl->counters[mappos],
-					  &index2entry(*handle, i)->counters);
-			break;
-
-		case COUNTER_MAP_SET:
-			/* Want to set counter (iptables-restore) */
-
-			memcpy(&newcounters->counters[i],
-			       &index2entry(*handle, i)->counters,
-			       sizeof(STRUCT_COUNTERS));
-
-			break;
-		}
-	}
-
-#ifdef KERNEL_64_USERSPACE_32
-	{
-		/* Kernel will think that pointer should be 64-bits, and get
-		   padding.  So we accomodate here (assumption: alignment of
-		   `counters' is on 64-bit boundary). */
-		u_int64_t *kernptr = (u_int64_t *)&newcounters->counters;
-		if ((unsigned long)&newcounters->counters % 8 != 0) {
-			fprintf(stderr,
-				"counters alignment incorrect! Mail rusty!\n");
-			abort();
-		}
-		*kernptr = newcounters->counters;
-	}
-#endif /* KERNEL_64_USERSPACE_32 */
-
-	if (setsockopt(sockfd, TC_IPPROTO, SO_SET_ADD_COUNTERS,
-		       newcounters, counterlen) < 0) {
-		free(repl->counters);
-		free(repl);
-		free(newcounters);
-		return 0;
-	}
-
-	free(repl->counters);
-	free(repl);
-	free(newcounters);
-
- finished:
-	TC_FREE(handle);
-	return 1;
-}
-
-/* Get raw socket. */
-int
-TC_GET_RAW_SOCKET()
-{
-	return sockfd;
-}
-
-/* Translates errno numbers into more human-readable form than strerror. */
-const char *
-TC_STRERROR(int err)
-{
-	unsigned int i;
-	struct table_struct {
-		void *fn;
-		int err;
-		const char *message;
-	} table [] =
-	  { { TC_INIT, EPERM, "Permission denied (you must be root)" },
-	    { TC_INIT, EINVAL, "Module is wrong version" },
-	    { TC_INIT, ENOENT, 
-		    "Table does not exist (do you need to insmod?)" },
-	    { TC_DELETE_CHAIN, ENOTEMPTY, "Chain is not empty" },
-	    { TC_DELETE_CHAIN, EINVAL, "Can't delete built-in chain" },
-	    { TC_DELETE_CHAIN, EMLINK,
-	      "Can't delete chain with references left" },
-	    { TC_CREATE_CHAIN, EEXIST, "Chain already exists" },
-	    { TC_INSERT_ENTRY, E2BIG, "Index of insertion too big" },
-	    { TC_REPLACE_ENTRY, E2BIG, "Index of replacement too big" },
-	    { TC_DELETE_NUM_ENTRY, E2BIG, "Index of deletion too big" },
-	    { TC_READ_COUNTER, E2BIG, "Index of counter too big" },
-	    { TC_ZERO_COUNTER, E2BIG, "Index of counter too big" },
-	    { TC_INSERT_ENTRY, ELOOP, "Loop found in table" },
-	    { TC_INSERT_ENTRY, EINVAL, "Target problem" },
-	    /* EINVAL for CHECK probably means bad interface. */
-	    { TC_CHECK_PACKET, EINVAL,
-	      "Bad arguments (does that interface exist?)" },
-	    { TC_CHECK_PACKET, ENOSYS,
-	      "Checking will most likely never get implemented" },
-	    /* ENOENT for DELETE probably means no matching rule */
-	    { TC_DELETE_ENTRY, ENOENT,
-	      "Bad rule (does a matching rule exist in that chain?)" },
-	    { TC_SET_POLICY, ENOENT,
-	      "Bad built-in chain name" },
-	    { TC_SET_POLICY, EINVAL,
-	      "Bad policy name" },
-
-	    { NULL, 0, "Incompatible with this kernel" },
-	    { NULL, ENOPROTOOPT, "iptables who? (do you need to insmod?)" },
-	    { NULL, ENOSYS, "Will be implemented real soon.  I promise ;)" },
-	    { NULL, ENOMEM, "Memory allocation problem" },
-	    { NULL, ENOENT, "No chain/target/match by that name" },
-	  };
-
-	for (i = 0; i < sizeof(table)/sizeof(struct table_struct); i++) {
-		if ((!table[i].fn || table[i].fn == iptc_fn)
-		    && table[i].err == err)
-			return table[i].message;
-	}
-
-	return strerror(err);
-}
diff -urN iptables-1.2.9/libiptc2/linux_list.h iptables-1.2.10/libiptc2/linux_list.h
--- iptables-1.2.9/libiptc2/linux_list.h	2003-07-23 14:19:46.000000000 +0200
+++ iptables-1.2.10/libiptc2/linux_list.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,161 +0,0 @@
-#ifndef _LINUXLIST_H
-#define _LINUXLIST_H
-
-
-/*
- * Simple doubly linked list implementation.
- *
- * Some of the internal functions ("__xxx") are useful when
- * manipulating whole lists rather than single entries, as
- * sometimes we already know the next/prev entries and we can
- * generate better code by using them directly rather than
- * using the generic single-entry routines.
- */
-
-struct list_head {
-	struct list_head *next, *prev;
-};
-
-#define LIST_HEAD_INIT(name) { &(name), &(name) }
-
-#define LIST_HEAD(name) \
-	struct list_head name = LIST_HEAD_INIT(name)
-
-#define INIT_LIST_HEAD(ptr) do { \
-	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
-} while (0)
-
-/*
- * Insert a new entry between two known consecutive entries. 
- *
- * This is only for internal list manipulation where we know
- * the prev/next entries already!
- */
-static __inline__ void __list_add(struct list_head * new,
-	struct list_head * prev,
-	struct list_head * next)
-{
-	next->prev = new;
-	new->next = next;
-	new->prev = prev;
-	prev->next = new;
-}
-
-/**
- * list_add - add a new entry
- * @new: new entry to be added
- * @head: list head to add it after
- *
- * Insert a new entry after the specified head.
- * This is good for implementing stacks.
- */
-static __inline__ void list_add(struct list_head *new, struct list_head *head)
-{
-	__list_add(new, head, head->next);
-}
-
-/**
- * list_add_tail - add a new entry
- * @new: new entry to be added
- * @head: list head to add it before
- *
- * Insert a new entry before the specified head.
- * This is useful for implementing queues.
- */
-static __inline__ void list_add_tail(struct list_head *new, struct list_head *head)
-{
-	__list_add(new, head->prev, head);
-}
-
-/*
- * Delete a list entry by making the prev/next entries
- * point to each other.
- *
- * This is only for internal list manipulation where we know
- * the prev/next entries already!
- */
-static __inline__ void __list_del(struct list_head * prev,
-				  struct list_head * next)
-{
-	next->prev = prev;
-	prev->next = next;
-}
-
-/**
- * list_del - deletes entry from list.
- * @entry: the element to delete from the list.
- * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
- */
-static __inline__ void list_del(struct list_head *entry)
-{
-	__list_del(entry->prev, entry->next);
-}
-
-/**
- * list_del_init - deletes entry from list and reinitialize it.
- * @entry: the element to delete from the list.
- */
-static __inline__ void list_del_init(struct list_head *entry)
-{
-	__list_del(entry->prev, entry->next);
-	INIT_LIST_HEAD(entry); 
-}
-
-/**
- * list_empty - tests whether a list is empty
- * @head: the list to test.
- */
-static __inline__ int list_empty(struct list_head *head)
-{
-	return head->next == head;
-}
-
-/**
- * list_splice - join two lists
- * @list: the new list to add.
- * @head: the place to add it in the first list.
- */
-static __inline__ void list_splice(struct list_head *list, struct list_head *head)
-{
-	struct list_head *first = list->next;
-
-	if (first != list) {
-		struct list_head *last = list->prev;
-		struct list_head *at = head->next;
-
-		first->prev = head;
-		head->next = first;
-
-		last->next = at;
-		at->prev = last;
-	}
-}
-
-/**
- * list_entry - get the struct for this entry
- * @ptr:	the &struct list_head pointer.
- * @type:	the type of the struct this is embedded in.
- * @member:	the name of the list_struct within the struct.
- */
-#define list_entry(ptr, type, member) \
-	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
-
-/**
- * list_for_each	-	iterate over a list
- * @pos:	the &struct list_head to use as a loop counter.
- * @head:	the head for your list.
- */
-#define list_for_each(pos, head) \
-	for (pos = (head)->next; pos != (head); pos = pos->next)
-        	
-/**
- * list_for_each_safe	-	iterate over a list safe against removal of list entry
- * @pos:	the &struct list_head to use as a loop counter.
- * @n:		another &struct list_head to use as temporary storage
- * @head:	the head for your list.
- */
-#define list_for_each_safe(pos, n, head) \
-	for (pos = (head)->next, n = pos->next; pos != (head); \
-		pos = n, n = pos->next)
-
-#endif
diff -urN iptables-1.2.9/libiptc2/linux_listhelp.h iptables-1.2.10/libiptc2/linux_listhelp.h
--- iptables-1.2.9/libiptc2/linux_listhelp.h	2003-07-23 14:19:47.000000000 +0200
+++ iptables-1.2.10/libiptc2/linux_listhelp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,99 +0,0 @@
-#ifndef _LINUX_LISTHELP_H
-#define _LINUX_LISTHELP_H
-#include <stdlib.h>
-#include <string.h>
-#include "linux_list.h"
-
-/* Header to do more comprehensive job than linux/list.h; assume list
-   is first entry in structure. */
-
-/* Return pointer to first true entry, if any, or NULL.  A macro
-   required to allow inlining of cmpfn. */
-#define LIST_FIND(head, cmpfn, type, args...)		\
-({							\
-	const struct list_head *__i = (head);		\
-							\
-	do {						\
-		__i = __i->next;			\
-		if (__i == (head)) {			\
-			__i = NULL;			\
-			break;				\
-		}					\
-	} while (!cmpfn((const type)__i , ## args));	\
-	(type)__i;					\
-})
-
-#define LIST_FIND_W(head, cmpfn, type, args...)	\
-({						\
-	const struct list_head *__i = (head);	\
-						\
-	do {					\
-		__i = __i->next;		\
-		if (__i == (head)) {		\
-			__i = NULL;		\
-			break;			\
-		}				\
-	} while (!cmpfn((type)__i , ## args));	\
-	(type)__i;				\
-})
-
-static inline int
-__list_cmp_same(const void *p1, const void *p2) { return p1 == p2; }
-
-/* Is this entry in the list? */
-static inline int
-list_inlist(struct list_head *head, const void *entry)
-{
-	return LIST_FIND(head, __list_cmp_same, void *, entry) != NULL;
-}
-
-/* Delete from list. */
-#define LIST_DELETE(head, oldentry) list_del((struct list_head *)oldentry)
-
-/* Append. */
-static inline void
-list_append(struct list_head *head, void *new)
-{
-	list_add((new), (head)->prev);
-}
-
-/* Prepend. */
-static inline void
-list_prepend(struct list_head *head, void *new)
-{
-	list_add(new, head);
-}
-
-/* Insert according to ordering function; insert before first true. */
-#define LIST_INSERT(head, new, cmpfn)				\
-do {								\
-	struct list_head *__i;					\
-	for (__i = (head)->next;				\
-	     !cmpfn((new), (typeof (new))__i) && __i != (head);	\
-	     __i = __i->next);					\
-	list_add((struct list_head *)(new), __i->prev);		\
-} while(0)
-
-/* If the field after the list_head is a nul-terminated string, you
-   can use these functions. */
-static inline int __list_cmp_name(const void *i, const char *name)
-{
-	return strcmp(name, i+sizeof(struct list_head)) == 0;
-}
-
-/* Returns false if same name already in list, otherwise does insert. */
-static inline int
-list_named_insert(struct list_head *head, void *new)
-{
-	if (LIST_FIND(head, __list_cmp_name, void *,
-		      new + sizeof(struct list_head)))
-		return 0;
-	list_prepend(head, new);
-	return 1;
-}
-
-/* Find this named element in the list. */
-#define list_named_find(head, name)			\
-LIST_FIND(head, __list_cmp_name, void *, name)
-
-#endif /*_LISTHELP_H*/
